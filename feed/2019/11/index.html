<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
xmlns:content="http://purl.org/rss/1.0/modules/content/"
xmlns:dc="http://purl.org/dc/elements/1.1/"
xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
xmlns:atom="http://www.w3.org/2005/Atom"
xmlns:wfw="http://wellformedweb.org/CommentAPI/">
<channel>
<title>Marco Nie - 2019年11月</title>
<link>https://blog.niekun.net/2019/11/</link>
<atom:link href="https://blog.niekun.net/feed/2019/11/" rel="self" type="application/rss+xml" />
<language>zh-CN</language>
<description>you are the company you keep...</description>
<lastBuildDate>Fri, 29 Nov 2019 08:55:47 +0800</lastBuildDate>
<pubDate>Fri, 29 Nov 2019 08:55:47 +0800</pubDate>
<item>
<title>胶卷底片复原照片 in Photoshop</title>
<link>https://blog.niekun.net/archives/548.html</link>
<guid>https://blog.niekun.net/archives/548.html</guid>
<pubDate>Fri, 29 Nov 2019 08:55:47 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[过去胶卷时代，相机拍摄的胶卷底片需要冲洗才能得到最后的照片，如果你手头有一些底片，可以使用 Photoshop 还原成真实照片。]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p><img src="https://niekun.net/usr/uploads/2019/11/665355333.png" alt="2019-11-29T00:41:47.png" title="2019-11-29T00:41:47.png"></p><p>过去胶卷时代，相机拍摄的胶卷底片需要冲洗才能得到最后的照片，如果你手头有一些底片，可以使用 Photoshop 还原成真实照片。</p><!--more--><p>首先将底片放置着白色发光底板上，可以使用手机当作底板，尽量使用好的拍照设备拍摄底片：<br><img src="https://niekun.net/usr/uploads/2019/11/1571627859.png" alt="2019-11-29T00:43:49.png" title="2019-11-29T00:43:49.png"></p><p>导入 ps 建立 invert 图层反转图像，可以看到图片基本转换为了正常的色彩亮度：<br><img src="https://niekun.net/usr/uploads/2019/11/3051355523.png" alt="2019-11-29T00:44:52.png" title="2019-11-29T00:44:52.png"></p><p>新建曲线图层，使用左侧 middle tone 工具，拾取图片应该是中间调灰度的地方来调整白平衡等色彩信息：<br><img src="https://niekun.net/usr/uploads/2019/11/1234909698.png" alt="2019-11-29T00:49:57.png" title="2019-11-29T00:49:57.png"></p><p>配合 alt 键，调节滑块左右，调整高光阴影，曲线调节对比度：<br><img src="https://niekun.net/usr/uploads/2019/11/3549391692.png" alt="2019-11-29T00:53:10.png" title="2019-11-29T00:53:10.png"></p><p>根据情况，增加 color balance 图层，精细调节色彩：<br><img src="https://niekun.net/usr/uploads/2019/11/1556604887.png" alt="2019-11-29T00:55:09.png" title="2019-11-29T00:55:09.png"></p><p>剪裁出有效图片：<br><img src="https://niekun.net/usr/uploads/2019/11/423915599.png" alt="2019-11-29T00:55:49.png" title="2019-11-29T00:55:49.png"></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/548.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/548.html</wfw:commentRss>
</item>
<item>
<title>Linux 管道命令的使用</title>
<link>https://blog.niekun.net/archives/547.html</link>
<guid>https://blog.niekun.net/archives/547.html</guid>
<pubDate>Wed, 27 Nov 2019 14:36:24 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[配合 Linux 管道符，可以根据情况执行多条命令，常用的符号有：'|' '&&' ';' '||' '&gt;' '&gt;&gt;'|管道符 "|" 主要用来将上一个命令的输出作为下一个命令...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>配合 Linux 管道符，可以根据情况执行多条命令，常用的符号有：'|' '&&' ';' '||' '&gt;' '&gt;&gt;'</p><h2>|</h2><p>管道符 "|" 主要用来将上一个命令的输出作为下一个命令的输入。</p><p>例如：</p><pre><code>ps aux | grep test.sh
</code></pre><p>将当前所有进程信息作为输出信息，grep 将输出的内容作为输入，列出有 "test.sh" 的行。</p><p>可同时使用多条管道：</p><pre><code>cat /etc/passwd | grep /bin/bash | wc -l
</code></pre><p>这条命令使用了两个管道，利用第一个管道将cat命令（显示passwd文件的内容）的输出送给grep命令，grep命令找出含有“/bin /bash”的所有行；第二个管道将grep的输出送给wc命令，wc命令统计出输入中的行数。这个命令的功能在于找出系统中有多少个用户使用bash。</p><h2>多命令顺序执行符</h2><pre><code>;     命令1;命令2    多个命令顺序执行，命令之间无任何逻辑关系
&amp;&amp;    命令1&amp;&amp;命令2   逻辑与：当命令1正确执行后，命令2才会正确执行，否则命令2不会执行
||    命令1||命令2   逻辑或：当命令1不正确执行后，命令2才会正确执行，否则命令2不会执行</code></pre><p>例如：</p><pre><code>pwd;ls;date
ls test.sh &amp;&amp; echo found file
ls test.sh || echo no file
</code></pre><h2>重导向</h2><p>重导向就是使命令改变它所认定的标准输出。</p><p>'&gt;' 可将结果输出到文件中，该文件原有内容会被删除，'&gt;&gt;' 则将结果附加到文件中，原文件内容不会被删除。</p><p>将 file1.txt 的内容复制到 file2.txt，file2.txt 原内容会被清空。</p><pre><code>cat file1.txt &gt; file2.txt
</code></pre><p>将 file1.txt 的内容附加到 file2.txt，file2.txt 原内容保留。</p><pre><code>cat file1.txt &gt;&gt; file2.txt
</code></pre>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/547.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/547.html</wfw:commentRss>
</item>
<item>
<title>grep 全局匹配打印命令 in Linux</title>
<link>https://blog.niekun.net/archives/546.html</link>
<guid>https://blog.niekun.net/archives/546.html</guid>
<pubDate>Wed, 27 Nov 2019 14:15:56 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[grep: global regular expression print常用来查找包含特定字符串的文件所在行并显示，也可以配合管道符：| 来有条件的过滤显示终端输出内容。]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p><strong>grep: global regular expression print</strong></p><p>常用来查找包含特定字符串的文件所在行并显示，也可以配合管道符：| 来有条件的过滤显示终端输出内容。</p><!--more--><h2>安装</h2><pre><code>apt-get install grep
</code></pre><h2>使用</h2><p>查找当前目录下后缀有 file 文件中包含 test 字符串的文件，并打印出该字符串的行：</p><pre><code>grep test file
</code></pre><p>查找当前目录下文件名包含 file 的所以文件：</p><pre><code>grep test *file*
</code></pre><p>查找目录及其子目录中所有文件包含 test 字符串的文件，并打印出该字符串的行：</p><pre><code>grep -r test /path
</code></pre><p>忽略字符串匹配大小写：-i</p><pre><code>grep -i &quot;test&quot; file
</code></pre><p>字符串匹配完整 word，不匹配 word 内字符串：-w</p><pre><code>grep -w &quot;is&quot; file
</code></pre><p>上面命令不会匹配：his this 等单词。</p><h2>配合其他命令过滤结果</h2><p>可以使用管道符：| 将其他命令的输出作为处理对象</p><p>例如：</p><pre><code>ps aux | grep file.sh
</code></pre><p>输出当前进程中包含 file.sh 的行，即可查看 file.sh 当前执行信息。</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/546.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/546.html</wfw:commentRss>
</item>
<item>
<title>tar 打包/压缩 in Linux</title>
<link>https://blog.niekun.net/archives/544.html</link>
<guid>https://blog.niekun.net/archives/544.html</guid>
<pubDate>Wed, 27 Nov 2019 09:42:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[tar 是 Linux 下常用的处理打包或压缩的常用命令，常用来处理后缀名为：tar, tar.gz tar.bz2 的文件。tar：存档格式，未经过压缩tar.gz：在tar基础上进行 gzi...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p><strong>tar</strong> 是 Linux 下常用的处理<strong>打包或压缩</strong>的常用命令，常用来处理后缀名为：tar, tar.gz tar.bz2 的文件。</p><p><strong>tar</strong>：存档格式，未经过压缩<br><strong>tar.gz</strong>：在tar基础上进行 <strong>gzip</strong> 压缩，tar.gz 和 tgz 类似<br><strong>tar.bz2</strong>：比 gzip 压缩比更高，但更耗时， tar.bz2，tbz 和 tb2 类似</p><!--more--><h2>语法</h2><pre><code>tar [options] [archive-file] [file or directory to be archived]
</code></pre><p>-c : 建立存档<br>-x : 解压存档<br>-f : 指定文件名<br>-t : 列出文档内容<br>-u : archives and adds to an existing archive file<br>-v : 显示处理过程信息<br>-z : zip, 指定处理 gzip<br>-j : 指定处理 tbzip<br>-W : 验证存档<br>-r : 添加文件/文件夹到已知存档</p><h2>打包存档</h2><p><strong>tar：</strong></p><pre><code>tar -cvf test.tar /home/test
</code></pre><p><strong>tar.gz：</strong></p><pre><code>tar -zcvf test.tar.gz /home/test</code></pre><p>或</p><pre><code>tar -zcvf test.tgz /home/test
</code></pre><p><strong>tar.bz2：</strong></p><pre><code>tar -jcvf test.tar.bz2 /home/test</code></pre><p>或</p><pre><code>tar -jcvf test.tar.tb2 /home/test</code></pre><p>或</p><pre><code>tar -jcvf test.tar.tbz /home/test
</code></pre><h2>将文件/文件夹添加到存档</h2><pre><code>tar -rvf test.tar file
tar -rvf test.tar.gz file
tar -rvf test.tar.zb2 file
</code></pre><h2>解压存档</h2><p><strong>tar：</strong></p><pre><code>tar -xvf test.tar
</code></pre><p>解压到特定目录：-C</p><pre><code>tar -xvf test.tar -C /home/path/
</code></pre><p><strong>tar.gz:</strong></p><pre><code>tar -zxvf test.tar.gz
</code></pre><p>解压到特定目录：-C</p><pre><code>tar -zxvf test.tar.gz -C /home/path/
</code></pre><p><strong>tar.bz2：</strong></p><pre><code>tar -jxvf test.tar.bz2
</code></pre><p>解压到特定目录：-C</p><pre><code>tar -jxvf test.tar.bz2 -C /home/path/
</code></pre><h3>解压存档部分文件/文件夹</h3><p>解压单个文件：</p><pre><code>tar -xvf test.tar file.sh
tar -zxvf test.tar.gz file.sh
tar -jxvf test.tar.zb2 file.sh
</code></pre><p>解压多个文件：</p><pre><code>tar -xvf test.tar &quot;file1&quot; &quot;file2&quot;
tar -zxvf test.tar.gz &quot;file1&quot; &quot;file2&quot;
tar -jxvf test.tar.zb2 &quot;file1&quot; &quot;file2&quot;
</code></pre><p>解压特定名字的文件：</p><pre><code>tar -xvf test.tar --wildcards '*.php'
tar -zxvf test.tar.gz --wildcards '*.php'
tar -jxvf test.tar.zb2 --wildcards '*.php'
</code></pre><h2>list 存档内容</h2><pre><code>tar -tvf test.tar
tar -tvf test.tar.gz
tar -tvf test.tar.zb2
</code></pre><h2>验证存档</h2><p>只能验证 tar 打包的存档：-W</p><pre><code>tar tvfW test.tar
</code></pre><h2>检查存档大小size</h2><pre><code>tar czf file.tar | wc -c
tar czf file.tar.gz | wc -c
tar czf file.tar.tbz | wc -c
</code></pre>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/544.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/544.html</wfw:commentRss>
</item>
<item>
<title>Linux 查询程序或文件位置 which/find/locate</title>
<link>https://blog.niekun.net/archives/543.html</link>
<guid>https://blog.niekun.net/archives/543.html</guid>
<pubDate>Tue, 26 Nov 2019 11:42:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[经常忘记将一些文件放在什么，或者安装一个应用程序后不知道准确的安装路径。使用命令可以进行查询：whichwhich pythonwhich 命令可用来查询 app 安装位置，返回值为路径。fin...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>经常忘记将一些文件放在什么，或者安装一个应用程序后不知道准确的安装路径。使用命令可以进行查询：</p><h2>which</h2><pre><code>which python
</code></pre><p><code>which</code> 命令可用来查询 app 安装位置，返回值为路径。</p><h2>find</h2><pre><code>find / -name file -type f
</code></pre><p>斜线：/ 代表从系统根目录查找，也可以定义特定的目录开始搜索<br>-name：代表只找文件名匹配，不找文件内的字符串<br>-iname：代表文件名不区分大小写<br>-type：搜索的文件类型 <code>f</code> 代表只找文件不找文件夹匹配，<code>l</code> 代表软链接文件<br>-mtime：指定查找日期天数<br>-exec：查找后执行 command 命令，注意最后要有分号 <code>;</code></p><p>例如，查找指定目录三天前的文件，然后删除文件：</p><pre><code>find /temp/* -mtime +2 -exec rm -rf {} \;
</code></pre><p>-mtime 使用加号 <code>+</code> 代表指定日期前查找，减号 <code>-</code> 代表指定日期内查找。查找天数为取整关系，例如 2.5 天前的文件会被包含在 -mtime -2 内而不在 -mtime +2 内。</p><p>-exec 指令后跟需要执行的命令。</p><p>查询已知文件名的文件的所有位置，<code>find</code> 命令直接从文件系统 filesystem 查找文件，速度可能会比较慢，但优点是找到的文件当前肯定在系统内。</p><h2>locate</h2><p><code>locate</code> 用来根据文件名寻找文件，它和 <code>find</code> 命令不同点是，<code>find</code> 从当前文件系统直接查找匹配，而 <code>locate</code> 命令会有一个背景进程，记录当前所有文件名到一个数据库文件中，当新建或删除一个文件时会动态更新这个数据库。当使用 <code>locate</code> 命令查找文件时，会从这个数据库里查找，这样速度会相比 <code>find</code> 快很多。</p><p>语法：</p><pre><code>locate [option] strFile
</code></pre><p>strFile：将匹配所有包含此字符串的文件</p><p>option：<br>-i：不区分大小写<br>-c：输出匹配到的文件的个数</p><p>对于一些刚刚建立的文件，可能数据库没有更新到，所以无法通过命令查找到，这时候可以手动更新数据库：</p><pre><code>sudo updatedb
</code></pre>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/543.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/543.html</wfw:commentRss>
</item>
<item>
<title>使用 frp 实现内网穿透/远程管理/文件服务器</title>
<link>https://blog.niekun.net/archives/539.html</link>
<guid>https://blog.niekun.net/archives/539.html</guid>
<pubDate>Mon, 25 Nov 2019 20:34:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[首先判断自己网络 IP 地址是固定 IP/动态 IP/内网 IP，通过站长工具可以查询，或者终端执行如下指令查看外网看本地 IP 地址：curl https://info.niekun.net/...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>首先判断自己网络 IP 地址是固定 IP/动态 IP/内网 IP，通过站长工具可以查询，或者终端执行如下指令查看外网看本地 IP 地址：</p><pre><code>curl https://info.niekun.net/ip
</code></pre><p>然后从本地通过 ipconfig(win)/ifconfig(linux) 来查看网络路径，如果本地 IP 和上面检测出的一致，那就是有外网 IP，如果不一样则很可能自己分配到的是一个运营商内网。如下是我本地 Windows 电脑的结果，确认是内网：<br><img src="https://niekun.net/usr/uploads/2020/03/3819524027.png" alt="2020-03-05T02:58:24.png" title="2020-03-05T02:58:24.png"></p><p>对于有外网 IP 但是是动态的，每隔一段时间自动变化的情况，可以使用 DDNS 来处理。</p><p>对于大多数家庭网络用户，都没有固定的 IP 地址或者也没有动态的 IP 地址，在本地搭建网络服务无法直接在外网访问，使用 frp 可以实现这一需求。</p><p>使用场景：<strong>路由器远程访问</strong> <strong>远程访问/控制电脑</strong> <strong>网搭建网站公网访问</strong></p><p>项目地址：<a href="https://github.com/fatedier/frp">https://github.com/fatedier/frp</a><br>使用手册：<a href="https://gofrp.org/docs/">https://gofrp.org/docs/</a></p><p>Windows 脚本参考：<a href="https://sspai.com/post/52523">https://sspai.com/post/52523</a></p><!--more--><p>环境需求：<br>一台有独立 IP 的服务器<br>可安装 frp 的本地主机或路由器(windows/linux)</p><h2>安装</h2><p>从 <a href="https://github.com/fatedier/frp/releases">release</a> 页面分别下载合适版本的最新程序到客户端和独立 IP 的服务端。</p><p>程序内包含服务端程序(frps)及客户端程序(frpc)，以及对应配置文件。</p><h2>使用</h2><h3>服务器端</h3><p>修改 frps.ini 文件，示例：</p><pre><code>[common]
# 服务端和客户端的 common 配置中的 token 参数一致则身份验证通过
token=12345678

# 服务端本地地址和客户端握手端口，bind_port 设置同 server_port
bind_addr = 0.0.0.0
bind_port = 6000

# udp 内网穿透端口
bind_udp_port = 6001

# kcp 协议端口，可以和 bind_port 一样，不设置的话不开启
kcp_bind_port = 6000

# http 和 https web 服务访问端口，如：test.com:8080，即可访问内网 web 页面
vhost_http_port = 6002
vhost_https_port = 6003

# frp状态面板端口，用来显示一些连接状态的 web 页面，0.0.0.0 表示开放给外网访问
dashboard_addr = 0.0.0.0
dashboard_port = 6004

# 设置面板的账户密码访问，不设置默认为 admin
dashboard_user = admin
dashboard_pwd = admin

# 日志记录文件定义，不写则不记录
log_file = /usr/log/frps.log
log_level = info
log_max_days = 3
disable_log_color = false

# 为给客户端开放的端口，用于和客户端数据交互，如不设置此条目，则默认开放所有端口
allow_ports = 6000-6100,8000

# 如果想要通过域名访问 http/https web 服务，需要在服务端指定服务器的域名
subdomain_host = niekun.net</code></pre><p><strong>执行以下命令启动：</strong></p><pre><code>path/to/frps -c path/to/frps.ini
</code></pre><p><img src="https://niekun.net/usr/uploads/2020/02/1052737661.png" alt="2020-02-13T06:19:07.png" title="2020-02-13T06:19:07.png"></p><h3>客户端</h3><p>修改 frpc.ini 文件，示例：</p><pre><code>[common]
# 服务端和客户端的 common 配置中的 token 参数一致则身份验证通过
token=12345678

# 远程独立 IP 地址
server_addr = xxx.xxx.xxx.xxx

# 和服务端握手端口，bind_port 设置同 server_port
server_port = 6000

# 日志记录文件定义，不写则不记录
log_file = /usr/log/frpc.log
log_level = info
log_max_days = 3
disable_log_color = false

# 查看 frpc 客户端配置文件等信息的 web 地址
admin_addr = 127.0.0.1
admin_port = 6005
admin_user = admin
admin_pwd = admin

# 定义链接服务器的协议，支持 tcp，kcp，websocket, default is tcp
protocol = kcp

#加密连接服务端
tls_enable = true

#当第一次链接服务器失败是否退出程序，如果设置开机自启这里需要设置为 false，否则可能启动不成功
#设置为 false 会在链接失败后再次尝试链接
login_fail_exit = false

# ssh 是自定义代理块标记，可以是任意的名称
[ssh]
# tcp | udp | http | https | stcp | xtcp, default is tcp
type = tcp
# 客户端 ssh 服务的地址和端口
local_ip = 127.0.0.1
local_port = 22
# 远程 frps 连接地址
remote_port = 6006
# 和 frps 的数据是否加密，默认 false
use_encryption = false
# if true, 数据会被压缩传输
use_compression = false

# remote disktop 远程桌面设置
[rdp]
type = tcp
local_ip = 127.0.0.1
# 远程访问端口是3389
local_port = 3389
remote_port = 6010
use_encryption = true
use_compression = true

# web 服务
[web01]
# 支持 http https
type = http
# 客户端 http 页面的地址和端口
local_ip = 127.0.0.1
local_port = 80
use_encryption = false
use_compression = true
# 如果服务端域名为 niekun.net, 可以通过链接访问 web01: http://web01.niekun.net:8080，此子域名需要在域名服务商处进行 DNS 解析
subdomain = web01
# custom_domains 为 域名/服务器 IP 如果上面定义了 subdomain 此处可以不要
#custom_domains = web01.niekun.net/IP
# 如访问 web 页面是不需要密码则去掉 客户端 http_user 及 http_pwd
http_user = xxxx
http_pwd = xxxxxxxxxxx

# https web 示例
[web02]
type = https
# 客户端 https 页面的地址和端口
local_ip = 127.0.0.1
local_port = 443
use_encryption = false
use_compression = false
subdomain = web02
# if not empty, frpc will use proxy protocol to transfer connection info to your local service
# v1 or v2 or empty
proxy_protocol_version = v2

# 对外提供简单的文件访问服务
[test_static_file]
type = tcp
remote_port = 6020
plugin = static_file
# 要对外暴露的文件目录
plugin_local_path = /tmp/file
# 用户访问 URL 的 location 路径
plugin_strip_prefix = static
plugin_http_user = admin
plugin_http_passwd = admin

# 转发 DNS 查询请求
[dns]
type = udp
# 指定 DNS 服务器地址
local_ip = 8.8.8.8
local_port = 53
remote_port = 6033

# 将内网机器作为 HTTP 代理暴露给其他服务，可以通过此代理访问到此内网机器能够访问到的其他服务
[http_proxy]
type = tcp
remote_port = 6034
plugin = http_proxy
plugin_http_user = admin
plugin_http_passwd = admin</code></pre><p>执行以下命令启动：</p><pre><code>path/to/frpc -c path/to/frpc.ini
</code></pre><h2>测试</h2><h3>访问内网 ssh</h3><pre><code>ssh -oPort=6006 username@x.x.x.x
</code></pre><p>IP 为远程服务器的 IP，username 为内网设备的用户名。输入后提示密码，也为内网设备 ssh 密码。</p><h3>web 服务</h3><pre><code>http://web01.niekun.net:6002
</code></pre><p>如果设置有用户名密码，会提示口令，然后进入 web 页面。</p><h3>frps 控制面板</h3><pre><code>http://xxx.xxx.xxx.xxx:6004
</code></pre><h3>文件服务器</h3><p>通过浏览器访问 <code>http://xxx.xxx.xxx.xxx:6020/static/</code> 来查看位于 <code>/tmp/file</code> 目录下的文件，会要求输入已设置好的用户名和密码。</p><h3>转发 DNS 查询请求</h3><p>通过 dig 测试 UDP 包转发是否成功，预期会返回 www.baidu.com 域名的解析结果:</p><pre><code>dig @xxx.xxx.xxx.xxx -p 6033 www.baidu.com
</code></pre><h3>代理服务器</h3><p>可以将内网设备作为 http 或 socks 代理服务器，这样外网设备就可以通过这个代理服务器访问到这台内网服务器能够访问到的服务了，如打印机等。</p><p>如果内网设备可以访问内部网页：<a href="http://10.10.1.100">http://10.10.1.100</a></p><p>测试将外网设备设置 http 代理：</p><pre><code>http_proxy=http://xxx.xxx.xxx.xxx:6034
</code></pre><p>设置完成后外网设备测试在浏览器直接访问这个内部网页：<a href="http://10.10.1.100">http://10.10.1.100</a></p><h2>服务端 nginx 代理 frp</h2><p>我服务器上使用 nginx 管理 http 请求，可以使用 nginx 代理 frp 的 http 服务。这样可以实现不带端口访问 frp 和使用 nginx 上已经设置的 https 加密而不需要单独给 frp 配置 https。</p><p>客户端和服务端使用上面示例的配置，web01 页面可通过：<a href="http://web01.niekun.net:6002">http://web01.niekun.net:6002</a> 访问。下面我们设置 nginx 代理服务：</p><pre><code>server {
    listen        443 ssl http2;
    listen        [::]:443 ssl http2;
    server_name   frp.niekun.net;
    include       my-server/ssl; ssl 配置文件

    location / {
        proxy_pass          http://127.0.0.1:6004;
        proxy_redirect      off;
    }
}

server {
    listen        443 ssl http2;
    listen        [::]:443 ssl http2;
    server_name   web01.niekun.net;
    include       my-server/ssl;

    location / {
        proxy_pass          http://127.0.0.1:6002;
        proxy_redirect      off;

        proxy_set_header    Host              $http_host;
        proxy_set_header    X-Real-IP         $remote_addr;
        proxy_set_header    X-Forwarded-For   $proxy_add_x_forwarded_for;
        proxy_set_header    X-Forwarded-Proto $scheme;
        proxy_set_header    Upgrade           $http_upgrade;
        proxy_set_header    Connection        &quot;upgrade&quot;;
        proxy_http_version  1.1;
    }
}</code></pre><p>我的 https 配置文件放在 my-server/ssl 文件内。</p><p>第一个 server 配置了 frp.niekun.net 域名转发给 frps 控制面板端口 6004，这样访问：<a href="https://frp.niekun.net">https://frp.niekun.net</a> 就可以访问 frps 控制面板。</p><p>第二个 server 配置了 web01.niekun.net 域名转发给 frps 监听的 http 端口 6002，访问：<a href="https://web01.niekun.net">https://web01.niekun.net</a> 就可以访问内网的 web01 页面了。proxy_set_header 设置转发给 frps 的请求头，有些网页如果缺少一些请求头信息会报错。</p><p>更详细的 nginx 代理服务器的使用参考我的文章：<a href="https://blog.niekun.net/archives/1378.html">NGINX Reverse Proxy 反向代理的使用</a></p><p><strong>注意：由于 rdp 是 tcp 协议，所以不能通过 nginx 代理使用域名进行访问。</strong></p><p>nginx 和 frp 的更多配合方式参考示例：<a href="https://github.com/raymond9zhou/frps-nginx-https">https://github.com/raymond9zhou/frps-nginx-https</a></p><h3>客户端 frpc Windows 运行脚本及自启动</h3><p>Windows 下可以写一个 bat 脚本，双击直接后台运行命令：</p><pre><code>@echo off
if &quot;%1&quot; == &quot;h&quot; goto begin
mshta vbscript:createobject(&quot;wscript.shell&quot;).run(&quot;&quot;&quot;%~nx0&quot;&quot; h&quot;,0)(window.close)&amp;&amp;exit
:begin
REM
cd C:\frp
frpc -c frpc.ini
exit</code></pre><p>上面的 frpc 地址修改为实际地址，程序会在后台运行，想要关闭可以在任务管理器中结束进程： frpc.exe</p><p>将脚本快捷方式放到开机启动文件夹可以实现开机自启动，Windows 10 自启文件夹地址是：<code>%APPDATA%\Microsoft\Windows\Start Menu\Programs\Startup</code></p><h3>linux systemd service 脚本</h3><p>通过 systemd service 脚本可以方便的启动，关闭 frp 服务，也可以设置开机自启。</p><p>在 <code>/usr/lib/systemd/system</code> 目录下新建文件 <strong>frp.service</strong> 内容如下：</p><pre><code>[Unit]
Description=frp Service
After=network.target nss-lookup.target

[Service]
User=root
ExecStart=/opt/frp/frps -c /opt/frp/frps.ini
Restart=on-failure

[Install]
WantedBy=multi-user.target</code></pre><p><strong>注意如果是服务端需要启动 frps 程序，客户端启动 frpc 程序</strong>，根据实际修改其中的配置文件路径。</p><p>重新加载配置文件：</p><pre><code>sudo systemctl daemon-reload
</code></pre><p>启动 frp 服务：</p><pre><code>sudo systemctl start frp.service
</code></pre><p>设置开机自启动：</p><pre><code>sudo systemctl enable frp.service
</code></pre><p>以上就是 frp 的简单使用，高级用法参考官方手册。</p><p><strong>详细配置文件：</strong><br>frps：<br><a href="https://gofrp.org/docs/reference/server-configures/">https://gofrp.org/docs/reference/server-configures/</a></p><p>frpc：<br><a href="https://gofrp.org/docs/reference/client-configures/">https://gofrp.org/docs/reference/client-configures/</a></p><p>可用代理类型：<br><a href="https://gofrp.org/docs/reference/proxy/">https://gofrp.org/docs/reference/proxy/</a></p><p>可用插件：<br><a href="https://gofrp.org/docs/features/common/client-plugin/">https://gofrp.org/docs/features/common/client-plugin/</a></p><p>参考连接：<br><a href="https://www.anquanke.com/post/id/184855">https://www.anquanke.com/post/id/184855</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/539.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/539.html</wfw:commentRss>
</item>
<item>
<title>cat 命令 in Linux</title>
<link>https://blog.niekun.net/archives/534.html</link>
<guid>https://blog.niekun.net/archives/534.html</guid>
<pubDate>Mon, 18 Nov 2019 21:48:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[cat 是 Linux 下常用的一个命令。主要功能是：显示文件内容/新建文件/合并文件]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>cat 是 Linux 下常用的一个命令。主要功能是：显示文件内容/新建文件/合并文件</p><!--more--><h2>输出文件内容到终端</h2><p>输出一个文件：</p><pre><code>cat file1
</code></pre><p>输出多个文件：</p><pre><code>cat file1 file2
</code></pre><p>输出文件内容，显示行号：</p><pre><code>cat -n song.txt

1  &quot;Heal The World&quot;
2  There's A Place In
3  Your Heart
4  And I Know That It Is Love
5  And This Place Could</code></pre><p>行尾和空行显示 $:</p><pre><code>cat -e test

hello everyone, how do you do?$
$
Hey, am fine.$
How's your training going on?$
$</code></pre><h2>新建文件：</h2><p>新建空文件：</p><pre><code>cat /dev/null &gt; file
</code></pre><p>将文件复制到新文件：</p><pre><code>cat file1 &gt; file2
</code></pre><p>将文件复制添加到文件末尾：</p><pre><code>cat file1 &gt;&gt; file2
</code></pre><p>将多个文件合并到一个文件：</p><pre><code>cat file1 file2 file3 &gt; file_new
cat file* &gt; file_new</code></pre>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/534.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/534.html</wfw:commentRss>
</item>
<item>
<title>Linux kernel 内核更新</title>
<link>https://blog.niekun.net/archives/526.html</link>
<guid>https://blog.niekun.net/archives/526.html</guid>
<pubDate>Sun, 17 Nov 2019 22:36:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[Linux内核（英语：Linux kernel），是一种开源的类Unix操作系统宏内核。如果你在安装新硬件后遇到：网卡不能使用，亮度不能调节，触摸板不能识别，蓝牙不能使用等等，这些关系都和lin...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>Linux内核（英语：Linux kernel），是一种开源的类Unix操作系统宏内核。</p><p>如果你在安装新硬件后遇到：网卡不能使用，亮度不能调节，触摸板不能识别，蓝牙不能使用等等，这些关系都和linux的内核有关系。Kernel 是 Linux 系统的核心，主要负责硬件的支持。Linux 内核提供了安全补丁，bugfix 和新特性。</p><h3>内核信息</h3><p>查看当前运行内核：</p><pre><code>uname -r

4.4.0-124-generic</code></pre><p>Linux 内核版本号由 3 组数字组成：第一个组数字。第二组数字。第三组数字</p><p>第一个组数字：目前发布的内核主版本。<br>第二个组数字：偶数表示稳定版本；奇数表示开发中版本。<br>第三个组数字：错误修补的次数。</p><!--more--><p>查看当前设备已安装的内核：</p><pre><code>dpkg --get-selections| grep linux

libselinux1:amd64                               install
linux-firmware                                  install
linux-generic-lts-xenial                        install
linux-headers-4.4.0-124                         install
linux-headers-4.4.0-124-generic                 install
linux-headers-generic-lts-xenial                install
linux-image-4.4.0-116-generic                   deinstall
linux-image-4.4.0-119-generic                   deinstall
linux-image-4.4.0-121-generic                   deinstall
linux-image-4.4.0-124-generic                   install
linux-image-4.4.0-31-generic                    deinstall
linux-image-extra-4.4.0-116-generic             deinstall
linux-image-extra-4.4.0-119-generic             deinstall
linux-image-extra-4.4.0-121-generic             deinstall
linux-image-extra-4.4.0-124-generic             install
linux-image-extra-4.4.0-31-generic              deinstall
linux-image-generic-lts-xenial                  install
linux-libc-dev:amd64                            install
python-selinux                                  install
selinux-policy-default                          install
selinux-utils                                   install
util-linux                                      install</code></pre><p>可以看到一台设备可以安装多个内核，但只能使用一个。</p><h3>切换内核版本</h3><p>一个系统可以同时安装多个内核，但是运行时只能选择一个，当启动电脑时，在显示 grub 菜单时可以选择加载哪一个内核。当只有一个系统安装时，grub 菜单可能被跳过，强制显示 grub 菜单可以在启动电脑时一直按住 <strong>Shift</strong> 按键。</p><h3>安装内核</h3><p>需要时可以自己手动更新系统内核，可以直接安装打包好的内核或自行从源码编译内核。</p><h4>apt 安装</h4><p>首先搜索可用内核：</p><pre><code>apt-get update
apt-cache search linux-generic
</code></pre><p>在输出的结果中，找到合适的内核版本进行安装：</p><pre><code>apt-get install linux-image-4.10.0-27-generic
</code></pre><p>清空下载的 deb 安装包文件，重启系统：</p><pre><code>rm *.deb
sudo reboot
</code></pre><p>重启后查看内核版本：</p><pre><code>uname -r
</code></pre><p><strong>此方法一般无法安装最新版内核。</strong></p><p><strong>apt 卸载内核：</strong></p><p>首先使用以上命令查看当前已安装的内核，然后卸载：</p><pre><code>dpkg --get-selections| grep linux
sudo apt-get purge -f xxx
</code></pre><h3>官方内核安装包</h3><p>apt 方式安装的内核一般没有更新到最新，如果想要快速安装较新版本的内核可以去官网找到对应系统的内核安装包。以下里 Ubuntu 为例。</p><p>首先根据自己 Linux 系统版本，找到合适的可安装的最高版本内核：<a href="https://wiki.ubuntu.com/Kernel/Support">https://wiki.ubuntu.com/Kernel/Support</a></p><p>了解到需要安装的内核后，进入一下官方网站找到需要版本内核的目录进入：<br><a href="https://kernel.ubuntu.com/~kernel-ppa/mainline/">https://kernel.ubuntu.com/~kernel-ppa/mainline/</a></p><p>下载对应版本的 deb 安装包：<br><img src="https://niekun.net/usr/uploads/2019/11/2288673441.png" alt="Screen Shot 2019-11-17 at 22.29.00.png" title="Screen Shot 2019-11-17 at 22.29.00.png"></p><pre><code>wget https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.3.11/linux-headers-5.3.11-050311_5.3.11-050311.201911121635_all.deb
wget https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.3.11/linux-headers-5.3.11-050311-generic_5.3.11-050311.201911121635_amd64.deb
wget https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.3.11/linux-image-unsigned-5.3.11-050311-generic_5.3.11-050311.201911121635_amd64.deb
wget https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.3.11/linux-modules-5.3.11-050311-generic_5.3.11-050311.201911121635_amd64.deb
</code></pre><p>安装：</p><pre><code>dpkg -i *.deb
</code></pre><p>如果安装过程报错，需要立刻卸载掉已安装的相关新内核部分：</p><pre><code>dpkg --get-selections| grep linux
sudo apt-get purge -f xxx
</code></pre><p>如果安装顺利完成，重启系统：</p><pre><code>reboot
</code></pre><p>查看内核版本：</p><pre><code>uname -r
</code></pre><h3>源码编译内核</h3><p>如果你的动手能力较强，或者需要内核支持某些特性但是默认安装的内核不包含对应模块，可以源码编译内核并安装。</p><p>kernel 官网：<a href="https://www.kernel.org/">https://www.kernel.org/</a></p><p><img src="https://niekun.net/usr/uploads/2019/11/25997780.png" alt="2019-11-17T14:19:48.png" title="2019-11-17T14:19:48.png"></p><p><strong>以上官网列出的多个版本内核代表意义不同：</strong><br>5.3.11 是最新的稳定版<br>4.19.84 是最新的 LTS 版本<br>4.14.154、4.9.202、以及 4.4.202 是仍然处于维护状态的老的 LTS 版本</p><p><strong>建议使用的内核的分级，从最佳的方案到最差的方案如下：</strong></p><ul><li>你最喜欢的 Linux 发行版支持的内核</li><li>最新的稳定版</li><li>最新的 LTS （长期支持）版本</li><li>仍然处于维护状态的老的 LTS 版本</li></ul><p>绝对不要去使用的内核：</p><ul><li>不再维护的内核版本</li></ul><p>官网首页有各个版本内核的下载站链接，点击 <strong>tarball</strong> 可以直接下载源码包。</p><p>如果你要下载的内核版本过老或者没有在列表中，可以到镜像网站：<a href="https://mirrors.edge.kernel.org/pub/linux/kernel/">https://mirrors.edge.kernel.org/pub/linux/kernel/</a> 去找找。</p><p>首先查看当前系统安装的内核版本：</p><pre><code>$uname -r
4.15.0-29-generic
</code></pre><p>安装编译内核需要的依赖：</p><pre><code>sudo apt-get install git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison
</code></pre><p>下载内核压缩包到本地任意目录，解压后容量较大，请注意存储空间是否足够：</p><pre><code>cd /home
wget https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.19.164.tar.xz
tar xvf linux-4.19.164.tar.xz
cd linux-4.19.164
</code></pre><p>编译内核前，我们需要提前知道需要启用那些模块，选择了错误的或者少选择某些模块可能导致系统无法正常运行。一个简单的方式是拷贝当前内核的配置文件来作为基础再进行进一步修改，这样比较安全。当前内核的配置文件是在 <strong>/boot</strong> 目录下的 <strong>config</strong> 开头的文件，复制到内核源码目录并重命名为 <strong>.config</strong>：</p><pre><code>cp /boot/config-$(uname -r) .config
</code></pre><p>通过 <strong>make menuconfig</strong> 打开图形化配置界面，这样更加清晰简单的设置需要启动的内核模块：</p><pre><code>make menuconfig
</code></pre><p><img src="https://blog.niekun.net/usr/uploads/2020/12/2578758003.png" alt="2020-12-31T08:32:12.png" title="2020-12-31T08:32:12.png"></p><p>使用上下左右切换菜单，带箭头的项 <strong>---&gt;</strong> 表示含有子菜单，通过 enter 进入。</p><p>想要启用的模块点击 <strong>y</strong> 启用，想要关闭的模块点击 <strong>n</strong> 取消选中。</p><p>设置完成后，切换到 <strong>save</strong> 项保存设置到 <strong>.config</strong> 文件然后 <strong>exit</strong>。</p><p>下面开始编译内核，可以设置使用多个核心来加快速度：</p><pre><code>make -j 4
</code></pre><p>编译用时较长，需要耐心等待。</p><p>完成后安装内核模块，会将相关内核模块安装到/lib/modules目录下：</p><pre><code>make modules_install
</code></pre><p>最后安装内核：</p><pre><code>make install
</code></pre><p>安装完成后在 <strong>/boot/</strong> 目录下可以看到新内核对应的相关文件。</p><p>查看 grub 配置文件：<code>/boot/grub/grub.conf</code>，理论上已经添加新安装的内核到启动项中，按顺序排列在最前面：</p><p><strong>default</strong> 项定义启动哪一个内核，<strong>0</strong> 表示排在最前面的 <strong>1</strong> 表示第二个，默认启动的内核还是之前的内核，修改 <strong>default=0</strong> 默认启动新内核。</p><p>重启系统测试，如果没有修改 <strong>grub</strong> 的默认启动内核，启动时按住 <strong>shift</strong> 键打开启动项菜单，选择性内核启动系统即可。</p><p>查看内核版本：</p><pre><code>uname -r
</code></pre><p>以上就是编译内核的简单过程。</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/526.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/526.html</wfw:commentRss>
</item>
<item>
<title>Linux 命令行 换行符</title>
<link>https://blog.niekun.net/archives/525.html</link>
<guid>https://blog.niekun.net/archives/525.html</guid>
<pubDate>Sun, 17 Nov 2019 21:25:18 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[当需要输入一段很长的命令时，为了书写或查看方便，可以对命令分割换行处理，使用换行符 \例如：sudo apt-get install --install-recommends -y \linux...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>当需要输入一段很长的命令时，为了书写或查看方便，可以对命令分割换行处理，使用换行符 <code>\</code></p><p>例如：</p><pre><code>sudo apt-get install --install-recommends -y \
linux-generic-lts-xenial</code></pre><p>等价于：</p><pre><code>sudo apt-get install --install-recommends -y linux-generic-lts-xenial</code></pre>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/525.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/525.html</wfw:commentRss>
</item>
<item>
<title>github page build failed 问题修复</title>
<link>https://blog.niekun.net/archives/524.html</link>
<guid>https://blog.niekun.net/archives/524.html</guid>
<pubDate>Sun, 17 Nov 2019 20:40:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[在使用 github page 时可能会遇到提示 build failed 的问题，但是在本地加载页面没有问题，原因是 当你没有使用 Jekyll 建立网站时，github page 会错误的将...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>在使用 github page 时可能会遇到提示 build failed 的问题，但是在本地加载页面没有问题，原因是 当你没有使用 Jekyll 建立网站时，github page 会错误的将一些 characters, specifically curly braces, as jekyll objects, tags, etc.，导致错误。</p><p>最简单的办法是在仓库根目录建立一个 <code>.nojekyll</code> 文件，让 github page 在 build 时跳过 Jekyll。</p><p>参考：<a href="https://github.community/t5/GitHub-Pages/GitHub-Pages-Builds-Fail/td-p/29172">https://github.community/t5/GitHub-Pages/GitHub-Pages-Builds-Fail/td-p/29172</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/524.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/524.html</wfw:commentRss>
</item>
</channel>
</rss>