<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"
xmlns:thr="http://purl.org/syndication/thread/1.0"
xml:lang="zh-CN"
xml:base="https://blog.niekun.net/category/other/"
>
<title type="text">Marco Nie - other</title>
<subtitle type="text">杂文</subtitle>
<updated>2024-05-30T20:02:55+08:00</updated>
<generator uri="https://typecho.org/" version="1.3.0">Typecho</generator>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/category/other/" />
<id>https://blog.niekun.net/feed/atom/category/other/</id>
<link rel="self" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/other/" />
<entry>
<title type="html"><![CDATA[修改 pip 为国内源]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/pip.html" />
<id>https://blog.niekun.net/archives/pip.html</id>
<updated>2024-05-30T20:02:55+08:00</updated>
<published>2024-05-30T20:02:55+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<category scheme="https://blog.niekun.net/category/Linux/" term="Linux" />
<category scheme="https://blog.niekun.net/category/other/" term="other" />
<summary type="html"><![CDATA[一键替换命令：# 清华源pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple# 阿里源pip conf...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/pip.html" xml:lang="zh-CN"><![CDATA[
<p>一键替换命令：</p><pre><code># 清华源
pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple

# 阿里源
pip config set global.index-url https://mirrors.aliyun.com/pypi/simple/

# 腾讯源
pip config set global.index-url http://mirrors.cloud.tencent.com/pypi/simple

# 豆瓣源
pip config set global.index-url http://pypi.douban.com/simple/

# 换回默认源
pip config unset global.index-url</code></pre>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/pip.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/other/archives/pip.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[nftables 使用教程]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/nftables.html" />
<id>https://blog.niekun.net/archives/nftables.html</id>
<updated>2024-05-08T10:14:00+08:00</updated>
<published>2024-05-08T10:14:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<category scheme="https://blog.niekun.net/category/Linux/" term="Linux" />
<category scheme="https://blog.niekun.net/category/other/" term="other" />
<summary type="html"><![CDATA[新版本的 openwrt 使用 fw4 防火墙，默认已经从 iptables 切换到了 nftables，语法有了很大的变化，下面介绍 nftables 的使用方法。]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/nftables.html" xml:lang="zh-CN"><![CDATA[
<p>新版本的 openwrt 使用 fw4 防火墙，默认已经从 iptables 切换到了 nftables，语法有了很大的变化，下面介绍 nftables 的使用方法。</p><!--more--><h3>路由表配置</h3><p>路由表是 nftables 中最顶层的容器，它管理着  chains, sets, maps, flowtables, 和 stateful objects.</p><h4>family 集合</h4><p>每个路由表都只能属于一个 family 集合，可用的 family 有：</p><ul><li><strong>ip</strong>      监听 ipv4 的流量</li><li><strong>ip6</strong>     监听 ipv6 的流量</li><li><strong>inet</strong>    同时监听 ipv4 和 ipv6 的流量</li><li><strong>arp</strong>     监听 ARP-level 地址解析协议的流量</li><li><strong>bridge</strong>  监听 bridge 桥接流量 如交换机</li><li><strong>netdev</strong>  用于监听某个单独网卡的流量</li></ul><h4>基本语法</h4><p><strong>新建路由表：</strong></p><pre><code>nft add table ip tabletest
</code></pre><p>以上命令在 ip 集合中新建一个名称为 tabletest 的路由表，可以处理 ipv4 流量</p><p><strong>路由表列表：</strong></p><pre><code># 列出所有路由表
nft list tables

# 列出所有 ip 集合的路由表
nft list tables ip</code></pre><p>删除一个路由表：</p><pre><code>nft delete table ip tabletest
</code></pre><h3>路由链配置</h3><p>不同于 iptables，nftables 没有预定义的链，如 input output 等。想要在某个环节处理流量，需要定义一个自定义名称的基本链，然后将其挂载在一个特定的 netfilter hook 钩子上。下图是流量包在 linux 网络中的传输路径：<br><img src="https://blog.niekun.net/usr/uploads/2024/05/605130879.png" alt="image.png" title="image.png"></p><p>外部访问流量传输到本机后如果目标地址是本机，流量传输路径是 <strong>prerouting -&gt; input hooks -&gt; 本机</strong>，然后经过本机处理后流向 <strong> 本机 -&gt; output -&gt; postrouting hooks</strong>。</p><p>如果传入本机的外部流量目标地址不是本机，则受 <strong>forward hook</strong> 监听，这类流量的传输路径是 <strong>prerouting -&gt; forward -&gt; postrouting</strong>。</p><p>本机访问外部地址的流量传输路径是 <strong>本机 -&gt; output -&gt; postrouting hooks</strong>。</p><p>注意如果本机作为 router 路由使用，需要提前开启 ip 转发功能：</p><pre><code>echo 1 &gt; /proc/sys/net/ipv4/ip_forward
</code></pre><p>以下是 netfilter 可用的 chains 和 hooks 列表：<br><img src="https://blog.niekun.net/usr/uploads/2024/05/2591276956.png" alt="image.png" title="image.png"></p><h4>基本语法</h4><p>建立基本链，挂载在一个特定 type 的 netfilter hook：</p><pre><code>nft add chain [&lt;family&gt;] &lt;table_name&gt; &lt;chain_name&gt; { type &lt;type&gt; hook &lt;hook&gt; priority &lt;value&gt; \; [policy &lt;policy&gt; \;] [comment \&quot;text comment\&quot; \;] }
</code></pre><p>注意，由于 nft 语法使用了特殊字符，如: <code>;</code>，在命令行中执行需要加转义符 <code>\</code>。或者可以使用单引号 <code>'</code>` 将 nft 后的语句包起来，以下两种写法效果相同：</p><pre><code>nft add chain ip tabletest input { type filter hook input priority 0 \; }
nft 'add chain ip tabletest input { type filter hook input priority 0 ; }'
</code></pre><p>另一种方法是运行 nft 在交互模式，执行以下命令后就可以不加转义符: <code>nft -i</code>。</p><p>上面的命令在 tebletest 路由表中新建一个 input 链，挂载在 filter 路由链的 input hook 上。这样就可以监听所有进入本地的流量。</p><p><strong>priority</strong> 决定了所有链的顺序，例如在 filter input hook 上挂载了多个自定义链，通过 priority 决定其执行顺序。数值越低执行优先级越高，例如 -12, -1, 0, 10。如果给多个挂载在同一个 hook 上的自定义基本链同样的 priority，它们的先后执行顺序就是不确定的。</p><p>添加以下命令后就可以在 tabletest 基本链中监听本机输出的流量：</p><pre><code>nft 'add chain ip tabletest output { type filter hook output priority 0 ; }'
</code></pre><p><strong>如果不定义大括号中的内容，也就是不挂载在特定 hook 上，则路由链不会监听任何流量。</strong></p><p><strong>policy</strong> 定义了默认的策略，可用的默认策略为：<strong>accept</strong> 和 <strong>drop</strong>，如果路由链中的规则都没有匹配则会应用默认策略：</p><ul><li><strong>accept</strong> 没有匹配到的流量继续在网络层传输</li><li><strong>drop</strong>   没有匹配到的流量被丢弃</li></ul><p><strong>type</strong> 指定自定义路由链挂载到那个基本 chain，可用的基本链：</p><ul><li><strong>filter</strong>, 用于过滤流量包</li><li><strong>route</strong>, 用于重路由，等同于 iptables 的 mangle 路由链的 output hook (其他 mangle hooks 可以使用 filter 代替)</li><li><strong>nat</strong>, 用于运行 Networking Address Translation (NAT). 只有第一个 nat 流量包会匹配到此链剩余的包会跳过此链，因此尽量不要使用此链过滤流量</li></ul><p><strong>hook</strong> 定义了挂载的基本链 hook，可用的 hooks 如下：</p><ul><li>ingress 只能用于 netdev 和 inet family: 监听来自于 NIC driver 的流量, 早于 prerouting.</li><li>prerouting: 监听所有在 routing 前的入口流量. 流量可能重定向到 local 或 remote systems.</li><li>input: 监听所有被路由或重定向到 local system 的入口流量</li><li>forward: 监听所有不被重定向到 local system 的入口流量</li><li>output: 监听所有在 local machine 被管理的出口流量</li><li>postrouting: 监听所有被路由后的即将离开 local system 的出口流量</li></ul><p>列出一个路由表的所有路由链：</p><pre><code>nft list ip table tabletest
</code></pre><p>列出一个路由表的指定路由链：</p><pre><code>nft list chain ip tabletest output
</code></pre><p><strong>comment</strong> 可以给规则添加注释：</p><pre><code>nft add rule ip tabletest input counter comment \&quot;test comment\&quot;
</code></pre><h3>基本规则配置</h3><p>通过规则可以控制路由链上的流量。</p><h4>基本语法</h4><p><strong>添加规则：</strong></p><pre><code>nft add rule ip tabletest output ip daddr 8.8.8.8 counter
</code></pre><p>以上命令会在 tabletest 路由表的 output 链中添加一条规则，匹配出口流量中 ip 地址为 8.8.8.8 的流量并对匹配次数计数，nftables 中 counter 会默认启用即使不写。以上命令相当于 iptables 中的 <code>-A</code> 命令。</p><p><strong>列出某个链包含的规则：</strong></p><pre><code>root@OpenWrt:~# nft list chain ip tabletest output
table ip tabletest {
        chain output {
                type filter hook output priority filter; policy accept;
                ip daddr 8.8.8.8 counter packets 0 bytes 0
        }
}</code></pre><p>下面测试以上规则是否生效，执行以下命令：</p><pre><code>ping -c 1 8.8.8.8</code></pre><p>再次查看此链的规则：</p><pre><code>root@OpenWrt:~# nft list chain ip tabletest output
table ip tabletest {
        chain output {
                type filter hook output priority filter; policy accept;
                ip daddr 8.8.8.8 counter packets 1 bytes 84
        }
}</code></pre><p>可以看到已经有一次计数了。</p><p><strong>指定位置添加规则：</strong><br>nftables 中必须通过 handle num 编号来在指定位置添加规则，需要通过 <code>-a</code> 查看链中已经存在的规则的编号：</p><pre><code>nft -n -a list table ip tabletest
</code></pre><p><code>-n</code> 可以按数字顺序排号避免出现重复编号。再次查看链中的规则：</p><pre><code>root@OpenWrt:~# nft -n -a list table ip tabletest
table ip tabletest { # handle 4
        chain output { # handle 1
                type filter hook output priority 0; policy accept;
                ip daddr 8.8.8.8 counter packets 0 bytes 0 # handle 5
        }
}</code></pre><p>handle 5 就是这条规则的编号。</p><p>下面我们通过 handle 索引在这条规则后添加一条新规则：</p><pre><code>nft add rule ip tabletest output position 5 ip daddr 127.0.0.8 drop
</code></pre><p>查看链中的规则：</p><pre><code>root@OpenWrt:~# nft -n -a list table ip tabletest
table ip tabletest { # handle 4
        chain output { # handle 1
                type filter hook output priority 0; policy accept;
                ip daddr 8.8.8.8 counter packets 0 bytes 0 # handle 5
                ip daddr 127.0.0.8 drop # handle 6
        }
}</code></pre><p>如果要在某条规则前插入一条规则需要使用 insert 指令：</p><pre><code>nft insert rule ip tabletest output position 5 ip daddr 127.1.1.8 drop
</code></pre><p>查看效果：</p><pre><code>root@OpenWrt:~# nft -n -a list table ip tabletest
table ip tabletest { # handle 4
        chain output { # handle 1
                type filter hook output priority 0; policy accept;
                ip daddr 127.1.1.8 drop # handle 7
                ip daddr 8.8.8.8 counter packets 0 bytes 0 # handle 5
                ip daddr 127.0.0.8 drop # handle 6
        }
}</code></pre><p><strong>在某条链最前面添加一条规则：</strong></p><pre><code>nft insert rule ip tabletest output ip daddr 192.168.2.1 counter
</code></pre><p>在最前面添加规则就不需要指定 handle 了。</p><p><strong>替换某条规则：</strong><br>替换一条规则也需要 handle 编号。下面示例会替换 handle 5 为新的规则：</p><pre><code>nft replace rule ip tabletest output handle 5 ip daddr 1.1.1.1
</code></pre><p><strong>删除规则：</strong><br>同样的，删除某一条规则也需要获取这条规则的 handle 编号。</p><p>删除 tabletest 链的 handle 7 规则：</p><pre><code> nft delete rule ip tabletest output handle 7
</code></pre><p>删除链中所有规则：</p><pre><code>nft flush chain ip tabletest output
</code></pre><p>删除路由表中所有链的所有规则：</p><pre><code>nft flush table ip tabletest
</code></pre><h3>ruleset 层级的操作</h3><p>显示所有 family 的所有 rule 规则：</p><pre><code>nft list ruleset
</code></pre><p>显示某一个集合的所有 rule：</p><pre><code> % nft list ruleset arp
 % nft list ruleset ip
 % nft list ruleset ip6
 % nft list ruleset bridge
 % nft list ruleset inet</code></pre><p>清除所有集合的所有规则：</p><pre><code>nft flush ruleset
</code></pre><p>清除某一个集合的所有规则：</p><pre><code> % nft flush ruleset arp
 % nft flush ruleset ip
 % nft flush ruleset ip6
 % nft flush ruleset bridge
 % nft flush ruleset inet</code></pre><p>备份规则到文件：</p><pre><code># 备份所有集合的所有规则
nft list ruleset &gt;&gt; backup.nft

# 备份 ip 集合的所有规则
nft list ruleset ip &gt;&gt; backup.nft</code></pre><p>从文件恢复规则：</p><pre><code>nft -f backup.nft
</code></pre><p>以 json 格式显示所有规则：</p><pre><code>nft --json list ruleset
</code></pre><h3>流量元信息匹配</h3><p>通过 <strong>meta</strong> 选择器可以进行流量匹配或流量设置。下面简单介绍几个常用的匹配模式，更加详细的参考官方资料：<a href="https://wiki.nftables.org/wiki-nftables/index.php/Matching_packet_metainformation">https://wiki.nftables.org/wiki-nftables/index.php/Matching_packet_metainformation</a></p><p>iifname 匹配网卡名称：</p><pre><code># lo 网卡的入口流量会被接收
nft add rule tabletest input meta iifname lo accept</code></pre><p>mark 匹配流量标记：</p><pre><code># 流量标记为 123 的出口流量计数
nft add rule tabletest output meta mark 123 counter</code></pre><p>skgid 匹配流量由特定 gid 用户产生的数据：</p><pre><code># 匹配来自 gid 用户 1000 的流量
nft add rule tabletest output meta skgid 1000 counter</code></pre><h3>流量头信息匹配</h3><p>通过 <strong>ip {saddr | daddr}</strong>  可以匹配 ipv4 的源流量或目标流量：</p><pre><code># 匹配来自 192.168.1.100 且去往 192.168.1.1 的流量并计数
# 注意本机地址必须为 192.168.1.1 才可以由 input hook 截获
nft add rule ip tabletest input ip saddr 192.168.1.100 ip daddr 192.168.1.1 counter</code></pre><p>通过 <strong>icmp type</strong> 关键词来匹配 icmp 流量，如 ping request：</p><pre><code>nft add rule ip tabletest input icmp type echo-request counter drop
</code></pre><p>可以通过命令查询所有可用的 icmp type 类型：</p><pre><code>root@OpenWrt:~# nft describe icmp type
payload expression, datatype icmp_type (ICMP type) (basetype integer), 8 bits

pre-defined symbolic constants (in decimal):
        echo-reply                                         0
        destination-unreachable                            3
        source-quench                                      4
        redirect                                           5
        echo-request                                       8
        router-advertisement                               9
        router-solicitation                               10
        time-exceeded                                     11
        parameter-problem                                 12
        timestamp-request                                 13
        timestamp-reply                                   14
        info-request                                      15
        info-reply                                        16
        address-mask-request                              17
        address-mask-reply                                18</code></pre><p><strong>通过 ip protocol 匹配 ip family 任意类型的协议：</strong></p><pre><code># 匹配所有 tcp 流量
nft add rule ip tabletest output ip protocol tcp

# 匹配所有 tcp udp 流量
nft add rule ip tabletest output ip protocol { tcp, udp }</code></pre><p><strong>通过 meta l4proto 匹配 inet family 任意类型的协议：</strong></p><pre><code># tabletest 需要定义为 inet 集合
nft add rule inet tabletest output meta l4proto tcp</code></pre><p><strong>匹配特定端口的流量：</strong></p><pre><code># 丢弃所有端口为 1-1024 的 tcp 流量访问本机
nft add rule ip tabletest input tcp dport 1-1024 counter drop</code></pre><h3>流量匹配动作</h3><h4>accept 和 drop</h4><p>drop 可以对匹配的流量直接丢弃，注意 drop 不能和其他动作组合使用：</p><pre><code>nft add rule ip tabletest input ip protocol udp drop
</code></pre><p>accept 可以对匹配的流量接收，可以和其他动作组合使用 如 counter 计数：</p><pre><code>nft add rule ip tabletest input counter accept
</code></pre><h4>reject 流量</h4><p>不同于 drop，reject 可以在拒绝流量的基础上进行很多其他动作，如返回给源请求地址无法访问的原因等。如果不指定其他动作，默认会返回源地址一个 ICMP/ICMPv6 port unreachable 的流量包。</p><p>示例如下：</p><pre><code># 拒绝所有 input 的 udp 流量
nft add rule ip tabletest input ip protocol udp reject

# 拒绝指定流量并返回 icmp host-unreachable
nft add rule ip tabletest input reject with icmp type host-unreachable</code></pre><p>icmp 可用如下原因：</p><pre><code>net-unreachable: Destination network unreachable
host-unreachable: Destination host unreachable
prot-unreachable: Destination protocol unreachable
port-unreachable: Destination port unreachable (this is the default)
net-prohibited: Network administratively prohibited
host-prohibited: Host administratively prohibited
admin-prohibited: Communication administratively prohibited</code></pre><h4>jump 跳转到其他 chain</h4><p>注意只能跳转到同一个路由表的其他 chain。</p><p>首先我们新建一个 chain：</p><pre><code>nft add chain ip tabletest tcp-chain
</code></pre><p>然后定义这个链的规则：</p><pre><code>nft add rule ip tabletest tcp-chain counter
</code></pre><p>然后可以定义将所有匹配的流量跳转过去：</p><pre><code>ft add rule ip tabletest input ip protocol tcp jump tcp-chain
</code></pre><p>以上示例实现的就是将所有 input 的 tcp 流量跳转到 tcp-chain 计数，然后就返回原始 input 环节继续流转。</p><h4>log 日志</h4><p>通过 log 可以记录匹配到的流量信息，在系统日志中可以查看到。</p><p>下面是一个示例，可以记录所有对本机的 ping 请求：</p><pre><code>nft add rule ip tabletest input icmp type echo-request log prefix \&quot;New ping request: \&quot; accept</code></pre><p>从局域网对本机进行 ping 后，系统日志如下：</p><pre><code>Thu May  9 11:58:04 2024 kern.warn kernel: [ 3741.786865] New ping request: IN=br-lan OUT= MAC=00:0c:29:c5:39:8d:00:50:56:c0:00:02:08:00 SRC=192.168.244.2 DST=192.168.244.1 LEN=60 TOS=0x00 PREC=0x00 TTL=128 ID=49655 PROTO=ICMP TYPE=8 CODE=0 ID=1 SEQ=6609</code></pre><h4>网络地址转换</h4><p>nat 链类型可以执行网络地址转换的功能，这种链类型有其特有的属性：</p><ul><li>流量中只有第一个包会被用来进行匹配规则</li><li>流量包中后续的流量不会被检查</li><li>nat 链类型特有的规则赋予其他链类型会报错</li></ul><p>先定义一个 nat 类型的基本链：</p><pre><code>nft add chain ip tabletest postrouting { type nat hook postrouting priority 0 \; }
</code></pre><p>以上定义了一个 nat 类型的基本链挂载在 postrouting hook 上。</p><p><strong>snat</strong> 表示源地址。</p><p>下面的规则可以将来自 192.168.1.0/24 从 eth0 网卡发出的流量在发送出去的时候，将源地址修改为 1.2.3.4</p><pre><code>nft add rule ip tabletest postrouting ip saddr 192.168.1.0/24 oif eth0 snat to 1.2.3.4
</code></pre><p>也可以定义一个地址范围：</p><pre><code># 将所有 tcp 流量的源地址都修改为指定的ip范围内
nft add rule ip tabletest postrouting ip protocol tcp snat ip to 10.0.0.1-10.0.0.100:3000-4000</code></pre><p>下面介绍如何修改目标地址，再定义一个 nat 类型的基本链：</p><pre><code>nft add chain ip tabletest prerouting { type nat hook prerouting priority 0 \; }
</code></pre><p>以上定义了一个 nat 类型的基本链挂载在 prerouting hook 上。</p><p><strong>dnat</strong> 表示目标地址。</p><p>下面规则会将要进入 eth0 的 tcp 80 443 端口的流量的目标地址改为 192.168.1.120 也就是重定向：</p><pre><code>nft 'add rule ip tabletest prerouting iif eth0 tcp dport { 80, 443 } dnat to 192.168.1.120'
</code></pre><p><strong>redirect</strong> 是一种特殊的 <strong>dnat</strong>，它会将流量重定向到本机设备上：</p><pre><code>nft add rule ip tabletest prerouting tcp dport 22 redirect to 2222
</code></pre><p>以上规则会将进入的 tcp 22 端口的流量转发到本机 2222端口上。</p><p><strong>需要注意的是 redirect 只能应用于 nat 链类型的 prerouting 和 output hooks。</strong></p><h4>设置流量包元信息</h4><p>设置 mark 标记：</p><pre><code>nft add rule ip tabletest output mark set 123
</code></pre><h3>set 架构</h3><p>nftables 提供了 set 架构可以用任意支持的选择器来搭建 sets。</p><h4>匿名 set</h4><p>匿名 set 是直接定义在 rule 内的 set，它没有特定的名称，也不可以更新 set 中的元素，下面是一个示例：</p><pre><code>nft add rule ip tabletest output tcp dport { 22, 23 } counter
</code></pre><p><code>{ 22, 23 }</code> 就属于一个匿名 set。规则会去尝试匹配 set 中的每个元素。</p><h4>非匿名 set</h4><p>可以通过 <code>nft add set</code> 来创建一个有名称的 set，例如：</p><pre><code>nft add set ip tabletest blackhole { type ipv4_addr \; comment \&quot;drop all packets from these hosts\&quot; \; }
</code></pre><p><strong>blackhole</strong> 就是这个 set 的名称，后续可以再 rule 中使用。set 类型指定是 ipv4 数据。set 名称需要小于等于16个字符，comment 注释是可选项。</p><p>可用的 type 类型有：<br>ipv4_addr: IPv4 address<br>ipv6_addr: IPv6 address.<br>ether_addr: Ethernet address.<br>inet_proto: Inet protocol type.<br>inet_service: Internet service (read tcp port for example)<br>mark: Mark type.<br>ifname: Network interface name (eth0, eth1..)</p><p>建立好之后就可以往 set 里添加元素了：</p><pre><code>nft add element ip tabletest blackhole { 192.168.3.4 }
nft add element ip tabletest blackhole { 192.168.1.4, 192.168.1.5 }</code></pre><p>如果要添加一个 ip 网段则需要将 set 定义 flags interval：</p><pre><code>nft add set ip tabletest blackhole { type ipv4_addr \; flags interval \; }
</code></pre><p>然后就可以添加一个 ip 网段了：</p><pre><code>nft add element ip tabletest blackhole { 192.168.1.0/24 }
</code></pre><p>可以查询 set 中现有的元素：</p><pre><code>root@OpenWrt:~# nft list set ip tabletest blackhole
table ip tabletest {
        set blackhole {
                type ipv4_addr
                comment &quot;drop all packets from these hosts&quot;
                elements = { 192.168.1.4, 192.168.1.5,
                             192.168.3.4 }
        }
}</code></pre><p>下面就可以通过 set 名称在 nftables 规则中应用：</p><pre><code>nft add rule ip tabletest input ip saddr @blackhole drop
nft add rule ip tabletest output ip daddr != @blackhole accept</code></pre><p>以上就是 natables 的基本用法。</p><h3>参考链接</h3><p><a href="https://wiki.nftables.org/wiki-nftables/index.php/Main_Page">nftables HOWTO documentation page</a><br><a href="https://wiki.nftables.org/wiki-nftables/index.php/Nftables_families">Nftables families</a><br><a href="https://wiki.nftables.org/wiki-nftables/index.php/Netfilter_hooks">Netfilter hooks</a><br><a href="https://wiki.nftables.org/wiki-nftables/index.php/Operations_at_ruleset_level">Operations at ruleset level</a></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/nftables.html#comments" thr:count="1" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/other/archives/nftables.html" thr:count="1"/>
</entry>
<entry>
<title type="html"><![CDATA[解决在 intel 12代以后的 CPU 上 vmwre 虚拟机性能低下问题]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/intel-12-CPU-vmwre.html" />
<id>https://blog.niekun.net/archives/intel-12-CPU-vmwre.html</id>
<updated>2024-04-18T13:01:52+08:00</updated>
<published>2024-04-18T13:01:52+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<category scheme="https://blog.niekun.net/category/Windows/" term="Windows" />
<category scheme="https://blog.niekun.net/category/other/" term="other" />
<summary type="html"><![CDATA[最近更换了新的电脑，是 i7 12700H 的 CPU，按理说比以前的电脑性能好一些，但是导入之前的 vmware 虚拟机后发现运行起来优点卡顿，但是观察主机资源占用很低，cpu 占用也很低，研...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/intel-12-CPU-vmwre.html" xml:lang="zh-CN"><![CDATA[
<p>最近更换了新的电脑，是 i7 12700H 的 CPU，按理说比以前的电脑性能好一些，但是导入之前的 vmware 虚拟机后发现运行起来优点卡顿，但是观察主机资源占用很低，cpu 占用也很低，研究了下才发现是由于新款 cpu 采用了大小核设计导致这个问题。</p><p>我的这一款是 6 大核 8 小核 20 线程设计。默认情况下启动虚拟机资源分配是交给 windows 主机自己协调的，很可能会分配给小核运行虚拟机导致运行卡顿，资源管理器可以看到 cpu 负载都在后面的小核上：<br><img src="https://blog.niekun.net/usr/uploads/2024/04/1346184507.png" alt="image.png" title="image.png"></p><p>解决方法就是以管理员权限运行 vmware，这样 VMware 会自己调度资源使用，优先级大概是大核&gt;小核&gt;超线程。实际效果很明显，基本都运行在了大核上：<br><img src="https://blog.niekun.net/usr/uploads/2024/04/2751437887.png" alt="image.png" title="image.png"></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/intel-12-CPU-vmwre.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/other/archives/intel-12-CPU-vmwre.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[openwrt 系统升级]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/openwrt-1.html" />
<id>https://blog.niekun.net/archives/openwrt-1.html</id>
<updated>2024-04-02T10:26:03+08:00</updated>
<published>2024-04-02T10:26:03+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<category scheme="https://blog.niekun.net/category/Linux/" term="Linux" />
<category scheme="https://blog.niekun.net/category/other/" term="other" />
<summary type="html"><![CDATA[小版本升级小版本升级，例如 19.05-&amp;gt; 19.07。这种小版本的升级最方便的就是通过 Attended Sysupgrade 功能，可以保留已安装的包和系统设置。最大限度地无缝过渡。官...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/openwrt-1.html" xml:lang="zh-CN"><![CDATA[
<h3>小版本升级</h3><p>小版本升级，例如 19.05-&gt; 19.07。</p><p>这种小版本的升级最方便的就是通过 Attended Sysupgrade 功能，可以保留已安装的包和系统设置。最大限度地无缝过渡。官方介绍：<a href="https://openwrt.org/docs/guide-user/installation/attended.sysupgrade">https://openwrt.org/docs/guide-user/installation/attended.sysupgrade</a></p><p>需要先安装 Attended Sysupgrade luci 界面包：</p><pre><code>opkg install luci-app-attendedsysupgrade
</code></pre><p>建议使用此功能前依然做一次数据备份。</p><p>然后重新登录 luci，在 system - Attended Sysupgrade 找到入口，点击 search for firmware upgrade 即可在线搜索可更新的系统。</p><!--more--><h3>大版本升级</h3><p>最方便的就是通过 luci 界面升级系统，目前支持直接升级的大版本顺序是：<strong>19.07 &gt; 21.02 &gt; 22.03 &gt; 23.05</strong>。</p><h3>大版本升级改动</h3><p><strong>openwrt 21</strong>：<a href="https://openwrt.org/releases/21.02/notes-21.02.0">https://openwrt.org/releases/21.02/notes-21.02.0</a></p><ul><li>WPA3 support included by default</li><li>TLS and HTTPS support included by default</li><li>LuCI is now available over HTTPS</li><li>Initial DSA support replaces the swconfig system</li><li>New network configuration syntax and board.json change</li><li>Kernel with container support</li></ul><p><strong>openwrt 22：</strong><a href="https://openwrt.org/releases/22.03/notes-22.03.0">https://openwrt.org/releases/22.03/notes-22.03.0</a></p><ul><li>Firewall4 based on nftables，superseding the iptables-based firewall3</li><li>Dark mode in LuCI</li></ul><p><strong>openwrt 23：</strong><a href="https://openwrt.org/releases/23.05/notes-23.05.0">https://openwrt.org/releases/23.05/notes-23.05.0</a></p><ul><li>Switch from wolfssl to mbedtls as default，TLS 1.3 Support</li><li>Rust Package Support</li></ul><h3>数据备份</h3><p>每个版本升级实际上就是重新刷入了一次固件，所以之前的配置文件什么的基本上都会被覆盖，所以系统内修改过的配置最好做一次备份。</p><p>打开 luci 界面，选择 <strong>system - backup/flash firmware</strong>，在 <strong>configuration</strong> 菜单栏中将需要保存的文件或目录定义出来，然后在 <strong>action</strong> 菜单栏中选择 backup - generate archive 即可保存备份到本地。</p><h3>已安装包列表</h3><p>可以通过 awk 脚本识别出自己手动安装的包列表，方便更新系统后安装回去，下载脚本：<a href="https://github.com/richb-hanover/OpenWrtScripts/blob/main/opkgscript.sh">https://github.com/richb-hanover/OpenWrtScripts/blob/main/opkgscript.sh</a></p><p>执行以下命令会保存已安装的包列表到 <strong>/etc/config/opkg.installed</strong>：</p><pre><code>opkgscript.sh -v write
</code></pre><p>执行以下命令会识别并安装 <strong>/etc/config/opkg.installed</strong> 列表中的包：</p><pre><code>opkgscript.sh -v install
</code></pre><p>也可以执行以下 awk 脚本可以单独列出自己手动安装的包列表：</p><pre><code>#!/usr/bin/awk -f
BEGIN {
    ARGV[ARGC++] = &quot;/usr/lib/opkg/status&quot;
    cmd=&quot;opkg info busybox | grep '^Installed-Time: '&quot;
    cmd | getline FLASH_TIME
    close(cmd)
    FLASH_TIME=substr(FLASH_TIME,17)
}
/^Package:/{PKG= $2}
/^Installed-Time:/{
    INSTALLED_TIME= $2
    # Find all packages installed after FLASH_TIME
    if ( INSTALLED_TIME &gt; FLASH_TIME ) {
        cmd=&quot;opkg whatdepends &quot; PKG &quot; | wc -l&quot;
        cmd | getline WHATDEPENDS
        close(cmd)
        # If nothing depends on the package, it is installed by user
        if ( WHATDEPENDS == 3 ) print PKG
    }
}
EOF</code></pre><p>保存以上内容到 listuserpackages.awk 文件中并执行即可列出用户自行安装包列表。</p><h3>下载升级固件</h3><p>x86 版本的 openwrt 的升级固件就是全新安装时候用的固件，直接在官网下载需要版本的 gz 压缩包即可。</p><p>下载地址：<a href="https://downloads.openwrt.org/releases/">https://downloads.openwrt.org/releases/</a></p><p>我下载的是：<strong>generic-ext4-combined.img.gz</strong>，注意不要解压出来，保留压缩包即可。</p><p>进入 luci 的 <strong>system - backup/flash firmware</strong> 选择 Flash image ，然后选择刚才下载的压缩包即可上传更新，会提示是否保留设置和配置，<strong>跨大版本的升级必须取消选择保留数据，否则可能升级失败</strong>：<br><img src="https://blog.niekun.net/usr/uploads/2024/04/23408611.png" alt="image.png" title="image.png"></p><p>如果升级后卡在 <strong>grub</strong> 界面说明可能是由于选择了保留配置导致升级失败了，可以参考官方教程通过 failsafe mode 恢复默认配置：<a href="https://openwrt.org/docs/guide-user/troubleshooting/failsafe_and_factory_reset">Failsafe mode, factory reset, and recovery mode</a>，或者直接重新安装系统。</p><h3>网络配置</h3><p>稍等几分钟安装好后你可能会发现 luci 无法在局域网中访问了，这是由于新安装的固件恢复了 network 配置，需要直接到 openwrt 设备上配置网络。</p><p>配置教程参考：<a href="https://blog.niekun.net/archives/2291.html">openwrt network 配置</a></p><p>配置好网络后在局域网设备中可以用 ssh 登录了，此时会发现提示：</p><pre><code>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the RSA key sent by the remote host is
SHA256:U9XODs/7A4k065pxSMyEtQ2m98v2P0bf/ML0MfzU.
Please contact your system administrator.
Add correct host key in C:\\Users\\Marco Nie/.ssh/known_hosts to get rid of this message.
Offending RSA key in C:\\Users\\Marco Nie/.ssh/known_hosts:6
Host key for 192.168.244.1 has changed and you have requested strict checking.
Host key verification failed.</code></pre><p>这是由于更新系统后 ssh 指纹发生了变化，需要删除本地缓存的 openwrt 设备的指纹在登陆，windows 系统 ssh 指纹保存地址为当前用户目录下的 <strong>.ssh</strong> 文件夹。</p><h3>升级后续</h3><p>升级后可以通过之前的脚本列出的已安装包的列表将自己需要的包安装回去，同时将备份数据按照新系统的格式恢复回去。</p><p>从 openwrt 21 开始修改了 network 配置文件格式，参考：<a href="https://blog.niekun.net/archives/2291.html">https://blog.niekun.net/archives/2291.html</a><br>从 openwrt 22 开始替换 iptables 为 nftables，需要原始工具的话可以自行安装回去：<strong>opkg install iptables</strong></p><h3>参考链接</h3><p><a href="https://openwrt.org/docs/guide-user/additional-software/opkg#upgrading_packages">Opkg package manager</a><br><a href="https://lowtek.ca/roo/2021/openwrt-19-07-to-21-02-0-upgrade/">OpenWRT 19.07 to 21.02.0 upgrade</a></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/openwrt-1.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/other/archives/openwrt-1.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[Linux 查询及编辑用户及用户组]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/Linux.html" />
<id>https://blog.niekun.net/archives/Linux.html</id>
<updated>2024-04-01T16:20:00+08:00</updated>
<published>2024-04-01T16:20:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<category scheme="https://blog.niekun.net/category/Linux/" term="Linux" />
<category scheme="https://blog.niekun.net/category/other/" term="other" />
<summary type="html"><![CDATA[查询当前所有用户compgen -u查询当前所有用户组compgen -g添加一个用户到某个组sudo usermod -a -G groupName userNamenewgrp groupN...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/Linux.html" xml:lang="zh-CN"><![CDATA[
<h3>查询当前所有用户</h3><pre><code>compgen -u
</code></pre><h3>查询当前所有用户组</h3><pre><code>compgen -g
</code></pre><h3>添加一个用户到某个组</h3><pre><code>sudo usermod -a -G groupName userName
newgrp groupName
</code></pre><h3>删除一个用户从某个组</h3><pre><code>sudo usermod -G groupName userName
newgrp groupName
</code></pre><p>用户和组对文件的权限管理参考：<a href="https://blog.niekun.net/archives/224.html">chown 和 chmod 管理文件权限</a></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/Linux.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/other/archives/Linux.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[Linux 获取本地网关所有 ip 段地址]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/Linux-ip.html" />
<id>https://blog.niekun.net/archives/Linux-ip.html</id>
<updated>2024-03-28T15:35:07+08:00</updated>
<published>2024-03-28T15:35:07+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<category scheme="https://blog.niekun.net/category/Linux/" term="Linux" />
<category scheme="https://blog.niekun.net/category/other/" term="other" />
<summary type="html"><![CDATA[执行下面命令即可获取本地网关所有的 ip 段地址：$ ip address | grep -w inet | awk '{print $2}'127.0.0.1/8192.168.122.2/2...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/Linux-ip.html" xml:lang="zh-CN"><![CDATA[
<p>执行下面命令即可获取本地网关所有的 ip 段地址：</p><pre><code>$ ip address | grep -w inet | awk '{print $2}'
127.0.0.1/8
192.168.122.2/24
172.18.0.1/16
172.17.0.1/16
172.19.0.1/16</code></pre>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/Linux-ip.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/other/archives/Linux-ip.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[codesys enum 枚举数据类型单元的使用]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/codesys-enum.html" />
<id>https://blog.niekun.net/archives/codesys-enum.html</id>
<updated>2024-03-07T08:21:07+08:00</updated>
<published>2024-03-07T08:21:07+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<category scheme="https://blog.niekun.net/category/other/" term="other" />
<category scheme="https://blog.niekun.net/category/codesys/" term="CODESYS" />
<summary type="html"><![CDATA[enum 类型的 dut 可以定义一组属性及其值，调用的时候可以方便的通过写其属性名称得到属性的值，也可以获取到属性本身的名称。下面举一个例子说明：{attribute 'qualified_o...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/codesys-enum.html" xml:lang="zh-CN"><![CDATA[
<p>enum 类型的 dut 可以定义一组属性及其值，调用的时候可以方便的通过写其属性名称得到属性的值，也可以获取到属性本身的名称。</p><p>下面举一个例子说明：</p><pre><code>{attribute 'qualified_only'}            // 必须先写类型名称再写属性名称 (例如 eColor.Red)
// {attribute 'strict'}                 //取消 'strict' 以允许转换 UDINT 数据类型
{attribute 'to_string'}                 // 运行字符串转换 (例如 TO_STRING(eColor.Red) = 'Red')
TYPE eColor :
(
    Red         := 16#FFFF0000,
    Green       := 16#FF00FF00,
    Blue        := 16#FF0000FF
    Yellow      := 16#FFFFFF00,
) UDINT;                                // 声明 UDINT 作为 int 整形类型
END_TYPE

// 定义一些变量
    ColorVar1   : eColor;
    ColorVar2   : eColor;
    ColorName   : STRING;
    ColorValue  : UDINT;

    ColorVar1 := eColor.Green;            // ColorVar1 = 16#FF00FF00
    ColorName := TO_STRING(ColorVar1);    // ColorName = 'Green';
    ColorValue := TO_UDINT(ColorVar1);    // ColorValue = 16#FF00FF00

    ColorVar2 := 16#FF00FF00;             // ColorVar2.Green
    ColorName := TO_STRING(ColorVar2);    // ColorName = 'Green';
    ColorValue := TO_UDINT(ColorVar2);    // ColorValue = 16#FF00FF00

    ColorVar1 := ColorVar2 OR eColor.Red; // 按位相与得到 Yellow=16#FFFFFF00
    ColorName := TO_STRING(ColorVar1);    // ColorName = 'Yellow';
    ColorValue := TO_UDINT(ColorVar1);    // ColorValue = 16#FFFFFF00</code></pre><p>以上示例列举了常用的 enum 类型可进行的数据交互方式。</p><p><code>eColor.Green</code> 可以获取enum类型属性的值，并可以赋值给其他对应 enum 实例<br><code>TO_STRING(ColorVar1)</code> 可以转换获取 enum 实例当前值对应属性名称字符串</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/codesys-enum.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/other/archives/codesys-enum.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[codesys 常见编译及下载时报错解决方法]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/codesys.html" />
<id>https://blog.niekun.net/archives/codesys.html</id>
<updated>2024-03-06T16:35:00+08:00</updated>
<published>2024-03-06T16:35:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<category scheme="https://blog.niekun.net/category/other/" term="other" />
<category scheme="https://blog.niekun.net/category/codesys/" term="CODESYS" />
<summary type="html"><![CDATA[No source code available for this object下载时出现此报警，原因是 task 任务中对 gou 的排序有问题，放在前面的 pou 中使用了后面 pou 才设...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/codesys.html" xml:lang="zh-CN"><![CDATA[
<h3>No source code available for this object</h3><p>下载时出现此报警，原因是 task 任务中对 gou 的排序有问题，放在前面的 pou 中使用了后面 pou 才设定好的数据，需要重新排列 task 任务序列：<br><img src="https://blog.niekun.net/usr/uploads/2024/03/1281212428.png" alt="image.png" title="image.png"></p><h3>SMC_FB_CALLED_FROM_WRONG_TASK</h3><p><code>mc_power</code> <code>mc_jog</code> 等控制轴的功能块，一运行就报错 <strong>SMC_FB_CALLED_FROM_WRONG_TASK</strong>，可能是不同的 pou 放在了多个 task 任务中，循环中内部有了冲突，将所有的 pou 放在同一个 task 中就可以解决问题。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/codesys.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/other/archives/codesys.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[服务器部署 immich 照片备份工具]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/immich.html" />
<id>https://blog.niekun.net/archives/immich.html</id>
<updated>2024-03-04T09:30:00+08:00</updated>
<published>2024-03-04T09:30:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<category scheme="https://blog.niekun.net/category/ubuntu/" term="ubuntu" />
<category scheme="https://blog.niekun.net/category/other/" term="other" />
<summary type="html"><![CDATA[目前有很多的云备份服务可以使用，比如 icloud，google photos 等。immich 是一款实现类似功能的本地部署工具，将数据都存储在自己本地服务器上，拥有完善的手机端 app 可以...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/immich.html" xml:lang="zh-CN"><![CDATA[
<p>目前有很多的云备份服务可以使用，比如 icloud，google photos 等。immich 是一款实现类似功能的本地部署工具，将数据都存储在自己本地服务器上，拥有完善的手机端 app 可以方便的同步备份手机图片。</p><p>GitHub 主页：<a href="https://github.com/immich-app/immich">https://github.com/immich-app/immich</a><br>官网教程：<a href="https://immich.app/docs/overview/introduction/">https://immich.app/docs/overview/introduction/</a></p><!--more--><h3>安装服务端</h3><p>使用 docker compose 安装，新建一个 immich 文件夹，下载 <strong>docker-compose.yml</strong> 和 <strong>.env</strong> 文件到文件夹：</p><pre><code>wget https://github.com/immich-app/immich/releases/latest/download/docker-compose.yml
wget -O .env https://github.com/immich-app/immich/releases/latest/download/example.env</code></pre><p>打开 <strong>.env</strong> 文件配置环境变量，主要就是配置备份路径和数据库密码，修改 <strong>UPLOAD_LOCATION</strong> 和 <strong>DB_PASSWORD</strong>。</p><p>启动容器：</p><pre><code>docker compose up -d</code></pre><p>后续更新只需要进入 immich 文件夹执行下面命令即可：</p><pre><code>docker compose pull &amp;&amp; docker compose up -d
</code></pre><p><strong>docker-compose.yml</strong> 文件中默认将 3001 端口映射到了本地 2283 端口，3001就是服务端访问端口号。</p><p>下面是所有可用的端口，根据需要可以修改 docker-compose 文件映射到本地：</p><table><tbody><tr><td align="center">PORT</td><td align="center">Web Port</td><td>3000</td><td>web</td></tr><tr><td align="center">SERVER_PORT</td><td align="center">Server Port</td><td>3001</td><td>server</td></tr><tr><td align="center">MICROSERVICES_PORT</td><td align="center">Microservices Port</td><td>3002</td><td>microservices</td></tr><tr><td align="center">MACHINE_LEARNING_HOST</td><td align="center">Machine Learning Host</td><td>0.0.0.0</td><td>machine learning</td></tr><tr><td align="center">MACHINE_LEARNING_PORT</td><td align="center">Machine Learning Port</td><td>3003</td><td>machine learning</td></tr></tbody></table><h3>配置账户</h3><p>网页端访问：<strong><a href="http://you.machine.ip:2283">http://you.machine.ip:2283</a></strong> 进入配置页面，根据提示建立一个管理员账户，后续可以在管理员账户中建立其他子账户供其他人使用。</p><h3>登录 app</h3><p>下载手机端 app，ios 直接在 app store 搜索 immich 下载，安卓在 github 发布页下载 apk：<a href="https://github.com/immich-app/immich/releases">https://github.com/immich-app/immich/releases</a></p><p>在手机端输入以下网址进入：<strong><a href="http://you.machine.ip:2283/api">http://you.machine.ip:2283/api</a></strong></p><p>然后就可以配置需要备份的手机端图片文件夹了。</p><h3>外网访问</h3><p>服务器在本地，如果要外网域名远程访问图库，需要一些额外的配置，我这里是通过 cloudflare 配置子域名，nginx 配置反向代理到 frps，最后本地服务器 frpc 配置本地 2283 端口绑定到远程域名访问即可。</p><p>可以参考我之前的关于 frp 的教程：<a href="https://blog.niekun.net/archives/539.html">https://blog.niekun.net/archives/539.html</a></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/immich.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/other/archives/immich.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[Ubuntu 20.04 添加第三方 ppa]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/Ubuntu-20-04-ppa.html" />
<id>https://blog.niekun.net/archives/Ubuntu-20-04-ppa.html</id>
<updated>2024-02-22T09:18:33+08:00</updated>
<published>2024-02-22T09:18:33+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<category scheme="https://blog.niekun.net/category/ubuntu/" term="ubuntu" />
<category scheme="https://blog.niekun.net/category/other/" term="other" />
<summary type="html"><![CDATA[我服务器目前安装的是 Ubuntu 20.04 系统，很多新的软件包并没有在官方维护的源中提供，所以为了方便需要可以添加第三方的源。添加需要用到的命令是：add-apt-repository，但...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/Ubuntu-20-04-ppa.html" xml:lang="zh-CN"><![CDATA[
<p>我服务器目前安装的是 Ubuntu 20.04 系统，很多新的软件包并没有在官方维护的源中提供，所以为了方便需要可以添加第三方的源。</p><p>添加需要用到的命令是：<strong>add-apt-repository</strong>，但是默认系统并没有安装这个环境，需要先手动安装 package software-properties-common：</p><pre><code>sudo apt install software-properties-common
</code></pre><p>然后就可以安装需要的源了，推荐两个：<br><a href="https://launchpad.net/%7Esavoury1/+archive/ubuntu/backports?field.series_filter=bionic">https://launchpad.net/%7Esavoury1/+archive/ubuntu/backports?field.series_filter=bionic</a><br><a href="https://launchpad.net/%7Esavoury1/+archive/ubuntu/utilities?field.series_filter=bionic">https://launchpad.net/%7Esavoury1/+archive/ubuntu/utilities?field.series_filter=bionic</a></p><p>安装方法很简单：</p><pre><code>sudo add-apt-repository ppa:savoury1/backports
sudo add-apt-repository ppa:savoury1/utilities
sudo apt-get update</code></pre><p>执行 apt update 后会发现很多可更新的软件了。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/Ubuntu-20-04-ppa.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/other/archives/Ubuntu-20-04-ppa.html" thr:count="0"/>
</entry>
</feed>