<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"
xmlns:thr="http://purl.org/syndication/thread/1.0"
xml:lang="zh-CN"
xml:base="https://blog.niekun.net/category/js/"
>
<title type="text">Marco Nie - javascript</title>
<subtitle type="text"></subtitle>
<updated>2021-02-25T17:23:00+08:00</updated>
<generator uri="http://typecho.org/" version="1.2/18.10.23">Typecho</generator>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/category/js/" />
<id>https://blog.niekun.net/feed/atom/category/js/</id>
<link rel="self" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/js/" />
<entry>
<title type="html"><![CDATA[React 入门教程之四 -- Event]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/2189.html" />
<id>https://blog.niekun.net/archives/2189.html</id>
<updated>2021-02-25T17:23:00+08:00</updated>
<published>2021-02-25T17:23:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[events 处理处理 React elements events 和处理 DOM elements 很相似，但有一些语法区别：React events 命名使用 camelCase 规则，而不...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/2189.html" xml:lang="zh-CN"><![CDATA[
<h3>events 处理</h3><p>处理 React elements events 和处理 DOM elements 很相似，但有一些语法区别：</p><ul><li>React events 命名使用 camelCase 规则，而不是 lowercase</li><li>使用 JSX 传入 function 作为 events handler，而不是 string 字符串</li></ul><p>HMTL 中处理 events 示例如下：</p><pre><code>&lt;button onclick=&quot;activateLasers()&quot;&gt;
  Activate Lasers
&lt;/button&gt;</code></pre><p>React 中示例如下：</p><pre><code>&lt;button onClick={activateLasers}&gt;
  Activate Lasers
&lt;/button&gt;</code></pre><p>注意它们的区别之处一个是 event 名称，一个是 handler 定义方式。</p><!--more--><p>另一个区别是在 React 中不能通过 <strong>return false</strong> 的方式防止 events 的默认行为，需要明确的调用 <strong>preventDefault</strong> method 来实现。</p><p>例如在一个 html 页面中定义一个 <strong>a</strong> tag 并取消其默认打开新页面的行为，实现如下：</p><pre><code>&lt;a href=&quot;#&quot; onclick=&quot;console.log('The link was clicked.'); return false&quot;&gt;
  Click me
&lt;/a&gt;</code></pre><p>React 中实现同样功能代码如下：</p><pre><code>class Link extends React.Component {
    constructor(props) {
        super(props);
        this.handleClick = this.handleClick.bind(this);
    }
    handleClick(e) {
        e.preventDefault();
        console.log('clicked me');
    }
    render() {
        return (
            &lt;a href='#' onClick={this.handleClick}&gt;click me&lt;/a&gt;
        )
    }
}</code></pre><p><strong>e</strong> 表示 synthetic 综合的 event，当前哪个 event 触发了 <strong>e</strong> 就表示哪一个。使用 bind 绑定 的 method 在调用时会自动将 <strong>e</strong> 传入 method。下面会对 <strong>bind</strong> 是什么作出解释。</p><p>React events 同原生的 events 不完全相同，查看所有可用的 events 查看官方介绍：<a href="https://reactjs.org/docs/events.html">https://reactjs.org/docs/events.html</a></p><p>在 React 中一般情况下不需要通过调用 addEventListener 来给 element 添加 event listener。直接在 element 初始化时为其设置 event listener 即可。</p><p>当通过 class 来定义 component 时 event handler 一般是一个 class method，例如上面示例的 <strong>handleClick</strong>。</p><p>下面的示例我们构建一个 <strong>Toggle</strong> component 可以让用户通过一个 button 来切换 ON/OFF 状态：</p><pre><code>const React = require('react')
const ReactDOM = require('react-dom')

class Toggle extends React.Component {
    constructor(props) {
        super(props);
        this.state = { isToggleOn: true };
        this.handleClick = this.handleClick.bind(this);
    }
    handleClick() {
        this.setState({ isToggleOn: !this.state.isToggleOn });
    }
    render() {
        return (&lt;button onClick={this.handleClick}&gt; { this.state.isToggleOn ? 'ON' : 'OFF'} &lt;/button&gt;);
    }
}

ReactDOM.render(&lt;
    Toggle /&gt;,
    document.getElementById('root')
);</code></pre><p>在 <strong>JSX callback</strong> 中使用 <strong>this</strong> 需要特别注意，JavaScript class 的 methods 默认是相互隔离的，如果没有主动 <strong>bind</strong> 捆绑 method 到 <strong>this</strong>，在另一个 method 中使用 <strong>this.method</strong> 会报错 <strong>undefined</strong>。</p><p>如果调用 method 时不写括号<code>()</code> 例如：<code>onClick={this.handleClick}</code> 则需要提前 <strong>bind</strong> 这个 method 到 this 中，如上面的示例，<strong>bind</strong> 语法如下：</p><pre><code>this.handleClick = this.handleClick.bind(this);
</code></pre><p>一般将其放在 constructor 中，这样初始化中就会自动执行，当然也可以在调用时直接定义：</p><pre><code>&lt;button onClick={this.handleClick.bind(this)}&gt; { this.state.isToggleOn ? 'ON' : 'OFF'} &lt;/button&gt;
</code></pre><p><strong>如果不想使用 bind 语法来处理，那么还有两种方式来处理 class 中 methods 互相隔离这个问题。</strong></p><p><strong>第一种</strong>叫做 <strong>class fields syntax</strong> 语法，通过使用 <strong>arrow function</strong> 的模式定义 method，这样就可以通过通过 this.method 的方法调用 method：</p><pre><code>    constructor(props) {
        super(props);
        this.state = { isToggleOn: true };
    }
    handleClick = () =&gt; {
        this.setState({ isToggleOn: !this.state.isToggleOn });
    }
    render() {
        return (&lt;button onClick={this.handleClick} &gt; { this.state.isToggleOn ? 'ON' : 'OFF'} &lt;/button&gt;);
    }</code></pre><p>这样就不需要在 constructor 中定义 <strong>bind</strong> 同时可以在 callback 中直接调用 this.handleClick。</p><p>但是需要注意目前这只是 React 实验性的语法，不一定保证以后会一直可用。</p><p><strong>第二种</strong>是在 callback 中通过 <strong>arrow function</strong> 的模式调用 method：</p><pre><code>    handleClick() {
        this.setState({ isToggleOn: !this.state.isToggleOn });
    }
    render() {
        return (&lt;button onClick={() =&gt; this.handleClick()} &gt; { this.state.isToggleOn ? 'ON' : 'OFF'} &lt;/button&gt;);
    }</code></pre><p>注意这种方法需要在 method 名称后加括号<code>()</code>。</p><p>这种方法的缺点是当每次重新 render 渲染时都会创建新的 callback。当这个 callback 包含传给其 child component 的 props 时，可能会导致 child 重新被渲染。通常情况下推荐使用 constructor 定义 <strong>bind</strong> 或者使用 <strong>class fields syntax</strong> 语法来避免这些性能问题。</p><h4>给 event handler 传入数据</h4><p>有时候需要给 event handler 传入附加的参数，如下面示例 button 点击时输出一个输入数据到终端：</p><pre><code>    handleClick(a, e) {
        this.setState({ isToggleOn: !this.state.isToggleOn });
        console.log(e._reactName);
        console.log(a);
    }
    render() {
        return (&lt;button onClick={this.handleClick.bind(this, 'aaa')} &gt; { this.state.isToggleOn ? 'ON' : 'OFF'} &lt;/button&gt;);
    }</code></pre><p>上面的示例将字符串 <strong>aaa</strong> 作为 handleClick 的传入参数，并将 bind 绑定过程直接放在 callback 中，这样就不需要在 constructor 中进行 bind 定义了。</p><p>通过 bind 绑定后会自动将 <strong>e</strong>：synthetic 综合的 event 作为第二个参数传入 function，<strong>e._reactName</strong> 返回 event 名称。</p><p>上面的示例也可以通过 <strong>arrow function</strong> 在 callback 中定义实现：</p><pre><code>    handleClick(a, e) {
        this.setState({ isToggleOn: !this.state.isToggleOn });
        console.log(e._reactName);
        console.log(a);
    }
    render() {
        return (&lt;button onClick={(e) =&gt; this.handleClick('aaa', e)} &gt; { this.state.isToggleOn ? 'ON' : 'OFF'} &lt;/button&gt;);
    }</code></pre><p>上面的示例中 e 依然表示 synthetic event。两种方法都会将 e 作为第二个参数传入。在 arrow function 中我们可以清晰地看到数据的位置，但是通过 <strong>bind</strong> 的方式会将有些参数自动转发过去。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/2189.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/2189.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[React 入门教程之四 -- rendering, components 和 state]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/2184.html" />
<id>https://blog.niekun.net/archives/2184.html</id>
<updated>2021-02-24T17:17:00+08:00</updated>
<published>2021-02-24T17:17:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[rendering elements 渲染元素一个 element 表示我们想要显示在屏幕上的内容：const element = &amp;lt;h1&amp;gt;Hello, world&amp;lt;/h1&amp;g...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/2184.html" xml:lang="zh-CN"><![CDATA[
<h3>rendering elements 渲染元素</h3><p>一个 element 表示我们想要显示在屏幕上的内容：</p><pre><code>const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;
</code></pre><p>不同于浏览器 DOM 中的 elements，React elements 是简单的 objects 且可以很方便的创建，React DOM 会严格的刷新 DOM 并匹配对应的 React elements。</p><p>容易混淆的概念是 component 和 element，区别是 component 是用来创建 element 的。在后续章节会介绍。</p><!--more--><h4>在 DOM 中渲染元素</h4><p>我们的 html 页面中定义了一个 div 容器：</p><pre><code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
</code></pre><p>我们将其称作 <strong>root</strong> DOM 节点，因为它所有的内容都是被 React DOM 管理的。</p><p>通常情况下使用 React 创建的程序只有一个 <strong>root</strong> DOM 节点。如果你是将 React 整合到现有网站中，你可以有任意个独立的 <strong>root</strong> DOM 节点。</p><p>将 React elements 渲染到 <strong>root</strong> DOM 节点，需要通过调用 <code>ReactDOM.render()</code>，并将 React element 和 <strong>root</strong> DOM 节点作为传入参数：</p><pre><code>const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;

ReactDOM.render(
    element,
    document.getElementById('root')
);</code></pre><p>此时页面会显示 hello world。</p><h4>刷新渲染的元素</h4><p>React element 是 immutable 不可改变的，当创建了一个 element 后不可以修改其 children 或 attributes，一个 element 就好像一个视频的一帧，它表示了某一时间点的 UI。</p><p>从我们目前学到的知识，唯一刷新 UI 的方法就是重新创建新的 elements 然后调用 <code>ReactDOM.render()</code>，通过设置 setInterval 来定时刷新：</p><pre><code>const tick = () =&gt; {
    const element = &lt;h1&gt;{new Date().toLocaleTimeString()}&lt;/h1&gt;;

    ReactDOM.render(
        element,
        document.getElementById('root')
    );
}
setInterval(tick, 1000);</code></pre><p>这样就会每秒钟创建一个新的 element 并通过 <code>ReactDOM.render()</code> 渲染到界面。</p><p>通常情况下大多数 React app 只会调用 <code>ReactDOM.render()</code> 一次。下一章节会介绍如何将封装到 component 中。</p><h3>React 只会更新必要的内容</h3><p>React DOM 会比较其当前和上一个状态的，然后只对有了变化的部分进行更新来达到最终期望的状态。</p><p>我们打开上面示例的运行页面，通过chrome 的开发工具查看 elements 情况，可以看到只有时间元素每秒在刷新：<br>![2021-02-24T07:44:17.png][<br>即使我们每秒钟都新建并渲染 element，但是只有时间文本 node 是一直通过 React DOM 在刷新的。通过以上的实验，思考我们的 UI 在某个时间点应该是什么样的，而不是只想这着去修改它。</p><h3>components 和 props</h3><p><strong>components</strong> 将 UI 元素分割为独立的，可复用的片段，每个片段都是单独存在的。这一章节介绍 component 的概念，更多细节参考：<a href="https://reactjs.org/docs/react-component.html">React.Component</a></p><p><strong>components</strong> 类似于 JavaScript 的 functions，它可以接受抽象的输入数据(<strong>props</strong>)，然后返回 React elements 用来在界面上显示。</p><h4>Function 和 Class Components</h4><p>最简单的定义 component 方式就是定义一个 JavaScript function：</p><pre><code>const Welcome = (props) =&gt; {
    return &lt;h1&gt; hello, {props.name}&lt;/h1&gt;
}</code></pre><p>上面的 function 是一个有效的 React component，因为它接受一个单参数 <strong>props</strong> object 作为传入数据并返回一个 React element。我们称这种 component 为 function component。</p><p>也可以使用 ES6 的 class 定义 component：</p><pre><code>class Welcome extends React.Component {
    render() {
        return &lt;h1&gt;hello, {this.props.name}&lt;/h1&gt;
    }
}</code></pre><p>以上两种定义方式是一致的。</p><p>需要注意的是 <strong>components</strong> 名称<strong>必须是以大写字母开头</strong>，因为 React 会见以小写字母开头的 components 作为 DOM tags 标签，如：<code>&lt;div /&gt;</code> 表示一个 html div 标签。</p><h4>rendering a component</h4><p>上面的介绍中，我们只遇到了 DOM tags 标签类型的 React elements，例如：</p><pre><code>const element = &lt;div /&gt;;
</code></pre><p>elements 也可以表示用户自定义的 components：</p><pre><code>const element = &lt;Welcome name='marco' /&gt;
</code></pre><p>当 React 检测到使用了用户自定义的 components 它会将此 JSX 内的 attributes 或 children 作为一个 object 传入 component，这个 object 叫做 <strong>props</strong>。</p><p>下面的示例会输出 <strong>hello, marco</strong>:</p><pre><code>const Welcome = (props) =&gt; {
    return &lt;h1&gt; hello, {props.name}&lt;/h1&gt;;
}

const element = &lt;Welcome name='marco' /&gt;;
ReactDOM.render(
    element,
    document.getElementById('root')
);</code></pre><p>以上示例过程如下：</p><ul><li>首先调用 <code>ReactDOM.render()</code> 渲染 <code>&lt;Welcome name=&quot;Sara&quot; /&gt;</code> 元素.</li><li>React 调用 <strong>Welcome</strong> component 使用 {name: 'Sara'} 作为 <strong>props</strong>.</li><li><strong>Welcome</strong> component 返回一个 <code>&lt;h1&gt;Hello, Sara&lt;/h1&gt;</code> 元素.</li><li><strong>React</strong> DOM 高效的更新 DOM 来匹配 <code>&lt;h1&gt;Hello, Sara&lt;/h1&gt;</code> 结果.</li></ul><h3>构建 component</h3><p>component 可以在其输出中引入关联其他 components。这可以让我们在一个 component 内抽象出一个多层的结构。一个 button，一个 form，一个 dialog 或者一个 screen，在 React app 中他们都统称为 components。</p><p>例如我们可以创建一个 App component 来渲染多个 Welcome component：</p><pre><code>const Welcome = (props) =&gt; {
    return &lt;h1&gt; hello, {props.name}&lt;/h1&gt;;
}

const App = () =&gt; {
    return (
        &lt;div&gt;
            &lt;Welcome name='marco' /&gt;
            &lt;Welcome name='tim' /&gt;
            &lt;Welcome name='jone' /&gt;
        &lt;/div&gt;
    )
}
ReactDOM.render(
    &lt;App /&gt;,
    document.getElementById('root')
);</code></pre><p>以上示例中，没有定义 App 的 props，因为不需要给其传入数据，也是可以的。</p><p>一般情况下，新建的 React app 只有一个顶层的 <strong>App</strong> component。</p><h4>拆解 component</h4><p>不要害怕将一个 component 拆解为多个小 components。例如下面这个 <strong>Comment</strong> component：</p><pre><code>function Comment(props) {
  return (
    &lt;div className=&quot;Comment&quot;&gt;
      &lt;div className=&quot;UserInfo&quot;&gt;
        &lt;img className=&quot;Avatar&quot;
          src={props.author.avatarUrl}
          alt={props.author.name}
        /&gt;
        &lt;div className=&quot;UserInfo-name&quot;&gt;
          {props.author.name}
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div className=&quot;Comment-text&quot;&gt;
        {props.text}
      &lt;/div&gt;
      &lt;div className=&quot;Comment-date&quot;&gt;
        {formatDate(props.date)}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</code></pre><p>它的 props 包含一个 <strong>author</strong> object，一个 <strong>text</strong>，一个 <strong>data</strong>，描述了一个社交网站上一个 commit 的内容。</p><p>修改这个 component 有点困难，因为它有很多的嵌套，同时也难以复用它的内部组件。下面我们尝试拆解这个 component。</p><p>首先我们拆解出 <strong>Avatar</strong>：</p><pre><code>const Avatar = (props) =&gt; {
    return (
        &lt;img className=&quot;Avatar&quot;
            src={props.user.avatarUrl}
            alt={props.user.name}
        /&gt;
    );
}</code></pre><p><strong>Avatar</strong> 并不需要知道它被用于 <strong>commit</strong> 中，因此我们修改其 <strong>prop</strong> 名称为一个更加通用的：<strong>user</strong>。推荐从 component 本身为出发点命名 props，而不是考虑什么地方使用它。</p><p>现在我们可以简化 Commit component：</p><pre><code>function Comment(props) {
    return (
        &lt;div className=&quot;Comment&quot;&gt;
            &lt;div className=&quot;UserInfo&quot;&gt;
                &lt;Avatar user={props.author} /&gt;
                &lt;div className=&quot;UserInfo-name&quot;&gt;
                    {props.author.name}
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div className=&quot;Comment-text&quot;&gt;
                {props.text}
            &lt;/div&gt;
            &lt;div className=&quot;Comment-date&quot;&gt;
                {formatDate(props.date)}
            &lt;/div&gt;
        &lt;/div&gt;
    );
}</code></pre><p>我们将 <strong>props.author</strong> 作为 <strong>user</strong> 数据传入 <strong>Avatar</strong> component 中。</p><p>下面我们拆解 <strong>UserInfo</strong>，其中包含一个 <strong>Avatar</strong> component：</p><pre><code>const UserInfo = (props) =&gt; {
    return (
        &lt;div className=&quot;UserInfo&quot;&gt;
            &lt;Avatar user={props.user} /&gt;
            &lt;div className=&quot;UserInfo-name&quot;&gt;
                {props.user.name}
            &lt;/div&gt;
        &lt;/div&gt;
    );
}</code></pre><p>然后进一步简化 Commit：</p><pre><code>function Comment(props) {
    return (
        &lt;div className=&quot;Comment&quot;&gt;
            &lt;UserInfo user={props.user} /&gt;
            &lt;div className=&quot;Comment-text&quot;&gt;
                {props.text}
            &lt;/div&gt;
            &lt;div className=&quot;Comment-date&quot;&gt;
                {formatDate(props.date)}
            &lt;/div&gt;
        &lt;/div&gt;
    );
}</code></pre><p>拆解 component 在开始看起来使工作量变大了，但是在稍微复杂写的 app 中我们就能够利用这些可复用的 components。一条基本准则是：如果 UI 中的某一部分被多次使用，如 button，panel，Avatar等，或者其自身结构比较复杂，如：App, FeedStory, Comment 等，将他们拆解为独立 components 是一个好的选项。</p><h4>props 是只读的</h4><p>当把一个 component 定义为 function 或 class 时，需要注意的是不可以修改 <strong>props</strong> 的值。</p><p>考虑下面的 function：</p><pre><code>function sum(a, b) {
  return a + b;
}</code></pre><p>以上的 function 被称作 pure 纯粹的，以为它没有尝试修改输入数据。</p><p>作为对比，下面的就是 impure 不纯粹的 function，因为会尝试修改它的输入数据：</p><pre><code>function sum(a, b) {
  a = b;
}</code></pre><p><strong>React</strong> 程序有一条限制条件：<strong>所有的 React components 都需要是 pure function 来对待 props 数据</strong>。</p><p>当然应用程序的 UI 是随时间动态变化的。下一节我们会介绍 state 的概念。通过 state 可以使 React components 在运行期间修改它们的输出 elements 来响应用户动作，网络响应等。同时不违反上面的那条规则。</p><h3>state 和 lifecycle</h3><p>这一节介绍 React components 中 state 和 lifecycle 的概念。</p><p>在前一章的示例中，我们通过一个 <strong>tick</strong> function 在指定时间间隔通过创建新 element 并渲染的方式刷新 UI：</p><pre><code>const tick = () =&gt; {
    const element = (
        &lt;div&gt;
            &lt;h1&gt;hello world&lt;/h1&gt;
            &lt;h2&gt;{new Date().toLocaleTimeString()}&lt;/h2&gt;
        &lt;/div&gt;
    );

    ReactDOM.render(
        element,
        document.getElementById('root')
    );
}
setInterval(tick, 1000);</code></pre><p>下面我们介绍通过创建一个封装好的 <strong>Clock</strong> component，设置定时器并更新其自身。</p><p>首先我们根据上面的示例创建 <strong>Clock</strong> component：</p><pre><code>const Clock = (props) =&gt; {
    &lt;div&gt;
        &lt;h1&gt;hello world&lt;/h1&gt;
        &lt;h2&gt;{props.date.toLocaleTimeString()}&lt;/h2&gt;
    &lt;/div&gt;
}

const tick = () =&gt; {
    ReactDOM.render(
        &lt;Clock date={new Date()} /&gt;,
        document.getElementById('root')
    );
}
setInterval(tick, 1000);</code></pre><p>在 <strong>tick</strong> 调用 <strong>Clock</strong> component 并定义 <strong>date</strong> prop 的数据供 Clock 使用。但是上面的实现缺乏一个基本需求，那就是 Clock 应该在其自身中定义定时器并每秒刷新数据的。</p><p>我们想要在渲染时达到如下效果调用 Clock：</p><pre><code>ReactDOM.render(
  &lt;Clock /&gt;,
  document.getElementById('root')
);</code></pre><p>为了实现上述功能，需要为 <strong>Clock</strong> 添加 <strong>state</strong>。<strong>state</strong> 类似于 <strong>props</strong> 但是它是由 component 私有且完全控制的。</p><p>首先我们需要将 component 转换为 class 模式，转换过程如下：</p><ul><li>首先创建一个 ES6 class，且继承自 <strong>React.Component</strong>。</li><li>添加一个 <code>render()</code> function，将原 component function 的返回元素放入其返回值中</li><li>在 <code>render()</code> 中用 <strong>this.props</strong> 代替 <strong>props</strong></li></ul><pre><code>class Clock extends React.Component {
    render() {
        return (
            &lt;div&gt;
                &lt;h1&gt;hello world&lt;/h1&gt;
                &lt;h2&gt;{this.props.date.toLocaleTimeString()}&lt;/h2&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>当 update 更新发生时会自动调用 <strong>render</strong> function。但当我们将 <code>&lt;Clock /&gt;</code> 放入 DOM 后，将只会有一个 <strong>Clock</strong> object 实例被使用，这就让我们可以使用 <strong>state</strong> 或 <strong>lifecycle</strong> 等功能。</p><h4>添加 state</h4><p>下面我们将 <strong>date</strong> 数据直接放入 <strong>CLock</strong> component 中。</p><p>首先将 render 中的 <strong>this.props.date</strong> 修改为 <strong>this.state.date</strong>：</p><pre><code>class Clock extends React.Component {
    render() {
        return (
            &lt;div&gt;
                &lt;h1&gt;hello world&lt;/h1&gt;
                &lt;h2&gt;{this.state.date.toLocaleTimeString()}&lt;/h2&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>然后添加 class constructor 构造器给 <strong>this.state</strong> 赋初值：</p><pre><code>class Clock extends React.Component {
    constructor(props) {
        super(props);
        this.state = {date: new Date()}
    }
    render() {
        return (
            &lt;div&gt;
                &lt;h1&gt;hello world&lt;/h1&gt;
                &lt;h2&gt;{this.state.date.toLocaleTimeString()}&lt;/h2&gt;
            &lt;/div&gt;
        );
    }
}</code></pre><p>注意 class component 总是应该使用 constructor 且初始化参数为 props。child class 有 constructor 时需要调用 super 来初始化 parent class，具体语法参考我的 JavaScript 教程：<a href="https://blog.niekun.net/archives/2011.html">https://blog.niekun.net/archives/2011.html</a></p><p>然后删除渲染到 DOM 中 <strong>Clock</strong> 的 <strong>date</strong> prop，以及我们设置的 <strong>setInterval</strong> 定时器：</p><pre><code>ReactDOM.render(
    &lt;Clock /&gt;,
    document.getElementById('root')
);</code></pre><p>修改完成后的完整代码如下：</p><pre><code>class Clock extends React.Component {
    constructor(props) {
        super(props);
        this.state = {date: new Date()}
    }
    render() {
        return (
            &lt;div&gt;
                &lt;h1&gt;hello world&lt;/h1&gt;
                &lt;h2&gt;{this.state.date.toLocaleTimeString()}&lt;/h2&gt;
            &lt;/div&gt;
        );
    }
}

ReactDOM.render(
    &lt;Clock /&gt;,
    document.getElementById('root')
);</code></pre><p>下面我们实现 Clock 设置自己的定时器并每秒更新。</p><h4>添加 lifecycle method</h4><p>对于包含很多 components 的程序，但某个 component 不再需要是需要及时释放其占用的资源。</p><p>我们需要 <strong>Clock</strong> 第一次在 DOM 中渲染时设置一个 timer 定时器，在 React 中叫做 <strong>mounting</strong> 载入。同时我们需要当 <strong>Clock</strong> 在 DOM 中被删除时清除这个定时器，在 React 中叫做 <strong>unmounting</strong> 卸载。</p><p>我们可以在 components 载入或载出时通过定义特殊的 method 来运行特定指令：</p><pre><code>  componentDidMount() {
  }

  componentWillUnmount() {
  }</code></pre><p>这些 methods 叫做 <strong>lifecycle methods</strong>。</p><p><strong>componentDidMount</strong> method 会在 component 第一次输出到 DOM 后被自动调用，我们可以将定时器定义在这里：</p><pre><code>    componentDidMount() {
        this.timerID = setInterval(() =&gt; this.tick(), 1000);
    }</code></pre><p>这样当 Clock 渲染到 UI 后会自动启动这个定时器。注意使用 this 定义的参数可以在 class 中任意地方被调用。</p><p>注意 <strong>setInterval</strong> 中定义的响应动作需要写在 callback 内 <code>() =&gt; {}</code> 中，不要直接写：<code>setInterval(this.tick, 1000)</code>。因为如果要在 callback 调用 method 需要在 constructor 中做如下定义：</p><pre><code>this.tick = this.tick.bind(this);
</code></pre><p><strong>componentWillUnmount</strong> method 会在 component 将要被删除时自动调用，我们将定时器在这里取消：</p><pre><code>    componentWillUnmount() {
        clearInterval(this.timerID);
    }</code></pre><p>接下来我们定义每秒都会自动运行的 <strong>tick</strong> method，通过 <code>this.setState()</code> 来更新本地 state 中的设置：</p><pre><code>    tick() {
        this.setState({ date: new Date() });
    }</code></pre><p>最终的完整代码如下：</p><pre><code>const React = require('react')
const ReactDOM = require('react-dom')

class Clock extends React.Component {
    constructor(props) {
        super(props);
        this.state = { date: new Date() }
    }

    componentDidMount() {
        this.timerID = setInterval(() =&gt; this.tick(), 1000);
    }

    componentWillUnmount() {
        clearInterval(this.timerID);
    }

    tick() {
        this.setState({ date: new Date() });
    }

    render() {
        return (
            &lt;div&gt;
                &lt;h1&gt;hello world&lt;/h1&gt;
                &lt;h2&gt;{this.state.date.toLocaleTimeString()}&lt;/h2&gt;
            &lt;/div&gt;
        );
    }
}

ReactDOM.render(
    &lt;Clock /&gt;,
    document.getElementById('root')
);</code></pre><p>现在整个处理流程如下：</p><ul><li>当 <code>ReactDOM.render()</code> 传入 <code>&lt;Clock /&gt;</code> 后，React 调用 Clock 构造器初始化 state 为一个包含 date 的 object</li><li>然后 React 调用 Clock 的 <code>render()</code> 查询到需要显示的 UI 元素，然后更新 DOM 以匹配 Clock 的输出</li><li>当 Clock 的输出嵌入到 DOM 后会调用 <strong>componentDidMount</strong>，Clock 告诉浏览器设置一个定时器每秒调用 <code>tick()</code></li><li>每秒钟调用一次 <code>tick()</code>，这里面 Clock component 通过 <code>setState()</code> 配置了其 UI 更新任务，通过 <code>setState()</code> React 就知道了 state 发生了变化并再次调用 <code>render()</code> 监测需要显示的内容，此时的 <code>this.state.date</code> 和上一次的发生了变化，React 就会更新 DOM 到最新的状态。</li><li>当 Clock 从 DOM 中删除后，React 会调用 <strong>componentWillUnmount</strong> 并结束定时器</li></ul><h4>正确使用 state</h4><p>关于 state 的使用需要如下的几点要求。</p><p>第一点，<strong>不要直接修改 state</strong>。</p><p>下面的语法不会触发重新 render 渲染 component：</p><pre><code>this.state.comment = 'Hello';
</code></pre><p>正确的语法为使用 <strong>setState()</strong>：</p><pre><code>this.setState({comment: 'Hello'});
</code></pre><p>唯一可以对 state 赋值的是在 constructor 构造器中。</p><p>第二点，<strong>state 更新是异步的</strong>。</p><p>React 为了性能可能会在一次 component update 更新中捆绑多个 <strong>setState()</strong> 调用，由于 <strong>this.props</strong> 和 <strong>this.state</strong> 可能会被异步更新，所以不要依赖他们的数据来计算后续的 <strong>state</strong>。</p><p>如下示例可能会错误的更新 counter：</p><pre><code>this.setState({
  counter: this.state.counter + this.props.increment,
});</code></pre><p>为了实现是这个需求，使用 setState 的另一种格式：传入一个 function，第一个参数为当前 state，第二个参数为 props 然后内部计算 state 更新：</p><pre><code>this.setState(function (state, props) {
    return {
        counter: state.counter + props.increment
    };
});</code></pre><p>第三点，<strong>state 更新会合并</strong>。</p><p>当调用 <code>setState()</code> 后，会合并设置的 object 到当前 state 中。</p><p>如下示例，<strong>state</strong> 可能包含多个独立的变量：</p><pre><code>    constructor(props) {
        super(props);
        this.state = {
            posts: [],
            comments: []
        };
    }</code></pre><p>然后我们可以单独调用 <strong>setState()</strong> 来分别更新它们：</p><pre><code>    componentDidMount() {
        fetchPosts().then(response =&gt; {
            this.setState({
                posts: response.posts
            });
        });

        fetchComments().then(response =&gt; {
            this.setState({
                comments: response.comments
            });
        });
    }</code></pre><p>合并过程是自动完成的，所以通过 <strong>setState</strong> 修改 comments 只会更新 comments 而不会改变 posts。</p><h4>数据向下传递</h4><p>一个 component 的 child 或 parent 都不会知道当前 component 是包含 state 还是不包含，且不关心是通过 function 还是 class 方式构建的 component。所以 state 被认为是封装的不能够被外界所访问。</p><p>component 的 state 可以作为 props 向它的 child component 传递：</p><pre><code>&lt;FormattedDate date={this.state.date} /&gt;
</code></pre><p>如上所示 FormattedDate 可以接受 date prop，它并不知道数据来自 parent 的 state 还是 props：</p><pre><code>function FormattedDate(props) {
  return &lt;h2&gt;It is {props.date.toLocaleTimeString()}.&lt;/h2&gt;;
}</code></pre><p>通常这叫做 <strong>top-down</strong> 或 <strong>unidirectional</strong> 数据流。任何 state 都被某个特定 component 所有，state 的数据只能在其 component 的 child 中传递出去。</p><p>我们通过建立 <strong>App</strong> component 并构建三个 <strong>Clock</strong> component 来展示 component 之间是互相独立的：</p><pre><code>function App() {
    return (
        &lt;div&gt;
            &lt;Clock /&gt;
            &lt;Clock /&gt;
            &lt;Clock /&gt;
        &lt;/div&gt;
    );
}

ReactDOM.render(
    &lt;App /&gt;,
    document.getElementById('root')
);</code></pre><p>每个 Clock 都有个各自的定时器并独立更新。</p><p>在 React 中，components 定义为 stateful 还是 stateless 的取决于其在运行中可能的变化，可以在 stateful 的 component 中使用 stateless 的 component，反过来亦可。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/2184.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/2184.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[React 入门教程之三 -- 介绍  JSX]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/2183.html" />
<id>https://blog.niekun.net/archives/2183.html</id>
<updated>2021-02-24T14:45:12+08:00</updated>
<published>2021-02-24T14:45:12+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[请看下面的一个定义：const element = &amp;lt;h1&amp;gt;Hello, world!&amp;lt;/h1&amp;gt;;它既不是一个 string 也不是 html。它叫做 JSX，是一种对 ...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/2183.html" xml:lang="zh-CN"><![CDATA[
<p>请看下面的一个定义：</p><pre><code>const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;
</code></pre><p>它既不是一个 string 也不是 html。它叫做 <strong>JSX</strong>，是一种对 JavaScript 语法的扩展。推荐在 React 中使用 JSX 来描述 UI，它用来创建 React 类型的 elements 然后将其在 DOM 中渲染。</p><p>下面对 JSX 做一些基本介绍。</p><!--more--><h3>使用 JSX 的原因</h3><p>React 认同这种观点：渲染逻辑结构和 UI 逻辑结构是原生相互耦合的，events 的处理，状态的变化，数据何时显示等。不同于人为的将 markup 部分和 logic 逻辑部分放在单独的文件，React 的耦合单元叫做 components 可以同时包含 markup 和 logic 部分。</p><p>React 并不强制要求使用 JSX，但是大部分开发者认为它可以帮助在 JavaScript 中处理 UI 的问题。它也可以帮助 React 显示更多的 error 或 warning 信息。</p><h3>JSX 中使用 JavaScript 表达式</h3><p>下面的示例中，我们声明一个变量并在 JSX 中通过大括号<code>{}</code> 调用变量：</p><pre><code>const name = 'marco nie';
const element = &lt;h1&gt;hello, {name}&lt;/h1&gt;

ReactDOM.render(
    element,
    document.getElementById('root')
);</code></pre><p>我们可以将任意的 JavaScript 表达式通过大括号<code>{}</code>放如 JSX 中。例如：<code>1 + 1</code>，<code>user.name</code> 都是有效的 JavaScript 表达式：</p><pre><code>const city = 'han zhong';
const user = {
    name: 'marco',
    age: 20
}
const element = &lt;h1&gt;hello, {user.name}, from {city}, time: {1 + 20}&lt;/h1&gt;</code></pre><p>可以将 JSX 分割成多行以提高代码可读性，需要使用小括号包围起来，防止编译器错误的自动添加分行符：</p><pre><code>const element = (
    &lt;h1&gt;
        hello, {user.name}, from {city}, time: {1 + 20}
    &lt;/h1&gt;
);</code></pre><p>编译后 JSX 表达式会转换为通用的 JavaScript function 或 objects。这就意味着我们可以在 if 或 for 表达式中，传入数据中或者 返回值中使用 JSX：</p><pre><code>const testFuc = () =&gt; {
    return &lt;h1&gt;hello, {user.name}&lt;/h1&gt;
}</code></pre><h3>JSX 中定义属性</h3><p>可以使用引号 <code>&quot;&quot;</code> 将一个字符串作为属性：</p><pre><code>const el1 = &lt;div tabIndex=&quot;0&quot;&gt;&lt;/div&gt;
</code></pre><p>可以以通过大括号<code>{}</code> 将一个 JavaScript 表达式嵌入属性：</p><pre><code>const el2 = &lt;img src={user.name}&gt;&lt;/img&gt;
</code></pre><p>当使用 JavaScript 嵌入属性时不能在大括号中使用引号，同一个属性中只能使用<strong>引号嵌入字符串</strong>或者<strong>大括号嵌入 JavaScript 表达式</strong>中的一种。</p><p>由于 JSX 更加接近于 JavaScript 而不是 html，所以 React 中的 DOM 使用 camelCase 属性命名规范代替 html 中的属性名称，例如 html 元素的 class 属性在 JSX 中定义为 className，tabindex 在 JSX 中为 tabIndex。</p><h3>定义子元素</h3><p>如果一个 tag 元素内容是空的则可以使用 <code>/&gt;</code> 立刻结束定义：</p><pre><code>const el3 = &lt;img src=''/&gt;
</code></pre><p>JSX tag 标签内也可以有子元素：</p><pre><code>const el4 = (
    &lt;div&gt;
        &lt;h1&gt;hello,&lt;/h1&gt;
        &lt;h2&gt;i am your friend&lt;/h2&gt;
    &lt;/div&gt;
);</code></pre><p>注意只能在一个元素内定义子元素，不能直接定义两个同级的元素否则会报错。</p><h3>防止 injection 注入攻击</h3><p>在 JSX 中嵌入用户输入是安全的：</p><pre><code>const title = response.potentiallyMaliciousInput;
// This is safe:
const element = &lt;h1&gt;{title}&lt;/h1&gt;;</code></pre><p>默认情况下 React 在渲染前会将脱开所有嵌入 JSX 中的数据，因此可以确保不会注入任何没有明确定义在应用中的数据。渲染前所有的所有内容都会转换为 string 字符串形式。则能够防止 XSS (cross-site-scripting) 攻击。</p><h3>JSX 表达 objects</h3><p>Babel 会将 JSX 向下编译为对 React.createElement() 的调用，以下两种定义方法是相同的：</p><pre><code>const el5 = (
    &lt;h1 className='test'&gt;
        hello world
    &lt;/h1&gt;
);</code></pre><pre><code>const el6 = React.createElement(
    'h1',
    {className: 'test'},
    'hello world'
)</code></pre><p>通过 <code>React.createElement()</code> 创建元素会额外做一些语法检查来防止错误代码。但通常我们使用下面语法创建一个 object：</p><pre><code>const el7 = {
    type: 'h1',
    props: {
        className: 'test',
        children: 'hello world'
    }
}</code></pre><p>以上方式创建的 object 叫做 <strong>React elements</strong>。React 使用这些 objects 来构建 DOM 并及时更新。</p><p>推荐代码编辑器使用 <strong>Babel</strong> 语法定义环境，这样可以同时支持 ES6 和 JSX 语法结构。设置方法参考：<a href="https://babeljs.io/docs/en/editors">https://babeljs.io/docs/en/editors</a></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/2183.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/2183.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[React 入门教程之二 -- hello world]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/2176.html" />
<id>https://blog.niekun.net/archives/2176.html</id>
<updated>2021-02-24T12:40:18+08:00</updated>
<published>2021-02-24T12:40:18+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[下面我们通过创建 Create React App 介绍 React 的基本语法。通过上一节介绍的方法创建一个新程序 my-app-1:npx create-react-app my-app-1...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/2176.html" xml:lang="zh-CN"><![CDATA[
<p>下面我们通过创建 <strong>Create React App</strong> 介绍 React 的基本语法。</p><p>通过上一节介绍的方法创建一个新程序 <strong>my-app-1</strong>:</p><pre><code>npx create-react-app my-app-1
cd my-app-1</code></pre><p>关于创建新项目及可能出现的问题参考上一篇：<a href="https://blog.niekun.net/archives/2175.html">https://blog.niekun.net/archives/2175.html</a></p><p><strong>Create React App</strong> 官方教程：<a href="https://create-react-app.dev/docs/documentation-intro">https://create-react-app.dev/docs/documentation-intro</a></p><!--more--><h3>项目结构</h3><p>程序目录结构如下：</p><pre><code>my-app-1
├── README.md
├── node_modules
├── package.json
├── .gitignore
├── public
│   ├── favicon.ico
│   ├── index.html
│   ├── logo192.png
│   ├── logo512.png
│   ├── manifest.json
│   └── robots.txt
└── src
    ├── App.css
    ├── App.js
    ├── App.test.js
    ├── index.css
    ├── index.js
    ├── logo.svg
    ├── serviceWorker.js
    └── setupTests.js</code></pre><p>对于一个项目而言，下面两个文件是必须的:</p><ul><li><strong>public/index.html</strong> 是页面的模板文件;</li><li><strong>src/index.js</strong> 是 JavaScript 入口文件.</li></ul><p>其他文件可以根据需要添加，删除或重命名。</p><p>可以在 src 目录下建立子目录，为了加快 build 编译项目的速度，只有在 src 目录下的文件才会被 webpack 处理。所以需要将所有的 js 和 css 文件放在 src 目录下，否则 webpack 打包器不会识别到它们。</p><p>只有在 public 目录下的文件才会被 <strong>public/index.html</strong> 文件识别到。</p><p>所以所有的项目文件都需要放在 public 和 src 目录下，与项目无关的文件可以放在上级路径内，例如项目说明文件等。</p><h3>可用脚本指令</h3><p>在项目目录下，可以执行如下命令。</p><h4>npm start</h4><p>开发模式下运行 app：</p><pre><code>npm start
</code></pre><p>打开 <a href="http://localhost">http://localhost</a>:3000 可以查看效果。对代码作出修改后页面会自动重新加载。</p><h4>npm test</h4><p>交互模式下运行 test 运行器。更多介绍参考：<a href="https://create-react-app.dev/docs/running-tests">https://create-react-app.dev/docs/running-tests</a></p><h4>npm run build</h4><p>编译项目程序到 build 目录下，会自动将 React 转换为产品模式，并优化项目结构以提高性能。代码是经过 minified 最小化处理过的，文件名都包含 hashes 以在客户端能够及时识别更新。</p><p>更多 build 参考：<a href="https://create-react-app.dev/docs/production-build">https://create-react-app.dev/docs/production-build</a></p><h3>清理项目</h3><p>默认使用的模板是 cra-template，包含一个基本的页面和 React component，我们先将项目清理掉不需要的内容。</p><p>打开 public 目录下的 index.html 可以看到 body 块内定义了：</p><pre><code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
</code></pre><p>index.html 内可以使用 <strong>%PUBLIC_URL%</strong> 表示 public 目录地址。</p><p>删除 src 目录内所有文件，并新建 index.js 文件。</p><p>运行程序：</p><pre><code>npm start
</code></pre><p>会自动在浏览器打开项目。</p><h3>hello world</h3><p>最简单的 <strong>React</strong> 示例如下，将代码加入 <strong>index.js</strong> 文件：</p><pre><code>const React = require('react')
const ReactDOM = require('react-dom')

ReactDOM.render(
    &lt;h1&gt;hello world&lt;/h1&gt;,
    document.getElementById('root')
);</code></pre><p>保存文件后刷新浏览器页面查看效果。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/2176.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/2176.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[React 入门教程之一 -- 简介]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/2175.html" />
<id>https://blog.niekun.net/archives/2175.html</id>
<updated>2021-02-23T15:39:00+08:00</updated>
<published>2021-02-23T15:39:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[React 是一个用来创建用户界面的 JavaScript 库。它从一开始就被设计为 gradual adoption 渐进式融入的模式，你可以根据需求使用 React 到你的项目中，无论是使用...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/2175.html" xml:lang="zh-CN"><![CDATA[
<p><strong>React</strong> 是一个用来创建用户界面的 JavaScript 库。</p><p>它从一开始就被设计为 gradual adoption 渐进式融入的模式，你可以根据需求使用 React 到你的项目中，无论是使用 React 对你的 html 页面做简单交互，或者完全使用 React 搭建程序。</p><!--more--><h3>对现有网页加入 React 支持</h3><p>当你需要对现有的网页做一些简单的交互动作时，React 也可以方便的加入进来。下面的示例中我们介绍如何通过 React 给页面添加一个 component 元素。</p><p>首先给 html 页面添加一个 DOM 元素：</p><pre><code>&lt;!-- ... existing HTML ... --&gt;
&lt;div id=&quot;like_button_container&quot;&gt;&lt;/div&gt;
&lt;!-- ... existing HTML ... --&gt;</code></pre><p>然后在 body 块结尾添加 React 模块的 script 脚本标签：</p><pre><code>  &lt;!-- ... other HTML ... --&gt;

  &lt;!-- Load React. --&gt;
  &lt;!-- Note: when deploying, replace &quot;development.js&quot; with &quot;production.min.js&quot;. --&gt;
  &lt;script src=&quot;https://unpkg.com/react@17/umd/react.development.js&quot; crossorigin&gt;&lt;/script&gt;
  &lt;script src=&quot;https://unpkg.com/react-dom@17/umd/react-dom.development.js&quot; crossorigin&gt;&lt;/script&gt;

  &lt;!-- Load our React component. --&gt;
  &lt;script src=&quot;like_button.js&quot;&gt;&lt;/script&gt;

&lt;/body&gt;</code></pre><p>前两个 script 加载 React，最后一个是我们加载自定义 component 的代码。</p><p>如果 script 部署在 CDN 上，推荐加上 <strong>crossorigin</strong> 属性可以提高加载速度。</p><p>然后我们使用 React 编写 like_button.js，详细的实现代码我们在后续介绍，最后我们通过下面指令将 React component 加入 html 容器：</p><pre><code>// ... the starter code you pasted ...

const domContainer = document.querySelector('#like_button_container');
ReactDOM.render(e(LikeButton), domContainer);</code></pre><p>以上就是将 React component 加入现有网页的过程。</p><h3>缩小 JavaScript 文件尺寸</h3><p>在部署我们的网站前，要注意没有经过缩小化处理的 JavaScript 脚本会导致页面加载缓慢。</p><p>首先我们将加载 React 的脚本使用缩小化的版本链接：</p><pre><code>&lt;script src=&quot;https://unpkg.com/react@17/umd/react.production.min.js&quot; crossorigin&gt;&lt;/script&gt;
&lt;script src=&quot;https://unpkg.com/react-dom@17/umd/react-dom.production.min.js&quot; crossorigin&gt;&lt;/script&gt;</code></pre><p>对于我们自己编写的 React 脚本可以通过工具得到缩小后的版本，这里介绍通过 <strong>node.js</strong> 的 <strong>terser</strong> 库来实现：</p><ul><li>首先安装 node.js</li><li>在项目目录下运行 <code>npm init -y</code></li><li>运行 <code>npm install terser</code></li></ul><p>例如需要缩小 <strong>like_button.js</strong>，在终端运行：</p><pre><code>npx terser -c -m -o like_button.min.js -- like_button.js
</code></pre><p>就会在当前目录下得到缩小后的脚本文件 <strong>like_button.min.js</strong>。</p><h3>创建一个新的 React 程序</h3><p>以上介绍了如何将 React 添加到现有的 html 中，但是通过一套整合的工具链可以得到更好的用户和开发体验。</p><p><strong>React</strong> 团队推荐下面几种解决方案：</p><ul><li>如果你要学习 React 或者要创建一个单页面 app，推荐使用 <strong>Create React App</strong></li><li>如果你要使用 node.js 创建一个 server-rendered 服务器端渲染的网站，推荐使用 <strong>Next.js</strong></li><li>如果你要建立一个静态内容的网站，推荐使用 <strong>Gatsby</strong></li></ul><h3>Create React App</h3><p><strong>Create React App</strong> 是学习 React 很好的环境，也是建立单页面 React 应用程序最好的方式。</p><p>官方网站：<a href="https://create-react-app.dev/">https://create-react-app.dev/</a></p><p>它会自动设置开发环境是我们可以使用最新的 JavaScript 功能，提供很好的开发体验以及对发布时对程序进行优化。</p><p>使用下面指令创建并运行一个新项目：</p><pre><code>npx create-react-app my-app
cd my-app
npm start</code></pre><p>注意如果你之前使用 <code>npm install -g create-react-app</code>全局安装过 <strong>create-react-app</strong>，推荐先卸载它 <code>npm uninstall -g create-react-app</code> 从而确保 npx 能够安装最新的版本。</p><p>node.js 会自动安装 <strong>react</strong>, <strong>react-dom</strong>, 和 <strong>react-scripts</strong> with <strong>cra-template</strong>。</p><p>通过 <code>--template</code> 选项可以自定义使用什么模板创建新程序，默认为：cra-template，模板可以在官网搜索：<a href="https://www.npmjs.com/search?q=cra-template-*">cra-template-*</a></p><p>如果安装中报错，可以尝试更新 npm 以及清除缓存，然后再次尝试安装：</p><pre><code>npm i -g npm@latest
npm cache clean -f
</code></pre><p>如果在本地开发推荐替换 npm 国内源可以提高下载速度，参考：<a href="https://blog.niekun.net/archives/2085.html">https://blog.niekun.net/archives/2085.html</a></p><p>创建 React App 不会处理后端的数据和逻辑，它只建立前端通道。所以你可以使用任何后端服务。</p><p>通过 <code>npm start</code> 运行程序后，打开 <a href="http://localhost">http://localhost</a>:3000/ 可以查看程序运行效果。</p><p>当程序需要进行部署时，运行 <code>npm run build</code> 会在 <strong>build</strong> 目录下创建一个经过最小化代码优化处理的项目包，可以将其部署到服务器。</p><h3>Next.js</h3><p>Next.js 是一个流行的 React framework 来创建 static 和 server‑rendered 程序。</p><p>官网：<a href="https://nextjs.org/">https://nextjs.org/</a></p><h3>Gatsby</h3><p>Gatsby 是通过 React 创建静态网站的最好的工具。它使我们可以使用 React components 但输出预渲染的 html 和 css 以确保页面加载速度。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/2175.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/2175.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[node.js 入门教程之十四 -- TypeScript]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/2169.html" />
<id>https://blog.niekun.net/archives/2169.html</id>
<updated>2021-02-21T22:02:00+08:00</updated>
<published>2021-02-21T22:02:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[TypeScript 是微软开发的开源编程语言，在全世界的开发者中流行。本质上来说 typescript 是 JavaScript 的超集，为其添加了很多功能。标志性的就是添加了 static ...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/2169.html" xml:lang="zh-CN"><![CDATA[
<p><strong>TypeScript</strong> 是微软开发的开源编程语言，在全世界的开发者中流行。</p><p>本质上来说 <strong>typescript</strong> 是 <strong>JavaScript</strong> 的超集，为其添加了很多功能。标志性的就是添加了 <strong>static type</strong> 静态类型定义，它可以声明期待的数据类型，例如：声明 function 中的期待的传入数据类型，期望的返回值的类型，object 的结构及 property 的数据类型等。</p><p>typescript 是一个强大的工具，给 JavaScript 项目开启了新的世界。它使我们的代码更加的安全有力，在程序发布前就可以防止很多的 bug 出现。在编写代码期间就能够及时反映出问题点，并且它已经被整合在现代的编译器中，如 VS code。</p><!--more--><h3>语法说明</h3><p>下面是一个 typescript 代码示例：</p><pre><code>type User = {
    name: string;
    age: number;
};

function isAdult(user: User): boolean {
    return user.age &gt;= 18;
}

const justine: User = {
    name: 'Justine',
    age: 23,
};

const isJustineAnAdult: boolean = isAdult(justine);</code></pre><ul><li>首先我们通过 <strong>type</strong> 关键词定义一个自定义的 object 类型 <strong>User</strong>，其中定义了 <strong>User</strong> 的两个 properties 及其数据类型。</li><li>然后在定义的 function <strong>isAudlt</strong> 中接收一个参数，此参数类型为 <strong>User</strong> 类型，然后返回值类型为 <strong>boolean</strong> 类型。</li><li>然后我们定义了 <strong>justine</strong> object 且其类型为 <strong>User</strong>。在其中定义的两个 properties 也符合 User 中的类型。</li><li>最后定义了变量 <strong>isJustineAnAdult</strong> 且其数据类型为 <strong>boolean</strong>，将 <strong>isAudlt</strong> 的返回值赋给它。</li></ul><p>如果我们在编程中没有使用指定的数据类型，typescript 将会给出警告提醒我们错误的地方，比如上面的示例中修改 justine 的 age 为一个字符串：<br><img src="https://blog.niekun.net/usr/uploads/2021/02/3878778226.png" alt="2021-02-21T13:39:09.png" title="2021-02-21T13:39:09.png"></p><p>在 vs code 中会提示此处有错误。</p><p>另一方面也并不需要将所有地方的数据类型都做出声明，typescript 会自动推断出需要的类型。例如：即使我们不给 <strong>isJustineAnAdult</strong> 声明 boolean 类型，typescript 也会自动推断它是 boolean 类型的。</p><p>那么如何运行 typescript 代码呢？首先需要通过 npm 安装 typescript，它会安装我们需要的一些可执行程序：</p><pre><code>npm install typescript
</code></pre><p>下面我们可以通过 <strong>tsc</strong> 命令将 typescript 代码转换为标准 JavaScript 代码。</p><p>我们将上面示例中的代码保存为 demo.ts 文件，然后通过 npx 调用 tsc 命令(如果以 global 方式安装 typescript 则可以直接运行命令)：</p><pre><code>npx tsc demo.ts
</code></pre><p>以上命令会转换 JavaScript 代码并自动创建一个 demo.js 文件，此文件可以在 node.js 运行:</p><pre><code>function isAdult(user) {
    return user.age &gt;= 18;
}
var justine = {
    name: 'Justine',
    age: 23
};
var isJustineAnAdult = isAdult(justine);</code></pre><p>如果 typescript 代码中包含错误，则使用上面的转换命令会出现报错信息：</p><pre><code>% npx tsc demo.ts
demo.ts:12:5 - error TS2322: Type 'string' is not assignable to type 'number'.

12     age: '23',
       ~~

  demo.ts:3:5
    3     age: number;
          ~~
    The expected type comes from property 'age' which is declared here on type 'User'


Found 1 error.</code></pre><p>可以看到 typescript 成功的防止将包含潜在错误代码的程序发布出去。</p><h3>更多介绍</h3><p>除此之外 typescript 也包含了很多其他很好的工具，如：<strong>interfaces</strong>, <strong>classes</strong>, <strong>utility types</strong> 等。更多使用方法参考 typescript 官方文档：<a href="https://www.typescriptlang.org/docs">https://www.typescriptlang.org/docs</a>。</p><p>typescript 在 node.js 生态中已经有了很好的发展，且被用于很多开源项目和框架中。以下是一些使用 typescript 的开源项目：</p><ul><li><strong>NestJS</strong> - robust and fully-featured framework that makes creating scalable and well-architected systems easy and pleasant</li><li><strong>TypeORM</strong> - great ORM influenced by other well-known tools from other languages like Hibernate, Doctrine or Entity Framework</li><li><strong>Prisma</strong> - next-generation ORM featuring a declarative data model, generated migrations and fully type-safe database queries</li><li><strong>RxJS</strong> - widely used library for reactive programming</li></ul><h3>总结</h3><p>通过这 14 篇教程，我们介绍了 node.js 的基本语法和相关使用场景。后期可以在具体项目中进行更加详细的体验。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/2169.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/2169.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[node.js 入门教程之十三 -- environment，error handler 和 log object]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/2165.html" />
<id>https://blog.niekun.net/archives/2165.html</id>
<updated>2021-02-20T17:19:00+08:00</updated>
<published>2021-02-20T17:19:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[environment 运行环境production environment 产品环境和 development environment 开发环境可以设置不同的配置。node.js 默认为 de...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/2165.html" xml:lang="zh-CN"><![CDATA[
<h3>environment 运行环境</h3><p><strong>production environment 产品环境</strong>和 <strong>development environment 开发环境</strong>可以设置不同的配置。</p><p>node.js 默认为 development env 开发环境。通过设置环境变量：<code>NODE_ENV=production</code> 可以告诉 node.js 当前为产品环境。Linux 中可以通过如下指令修改：</p><pre><code>export NODE_ENV=production
</code></pre><p>这样在当前 shell 中就会以 production 模式运行 node 程序，如果要永久修改此环境变量可以将命令写入 <strong>~/.bashrc</strong> 文件。</p><p>也可以在运行 node 程序时定义 <strong>NODE_ENV</strong>：</p><pre><code>NODE_ENV=production node app.js

</code></pre><!--more--><p>设置 <strong>NODE_ENV</strong> 为 <strong>production</strong> 有如下优势：</p><ul><li>日志记录保持在最小 level</li><li>更多的 caching 缓存级别来提高运行效率</li></ul><p>可以通过状态判读符来判断当前运行环境，执行不同指令：</p><pre><code>if (process.env.NODE_ENV === 'development') {
    console.log('running on development environment')
}
if (process.env.NODE_ENV === 'production') {
    console.log('running on production environment')
}
if (['production', 'staging'].indexOf(process.env.NODE_ENV) != -1) {
    console.log('running on production environment')
} else {
    console.log('running on development environment')
}</code></pre><p>上面第三个指令通过调用 array 的 <strong>indexOf</strong> 来获取某个字符串在数组中的索引号，如果不存在这个字符串则返回 <strong>-1</strong>。注意使用类型判断符<code>===</code> 是为了保证类型和数值都匹配。</p><h3>error handling 错误处理</h3><p>node.js 中通过 exceptions 来处理 error 情况。</p><p>可以通过 <strong>throw</strong> 创建一个 <strong>exception</strong>：</p><pre><code>const test = 123;
throw test;</code></pre><p>当 JavaScript 执行到上面的 throw 时程序会立刻停止，然后控制权会交给最近的 exception handler 例外控制器。</p><p>JavaScript 中 test 可以是任意的字符串，数字或者 object。但在 node.js 中只用来 throw <strong>Error</strong> objects。</p><p>一个 error object 可以是 <strong>Error</strong> 的实例或者是 Error class 的 child class 的实例：</p><pre><code>throw new Error('error')

class childError extends Error {
}
throw new childError('error')</code></pre><p>下面介绍几种 <strong>exception handler</strong> 处理器。</p><p><strong>第一种</strong>是通过 <strong>try/catch</strong> 声明来处理，在 try 中定义任意 exception 以及对应的 catch 块来响应：</p><pre><code>try {
    const a = 1;
    if (a == 0) {
        throw 'abc'
    } else {
        throw 123
    }
} catch (e) {
    console.log(e)
}</code></pre><p>catch 的参数 e 就是对应 throw 的数据。</p><p>如果在程序执行中，如果某个 throw 的 exception 没有被 catch，程序就会立刻 crash。可以通过监听 <strong>process</strong> 的 <strong>uncaughtException</strong> event 事件来解决这个问题：</p><pre><code>process.on('uncaughtException', err =&gt; {
    console.log('there was a uncaught error: ', err.message)
    process.exit(1)
})

throw new Error('error')</code></pre><p><strong>第二种</strong>是 <strong>promise</strong> 中的 error handler。</p><p>使用 promise 可以将多个操作过程组合成链，在链的最后处理 error 情况，下面是一个简单示例：</p><pre><code>let a = 0;
let b = 0;

const doSomething1 = new Promise((resolve, reject) =&gt; {
    if (a == 0)
        resolve('resolve 1')
    else
        reject('reject 1')
})

const doSomething2 = (data) =&gt; {
    return new Promise((resolve, reject) =&gt; {
        if (b == 0)
            resolve(data + ' : resolve 2')
        else
            reject('reject 2')

    })
}

doSomething1
    .then(doSomething2)
    .then(res =&gt; console.log(res))
    .catch(rej =&gt; console.log(rej))</code></pre><p>当 <strong>doSomething1</strong> 为 resolve 时会执行 <code>doSomething2()</code>，为 reject 时会直接进入 catch 块。同样的 <strong>doSomething2</strong> 返回的 promise 为 reject 时也会进入 catch 块。此时通过输出的信息可以知道是在哪一个 promise 链响应了 exception。</p><p><strong>第三种</strong>是 <strong>async/await</strong> 的 error handling。</p><p>使用 <strong>async/await</strong> 也是通过 <strong>try/catch</strong> 来处理 exception 情况的：</p><pre><code>let a = 1;
const demo = new Promise((resolve, reject) =&gt; {
    if (a == 0) {
        setTimeout(resolve, 1000, 'resolve');
    } else {
        reject('reject')
    }
})

const test = async() =&gt; {
    try {
        const data = await demo
        console.log(data)
    } catch (error) {
        console.log(error)
    }
}
test()

//output:
//reject</code></pre><p>当 <strong>demo</strong> promise 为 reject 时会响应 <code>test()</code> 中的 catch 块。</p><h3>日志输出 object</h3><p>当我们在浏览器中使用 <code>console.log()</code> 输出某个 object 时，会得到一个很好的效果：<br><img src="https://blog.niekun.net/usr/uploads/2021/02/2696578422.png" alt="2021-02-21T07:32:18.png" title="2021-02-21T07:32:18.png"></p><p>点击箭头可以展开日志，完整地展示 object 的 properties：<br><img src="https://blog.niekun.net/usr/uploads/2021/02/3439824675.png" alt="2021-02-21T07:33:15.png" title="2021-02-21T07:33:15.png"></p><p>在 node.js 中和浏览器有所不同，它是将 object 的内容以字符串的形式输出到终端或者日志文件中。</p><p>对于简单的 object 来说没有什么问题，但是对于包含超过 2 层嵌套以上的 object 来说 node.js 就会放弃输出所有内容而用一个 <strong>[Object]</strong> 占位符表示剩余内容：</p><pre><code>const obj = {
    name: 'joe',
    age: 35,
    person1: {
        name: 'Tony',
        age: 50,
        person2: {
            name: 'Albert',
            age: 21,
            person3: {
                name: 'Peter',
                age: 23
            }
        }
    }
}
console.log(obj)</code></pre><p>输出结果为：</p><pre><code>{
  name: 'joe',
  age: 35,
  person1: {
    name: 'Tony',
    age: 50,
    person2: { name: 'Albert', age: 21, person3: [Object] }
  }
}</code></pre><p>可以看到第三层的内容已经用 <strong>[Object]</strong> 取代。</p><p>强制要求输出 object 所有内容的最好的方法就是使用 <code>JSON.stringify()</code>：</p><pre><code>console.log(JSON.stringify(obj, undefined, 2))</code></pre><p>输出如下：</p><pre><code>{
  &quot;name&quot;: &quot;joe&quot;,
  &quot;age&quot;: 35,
  &quot;person1&quot;: {
    &quot;name&quot;: &quot;Tony&quot;,
    &quot;age&quot;: 50,
    &quot;person2&quot;: {
      &quot;name&quot;: &quot;Albert&quot;,
      &quot;age&quot;: 21,
      &quot;person3&quot;: {
        &quot;name&quot;: &quot;Peter&quot;,
        &quot;age&quot;: 23
      }
    }
  }
}</code></pre><p>第一个参数定义需要输出的 object，第二个参数是定义一个 function 用来转换字符串内容也可以不定义，第三个是定义缩进量。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/2165.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/2165.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[node.js 入门教程之十二 -- Streams 流]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/2161.html" />
<id>https://blog.niekun.net/archives/2161.html</id>
<updated>2021-02-20T14:43:00+08:00</updated>
<published>2021-02-20T14:43:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[Streams 是驱动 node.js 程序的核心概念。它提供了处理对文件的读写，网络传输，或者其他端到端的数据交换的更加高效的方式。streams 流并不是 node.js 首先引入的概念，u...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/2161.html" xml:lang="zh-CN"><![CDATA[
<p><strong>Streams</strong> 是驱动 node.js 程序的核心概念。它提供了处理对文件的读写，网络传输，或者其他端到端的数据交换的更加高效的方式。</p><p>streams 流并不是 node.js 首先引入的概念，unix 操作系统在很久之前就在使用了，一个程序可以通过 pipe 管道操作符 <code>|</code> 来传递 streams 流给其他程序。</p><p>下面的示例是在 Linux 中，通过 pipe 管道将 cat 读取的文件数据传递给 grep 进行过滤，test.txt 文件内容如下：</p><pre><code>aaa bbb
bbb ccc
aaa ccc</code></pre><pre><code>$ cat test.txt | grep aaa
aaa bbb
aaa ccc</code></pre><!--more--><h3>stream 优点</h3><p>在传统方法中，当程序读取一个文件内容时会先将文件内容全部读取到内存中，然后再去使用它。而使用 stream 时会一段段的读取文件内容并进行处理，而不需要整体读取到内存。</p><p>node.js 的 <strong>stream</strong> 模块是构建所有 streaming API 的底层。所有的 streams 流都是 eventEmitter 的实例。每种类型的 stream 都有各自的 event 事件，在数据流变化时触发对应事件。</p><p>相比于其他数据处理方法，<strong>streams</strong> 有两个优势：</p><ul><li>内存效率：在使用数据前不需要将大量数据存入内存中。</li><li>时间效率：能够更快的进入数据处理阶段，在获取到文件后能够很快的使用它而不需要等待它全部加载完毕。</li></ul><h3>使用方法</h3><p>下面我们从一个示例来说明 stream 的使用方法。我们建立一个 http server，当收到请求时读取一个本地文件的内容并作为 response 发送给客户端。</p><p>首先传统实现方式如下：</p><pre><code>const http = require('http')
const fs = require('fs')

const hostname = '127.0.0.1'
const port = 3000

const server = http.createServer((req, res) =&gt; {
    fs.readFile(__dirname + '/test.txt', (err, data) =&gt; {
        if (err) {
            console.log('read error')
        }
        res.end(data)
    })
})

server.listen(port, hostname, () =&gt; {
    console.log(`Server running at http://${hostname}:${port}/`)
})</code></pre><p>以上方式在收到请求后，通过 <code>readFile()</code> 读取文件内容到内存中，当成功后会调用 callback 通过 <code>res.end(data)</code> 发送读取的数据给客户端。如果文件较大时以上过程会花费一些时间。</p><p><strong>__dirname</strong> 返回当前执行文件的路径。</p><p>下面介绍使用 stream 实现上面的过程：</p><pre><code>const http = require('http')
const fs = require('fs')

const hostname = '127.0.0.1'
const port = 3000

const server = http.createServer((req, res) =&gt; {
    const stream = fs.createReadStream(__dirname + '/test.txt')
    stream.pipe(res)
})

server.listen(port, hostname, () =&gt; {
    console.log(`Server running at http://${hostname}:${port}/`)
})</code></pre><p>通过 <code>fs.createReadStream()</code> 返回一个文件的 stream。</p><p>不同于第一种，以上方式会在 stream 中只要有了 data chunk 块就立刻作为 response 数据传输给客户端。这样就会一边读取文件一边传输数据。</p><h3>pipe()</h3><p>以上示例中调用 <strong>stream</strong> 的 <code>pipe()</code> method。它的功能是建立一个 source stream 源流到 destination stream 目标流的 pipe 管道。这样文件的 stream 流通向了 http response。</p><p><code>pipe()</code> 的返回是 destination stream 目标流，这样就可以很方便的链接多个 pipe：</p><pre><code>src.pipe(dest1).pipe(dest2)</code></pre><p>以下写法和上面示例效果一样：</p><pre><code>src.pipe(dest1)
dest1.pipe(dest2)</code></pre><h3>基于 stream 的 node.js API</h3><p>由于 stream 的巨大优势，很多 node.js 核心模块提供了 stream 的原生支持，以下是常用的部分：</p><ul><li><strong>process.stdin</strong> 返回一个链接到 stdin 的 stream</li><li><strong>process.stdout</strong> 返回一个链接到 stdout 的 stream</li><li><strong>process.stderr</strong> 返回一个链接到 stderr 的 stream</li><li><strong>fs.createReadStream()</strong> 创建一个文件的可读的 stream</li><li><strong>fs.createWriteStream()</strong> 创建一个文件的可写的 stream</li><li><strong>net.connect()</strong> 初始化一个基于 stream 的连接</li><li><strong>http.request()</strong> 返回一个 http.ClientRequest 实例，它是一个可写的 stream</li></ul><h3>streams 的类型</h3><p>有四个 streams 的 calsses：</p><ul><li><strong>Readable</strong>: 一个可以作为管道源头的 stream，不能作为管道的目标也就是不能写入数据</li><li><strong>Writable</strong>: 一个可以作为管道目标的 stream，不能作为管道源头也就是不能从中获取数据</li><li><strong>Duplex</strong>: 一个既可作为管道源头也可以作为目标的 stream</li><li><strong>Transform</strong>: 类似于 Duplex</li></ul><h3>创建 readable stream</h3><p>从 stream 模块定义一个可读的 stream 然后通过定义 <code>readable._read()</code> method 内容完成初始化：</p><pre><code>const Stream = require('stream')
const readableStream = new Stream.Readable()

readableStream._read = () =&gt; {}</code></pre><p>初始化也可以这样写：</p><pre><code>const readableStream = new Stream.Readable({
    read() {}
})</code></pre><p>以上就创建了一个可读的 stream，可以给其传输数据：</p><pre><code>readableStream.push('hi')
readableStream.push('hello')</code></pre><p>可以将这个 stream 和一个可写的 stream 之间建立管道：</p><pre><code>readableStream.pipe(process.stdout)
</code></pre><h3>创建 writable stream</h3><p>通过实例化一个 <strong>Writable</strong> object 然后通过定义 <code>_write()</code> method 内容完成初始化：</p><pre><code>const Stream = require('stream')
const writeableStream = new Stream.Writable()

writeableStream._write = (chunk, encoding, callback) =&gt; {
    console.log(chunk.toString())
    callback()
}</code></pre><p>接收到的数据块传入 chunk，encoding 定义数据类型，callback function 是当一个 chunk 数据块传输完成后调用，此 callback 可在 <strong>writeableStream.write</strong> 内定义，一般可以是 error 处理，下面会介绍。</p><p>可以将定义的可写 stream 同一个可读 stream  pipe 管道连接：</p><pre><code>process.stdin.pipe(writeableStream)
</code></pre><p>这样就可以在 stdin 和 writeableStream 间建立 pipe，此时在 stdin 输入数据就会立刻将数据显示在终端。</p><h3>从可读的 stream 读取数据</h3><p>下面的示例中，我们建立一个可读的 stream 和一个 可写的 stream，并建立 pipe 管道连接：</p><pre><code>const Stream = require('stream')

const readableStream = new Stream.Readable()
readableStream._read = () =&gt; {}

const writeableStream = new Stream.Writable()
writeableStream._write = (chunk, encoding, callback) =&gt; {
    console.log(chunk.toString())
    callback()
}

readableStream.pipe(writeableStream)

readableStream.push('hi\n')
readableStream.push('hello\n')</code></pre><p>也通过 <strong>readable</strong> event 事件来处理可读 stream。当 stream 中有准备好的数据块时会触发 readable event：</p><pre><code>readableStream.on('readable', () =&gt; {
    console.log(readableStream.read().toString())
})</code></pre><h3>给可写的 stream 写入数据</h3><p>使用 write method 来写入数据：</p><pre><code>writeableStream.write('hello world\n')
</code></pre><p>可以定义写入数据的编码格式和 callback function：</p><pre><code>writeableStream.write('hello world\n', 'utf-8', err =&gt; {console.log(err)})
</code></pre><p>实际中 callback function 是否会执行要看 stream 初始化中在 <code>writeableStream._write</code> 是否调用了 callback。</p><p>如果数据写入已经完成，可以使用 <strong>end</strong> method 来告诉可写的 stream：</p><pre><code>const Stream = require('stream')
const writeableStream = new Stream.Writable()

writeableStream._write = (chunk, encoding, next) =&gt; {
    console.log(chunk.toString())
    next()
}

process.stdin.pipe(writeableStream)

writeableStream.write('hello world\n')
writeableStream.end()</code></pre><p>以上示例中如果在最后一句不调用 <strong>end</strong> method 则 writeableStream 会持续保持接收来自 stdin 的数据状态。</p><h3>创建 transform stream</h3><p>和可写的 stream 创建方式类似，可读也可写：</p><pre><code>const Stream = require('stream')
const transformStream = new Stream.Transform()

transformStream._transform = (chunk, encoding, callback) =&gt; {
    console.log('transform' + chunk.toString())
    transformStream.push(chunk)
    callback()
}

const writeableStream = new Stream.Writable()
writeableStream._write = (chunk, encoding, callback) =&gt; {
    console.log('write' + chunk.toString())
    callback()
}

process.stdin.pipe(transformStream).pipe(writeableStream)</code></pre><p>在 <code>transformStream._transform</code> 定义了当 transform stream 接收到数据后通过 <code>transformStream.push</code> 将数据发到 readable stream 中，这样其他 stream 就可以读取到它接收到的数据了。</p><p>更多 stream 使用方法参考：<a href="https://nodejs.org/api/stream.html">https://nodejs.org/api/stream.html</a></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/2161.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/2161.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[node.js 入门教程之十一 -- buffers 缓存]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/2157.html" />
<id>https://blog.niekun.net/archives/2157.html</id>
<updated>2021-02-16T17:26:00+08:00</updated>
<published>2021-02-16T17:26:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[一个 buffer 缓存就是一个内存空间。JavaScript 开发者相较于 c++/go 等语言的开发者对内存的理解比较少。它表示在 JavaScript V8 engine 之外的分配的一块...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/2157.html" xml:lang="zh-CN"><![CDATA[
<p>一个 buffer 缓存就是一个内存空间。JavaScript 开发者相较于 c++/go 等语言的开发者对内存的理解比较少。它表示在 JavaScript V8 engine 之外的分配的一块 fixed-size 固定大小的内存。可以想象 buffer 就是一个 integer 整型数组，每个元素代表一个 byte 的数据。</p><p>node.js 中 buffer 通过 <strong>Buffer</strong> class 实现。</p><!--more--><h3>为何需要 buffer</h3><p>引入 <strong>Buffer</strong> 是为了帮助开发者处理 binary 二进制数据。传统的 ecosystem 只可以处理 strings 字符串数据。<strong>Buffer</strong> 和 streams 是紧密关联的，当 stream processor 流处理器接收数据的速度大于其处理速度时，就会先将数据放在 buffer 中。</p><p>可以想象下，在我们看在线视频时，在网络较好的情况下进度条中可以看到视频下载的进度是超过当前播放进度的，此时浏览器就会先 buffer 缓存数据后续按时间顺序播放出来。</p><h3>创建 buffer</h3><p>可以通过 <code>Buffer.from()</code>, <code>Buffer.alloc()</code> 和 <code>Buffer.allocUnsafe()</code> methods 来创建一个 buffer，下面依次介绍。</p><p>使用 <strong>Buffer.from()</strong> 可以从 array 数组创建 buffer：</p><pre><code>const buf1 = Buffer.from('hey!')
</code></pre><p>使用 <strong>Buffer.from(string[, encoding])</strong> 可以设置 string 的编码类型，Default: <strong>utf8</strong>：</p><pre><code>const buf2 = Buffer.from('7468697320697320612074c3a97374', 'hex')
</code></pre><p>也可以根据另一个 buffer：</p><pre><code>const buf3 = Buffer.from(buf1)
</code></pre><p>通过 <strong>Buffer.alloc()</strong> 或 <strong>Buffer.allocUnsafe()</strong> 来初始化一个指定大小的 buffer，单位为 byte 字节：</p><pre><code>const buf4 = Buffer.alloc(1024)
const buf5 = Buffer.allocUnsafe(1024)
</code></pre><p>以上会创建一个 1kb 大小的 buffer。</p><p>通过 <strong>alloc</strong> 创建的 buffer 会初始化其数据为 0，而 <strong>allocUnsafe</strong> 创建的 buffer 内的数据会是 uninitiated 未初始化的，这就表示使用 <strong>allocUnsafe</strong> 比 <strong>alloc</strong> 创建速度更快。但是通过 <strong>allocUnsafe</strong> 创建的 buffer 内存空间会包含有以前的数据可能引起潜在问题。</p><h3>使用 buffer</h3><p>我们可以像访问数组一样访问 buffer 数据：</p><pre><code>const buf1 = Buffer.from('hey!')

console.log(buf1[0])
console.log(buf1[1])
console.log(buf1[2])

//output:
//104
//101
//121</code></pre><p>这些输出的数字就是代表 buffer 中每个字符的 Unicode Code，h =&gt; 104, e =&gt; 101, y =&gt; 121。</p><p>使用 <strong>toString()</strong> method 可以将 buffer 输出为字符：</p><pre><code>console.log(buf1)
console.log(buf1.toString())

//output:
//&lt;Buffer 68 65 79 21&gt;
//hey!</code></pre><p>buf1.length 可以读取 buffer 长度：</p><pre><code>console.log(buf1.length)

//output:
//4</code></pre><p>也可以使用循环 iterate buffer 的数据：</p><pre><code>for (const iterator of buf1) {
    console.log(iterator)
}

//output:
104
101
121
33</code></pre><p>通过 <strong>write()</strong> method 可以给 buffer 写入数据：</p><pre><code>const buf6 = Buffer.alloc(5)
buf6.write('hello')</code></pre><p>也可以像数组一样修改某个元素的数据：</p><pre><code>const buf6 = Buffer.alloc(5)
buf6.write('hello')
buf6[0] = 111
console.log(buf6.toString())

//output:
//oello</code></pre><p>可以看到需要修改字符对应的 Unicode Code。</p><p>使用 <strong>copy()</strong> method 可以复制 buffer 数据到其他 buffer：</p><pre><code>const buf1 = Buffer.from('hey!')
const buf7 = Buffer.alloc(4)
buf1.copy(buf7)
console.log(buf7.toString())

//output:
//hey!</code></pre><p>注意是源 buffer 掉用 <strong>copy</strong> method 来复制数据到目标 buffer。</p><p>默认情况下会复制 buffer 的整个数据， <strong>copy</strong> method 可以设置其他三个参数来自定义目标 buffer 起始接收数据位置，源 buffer 起始复制数据位置，以及复制的新 buffer 的长度：</p><pre><code>const buf8 = Buffer.alloc(2)
buf1.copy(buf8, 0, 0, 2)
console.log(buf8.toString())

//output:
//he</code></pre><p>可以使用 <strong>slice</strong> method 来选取 buffer 的一个片段，它和 copy 的不同是 slice 获取的 buffer 片段仍然和源 buffer 相关联，修改源 buffer 会改变片段中的 buffer 数据。</p><p>slice 的第一个参数定义起始位置，第二个参数是选项，可以定义终止位置：</p><pre><code>const buf1 = Buffer.from('hey!')
const slice = buf1.slice(0, 2)
console.log(slice.toString())
buf1[0] = 111
console.log(slice.toString())

//output:
//he
//oe</code></pre><p>以上就是 <strong>Buffer</strong> 的简单使用方法。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/2157.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/2157.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[node.js 入门教程之十 -- http 模块]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/2156.html" />
<id>https://blog.niekun.net/archives/2156.html</id>
<updated>2021-02-15T14:01:00+08:00</updated>
<published>2021-02-15T14:01:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[http 模块是 node.js 处理 networking 网络的关键模块。在之前的章节我介绍了使用 http 模块建立 server 以及发起 GET/POST 请求的方法，可以参考：htt...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/2156.html" xml:lang="zh-CN"><![CDATA[
<p><strong>http</strong> 模块是 node.js 处理 networking 网络的关键模块。在之前的章节我介绍了使用 <strong>http</strong> 模块建立 server 以及发起 GET/POST 请求的方法，可以参考：<a href="https://blog.niekun.net/archives/2137.html">https://blog.niekun.net/archives/2137.html</a></p><p>http 模块集成于 node.js 核心无需单独安装，使用下面命令引入模块：</p><pre><code>const http = require('http')
</code></pre><p>模块提供了很多 <strong>properties</strong>，<strong>methods</strong> 和 <strong>classes</strong>。</p><!--more--><h3>Properties 属性</h3><h4>http.METHODS</h4><p><strong>http.METHODS</strong> property 返回 http 所有的可用 method 列表：</p><pre><code>&gt; console.log(require('http').METHODS)
[
  'ACL',        'BIND',        'CHECKOUT',
  'CONNECT',    'COPY',        'DELETE',
  'GET',        'HEAD',        'LINK',
  'LOCK',       'M-SEARCH',    'MERGE',
  'MKACTIVITY', 'MKCALENDAR',  'MKCOL',
  'MOVE',       'NOTIFY',      'OPTIONS',
  'PATCH',      'POST',        'PRI',
  'PROPFIND',   'PROPPATCH',   'PURGE',
  'PUT',        'REBIND',      'REPORT',
  'SEARCH',     'SOURCE',      'SUBSCRIBE',
  'TRACE',      'UNBIND',      'UNLINK',
  'UNLOCK',     'UNSUBSCRIBE'
]</code></pre><h4>http.STATUS_CODES</h4><p><strong>http.STATUS_CODES</strong> 返回所有的 http 状态码及描述的 list 列表：</p><pre><code>&gt; console.log(require('http').STATUS_CODES)
{
  '100': 'Continue',
  '101': 'Switching Protocols',
  '102': 'Processing',
  '103': 'Early Hints',
  '200': 'OK',
  '201': 'Created',
  '202': 'Accepted',
  '203': 'Non-Authoritative Information',
  '204': 'No Content',
  '205': 'Reset Content',
  '206': 'Partial Content',
  '207': 'Multi-Status',
  '208': 'Already Reported',
  '226': 'IM Used',
  '300': 'Multiple Choices',
  '301': 'Moved Permanently',
  '302': 'Found',
  '303': 'See Other',
  '304': 'Not Modified',
  '305': 'Use Proxy',
  '307': 'Temporary Redirect',
  '308': 'Permanent Redirect',
  '400': 'Bad Request',
  '401': 'Unauthorized',
  '402': 'Payment Required',
  '403': 'Forbidden',
  '404': 'Not Found',
  '405': 'Method Not Allowed',
  '406': 'Not Acceptable',
  '407': 'Proxy Authentication Required',
  '408': 'Request Timeout',
  '409': 'Conflict',
  '410': 'Gone',
  '411': 'Length Required',
  '412': 'Precondition Failed',
  '413': 'Payload Too Large',
  '414': 'URI Too Long',
  '415': 'Unsupported Media Type',
  '416': 'Range Not Satisfiable',
  '417': 'Expectation Failed',
  '418': &quot;I'm a Teapot&quot;,
  '421': 'Misdirected Request',
  '422': 'Unprocessable Entity',
  '423': 'Locked',
  '424': 'Failed Dependency',
  '425': 'Too Early',
  '426': 'Upgrade Required',
  '428': 'Precondition Required',
  '429': 'Too Many Requests',
  '431': 'Request Header Fields Too Large',
  '451': 'Unavailable For Legal Reasons',
  '500': 'Internal Server Error',
  '501': 'Not Implemented',
  '502': 'Bad Gateway',
  '503': 'Service Unavailable',
  '504': 'Gateway Timeout',
  '505': 'HTTP Version Not Supported',
  '506': 'Variant Also Negotiates',
  '507': 'Insufficient Storage',
  '508': 'Loop Detected',
  '509': 'Bandwidth Limit Exceeded',
  '510': 'Not Extended',
  '511': 'Network Authentication Required'
}</code></pre><h4>http.globalAgent</h4><p><strong>http.globalAgent</strong> 指向 <strong>http.Agent</strong> class 的一个 instance 实例，也就是一个 <strong>Agent</strong> object。</p><p>这个 <strong>Agent</strong> object 用来管理 server 同 http 客户端链接的持续连接和链接复用，这也是 node.js 网络服务的关键点。</p><pre><code>&gt; console.log(require('http').globalAgent)
Agent {
  _events: [Object: null prototype] {
    free: [Function (anonymous)],
    newListener: [Function: maybeEnableKeylog]
  },
  _eventsCount: 2,
  _maxListeners: undefined,
  defaultPort: 80,
  protocol: 'http:',
  options: { path: null },
  requests: {},
  sockets: {},
  freeSockets: {},
  keepAliveMsecs: 1000,
  keepAlive: false,
  maxSockets: Infinity,
  maxFreeSockets: 256,
  scheduling: 'lifo',
  maxTotalSockets: Infinity,
  totalSocketCount: 0,
  [Symbol(kCapture)]: false
}</code></pre><h3>methods 功能</h3><h4>http.createServer()</h4><p><code>http.createServer()</code> 返回一个 <strong>http.Server</strong> class 实例。</p><pre><code>const server = http.createServer((req, res) =&gt; {
  //handle every single request with this callback
})</code></pre><h4>http.request()</h4><p><code>http.request()</code> 对服务器发起一个 http 请求。返回一个 <strong>http.ClientRequest</strong> class 实例。</p><pre><code>const options = {
    hostname: 'localhost',
    port: 3000,
    path: '/',
    method: 'GET'
}

const req = https.request(options, res =&gt; {
    console.log(`statusCode is：${res.statusCode}`);
    res.on('data', d =&gt; {
        process.stdout.write(d)
    })
})

req.on('error', err =&gt; console.log(err))
req.end()</code></pre><h4>http.get()</h4><p><code>http.get()</code> 同 <code>http.request()</code> 类似，但会自动将 http method 设置为 GET，且自动调用 <code>req.end()</code>。</p><pre><code>const https = require('http')
const options = {
    hostname: 'localhost',
    port: 3000,
    path: '/'
}

const req = https.get(options, res =&gt; {
    console.log(`statusCode is：${res.statusCode}`);
    res.on('data', d =&gt; {
        process.stdout.write(d)
    })
})

req.on('error', err =&gt; console.log(err))</code></pre><h3>Classes 类</h3><p>http 模块提供 5 个 calsses：</p><ul><li>http.Agent</li><li>http.ClientRequest</li><li>http.Server</li><li>http.ServerResponse</li><li>http.IncomingMessage</li></ul><h4>http.Agent</h4><p>node.js 会创建一个全局的 <strong>http.Agent</strong> instance 实例来管理 server 同 http 客户端链接的持续连接和链接复用，这个 object 可以确保一个客户端对服务端发起的一系列请求是按队列排序的，且使用单独的 socket 接口。同样 agent object 管理着一个 sockets 池，这是影响性能的关键因素。</p><h4>http.ClientRequest</h4><p>当 <code>http.request()</code> 或 <code>http.get()</code> 被调用时会创建一个 <strong>http.ClientRequest</strong> object。</p><p>当收到来自服务器的 response 时，<strong>response</strong> event 会被触发，<code>http.request()</code> 内定义的 callback 会作为 <strong>response</strong> 的响应被调用，同时将 <strong>http.IncomingMessage</strong> 的实例作为传入参数，其中包含了 response 数据。</p><p>response 数据有两种方式读取，第一种是通过 <code>response.read()</code> method，第二种是在 response 的 callback function 中通过监听 <strong>data</strong> event 来获取 stream 中的数据。</p><h4>http.Server</h4><p>当通过 <code>http.createServer()</code> 创建一个 server 时会返回 <strong>http.Server</strong> 实例。 <strong>http.Server</strong> 实例需要使用它的以下 method：</p><ul><li><code>close()</code> 停止 server 接收新的链接</li><li><code>listen()</code> 启动 server 并开始监听请求</li></ul><p><code>http.createServer()</code> 的 callback 监听 <strong>request</strong> event 并响应。</p><h4>http.ServerResponse</h4><p>由 <strong>http.Server</strong> object 创建，作为 <strong>request</strong> event 的第二个参数传入，代码中作为 callback 的 res 参数使用：</p><pre><code>const server = http.createServer((req, res) =&gt; {
  //res is an http.ServerResponse object
})</code></pre><p><code>end()</code> 是 <strong>http.ServerResponse</strong> object 必须被使用的 method，用来表示 response 信息已经完整，可以结束这个 response，同时将 response 发送出去。</p><p>下面的 method 可以用来处理 http headers：</p><ul><li><strong>getHeaderNames()</strong> 获取当前 http headers 名称的列表</li><li><strong>getHeaders()</strong> 获取当前 http headers 副本</li><li><strong>setHeader('headername', value)</strong> 设置一个 http header</li><li><strong>getHeader('headername')</strong> 获取当前的一个 http header 的设置</li><li><strong>removeHeader('headername')</strong> 删除一个 http header</li><li><strong>hasHeader('headername')</strong> 如果某个 http header 有被设置则返回 true</li><li><strong>headersSent()</strong> 如果 http headers 已经发送给了客户端则返回 true</li></ul><p>服务端编辑好 headers 条目后可以通过 <code>response.writeHead()</code> method 发送给客户端，第一个参数是 statusCode。</p><p>通过 <code>response.write()</code> 在 response body 中发送数据给客户端，它会将缓冲区的数据发送到 http response stream。如果还没有使用 <code>response.writeHead()</code> 发送 headers 则会先发送 headers，包含 statusCode 和 message，它们可以通过下面语法设置：</p><pre><code>response.statusCode = 500
response.statusMessage = 'Internal Server Error'</code></pre><h4>http.IncomingMessage</h4><p><strong>http.IncomingMessage</strong> 可以在以下两个地方创建：</p><ul><li><strong>http.Server</strong> 当监听 <strong>request</strong> event</li><li><strong>http.ClientRequest</strong> 当监听 <strong>response</strong> event</li></ul><p>它可以用来访问 response 数据：</p><ul><li>通过 <strong>statusCode</strong> 和 <strong>statusMessage</strong> 读取状态信息</li><li>通过 <strong>headers</strong> method 或 <strong>rawHeaders</strong> method 读取 headers 信息</li><li>通过 <strong>method</strong> method 获取可用 http method</li><li>通过 <strong>httpVersion</strong> method 获取 http 版本信息</li><li>通过 <strong>url</strong> method 获取 URL 信息</li><li>通过 <strong>socket</strong> method 获取底层 socket 信息</li></ul><p>在 <strong>http.IncomingMessage</strong> 生效一个可读的 stream 接口后，数据可在 stream 中读取。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/2156.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/2156.html" thr:count="0"/>
</entry>
</feed>