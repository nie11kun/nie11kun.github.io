<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"
xmlns:thr="http://purl.org/syndication/thread/1.0"
xml:lang="zh-CN"
xml:base="https://blog.niekun.net/category/media/"
>
<title type="text">Marco Nie - media process</title>
<subtitle type="text"></subtitle>
<updated>2022-03-28T14:04:00+08:00</updated>
<generator uri="http://typecho.org/" version="1.2.0">Typecho</generator>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/category/media/" />
<id>https://blog.niekun.net/feed/atom/category/media/</id>
<link rel="self" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/media/" />
<entry>
<title type="html"><![CDATA[彩图转黑白 in Photoshop]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/2472.html" />
<id>https://blog.niekun.net/archives/2472.html</id>
<updated>2022-03-28T14:04:00+08:00</updated>
<published>2022-03-28T14:04:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<content type="html" xml:base="https://blog.niekun.net/archives/2472.html" xml:lang="zh-CN"><![CDATA[
<p><img src="https://blog.niekun.net/usr/uploads/2022/03/3939178568.png" alt="2022-03-28T05:38:15.png" title="2022-03-28T05:38:15.png"></p><p>黑白图片在某些场景下有其独特的风格，在人像摄影中可以体现出一种另类的雕塑感，下面通过实例介绍如何从一个彩色图片处理为一张黑白效果。使用的工具主要是 gradient map 和 camera raw。</p><p>下面是原始图片：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/4128302864.jpg" alt="Black and White - Gradient Map - Sample Image.jpg" title="Black and White - Gradient Map - Sample Image.jpg"></p><p>首先在原图上方建立 gradient map 图层，gradient map 的作用是根据图像的亮度分布进行颜色替换：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/4117532377.png" alt="2022-03-28T05:43:51.png" title="2022-03-28T05:43:51.png"></p><p>首先将下方的 method 改为 classic，这样过渡效果更加平顺一些：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/389677896.png" alt="2022-03-28T05:47:49.png" title="2022-03-28T05:47:49.png"></p><p>默认是一个反色效果渐变，点击渐变条，修改其属性为左边黑色右边白色：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/3910938814.png" alt="2022-03-28T05:46:56.png" title="2022-03-28T05:46:56.png"></p><p>下面我们增加黑白色差效果，调节左侧下方滑块可以使得黑色区域更黑，调节右侧下方滑块可以使得白色区域更白，调节中间滑块可以调节黑白区域范围：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/1041442527.png" alt="2022-03-28T05:50:16.png" title="2022-03-28T05:50:16.png"></p><p>调节到合适效果后确认即可，这样我们初步就有了一个效果。</p><p>下面为了让背景更加黑，我们通过选取提取出背景，创建一个纯黑背景。选中图像图层，选区工具下选中 select and mask：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/2572737743.png" alt="2022-03-28T05:54:09.png" title="2022-03-28T05:54:09.png"></p><p>点击 select subject 可以自动选中主体：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/4005078115.png" alt="2022-03-28T05:55:10.png" title="2022-03-28T05:55:10.png"></p><p>点击 color aware 和 shift edge 调节选区边沿：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/2779694229.png" alt="2022-03-28T05:56:49.png" title="2022-03-28T05:56:49.png"></p><p>确认后可以获取到主体的选取，创建一个 solid color 黑色图层，选中蒙版，ctrl I 反转选区即可：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/3398572673.png" alt="2022-03-28T05:58:39.png" title="2022-03-28T05:58:39.png"></p><p>放大我们可以发现主体边沿和背景没有完美的融合，这时可以通过复制刚才的 gradient map 图层强化黑白效果，然后通过笔刷工具将复制的图层只保留主体边沿部分，注意使用笔刷的时候不透明度调节稍微低一些：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/4030393213.png" alt="2022-03-28T06:10:16.png" title="2022-03-28T06:10:16.png"></p><p>基本效果已经可以了，下面调节细节部分，首先眼睛需要提亮，新建 curves 图层，提亮曲线后反转蒙版，使用笔刷工具涂抹出眼睛的亮度：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/1597724556.png" alt="2022-03-28T06:15:36.png" title="2022-03-28T06:15:36.png"></p><p>黑白图片效果一般在提高锐度的时候会更加具有特点，下面我们通过 camera raw 来做调整。</p><p>首先快捷键 ctrl shift alt E 盖印图层，然后转换为 smart object 方便后期返回来调整参数：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/4247719213.png" alt="2022-03-28T06:19:44.png" title="2022-03-28T06:19:44.png"></p><p>然后点击 filter - camera raw filter 进入编辑模式。</p><p>为了更加强烈的反差，我首先调节了亮度参数：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/2963793412.png" alt="2022-03-28T06:24:52.png" title="2022-03-28T06:24:52.png"></p><p>然后就是锐化的重点 - 提高 clarity 清晰度参数，注意不要调的过高而失真：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/3214151862.png" alt="2022-03-28T06:25:57.png" title="2022-03-28T06:25:57.png"></p><p>完成后保存返回 Photoshop，适当调节不透明度使图片更加自然：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/867381413.png" alt="2022-03-28T06:27:27.png" title="2022-03-28T06:27:27.png"></p><p>最终效果如下：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/4039780371.png" alt="2022-03-28T06:27:53.png" title="2022-03-28T06:27:53.png"></p><!--more-->
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/2472.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/media/" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[FFmpeg 简单用法]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1752.html" />
<id>https://blog.niekun.net/archives/1752.html</id>
<updated>2020-09-18T15:03:12+08:00</updated>
<published>2020-09-18T15:03:12+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<content type="html" xml:base="https://blog.niekun.net/archives/1752.html" xml:lang="zh-CN"><![CDATA[
<p>FFmpeg 是视频处理最常用的开源软件。</p><p>它功能强大，用途广泛，大量用于视频网站和商业软件（比如 Youtube 和 iTunes），也是许多音频和视频格式的标准编码/解码实现。</p><p>官方网站：<a href="https://www.ffmpeg.org/">https://www.ffmpeg.org/</a></p><!--more--><h3>安装</h3><p>最简单的方法就是用包管理工具如：apt 安装：</p><pre><code>apt update
apt install ffmpeg
</code></pre><p>或者也可以从源码安装，可以参考我之前的教程：<a href="https://blog.niekun.net/archives/891.html">https://blog.niekun.net/archives/891.html</a></p><h3>常用指令</h3><p>查看 ffmpeg 版本：</p><pre><code>ffmpeg -version
</code></pre><p>查看支持的编码格式：如 h.264, h.265</p><pre><code>ffmpeg -codecs
</code></pre><p>查看支持的容器：如 mp4, mp3, mkv</p><pre><code>ffmpeg -formats
</code></pre><p>查看已安装的编码器：如 libx264, libx265, libvpx, aac</p><pre><code>ffmpeg -encoders
</code></pre><h3>使用格式</h3><p>FFmpeg 的命令行参数非常多，可以分成五个部分。</p><pre><code>ffmpeg {1} {2} -i {3} {4} {5}
</code></pre><p>上面命令中，五个部分的参数依次如下：</p><pre><code>全局参数
输入文件参数
输入文件
输出文件参数
输出文件</code></pre><p>参数太多的时候，为了便于查看，ffmpeg 命令可以写成多行:</p><pre><code>$ ffmpeg \
[全局参数] \
[输入文件参数] \
-i [输入文件] \
[输出文件参数] \
[输出文件]</code></pre><p>下面是一个例子:</p><pre><code>ffmpeg \
-y \ # 全局参数
-c:a libfdk_aac -c:v libx264 \ # 输入文件参数
-i input.mp4 \ # 输入文件
-c:v libvpx-vp9 -c:a libvorbis \ # 输出文件参数
output.webm # 输出文件</code></pre><p>上面的命令将 mp4 文件转成 webm 文件，这两个都是容器格式。输入的 mp4 文件的音频编码格式是 aac，视频编码格式是 H.264；输出的 webm 文件的视频编码格式是 VP9，音频格式是 Vorbis。</p><p>如果不指明编码格式，FFmpeg 会自己判断输入文件的编码。<strong>一般可以省略输入文件参数。</strong></p><h3>常用命令参数</h3><pre><code>-c：指定编码器
-c copy：直接复制，不经过重新编码（这样比较快）
-c:v：指定视频编码器
-c:a：指定音频编码器
-i：指定输入文件
-an：去除音频流
-vn： 去除视频流
-preset：指定输出的视频质量，会影响文件的生成速度，有以下几个可用的值 ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow。
-y：不经过确认，输出时直接覆盖同名文件。</code></pre><h3>常规使用方法</h3><p>查看元数据信息，如时长，比特率等：</p><pre><code>ffmpeg -i test.mp4
</code></pre><p>输出的信息较多，可以通过 -hide_banner 只显示媒体文件信息：</p><pre><code>ffmpeg -i test.mp4 -hide_banner
</code></pre><p>转码，如 avi to h.264:</p><pre><code>ffmpeg -i test.avi -c:v libx264 test.mp4
</code></pre><p>转换容器：</p><pre><code>ffmpeg -i test.mp4 -c copy test.webm</code></pre><p>转换容器不需要转码，所以直接 copy 即可。</p><p>转换码率，转换成固定码率：</p><pre><code>ffmpeg -i test.mp4 -b:v 500k test_out.mp4
</code></pre><p>转换码率，转换成一个码率范围：</p><pre><code>ffmpeg -i test.mp4 -minrate 964K -maxrate 3856K -bufsize 2000K test_out.mp4
</code></pre><p>改变分辨率：转换成 480p</p><pre><code>ffmpeg \
-i input.mp4 \
-vf scale=480:-1 \
output.mp4</code></pre><p>视频中提取音频：</p><pre><code>ffmpeg \
-i input.mp4 \
-vn -c:a copy \
output.aac</code></pre><p>上面例子中，<code>-vn</code> 表示去掉视频，<code>-c:a copy</code> 表示不改变音频编码，直接拷贝。</p><p>视频截图：下面的例子是从指定时间开始，连续对1秒钟的视频进行截图</p><pre><code>ffmpeg \
-y \
-i input.mp4 \
-ss 00:01:24 -t 00:00:01 \
output_%3d.jpg</code></pre><p><code>%3d</code> 在 shell 里表示至少输出3个字符空间的数字：</p><pre><code>% means &quot;Print a variable here&quot;
3 means &quot;use at least 3 spaces to display, padding as needed&quot;
d means &quot;The variable will be an integer&quot;</code></pre><p>如果只需要截一张图，可以指定只截取一帧。</p><pre><code>$ ffmpeg \
-ss 01:23:45 \
-i input \
-vframes 1 -q:v 2 \
output.jpg</code></pre><p>上面例子中，<code>-vframes 1</code> 指定只截取一帧，<code>-q:v 2</code> 表示输出的图片质量，一般是1到5之间（1 为质量最高）。</p><p><strong>裁剪:</strong><br>裁剪（cutting）指的是，截取原始视频里面的一个片段，输出为一个新视频。可以指定开始时间（start）和持续时间（duration），也可以指定结束时间（end）。</p><pre><code>$ ffmpeg -ss [start] -i [input] -t [duration] -c copy [output]
$ ffmpeg -ss [start] -i [input] -to [end] -c copy [output]</code></pre><p>下面是实际的例子。</p><pre><code># 从1分50秒开始截取10.5秒
ffmpeg -ss 00:01:50 -i test.mp4 -t 10.5 -c copy out.mp4

# 从25秒开始截取10秒
ffmpeg -ss 25 -i test.mp4 -to 10 -c copy out.mp4
ffmpeg -i test.mp4 -ss 25 -to 10 -c copy out.mp4</code></pre><p>上面例子中，<code>-c copy</code> 表示不改变音频和视频的编码格式，直接拷贝，这样会快很多。</p><h3>高级用法</h3><h4>压缩视频内容到指定容量大小</h4><p>使用的技术主要是 ffmpeg 的 2 pass 方法和 ffprobe 得到码率和时长信息。</p><p>bash脚本：</p><pre><code>#!/bin/bash

target_video_size_MB=&quot;$2&quot;
origin_duration_s=$(ffprobe -v error -show_streams -select_streams a &quot;$1&quot; | grep -Po &quot;(?&lt;=^duration\=)\d*\.\d*&quot;)
origin_audio_bitrate_kbit_s=$(ffprobe -v error -pretty -show_streams -select_streams a &quot;$1&quot; | grep -Po &quot;(?&lt;=^bit_rate\=)\d*\.\d*&quot;)
target_audio_bitrate_kbit_s=$origin_audio_bitrate_kbit_s # TODO for now, make audio bitrate the same
target_video_bitrate_kbit_s=$(\
    awk \
    -v size=&quot;$target_video_size_MB&quot; \
    -v duration=&quot;$origin_duration_s&quot; \
    -v audio_rate=&quot;$target_audio_bitrate_kbit_s&quot; \
    'BEGIN { print  ( ( size * 8192.0 ) / ( 1.048576 * duration ) - audio_rate ) }')

ffmpeg \
    -y \
    -i &quot;$1&quot; \
    -c:v libx264 \
    -b:v &quot;$target_video_bitrate_kbit_s&quot;k \
    -pass 1 \
    -an \
    -f mp4 \
    /dev/null \
&amp;&amp; \
ffmpeg \
    -i &quot;$1&quot; \
    -c:v libx264 \
    -b:v &quot;$target_video_bitrate_kbit_s&quot;k \
    -pass 2 \
    -c:a aac \
    -b:a &quot;$target_audio_bitrate_kbit_s&quot;k \
    &quot;${1%.*}-$2mB.mp4&quot;</code></pre><p><strong>使用方法：</strong>压缩视频到 50 MB 大小</p><pre><code>./script.sh test.mp4 50
</code></pre><h4>切割视频到指定时长的多个视频</h4><p>使用的技术主要是 python，ffprobe 得到视频时长，然后计算需要切割为几个视频。<br>python 脚本：</p><pre><code>#!/usr/bin/env python

import csv
import subprocess
import math
import json
import os
import shlex
from optparse import OptionParser


def split_by_manifest(filename, manifest, vcodec=&quot;copy&quot;, acodec=&quot;copy&quot;,
                      extra=&quot;&quot;, **kwargs):

    if not os.path.exists(manifest):
        print(&quot;File does not exist: %s&quot; % manifest)
        raise SystemExit

    with open(manifest) as manifest_file:
        manifest_type = manifest.split(&quot;.&quot;)[-1]
        if manifest_type == &quot;json&quot;:
            config = json.load(manifest_file)
        elif manifest_type == &quot;csv&quot;:
            config = csv.DictReader(manifest_file)
        else:
            print(&quot;Format not supported. File must be a csv or json file&quot;)
            raise SystemExit

        split_cmd = [&quot;ffmpeg&quot;, &quot;-i&quot;, filename, &quot;-vcodec&quot;, vcodec,
                     &quot;-acodec&quot;, acodec, &quot;-y&quot;] + shlex.split(extra)
        try:
            fileext = filename.split(&quot;.&quot;)[-1]
        except IndexError as e:
            raise IndexError(&quot;No . in filename. Error: &quot; + str(e))
        for video_config in config:
            split_str = &quot;&quot;
            split_args = []
            try:
                split_start = video_config[&quot;start_time&quot;]
                split_length = video_config.get(&quot;end_time&quot;, None)
                if not split_length:
                    split_length = video_config[&quot;length&quot;]
                filebase = video_config[&quot;rename_to&quot;]
                if fileext in filebase:
                    filebase = &quot;.&quot;.join(filebase.split(&quot;.&quot;)[:-1])

                split_args += [&quot;-ss&quot;, str(split_start), &quot;-t&quot;,
                               str(split_length), filebase + &quot;.&quot; + fileext]
                print(&quot;########################################################&quot;)
                print(&quot;About to run: &quot;+&quot; &quot;.join(split_cmd+split_args))
                print(&quot;########################################################&quot;)
                subprocess.check_output(split_cmd+split_args)
            except KeyError as e:
                print(&quot;############# Incorrect format ##############&quot;)
                if manifest_type == &quot;json&quot;:
                    print(&quot;The format of each json array should be:&quot;)
                    print(&quot;{start_time: &lt;int&gt;, length: &lt;int&gt;, rename_to: &lt;string&gt;}&quot;)
                elif manifest_type == &quot;csv&quot;:
                    print(&quot;start_time,length,rename_to should be the first line &quot;)
                    print(&quot;in the csv file.&quot;)
                print(&quot;#############################################&quot;)
                print(e)
                raise SystemExit


def get_video_length(filename):

    output = subprocess.check_output((&quot;ffprobe&quot;, &quot;-v&quot;, &quot;error&quot;, &quot;-show_entries&quot;,
                                      &quot;format=duration&quot;, &quot;-of&quot;, &quot;default=noprint_wrappers=1:nokey=1&quot;, filename)).strip()
    video_length = int(float(output))
    print(&quot;Video length in seconds: &quot;+str(video_length))

    return video_length


def ceildiv(a, b):
    return int(math.ceil(a / float(b)))


def split_by_seconds(filename, split_length, vcodec=&quot;copy&quot;, acodec=&quot;copy&quot;,
                     extra=&quot;&quot;, video_length=None, **kwargs):
    if split_length and split_length &lt;= 0:
        print(&quot;Split length can't be 0&quot;)
        raise SystemExit

    if not video_length:
        video_length = get_video_length(filename)
    split_count = ceildiv(video_length, split_length)
    if(split_count == 1):
        print(&quot;Video length is less then the target split length.&quot;)
        raise SystemExit

    split_cmd = [&quot;ffmpeg&quot;, &quot;-i&quot;, filename, &quot;-vcodec&quot;,
                 vcodec, &quot;-acodec&quot;, acodec] + shlex.split(extra)
    try:
        filebase = &quot;.&quot;.join(filename.split(&quot;.&quot;)[:-1])
        fileext = filename.split(&quot;.&quot;)[-1]
    except IndexError as e:
        raise IndexError(&quot;No . in filename. Error: &quot; + str(e))
    for n in range(0, split_count):
        split_args = []
        if n == 0:
            split_start = 0
        else:
            split_start = split_length * n

        split_args += [&quot;-ss&quot;, str(split_start), &quot;-t&quot;, str(split_length),
                       filebase + &quot;-&quot; + str(n+1) + &quot;-of-&quot; +
                       str(split_count) + &quot;.&quot; + fileext]
        print(&quot;About to run: &quot;+&quot; &quot;.join(split_cmd+split_args))
        subprocess.check_output(split_cmd+split_args)


def main():
    parser = OptionParser()

    parser.add_option(&quot;-f&quot;, &quot;--file&quot;,
                      dest=&quot;filename&quot;,
                      help=&quot;File to split, for example sample.avi&quot;,
                      type=&quot;string&quot;,
                      action=&quot;store&quot;
                      )
    parser.add_option(&quot;-s&quot;, &quot;--split-size&quot;,
                      dest=&quot;split_length&quot;,
                      help=&quot;Split or chunk size in seconds, for example 10&quot;,
                      type=&quot;int&quot;,
                      action=&quot;store&quot;
                      )
    parser.add_option(&quot;-c&quot;, &quot;--split-chunks&quot;,
                      dest=&quot;split_chunks&quot;,
                      help=&quot;Number of chunks to split to&quot;,
                      type=&quot;int&quot;,
                      action=&quot;store&quot;
                      )
    parser.add_option(&quot;-S&quot;, &quot;--split-filesize&quot;,
                      dest=&quot;split_filesize&quot;,
                      help=&quot;Split or chunk size in bytes (approximate)&quot;,
                      type=&quot;int&quot;,
                      action=&quot;store&quot;
                      )
    parser.add_option(&quot;--filesize-factor&quot;,
                      dest=&quot;filesize_factor&quot;,
                      help=&quot;with --split-filesize, use this factor in time to&quot;
                      &quot; size heuristics [default: %default]&quot;,
                      type=&quot;float&quot;,
                      action=&quot;store&quot;,
                      default=0.95
                      )
    parser.add_option(&quot;--chunk-strategy&quot;,
                      dest=&quot;chunk_strategy&quot;,
                      help=&quot;with --split-filesize, allocate chunks according to&quot;
                      &quot; given strategy (eager or even)&quot;,
                      type=&quot;choice&quot;,
                      action=&quot;store&quot;,
                      choices=['eager', 'even'],
                      default='eager'
                      )
    parser.add_option(&quot;-m&quot;, &quot;--manifest&quot;,
                      dest=&quot;manifest&quot;,
                      help=&quot;Split video based on a json manifest file. &quot;,
                      type=&quot;string&quot;,
                      action=&quot;store&quot;
                      )
    parser.add_option(&quot;-v&quot;, &quot;--vcodec&quot;,
                      dest=&quot;vcodec&quot;,
                      help=&quot;Video codec to use. &quot;,
                      type=&quot;string&quot;,
                      default=&quot;copy&quot;,
                      action=&quot;store&quot;
                      )
    parser.add_option(&quot;-a&quot;, &quot;--acodec&quot;,
                      dest=&quot;acodec&quot;,
                      help=&quot;Audio codec to use. &quot;,
                      type=&quot;string&quot;,
                      default=&quot;copy&quot;,
                      action=&quot;store&quot;
                      )
    parser.add_option(&quot;-e&quot;, &quot;--extra&quot;,
                      dest=&quot;extra&quot;,
                      help=&quot;Extra options for ffmpeg, e.g. '-e -threads 8'. &quot;,
                      type=&quot;string&quot;,
                      default=&quot;&quot;,
                      action=&quot;store&quot;
                      )
    (options, args) = parser.parse_args()

    def bailout():
        parser.print_help()
        raise SystemExit

    if not options.filename:
        bailout()

    if options.manifest:
        split_by_manifest(**(options.__dict__))
    else:
        video_length = None
        if not options.split_length:
            video_length = get_video_length(options.filename)
            file_size = os.stat(options.filename).st_size
            split_filesize = None
            if options.split_filesize:
                split_filesize = int(
                    options.split_filesize * options.filesize_factor)
            if split_filesize and options.chunk_strategy == 'even':
                options.split_chunks = ceildiv(file_size, split_filesize)
            if options.split_chunks:
                options.split_length = ceildiv(
                    video_length, options.split_chunks)
            if not options.split_length and split_filesize:
                options.split_length = int(
                    split_filesize / float(file_size) * video_length)
        if not options.split_length:
            bailout()
        split_by_seconds(video_length=video_length, **(options.__dict__))


if __name__ == '__main__':
    main()</code></pre><p><strong>使用方法：</strong>将视频切割为单个视频100秒</p><pre><code>./split.py -f test.mp4 -s 100
</code></pre><h3>ffprobe 使用</h3><p>ffprobe 可以用来得到视频信息。</p><p>视频时长：秒</p><pre><code>ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 input.mp4
</code></pre><p>视频码率：bit</p><pre><code>ffprobe -v error -show_entries format=bit_rate -of default=noprint_wrappers=1:nokey=1 input.mp4
</code></pre><h3>参考链接</h3><p><a href="http://www.ruanyifeng.com/blog/2020/01/ffmpeg.html">http://www.ruanyifeng.com/blog/2020/01/ffmpeg.html</a><br><a href="https://stackoverflow.com/questions/29082422/ffmpeg-video-compression-specific-file-size">https://stackoverflow.com/questions/29082422/ffmpeg-video-compression-specific-file-size</a><br><a href="https://github.com/c0decracker/video-splitter">https://github.com/c0decracker/video-splitter</a><br><a href="https://trac.ffmpeg.org/wiki/FFprobeTips">https://trac.ffmpeg.org/wiki/FFprobeTips</a></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1752.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/media/" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[自由填充 Pattern in Photoshop]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1720.html" />
<id>https://blog.niekun.net/archives/1720.html</id>
<updated>2020-08-18T12:09:00+08:00</updated>
<published>2020-08-18T12:09:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<content type="html" xml:base="https://blog.niekun.net/archives/1720.html" xml:lang="zh-CN"><![CDATA[
<p><img src="https://blog.niekun.net/usr/uploads/2020/08/1117148355.jpg" alt="1.jpg" title="1.jpg"></p><p>对于单个 pattern 模型，如果想要在 layer 内以随机的角度或大小填充来实现更加自然的效果可以使用 script 脚本方便的实现。</p><!--more--><p>我们从如何定一个 pattern 开始，下面是一张 1 美元图片：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/2275032220.jpg" alt="2.jpg" title="2.jpg"></p><p>使用 object selection tool 快速将主体选出来：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/547813215.jpg" alt="3.jpg" title="3.jpg"></p><p>选区边沿如果有多余的或者缺失的部分，通过 按住 shift 和 alt 键来增加/减去选区：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/1909413931.jpg" alt="5.jpg" title="5.jpg"></p><p>点击添加图层蒙版，边沿如果需要调整，可以使用画笔工具来进一步修整蒙版。如果蒙版边沿有锯齿，可以双击蒙版打开属性框，调整 smooth 和 contract 来优化蒙版：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3707703993.jpg" alt="6.jpg" title="6.jpg"></p><p>使用选区工具框出一个矩形框包含我们的主体：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/1689003146.jpg" alt="7.jpg" title="7.jpg"></p><p>选择 edit - define pattern：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3798048595.jpg" alt="8.jpg" title="8.jpg"></p><p>定义一个名称，点击 ok：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/2156770301.jpg" alt="9.jpg" title="9.jpg"></p><p>新建图层，快捷键 shift backspace/shift delete 调出填充框：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3400954114.jpg" alt="10.jpg" title="10.jpg"></p><p>content 选择 pattern：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/1708881397.jpg" alt="11.jpg" title="11.jpg"></p><p>custom pattern 里选中我们刚才新建的模型：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/234781752.jpg" alt="12.jpg" title="12.jpg"></p><p>script 前打勾，然后右侧菜单里选择 random fill：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/2358508818.jpg" alt="13.jpg" title="13.jpg"></p><p>点击 ok 后进入调整菜单，首先将 下面的 color randomness 设为 0 避免图形的染色改变，brightness randomness 设置为 0.02 左右使亮度轻微可以随机改变，形成层次感：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/1452674295.jpg" alt="14.jpg" title="14.jpg"></p><p>将 density 设置为最大 10，将 minimum/maximum scale factor 设置为 1，这样 pattern 会以 1:1 比例显示：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/912797465.jpg" alt="15.jpg" title="15.jpg"></p><p>将 rotate pattern 打勾，这样模型会随机旋转：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/1309014316.jpg" alt="16.jpg" title="16.jpg"></p><p>设置完成后点击 ok，可以看到效果：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/186378886.jpg" alt="17.jpg" title="17.jpg"></p><p><strong>还可以做一些优化来使层叠效果更加真实，过程就是降低 density 和 scale，添加图层阴影效果。</strong></p><p>新建图层，使用上面的方法填充 pattern，在设置中将 density 设置为 9，scale 设置为 0.25：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/651526338.jpg" alt="18.jpg" title="18.jpg"></p><p>确认后可以看到效果，单个图形变小，填充密度变小：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/223800845.jpg" alt="19.jpg" title="19.jpg"></p><p>我们给图层添加阴影效果，双击图层打开 layer style，下方点击添加阴影：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3623006525.jpg" alt="20.jpg" title="20.jpg"></p><p>再次新建图层，使用上面图层的填充设置填充 pattern，可以将空缺的部分进一步补充完整：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/1465392084.jpg" alt="21.jpg" title="21.jpg"></p><p>按住 alt 键拖拽刚才的阴影特效到新图层，可以快速复制效果：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/1601765537.jpg" alt="22.jpg" title="22.jpg"></p><p>可以看到还是有空白的区域没有填充完整，继续重复上面的步骤，建立多个图层，直到完全充满整个区域为止，最终效果如下：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3607587483.jpg" alt="23.jpg" title="23.jpg"></p><p>以上就是使用 script 来实现 pattern 自由填充的过程。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1720.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/media/" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[眼睛进阶处理 in Photoshop]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1690.html" />
<id>https://blog.niekun.net/archives/1690.html</id>
<updated>2020-08-14T11:16:27+08:00</updated>
<published>2020-08-14T11:16:27+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<content type="html" xml:base="https://blog.niekun.net/archives/1690.html" xml:lang="zh-CN"><![CDATA[
<p><img src="https://blog.niekun.net/usr/uploads/2020/08/480024501.jpg" alt="26.jpg" title="26.jpg"><br>在人像照片中，一双炯炯有神的眼睛会让照片整体突出，下面我们来尝试通过提升亮度，增加细节等过程来实现。</p><!--more--><p>下图是我们的原图：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/1396099294.jpg" alt="1.jpg" title="1.jpg"></p><p>放大眼睛细节：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3561747204.jpg" alt="2.jpg" title="2.jpg"></p><p>原图已经很好了，很清晰。下面我们进行调整。</p><h3>强化亮部细节</h3><p>需要提亮的部分是光源点的对面，再此图中就是眼睛光斑的下方，新建图层，画笔工具画圆：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3017674335.jpg" alt="3.jpg" title="3.jpg"></p><p>擦除多余部分，笔刷选择软笔刷，可以先降低不透明度来看到背景：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3764677799.jpg" alt="4.jpg" title="4.jpg"></p><p>高斯模糊使过度自然：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3996858297.jpg" alt="5.jpg" title="5.jpg"><br><img src="https://blog.niekun.net/usr/uploads/2020/08/501671708.jpg" alt="6.jpg" title="6.jpg"></p><p>混合模式改为 overlay 实现提亮：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/335821335.jpg" alt="7.jpg" title="7.jpg"></p><p>blend option 去掉影响阴影部分：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3804539933.jpg" alt="8.jpg" title="8.jpg"></p><p>如果想要加强效果可以再次复制图层，调整不透明度。</p><h3>增加高光点</h3><p>新建曲线图层，拉高曲线：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/1354307723.jpg" alt="9.jpg" title="9.jpg"></p><p>ctrl I 反转图层蒙版，白色画笔工具软笔刷在瞳孔下方点击一下：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3285907289.jpg" alt="10.jpg" title="10.jpg"></p><p>可以看到效果太强了，调低不透明度到合适：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/295434221.jpg" alt="11.jpg" title="11.jpg"></p><h3>增加明暗细节</h3><p>新建曲线图层，提高曲线，反转图层蒙版：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/4087592833.jpg" alt="12.jpg" title="12.jpg"></p><p>白色画笔工具使用软笔刷沿着瞳孔在亮部区域画出射线，这一步注意如果有数位板来画的话会更好：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/1796541048.jpg" alt="13.jpg" title="13.jpg"></p><p>降低不透明度到合适：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3436373763.jpg" alt="14.jpg" title="14.jpg"></p><p>下面增加暗部细节，再次新建曲线，然后降低曲线，反转蒙版：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/691635148.jpg" alt="15.jpg" title="15.jpg"></p><p>同样的方法画出射线：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/1700268067.jpg" alt="16.jpg" title="16.jpg"></p><p>降低不透明度：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3272285669.jpg" alt="17.jpg" title="17.jpg"></p><h3>眼白清理</h3><p>首先清理红血丝，新建图层，选择修复画笔工具混合模式设置为 screen，这样可以只处理暗部血丝：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/912985796.jpg" alt="18.jpg" title="18.jpg"><br><img src="https://blog.niekun.net/usr/uploads/2020/08/3994121998.jpg" alt="19.jpg" title="19.jpg"></p><p>按 alt 键采样眼白，涂抹血丝区域：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/2541180553.jpg" alt="20.jpg" title="20.jpg"></p><p>然后进行 dogding and burning 明暗调节，首先建立 soild color 观察图层，混合模式改为 color 来只显示亮度情况：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/2919767102.jpg" alt="21.jpg" title="21.jpg"></p><p>新建图层，混合模式改为 soft light，选择笔刷工具软笔刷流量改为 1，快捷键 D 恢复颜色为黑/白，根据实际用白色笔刷涂抹暗部，黑色笔刷涂抹过亮部分：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3803864790.jpg" alt="22.jpg" title="22.jpg"></p><p>然后修复亮度调整后的颜色变化，新建图层，混合模式改为 color，快捷键 I 拾取眼白正常部分的颜色，然后在新图层上涂抹出需要修复的区域：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/825482316.jpg" alt="23.jpg" title="23.jpg"></p><h3>复制效果</h3><p>将亮部细节处理/高光点/明暗细节处理部分建立分组然后复制一份，安住 ctrl 拖动分组到另一只眼睛部分，可以配合蒙版清理多余部分：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3182465625.jpg" alt="24.jpg" title="24.jpg"></p><p>可以使用同样的方法清理另一只眼睛的眼白部分最终效果如下：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/2262252084.jpg" alt="25.jpg" title="25.jpg"></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1690.html#comments" thr:count="1" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/media/" thr:count="1"/>
</entry>
<entry>
<title type="html"><![CDATA[cinema 4D 快捷键]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1677.html" />
<id>https://blog.niekun.net/archives/1677.html</id>
<updated>2020-07-20T09:03:00+08:00</updated>
<published>2020-07-20T09:03:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<content type="html" xml:base="https://blog.niekun.net/archives/1677.html" xml:lang="zh-CN"><![CDATA[
<table><tbody><tr><td align="center">1</td><td align="center">视角移动</td></tr><tr><td align="center">2</td><td align="center">视野放大/缩小</td></tr><tr><td align="center">3</td><td align="center">视角旋转</td></tr><tr><td align="center"> </td><td align="center"> </td></tr><tr><td align="center">E</td><td align="center">object 移动</td></tr><tr><td align="center">R</td><td align="center">object 旋转</td></tr><tr><td align="center">T</td><td align="center">object 放大/缩小</td></tr><tr><td align="center"> </td><td align="center"> </td></tr><tr><td align="center"><strong>object 编辑</strong></td><td align="center"> </td></tr><tr><td align="center">U</td><td align="center">线段功能菜单</td></tr><tr><td align="center">U + L</td><td align="center">选择闭合曲线</td></tr><tr><td align="center">U + U</td><td align="center">取消区域曲线选择</td></tr><tr><td align="center">M</td><td align="center">块功能菜单</td></tr><tr><td align="center">M + T</td><td align="center">块生成工具</td></tr><tr><td align="center"> </td><td align="center"> </td></tr><tr><td align="center">Q</td><td align="center">隐藏 subdivision surface</td></tr><tr><td align="center"> </td><td align="center"> </td></tr><tr><td align="center">alt + R</td><td align="center">区域渲染</td></tr><tr><td align="center"> </td><td align="center"> </td></tr></tbody></table>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1677.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/media/" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[快速给黑白照上色 in Photoshop]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1653.html" />
<id>https://blog.niekun.net/archives/1653.html</id>
<updated>2020-07-14T14:37:09+08:00</updated>
<published>2020-07-14T14:37:09+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<content type="html" xml:base="https://blog.niekun.net/archives/1653.html" xml:lang="zh-CN"><![CDATA[
<p><img src="https://blog.niekun.net/usr/uploads/2020/07/44560624.png" alt="2020-07-14T06:37:35.png" title="2020-07-14T06:37:35.png"><br>如果你需要给黑白照片添加颜色，这个教程可以帮助你快速完成。它通过把照片上传到一个免费的网站来自动给照片上色，然后再 Photoshop 中对自动处理不完美的地方进行精细调整最终得到满意的效果。</p><p>免费上色网站地址为：<a href="https://imagecolorizer.com/">https://imagecolorizer.com/</a></p><!--more--><p>我们首先测试人像：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/543586783.png" alt="2020-07-14T06:17:56.png" title="2020-07-14T06:17:56.png"></p><p>将图片上传到网站，等待自动处理完成后下载到本地：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/3642678669.png" alt="2020-07-14T06:19:06.png" title="2020-07-14T06:19:06.png"></p><p>自动处理结果如下，可以看到基本比较完善，但是细节处有一些偏色，色条和漏掉颜色的地方：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/3456647720.png" alt="2020-07-14T06:20:27.png" title="2020-07-14T06:20:27.png"></p><p>下面我们进入 Photoshop 进行处理，将原图和处理后的图片导入，将处理后的图层模式设置为 color，我们只用处理后的色彩信息：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/974399740.png" alt="2020-07-14T06:24:06.png" title="2020-07-14T06:24:06.png"></p><p>首先处理皮肤表面的不规则色条，选择 filter - blur - furface blur，放大可以看到表面的色条：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/3152308407.png" alt="2020-07-14T06:26:00.png" title="2020-07-14T06:26:00.png"></p><p>调整 radius 和 threshold 使表面颜色平滑：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/2849828835.png" alt="2020-07-14T06:27:53.png" title="2020-07-14T06:27:53.png"></p><p>然后我们处理脖子部分的颜色丢失：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/3792211515.png" alt="2020-07-14T06:29:15.png" title="2020-07-14T06:29:15.png"></p><p>新建图层，混合模式改为 color，拾取附近色彩正常区域的颜色，快捷键 <code>I</code>：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/3906118047.png" alt="2020-07-14T06:30:39.png" title="2020-07-14T06:30:39.png"></p><p>使用画笔工具涂抹需要重新上色的区域：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/1268283782.png" alt="2020-07-14T06:34:49.png" title="2020-07-14T06:34:49.png"></p><p>面部饱和度过高，新建 hue 图层降低面部饱和度，配合蒙版操作：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/3887876296.png" alt="2020-07-14T06:36:36.png" title="2020-07-14T06:36:36.png"></p><p>最终效果如下：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/2061429475.png" alt="2020-07-14T06:37:00.png" title="2020-07-14T06:37:00.png"></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1653.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/media/" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[使用 graduated filter 处理特定颜色的区域 in lightroom]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1643.html" />
<id>https://blog.niekun.net/archives/1643.html</id>
<updated>2020-07-13T16:55:31+08:00</updated>
<published>2020-07-13T16:55:31+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<content type="html" xml:base="https://blog.niekun.net/archives/1643.html" xml:lang="zh-CN"><![CDATA[
<p><img src="https://blog.niekun.net/usr/uploads/2020/07/127928796.png" alt="2020-07-13T08:31:41.png" title="2020-07-13T08:31:41.png"></p><p>在 lightroom 中想要改变一个颜色的色相，最简单的方法就是在 hue panel 来处理：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/1529029449.png" alt="2020-07-13T08:34:19.png" title="2020-07-13T08:34:19.png"></p><p>通过移动某个颜色的滑块来改变这一颜色的色相，或者点击左上方的按钮，然后在图片中拖动来直接修改当前区域的色相。同理也可以修改饱和度和亮度。</p><p>这里介绍另一种通过 graduated filter 工具来处理，控制自由度更大，可以设定颜色影响的范围，也可以调节修改部分的亮度清晰度等信息。</p><!--more--><p>develop 里，最上方找到方形的工具就是 graduated filter：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/1332949299.png" alt="2020-07-13T08:39:29.png" title="2020-07-13T08:39:29.png"></p><p>它可以用直线将图片分割成两部分，一侧为保护区域一侧为修改区域，中间为过度区域。常用来单独处理天空和地面的亮度等。快捷键 <code>O</code> 查看修改区域的范围，红色部分为影响区域：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/1470270954.png" alt="2020-07-13T08:42:58.png" title="2020-07-13T08:42:58.png"></p><p>这里我们实验修改下方树木的颜色。</p><p>在下方找到 range mask，切换到 color，这就代表在当前选区下再次匹配特定颜色缩小范围：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/4228080011.png" alt="2020-07-13T08:46:38.png" title="2020-07-13T08:46:38.png"></p><p>点击左侧吸管，在图片内找到树木区域通过点击或者拖拽来选取颜色：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/854184568.png" alt="2020-07-13T08:48:32.png" title="2020-07-13T08:48:32.png"></p><p>拾取颜色后调节 amount 来控制选区范围，如果看不到选区范围，按快捷键 <code>O</code>：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/3119192917.png" alt="2020-07-13T08:50:48.png" title="2020-07-13T08:50:48.png"></p><p>选区范围完成后，按 <code>O</code> 取消选区显示，调节上方 hue 滑块修改颜色，点击下方的 use fine adjustment 可以精细调节色相：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/3719235794.png" alt="2020-07-13T08:53:04.png" title="2020-07-13T08:53:04.png"></p><p>和其他 filter 一样，可以调节白平衡，亮度，对比度等各种参数来精细控制区域的效果：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/465920212.png" alt="2020-07-13T08:55:58.png" title="2020-07-13T08:55:58.png"></p><p>以上就是通过使用 graduated filter 处理特定颜色的区域的过程。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1643.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/media/" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[修复图片污迹 in Photoshop]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1618.html" />
<id>https://blog.niekun.net/archives/1618.html</id>
<updated>2020-07-05T22:17:00+08:00</updated>
<published>2020-07-05T22:17:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<content type="html" xml:base="https://blog.niekun.net/archives/1618.html" xml:lang="zh-CN"><![CDATA[
<p><img src="https://blog.niekun.net/usr/uploads/2020/07/1700280046.png" alt="2020-07-05T14:16:57.png" title="2020-07-05T14:16:57.png"></p><p>某些特殊情况下，我们拍摄的照片上会有许多连续的斑点污迹，比如对着玻璃或者纸张拍摄的图片。这时候可以简单的通过 Photoshop 插件来处理。</p><!--more--><p><img src="https://blog.niekun.net/usr/uploads/2020/07/3792131336.png" alt="2020-07-05T13:46:36.png" title="2020-07-05T13:46:36.png"><br>上图是水族箱里的一条鱼，可以看到图片里充斥着白色小斑点，可能是水里的漂浮物或者玻璃上的污垢。</p><p>首先复制图层，转换为智能图层，选择 filter - noise - dust & scratches：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/3528759173.png" alt="2020-07-05T13:48:39.png" title="2020-07-05T13:48:39.png"><br><img src="https://blog.niekun.net/usr/uploads/2020/07/1714960519.png" alt="2020-07-05T13:54:52.png" title="2020-07-05T13:54:52.png"></p><p>首先将 radius 和 threshold 都拉到 0，然后选择到图片的高光地方，拖动 radius 使斑点刚好消失：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/8740210.png" alt="2020-07-05T13:52:43.png" title="2020-07-05T13:52:43.png"></p><p>然后调节 threshold，使边缘尽量锐化还原细节，但注意调得过高会导致噪点出现：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/1787353468.png" alt="2020-07-05T13:54:22.png" title="2020-07-05T13:54:22.png"></p><p>完成后点击确认，图片干净了很多，但是鱼身有些模糊了，所以需要将鱼身排除在外。新建图层蒙版，将鱼的部分涂抹黑色：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/3056008152.png" alt="2020-07-05T13:58:47.png" title="2020-07-05T13:58:47.png"></p><p>可以看到在阴影部分，依然有部分污迹没有消除，我们再次复制原始图层，使用上面的方法来处理。<br>这次我们只考虑阴影部分，将 radius 调大，使阴影部分的污迹也消除：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/920237042.png" alt="2020-07-05T14:01:36.png" title="2020-07-05T14:01:36.png"></p><p>完成后，按住 alt 键添加图层蒙版并反转为黑色，使用白色画笔将阴影部分在蒙版上涂抹出来：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/2100081718.png" alt="2020-07-05T14:04:33.png" title="2020-07-05T14:04:33.png"></p><p>这样背景上基本就很干净了，现在我们处理鱼身上的污迹，可以使用的方法有很多比如印章工具，修复画笔工具等，这里我们使用 content aware fill 来处理。</p><p>按快捷键 cmd alt shift E 盖印图层，然后使用套索工具选出污迹部分，注意按住 shift 键来添加选区：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/3563437076.png" alt="2020-07-05T14:10:32.png" title="2020-07-05T14:10:32.png"></p><p>选区完成后，点击 edit - content aware fill：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/3586222960.png" alt="2020-07-05T14:13:28.png" title="2020-07-05T14:13:28.png"></p><p>直接使用默认设置，点击确认，填充部分回放在一个新图层内，点击 cmd D 取消选区，可以看到鱼身上的污迹已经去除了：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/3148702917.png" alt="2020-07-05T14:15:13.png" title="2020-07-05T14:15:13.png"></p><p>最终效果如下：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/3157282403.png" alt="2020-07-05T14:15:43.png" title="2020-07-05T14:15:43.png"></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1618.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/media/" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[在 Final Cut Pro 中管理渲染文件]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1593.html" />
<id>https://blog.niekun.net/archives/1593.html</id>
<updated>2020-07-05T14:31:00+08:00</updated>
<published>2020-07-05T14:31:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<content type="html" xml:base="https://blog.niekun.net/archives/1593.html" xml:lang="zh-CN"><![CDATA[
<p>渲染就是为项目中 Final Cut Pro 无法实时播放的部分创建临时视频和音频渲染文件的过程。当添加<strong>效果、转场、发生器、字幕</strong>和其他项目时，您将需要对它们进行渲染才能以高质量进行播放。</p><p>在时间线中，需要渲染的片段上方将出现一条浅灰色点线。<br><img src="https://blog.niekun.net/usr/uploads/2020/07/4269995666.png" alt="2020-07-05T06:12:33.png" title="2020-07-05T06:12:33.png"></p><!--more--><p>Final Cut Pro 默认是打开实时渲染的，可以在 preference - playback 里看到 rendering：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/410002084.png" alt="2020-07-05T06:15:50.png" title="2020-07-05T06:15:50.png"></p><p>渲染文件默认将储存到项目文件内。可以打开项目设置查看：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/1554615253.png" alt="2020-07-05T06:18:48.png" title="2020-07-05T06:18:48.png"></p><p>随着时间的推移，渲染文件会累积，并占用储存空间，项目文件会越来越大：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/3908364157.png" alt="2020-07-05T06:21:07.png" title="2020-07-05T06:21:07.png"></p><p>如果要释放储存空间，您可以删除所选事件中未使用的渲染文件或者删除所选项目或事件的所有渲染文件。您还可以删除给定资源库的所有渲染文件。原始媒体文件将不会删除，因此您始终可以从原始媒体中重新生成渲染文件。</p><p>选中项目文件，点击 file - delete generated library files：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/889744413.png" alt="2020-07-05T06:21:45.png" title="2020-07-05T06:21:45.png"></p><p>在弹出的对话框中，可以选择删除未使用的文件或者全部渲染文件：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/866884754.png" alt="2020-07-05T06:22:38.png" title="2020-07-05T06:22:38.png"></p><p><strong>如果选择了删除全部渲染文件，如果设置里打开了自动渲染，则删除后会立刻开始生成新的渲染文件。</strong></p><p>删除后可以看到项目文件小了很多：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/524037119.png" alt="2020-07-05T06:24:33.png" title="2020-07-05T06:24:33.png"></p><p>如果打开了自动渲染，可以看到系统开始新的渲染了：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/1071406095.png" alt="2020-07-05T06:19:52.png" title="2020-07-05T06:19:52.png"></p><p>如果不想自动渲染，可以关闭设置里的自动渲染，然后在需要的时候手动进行渲染，首先在设置里关闭自动渲染，然后在需要进行渲染的时候，点击 modify - render all 系统就会开始渲染 timeline 的项目了：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/1094078703.png" alt="2020-07-05T06:27:56.png" title="2020-07-05T06:27:56.png"></p><p>参考文章：</p><p><a href="https://support.apple.com/zh-cn/guide/final-cut-pro/ver68a8c250/mac">在 Final Cut Pro 中管理渲染文件</a><br><a href="https://support.apple.com/zh-cn/guide/final-cut-pro/verb8e60ab7/10.4.7/mac/10.14">Final Cut Pro 中的“播放”偏好设置</a></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1593.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/media/" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[在 Final Cut Pro 中将片段重新链接到媒体文件]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1586.html" />
<id>https://blog.niekun.net/archives/1586.html</id>
<updated>2020-07-05T13:10:49+08:00</updated>
<published>2020-07-05T13:10:49+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<content type="html" xml:base="https://blog.niekun.net/archives/1586.html" xml:lang="zh-CN"><![CDATA[
<p>最近将存储盘目录重新整理了下，视频素材的路径和之前不一样了，导致 Final Cut Pro 项目打开后找不到媒体文件。可以在设置里重新链接文件到项目。</p><!--more--><p>打开项目后，左侧资源库显示媒体文件丢失：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/3255484177.png" alt="2020-07-05T05:02:32.png" title="2020-07-05T05:02:32.png"></p><p>选中最上边的library名称，选择 file - relink files：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/959592516.png" alt="2020-07-05T05:03:31.png" title="2020-07-05T05:03:31.png"></p><p>弹出的对话框会显示丢失文件列表，点击 locate all：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/1560001037.png" alt="2020-07-05T05:04:31.png" title="2020-07-05T05:04:31.png"></p><p>在弹出的对话框中找到当前项目需要的媒体文件所在文件夹并点击 open，返回后可以看到丢失文件列表已经清空，点击 relink files：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/1287755725.png" alt="2020-07-05T05:07:14.png" title="2020-07-05T05:07:14.png"></p><p>以上就完成了资源的重新 link，如果下方的 project 栏是空的，不用担心，在资源库滑动到最上方可以找到已经创建的 project：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/1122286787.png" alt="2020-07-05T05:09:36.png" title="2020-07-05T05:09:36.png"></p><p>双击 project 就可以打开项目了：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/837039260.png" alt="2020-07-05T05:11:02.png" title="2020-07-05T05:11:02.png"></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1586.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/media/" thr:count="0"/>
</entry>
</feed>