<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"
xmlns:thr="http://purl.org/syndication/thread/1.0"
xml:lang="zh-CN"
xml:base="https://blog.niekun.net/category/Linux/"
>
<title type="text">Marco Nie - Linux</title>
<subtitle type="text"></subtitle>
<updated>2022-03-14T11:35:31+08:00</updated>
<generator uri="http://typecho.org/" version="1.2.0">Typecho</generator>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/category/Linux/" />
<id>https://blog.niekun.net/feed/atom/category/Linux/</id>
<link rel="self" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/Linux/" />
<entry>
<title type="html"><![CDATA[使用 rclone 管理网盘文件]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/2454.html" />
<id>https://blog.niekun.net/archives/2454.html</id>
<updated>2022-03-14T11:35:31+08:00</updated>
<published>2022-03-14T11:35:31+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<content type="html" xml:base="https://blog.niekun.net/archives/2454.html" xml:lang="zh-CN"><![CDATA[
<p>之前介绍了通过 gdrive 在服务器上管理 Google drive 文件，实现服务器数据备份自动上传功能。最近发现有一个新的开源项目 rclone 支持更多的网盘，同时更新迭代速度也更快。</p><p>GitHub 主页：<a href="https://github.com/rclone/rclone">https://github.com/rclone/rclone</a></p><p>他支持的网盘列表：<a href="https://rclone.org/overview/">https://rclone.org/overview/</a></p><p>下面介绍它的安装使用方法。</p><!--more--><h3>安装</h3><p>Linux 下一键安装命令：</p><pre><code>curl https://rclone.org/install.sh | sudo bash
</code></pre><p>macos 通过 brew 安装：</p><pre><code>brew install rclone
</code></pre><h3>配置</h3><p>首次运行执行初始化配置：</p><pre><code>rclone config
</code></pre><p>根据提示创建新 remote：</p><pre><code>No remotes found - make a new one
n) New remote
r) Rename remote
c) Copy remote
s) Set configuration password
q) Quit config
n/r/c/s/q&gt; n</code></pre><p>然后设置此连接名称，后续就是通过这个名称来操作不同的网盘的：</p><pre><code>name&gt; remote
</code></pre><p>下一步选择网盘类型，如果是 Google drive 选择 16：</p><pre><code>Type of storage to configure.
Choose a number from below, or type in your own value
[snip]
16 / Google Drive
   \ &quot;drive&quot;
[snip]
Storage&gt; 16</code></pre><p>下面的 id 和 secret 都默认回车即可：</p><pre><code>Google Application Client Id - leave blank normally.
client_id&gt;
Google Application Client Secret - leave blank normally.
client_secret&gt;</code></pre><p>下面设置可访问全部网盘文件，选择 1：</p><pre><code>Scope that rclone should use when requesting access from drive.
Choose a number from below, or type in your own value
 1 / Full access all files, excluding Application Data Folder.
   \ &quot;drive&quot;
 2 / Read-only access to file metadata and file contents.
   \ &quot;drive.readonly&quot;
   / Access to files created by rclone only.
 3 | These are visible in the drive website.
   | File authorization is revoked when the user deauthorizes the app.
   \ &quot;drive.file&quot;
   / Allows read and write access to the Application Data folder.
 4 | This is not visible in the drive website.
   \ &quot;drive.appfolder&quot;
   / Allows read-only access to file metadata but
 5 | does not allow any access to read or download file content.
   \ &quot;drive.metadata.readonly&quot;
scope&gt; 1</code></pre><p>下面几步都默认回车即可。</p><p>注意到了 use auto config 的时候要选择 No，因为我们是远程 ssh 访问的服务器：</p><pre><code>Use auto config?
 * Say Y if not sure
 * Say N if you are working on a remote or headless machine or Y didn't work
y) Yes
n) No
y/n&gt; n</code></pre><p>下面会返回一个链接，复制链接到浏览器后，登录 google 账户给 rclone 授权。授权完成后会返回一个字符串码，粘贴回终端。</p><p>后续几步默认回车即可，最后输入 q 退出 config。</p><h3>使用</h3><p>配置完成后我们就可以使用了，下面介绍一些基本语法。下面示例中网盘配置名称为 remote。</p><p>列出网盘的所有文件：</p><pre><code>rclone ls remote:
</code></pre><p>列出一个文件夹内的所有文件：</p><pre><code>rclone ls remote:abc
</code></pre><p>创建一个文件夹：</p><pre><code>rclone mkdir remote:abc
rclone mkdir remote:abc/def
</code></pre><p>删除网盘内一个文件：</p><pre><code>rclone delete remote:abc/123.txt
</code></pre><p>删除一个文件夹：</p><pre><code>rclone rmdir remote:abc
</code></pre><p>复制本地一个文件到网盘：</p><pre><code>rclone copy 123.txt remote:abc
</code></pre><p>更多可用命令可以参考官方文档：<a href="https://rclone.org/docs/#subcommands">https://rclone.org/docs/#subcommands</a></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/2454.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/Linux/" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[Ubuntu 18.04 升级 Ubuntu 20.04 记录]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/2451.html" />
<id>https://blog.niekun.net/archives/2451.html</id>
<updated>2022-03-12T15:32:00+08:00</updated>
<published>2022-03-12T15:32:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<content type="html" xml:base="https://blog.niekun.net/archives/2451.html" xml:lang="zh-CN"><![CDATA[
<p>昨天决定把服务器的系统从 Ubuntu 18.04 升级到 Ubuntu 20.04，其中经历了不少问题点，下面记录下处理过程。</p><p>首先就是升级当前系统所有包到最新：</p><pre><code>apt update &amp;&amp; apt upgrade -y
apt autoremove &amp;&amp; apt purge
</code></pre><p>然后安装升级需要的管理包，不过一般系统都是自带的：</p><pre><code>apt install update-manager-core
</code></pre><p>然后就可以更新系统了：</p><pre><code>do-release-upgrade
</code></pre><p>标准流程就是以上几步，但是在最后一步的时候问题就开始出现了。</p><!--more--><p>在执行升级命令后出现报警：</p><pre><code>Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings
</code></pre><p>在查询一些资料后，原来是 ssl certificates 验证问题，系统无法鉴定上面的 https 链接证书是否有效就返回错误了。</p><p>这个问题也是我这个系统的一个遗留问题，每次执行 wget 或 curl 下载东西的时候就会提示证书报错，需要通过附加指令跳过证书验证，但这就会存在安全问题了。</p><p>解决方法就是更新本地证书库后添加 <code>SSL_CERT_DIR</code> 环境变量指向系统证书目录：</p><pre><code>update-ca-certificates --verbose --fresh
export SSL_CERT_DIR=/etc/ssl/certs
</code></pre><p>为了方便以后使用，将环境变量添加到 <code>~/.bashrc</code> 文件中。这样就解决了 https 链接证书验证问题。</p><p>然后先删除之前执行升级命令后错误内容：</p><pre><code>rm /var/lib/ubuntu-release-upgrader/release-upgrade-available
/usr/lib/ubuntu-release-upgrader/release-upgrade-motd
</code></pre><p>之后再次执行升级命令 <code>do-release-upgrade</code>。</p><p>这时候报错信息变化了，这时候提示的是 python3 有问题，原因是我当前系统使用的是自己编译的 python 3.8，路径在 /opt 目录下。当时将系统软链接 <code>/usr/bin/python</code> 和 <code>/usr/bin/python3</code> 都指向了自己安装的 python，需要将他们恢复到指向系统内置的 python 程序。</p><p>下面需要介绍下系统内 python 主程序和软链接的分布：</p><pre><code>python2 主应用程序为 /usr/bin/python2.7
python3 主应用程序为 /usr/bin/python3.6
pip 主程序为 /usr/bin/pip
pip3 主程序为 /usr/bin/pip3</code></pre><p>下面是默认的软链接及指向的应用程序：</p><pre><code>/usr/bin/python  -&gt;  /usr/bin/python2.7
/usr/bin/python2  -&gt;  /usr/bin/python2.7
/usr/bin/python3  -&gt;  /usr/bin/python3.6
/usr/local/bin/pip  -&gt;  /usr/bin/pip
/usr/local/bin/pip3  -&gt;  /usr/bin/pip3</code></pre><p>如果你修改过这些软链接到自己的 python 版本，就需要修改回来：</p><pre><code>ln -sf /usr/bin/python2.7 /usr/bin/python
ln -sf /usr/bin/python2.7 /usr/bin/python2
ln -sf /usr/bin/python3.6 /usr/bin/python3
ln -sf /usr/bin/pip /usr/local/bin/pip
ln -sf /usr/bin/pip3 /usr/local/bin/pip3
ldconfig</code></pre><p>以上问题都处理完后，再次执行升级命令，一切都正常了。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/2451.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/Linux/" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[解决 wget 下载时 certificates 证书报错问题]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/2448.html" />
<id>https://blog.niekun.net/archives/2448.html</id>
<updated>2022-03-11T16:48:00+08:00</updated>
<published>2022-03-11T16:48:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<content type="html" xml:base="https://blog.niekun.net/archives/2448.html" xml:lang="zh-CN"><![CDATA[
<p>我的服务器上在使用 wget 或者 curl 等网络工具时，每次都提示类似下面的报错：</p><pre><code>ERROR: cannot verify github.com's certificate, issued by ‘CN=DigiCert High Assurance TLS Hybrid ECC SHA256 2020 CA1,O=DigiCert\\, Inc.,C=US’:
  Unable to locally verify the issuer's authority.
To connect to github.com insecurely, use `--no-check-certificate'.</code></pre><p>需要通过参数跳过证书检查，但是这样又有了安全风险。</p><p>首先尝试更新本地证书文件：</p><pre><code>update-ca-certificates --verbose --fresh</code></pre><p>发现问题没有解决，原来是系统缺少了一个指向证书路径 <code>/etc/ssl/certs</code> 的环境变量，尝试添加：</p><pre><code>export SSL_CERT_DIR=/etc/ssl/certs</code></pre><p>再次测试 wget 命令，发现问题的确没有了。</p><p>可以将上面的环境变量添加到系统 shell 配置文件中，我这里是 <code>~/.bashrc</code>，添加后刷新一下即可：</p><pre><code>source ~/.bashrc</code></pre><p><strong>在更新 Ubuntu18.04 到 20.04 时，也是这个问题导致的报错。</strong></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/2448.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/Linux/" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[openwrt 扩展根目录空间]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/2321.html" />
<id>https://blog.niekun.net/archives/2321.html</id>
<updated>2021-06-22T21:40:00+08:00</updated>
<published>2021-06-22T21:40:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<content type="html" xml:base="https://blog.niekun.net/archives/2321.html" xml:lang="zh-CN"><![CDATA[
<p>我在软路由上通过 esxi 安装了 openwrt 作为路由系统。虚拟机分配了 5 GB 作为存储空间，但是安装完成后通过命令查看发现系统识别到的空间只有很小：</p><pre><code>root@OpenWrt:~# df -h
Filesystem                Size      Used Available Use% Mounted on
/dev/root               252.0M    241.4M      5.5M  98% /rom
tmpfs                   496.5M     68.0K    496.4M   0% /tmp
/dev/sda1                15.7M      3.8M     11.6M  25% /boot
/dev/sda1                15.7M      3.8M     11.6M  25% /boot
tmpfs                   512.0K         0    512.0K   0% /dev</code></pre><p>其中 <code>/dev/root</code> 是系统固件目录，不用考虑。<code>/dev/sda*</code> 就是系统实际可用的硬盘空间。我明明分配了 5 GB 空间给 openwrt 但是由于系统分区是在下载的固件中定义好的，所以其余空间就没有被识别。由于默认存储空间过小，当安装了过多的插件后，会提示空间不足导致无法安装更多插件：</p><pre><code>verify_pkg_installable: Only have 0kb available on filesystem /overlay, pkg luci-app-openvpn needs 9
opkg_install_cmd: Cannot install package luci-app-openvpn</code></pre><p>下面介绍如何将剩余空间挂在到 openwrt 中。</p><!--more--><p>首先安装需要的插件，注意顺序不能错：</p><pre><code>opkg update
opkg install block-mount e2fsprogs
opkg update
opkg install fdisk blkid</code></pre><p>然后配置存储空间，注意 fdisk 指令后的几个选项：</p><pre><code>fdisk -l

fdisk /dev/sda
m
n
p
&lt;默认,回车&gt; //–&gt;分区号为3
&lt;默认,回车&gt;
&lt;默认,回车&gt;
w

reboot</code></pre><p>重启后，格式化刚才建立的分区：</p><pre><code>mkfs.ext4 /dev/sda3
reboot</code></pre><p>重启后配置 fstab：</p><pre><code>uci add fstab mount

# 将下面第一行命令输出的 UUID 替换第二行命令后的 UUID
blkid -s UUID /dev/sda3 | cut -d\&quot; -f2
uci set fstab.@mount[-1].uuid=UUID

uci set fstab.@mount[-1].options=rw,sync,noatime
uci set fstab.@mount[-1].fstype=ext4
uci set fstab.@mount[-1].enabled_fsck=1
uci set fstab.@mount[-1].enabled=1
uci set fstab.@mount[-1].target=/
uci set fstab.@mount[-1].device=/dev/sda3
uci commit fstab</code></pre><p>然后根目录复制到新的分区下：</p><pre><code>mkdir /mnt/sda3
mount /dev/sda3 /mnt/sda3
mkdir -p /tmp/cproot
mount --bind / /tmp/cproot
tar -C /tmp/cproot -cvf - . | tar -C /mnt/sda3 -xf -

umount /tmp/cproot
umount /mnt/sda3</code></pre><p>然后启用引导：</p><pre><code>/etc/init.d/fstab enable
/etc/init.d/fstab start

reboot</code></pre><p>重启后再次查看系统分区信息：</p><pre><code>root@OpenWrt:~# df -h
Filesystem                Size      Used Available Use% Mounted on
/dev/root               252.0M    241.4M      5.5M  98% /rom
tmpfs                   496.5M      1.0M    495.5M   0% /tmp
/dev/sda3                 4.6G    257.2M      4.1G   6% /
/dev/sda1                15.7M      3.8M     11.6M  25% /boot
/dev/sda1                15.7M      3.8M     11.6M  25% /boot
tmpfs                   512.0K         0    512.0K   0% /dev</code></pre><p>可以看到 sda3 分区已经正常挂载了，后续可以继续安装需要的各种插件了。</p><h3>参考链接</h3><p><a href="https://blog.csdn.net/duandao123/article/details/99689383">Vmware下openwrt虚拟机扩展根目录大小</a></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/2321.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/Linux/" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[理解 Linux shell 脚本的 2&gt;&amp;1]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/2320.html" />
<id>https://blog.niekun.net/archives/2320.html</id>
<updated>2021-05-31T18:33:51+08:00</updated>
<published>2021-05-31T18:33:51+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<content type="html" xml:base="https://blog.niekun.net/archives/2320.html" xml:lang="zh-CN"><![CDATA[
<p>我们在编程中经常会使用一些固定语句来解决对应固定的问题，在 shell 脚本中一个被经常使用但不太好理解的短句就是 <code>2&gt;&amp;1</code>，例如：</p><pre><code>ls foo &gt; /dev/null 2&gt;&amp;1
</code></pre><p>下面我们一步步了解下这种结构的含义。</p><!--more--><h3>I/O redirection 重定向</h3><p>简单理解，redirection 重定向就是将一个命令的 output 输出发送到另一个地方。例如，我们通过 <code>cat</code> 命令打印一个文件的内容到屏幕：</p><pre><code>$ cat foo.txt
foo
bar
baz</code></pre><p>我们也可以将输出的内容发送到其他地方，例如将内容重定向到另一个文件 file.txt:</p><pre><code>$ cat foo.txt &gt; output.txt

$ cat output.txt
foo
bar
baz</code></pre><p>执行第一条 cat 命令，我们不会看到任何输出信息，因为我们修改了 <strong>standard output (stdout)标准输出</strong>到一个文件，所以它就不会输出到屏幕了。</p><p>需要注意的是还有另一个地方：<strong>standard error (stderr)标准错误</strong>，当有错误时会输出信息。所以当我们通过 cat 命令输出一个不存在的文件内容时：</p><pre><code>$ cat nop.txt &gt; output.txt
cat: nop.txt: No such file or directory</code></pre><p>以上示例中即使我们将 <strong>stdout</strong> 重定向到一个文件了，由于 output.txt 不存在，<strong>stderr</strong> 依然会输出错误信息到屏幕。因为我们重定向的只是 <strong>stdout</strong> 而不包括 <strong>stderr</strong>。</p><h3>file descriptors 文件描述器</h3><p>一个文件描述器是一个正整数，用来表示一个打开文件的。每个文件都有其各自的文件描述器。这里我们只需要知道 <strong>stdout</strong> 和 <strong>stderr</strong> 有其各自的文件描述器 id 定义了它们各自的地址。</p><p><strong>stdout</strong> 是 <strong>1</strong>，<strong>stderr</strong> 是 <strong>2</strong>。</p><p>在之前的示例中，我们可以修改命令为如下结构：</p><pre><code>cat foo.txt 1&gt; output.txt
</code></pre><p>这里的 <strong>1</strong> 就是 <strong>stdout</strong> 的文件描述器，通过重定向语法 <code>[FILE_DESCRIPTOR]&gt;</code> 将 <strong>stdout</strong> 重定向到另一个文件。注意 <code>1&gt;</code> 可以简写为 <code>&gt;</code>。</p><p>类似的，可以将 stderr 重定向到指定的目的地：</p><pre><code>$ cat nop.txt 2&gt; error.txt

$ cat error.txt
cat: nop.txt: No such file or directory</code></pre><p>这样就会将 error 存入 error.txt 文件，屏幕上不会输出任何信息。</p><p>下面我们理解下 <code>2&gt;&amp;1</code> 的意义。我们使用 <code>&amp;1</code> 来指向 <strong>stdout</strong> 的重定向地址，所以 <code>2&gt;&amp;1</code> 表示重定向 <strong>stderr</strong> 到和 <strong>stdout</strong> 同样的重定向位置上。所以我们就可以通过下面示例的方法同时将 <strong>stdout</strong> 和 <strong>stderr</strong> 重定向到同一个文件中：</p><pre><code>$ cat foo.txt &gt; output.txt 2&gt;&amp;1

$ cat output.txt
foo
bar
baz

$ cat nop.txt &gt; output.txt 2&gt;&amp;1

$ cat output.txt
cat: nop.txt: No such file or directory</code></pre><h3>总结</h3><ul><li>有两个地方用来让程序发送输出内容：<strong>stdout</strong>，<strong>stderr</strong></li><li>可以单独定义两个输出的重定向目的地</li><li>文件描述器用来识别 <strong>stdout (1)</strong> 和 <strong>stderr (2)</strong></li><li><code>command &gt; output</code> 是 <code>command 1&gt; output</code> 的简写</li><li>通过 <code>&amp;[FILE_DESCRIPTOR]</code> 指向一个文件描述器的重定向目标地址上</li><li><code>2&gt;&amp;1</code> 可以将 <strong>stderr</strong> 重定向到 <strong>stdout</strong> 同样的重定向地址上。反之亦然。</li></ul><h3>参考链接</h3><p><a href="https://www.brianstorti.com/understanding-shell-script-idiom-redirect/">Understanding Shell Script's idiom: 2&gt;&1</a><br><a href="https://stackoverflow.com/questions/818255/in-the-shell-what-does-21-mean">In the shell, what does “ 2&gt;&1 ” mean?</a></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/2320.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/Linux/" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[通过 telegram-cli 命令行发送 telegram 消息]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/2310.html" />
<id>https://blog.niekun.net/archives/2310.html</id>
<updated>2021-05-18T20:08:00+08:00</updated>
<published>2021-05-18T20:08:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<content type="html" xml:base="https://blog.niekun.net/archives/2310.html" xml:lang="zh-CN"><![CDATA[
<p>最近需要实现一个自动发送 telegram 消息的功能，GitHub 上发现一个 telegram 第三方的命令行终端：telegram-cli。可以实现我需要的功能。</p><p>GitHub 主页：<a href="https://github.com/vysheng/tg">https://github.com/vysheng/tg</a></p><p>测试平台为 Ubuntu 18.04</p><!--more--><h3>安装</h3><p>有两种方法安装，第一种是通过 snap 应用商店来安装，第二种是从源码安装。</p><p>snap 安装需要首先安装 snap 环境：</p><pre><code>sudo apt install snapd
</code></pre><p>然后就可以安装 telegram-cli：</p><pre><code>sudo snap install telegram-cli
</code></pre><p>默认安装路径为：<code>/snap/bin/telegram-cli</code></p><p>从源码编译稍微有些麻烦，因为 GitHub 上的源码最近更新是 2016 年，经过我的测试在 make 时会报错，查询后需要增加安装相关依赖库及调整配置选项后才能正常编译。</p><p>首先安装依赖：</p><pre><code> sudo apt-get install libreadline-dev libconfig-dev libssl-dev lua5.2 liblua5.2-dev libevent-dev libjansson-dev libpython-dev zlib1g-dev libgcrypt20-dev make
</code></pre><p>下载仓库源码：</p><pre><code>git clone --recursive https://github.com/vysheng/tg.git &amp;&amp; cd tg
</code></pre><p>然后配置 configure：</p><pre><code>./configure --disable-openssl
</code></pre><p>最后编译：</p><pre><code>make
</code></pre><p>编译完成后可执行文件在项目源码的 <strong>bin</strong> 文件夹内。</p><h3>使用</h3><p>安装完成后需要配置账户信息，输入 telegram-cli 命令：</p><pre><code>telegram-cli
</code></pre><p>会提示输入手机号，验证码和密码等信息，按照提示输入完成后就会登录到 telegram-cli 中了。</p><p>这时候通过 <code>msg USERNAME message</code> 的模式来给某个对话发送消息了：</p><pre><code>&gt; msg my_bot test
</code></pre><p>USERNAME 可以是某个用户，Bot 或者 channel。可以直接使用其名称或者通过<code>@username</code>的方式定义会话对象。</p><p>经过我的测试，第一次登录到 telegram-cli 后，直接给某个对象发送消息会提示：<strong>error FAIL: 38: can not parse arg #1</strong>，但是我的用户名写的是没问题的。这时候需要首先执行一下 <code>dialog_list</code> 会输出当前登录账户的会话列表，可以看到每个会话的对象名称，这时候就可以正常通过使用对象名称或者 <code>@username</code> 来发送消息了。</p><p>以上的操作都是在登录到 telegram-cli 中进行的，可以通过 <strong>quit</strong> 或 <strong>safe_quit</strong> 命令退出 telegram-cli 程序：</p><pre><code>&gt; quit
</code></pre><p>我们也可以直接通过 telegram-cli 命令发送给某个对象消息，需要 <code>-e</code> 参数加执行的命令，例如：</p><pre><code>telegram-cli -e &quot;msg @username message&quot;
</code></pre><p>建议执行时加上 <code>-W</code>参数以加载 dialog 列表，否则可能出现报警：<strong>error FAIL: 38: can not parse arg #1</strong>：</p><pre><code>telegram-cli -W -e &quot;msg @username message&quot;
</code></pre><p>使用 <code>-D</code> 参数可以关闭输出信息。使用 <code>-U</code> 参数可以自定义命令执行的用户。</p><p>更多 telegram-cli 可用参数如下：</p><pre><code># telegram-cli -h
telegram-cli Usage
  --phone/-u                           specify username (would not be asked during authorization)
  --rsa-key/-k                         specify location of public key (possible multiple entries)
  --verbosity/-v                       increase verbosity (0-ERROR 1-WARNIN 2-NOTICE 3+-DEBUG-levels)
  --enable-msg-id/-N                   message num mode
  --config/-c                          config file name
  --profile/-p                         use specified profile
  --log-level/-l                       log level
  --sync-from-start/-f                 during authorization fetch all messages since registration
  --disable-auto-accept/-E             disable auto accept of encrypted chats
  --lua-script/-s                      lua script file
  --wait-dialog-list/-W                send dialog_list query and wait for answer before reading input
  --disable-colors/-C                  disable color output
  --disable-readline/-R                disable readline
  --alert/-A                           enable bell notifications
  --daemonize/-d                       daemon mode
  --logname/-L &lt;log-name&gt;              log file name
  --username/-U &lt;user-name&gt;            change uid after start
  --groupname/-G &lt;group-name&gt;          change gid after start
  --disable-output/-D                  disable output
  --tcp-port/-P &lt;port&gt;                 port to listen for input commands
  --udp-socket/-S &lt;socket-name&gt;        unix socket to create
  --exec/-e &lt;commands&gt;                 make commands end exit
  --disable-names/-I                   use user and chat IDs in updates instead of names
  --enable-ipv6/-6                     use ipv6 (may be unstable)
  --help/-h                            prints this help
  --accept-any-tcp                     accepts tcp connections from any src (only loopback by default)
  --disable-link-preview               disables server-side previews to links
  --bot/-b                             bot mode
  --json                               prints answers and values in json format
  --permanent-msg-ids                  use permanent msg ids
  --permanent-peer-ids                 use permanent peer ids</code></pre><h3>crontab 定时任务</h3><p>可以通过 crontab 设置定时自动发送消息。</p><p>首先编辑执行脚本，将如下示例代码保存在 <strong>test.sh</strong> 中：</p><pre><code>#!/bin/sh
LOGFILE=&quot;/home/log/submit_code.log&quot;

telegram-cli -U root -W -e &quot;msg USERNAME test&quot; &gt;&gt; ${LOGFILE}</code></pre><p>以上脚本通过 root 用户执行发送消息，会首先加载 dialog list 然后发送消息，最后退出会话。</p><p>脚本中我配置了将发送信息保存在 log 文件中，也可以不保存日志，去掉最后的 <code>&gt;&gt; ${LOGFILE}</code> 即可。</p><p>然后配置 crontab 定时任务，可以参考我的教程：<a href="https://blog.niekun.net/archives/461.html">https://blog.niekun.net/archives/461.html</a></p><p>需要注意的是通过 snap 安装的 telegram-cli 可执行程序目录默认在 <code>/snap/bin</code> 目录下。需要将路径定义到 crontab 配置文件中才可以正常识别到脚本中的 telegram-cli 命令。</p><p>编辑 <code>/etc/crontab</code> 文件：</p><pre><code>SHELL=/bin/sh
PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/snap/bin
HOME=/root

10  9  *  *  * root bash   /path/to/test.sh</code></pre><p>注意 <strong>PATH</strong> 参数最后添加的 <code>/snap/bin</code>，如果是通过其他方式安装的 telegram-cli，需要根据实际情况定义可执行程序路径。</p><p>保存文件后，会自动在 9 点 10 分自动执行 <strong>test.sh</strong> 脚本。</p><h3>参考链接</h3><p><a href="https://snapcraft.io/install/telegram-cli/ubuntu">How to install telegram-clion Ubuntu</a><br><a href="https://www.91yun.co/archives/5691">使用telegram-cli命令行发送信息</a><br><a href="https://www.orzlee.com/toss/2021/02/24/lxk0301-jingdong-signin-scriptautomatic-submission-of-mutual-aid-codes.html">LXK0301京东签到脚本-自动提交互助码</a><br><a href="https://github.com/vysheng/tg/issues/548#issuecomment-169776227">FAIL: 38: can not parse arg #1</a></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/2310.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/Linux/" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[在 Ubuntu 中加载 smb 共享目录为本地路径]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/2303.html" />
<id>https://blog.niekun.net/archives/2303.html</id>
<updated>2021-04-29T10:15:00+08:00</updated>
<published>2021-04-29T10:15:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<content type="html" xml:base="https://blog.niekun.net/archives/2303.html" xml:lang="zh-CN"><![CDATA[
<p>最近在家里搭建了局域网环境，使用了一个海康威视 H99 网络驱动器作为家里的存储中心。它可以实现 smb 和 arp 协议的共享，从而满足我的基本需求。</p><p>访问 smb 共享目录的方法是在文件浏览器中通过：<code>smb://xxx.xxx.xxx.xxx</code> 的模式输入地址，然后就会将网络驱动器挂载到本地，显示为一个本地网络路径。之后就可以正常的管理远程文件内容了。</p><p>但是我发现在使用一些下载软件的时候，无法直接将共享目录作为下载目录设置，只能选择本地的目录地址。此时就需要将 smb 网络共享路径映射为本地地址才可以实现上述需求。</p><p>下面介绍在 Ubuntu 中配置。</p><!--more--><p>在 Linux 中，可以通过 <strong>mount</strong> 命令的 <strong>cifs</strong> 选项将 smb 共享加载到本地驱动器的某个地方。<strong>Common Internet File System (CIFS)</strong> 是一个网络文件共享协议，它是 smb 的一种格式。</p><h3>安装</h3><p>首先我们安装 CIFS 工具：</p><pre><code>sudo apt install cifs-utils
</code></pre><h3>加载</h3><p>加载一个远程 smb 共享和加载本地文件系统类似，使用 mount 命令实现。需要首先创建一个加载目录服务于远程路径：</p><pre><code>sudo mkdir /mnt/h99_share
</code></pre><p>通过下面命令加载某个 smb 共享：</p><pre><code>sudo mount -t cifs -o username=win_share_user,password=win_share_password //xxx.xxx.xxx.xxx/usbshare /mnt/h99_share
</code></pre><p>其中 username 和 password 是访问远程设备的账户密码，需要在配置 smb 共享时设置好。后面需要定义远程地址及共享目录，最后指定本地映射的目录地址。</p><p>默认情况下加载的共享目录所有者为 <strong>root</strong> 且权限为 777。通过 <strong>dir_mode</strong> 和 <strong>file_mode</strong> 参数可以自定义挂载的目录权限：</p><pre><code>sudo mount -t cifs -o username=win_share_user,password=win_share_password,dir_mode=0755,file_mode=0755 //xxx.xxx.xxx.xxx/usbshare /mnt/h99_share
</code></pre><p>如果当前登录用户不是 root 用户，则可能你无法修改共享目录下的内容，可以在挂载时指定用户和用户组：</p><pre><code>sudo mount -t cifs -o username=win_share_user,password=win_share_password,uid=marco,gid=marco,dir_mode=0755,file_mode=0755 //xxx.xxx.xxx.xxx/usbshare /mnt/h99_share
</code></pre><p>以上示例中，我们设置用户和用户组为 <strong>marco</strong>，这样当本地用户登录为 <strong>marco</strong> 时就可以读写共享目录的内容了。</p><h3>自动挂载</h3><p>以上命令挂载的目录在系统重启后会取消。</p><p>在 <code>/etc/fstab</code> 文件中可以定义指定的路径及文件系统在系统启动时自动挂载。下面我们在此文件中定义自动挂载配置，需要指定远程地址，共享目录以及本地映射地址：</p><pre><code># &lt;file system&gt;             &lt;dir&gt;          &lt;type&gt; &lt;options&gt;                                                                                           &lt;dump&gt;  &lt;pass&gt;                             
//xxx.xxx.xxx.xxx/usbshare  /mnt/h99_share  cifs  username=win_share_user,password=win_share_password,uid=marco,gid=marco,dir_mode=0755,file_mode=0755  0       0</code></pre><p>配置好 fatab 文件后，我们就可以使用以下命令直接挂载对应远程目录了：</p><pre><code>sudo mount /mnt/h99_share
</code></pre><p>mount 命令会自动读取 <code>/etc/fstab</code> 文件并挂载对应远程地址目录。并且下次系统重启会自动挂载此目录。</p><h3>卸载目录</h3><p>通过 <strong>umount</strong> 命令可以下载已经加载的文件系统：</p><pre><code>sudo umount /mnt/h99_share
</code></pre><p>如果当前加载的文件正在被其他进程使用，则 umount 卸载会失败，提示文件正忙。查询当前加载目录正在被那个进程使用，可以通过 fuser 命令实现：</p><pre><code>fuser -m /mnt/h99_share
</code></pre><p>可以根据输出信息使用 kill 结束对应进程，然后就可以正常卸载了。</p><h3>参考链接</h3><p><a href="https://linuxize.com/post/how-to-mount-cifs-windows-share-on-linux/">How to Mount Windows Share on Linux using CIFS</a><br><a href="https://www.systutorials.com/force-linux-unmount-filesystem-reporting-device-busy/">Forcing Linux to Unmount a Filesystem Reporting “device is busy”</a></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/2303.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/Linux/" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[ openwrt 时区设置]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/2294.html" />
<id>https://blog.niekun.net/archives/2294.html</id>
<updated>2021-04-10T13:24:55+08:00</updated>
<published>2021-04-10T13:24:55+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<content type="html" xml:base="https://blog.niekun.net/archives/2294.html" xml:lang="zh-CN"><![CDATA[
<p>最近在使用 openwrt 时发现在 web 控制台设置好时区后，系统日志依然显示的是 UTC 时间，慢了 8 小时。查了下原来是 openwrt 默认没有安装 zoneinfo，安装后即可。</p><p>首先在 web 端或直接修改配置文件：<code>/etc/config/system</code> 中的 zone 相关参数：<br><img src="https://blog.niekun.net/usr/uploads/2021/04/2639787103.png" alt="2021-04-10T05:23:23.png" title="2021-04-10T05:23:23.png"></p><p>然后安装对应 zoneinfo：</p><pre><code>opkg update
opkg install zoneinfo-asia
</code></pre><p>重启 system 服务：</p><pre><code>/etc/init.d/system restart
</code></pre><p>然后输出日志日期就正常了。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/2294.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/Linux/" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[openwrt network 配置]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/2291.html" />
<id>https://blog.niekun.net/archives/2291.html</id>
<updated>2021-04-10T09:46:44+08:00</updated>
<published>2021-04-10T09:46:44+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<content type="html" xml:base="https://blog.niekun.net/archives/2291.html" xml:lang="zh-CN"><![CDATA[
<p>openwrt 适合作为路由器系统使用，我们的路由器上一般会有多个网卡接口可供使用，其中一个作为 wan 口来连接外网，其他的可以作为 lan 口连接本地设备。</p><p>在默认的 network 配置文件中 lan 内只绑定了一个网卡，也就是只有一个接口可以连接到 lan 网络，下面介绍如何配置多个网卡通过桥接的方式共享 lan 网络。这样可以实现无论将设备接入哪一个网卡都可以连接到同一个 lan。</p><!--more--><p>下面是一个默认的 <code>/etc/config/network</code> 文件内容：</p><pre><code>&quot;/etc/config/network&quot;

config interface 'loopback'
        option ifname 'lo'
        option proto 'static'
        option ipaddr '127.0.0.1'
        option netmask '255.0.0.0'

config globals 'globals'
        option ula_prefix 'fd6e:929e:e9ab::/48'

config interface 'lan'
        option ifname 'eth0'
        option proto 'static'
        option ipaddr '192.168.85.1'
        option netmask '255.255.255.0'
        option ip6assign '60'
        option gateway '27.168.1.1'

config interface 'wan'
        option ifname 'eth1'
        option proto 'dhcp'

config interface 'wan6'
        option ifname 'eth1'
        option proto 'dhcpv6'</code></pre><p>可以看到默认配置了 lan 和 wan 网络，各自分配了一个网卡 eth0 和 eth1，其中 eth0 属于 lan 网络且设置了 static 静态地址，作为内网的网关，<strong>注意 lan 的 downlink 下级链接会自动开启 dhcp 服务</strong>，所以通过 eth0 连接的设备可以自动获取到地址。eth1 属于 wan 网络且配置为 dhcp 自动获取 ip 地址，作为连接外网使用。</p><p>以上默认的 network 配置包含了 global 配置块和 <strong>loopback</strong>，<strong>lan</strong>，<strong>wan</strong> interface 的配置块。这也是最基本的需要配置的网络设置。</p><p>关于 network 配置文件的结构参考：<a href="https://openwrt.org/docs/guide-user/base-system/basic-networking">Network basics /etc/config/network</a></p><p>interfaces 配置块定义了对应 interface 具体连接的物理网卡名称和协议类型，通过 <strong>option</strong> 来定义这个 interface 具体参数。</p><p>一个最基本的 interface 配置项需要包含 <strong>proto 协议类型</strong>和 <strong>ifname 网卡名称</strong>，例如：</p><pre><code>config 'interface' 'wan'
        option 'proto' 'dhcp'
        option 'ifname' 'eth0.2'</code></pre><ul><li>wan 表示这个 interface 名称</li><li>dhcp 表示协议类型</li><li>eth0.2 表示绑定的物理网卡名称</li></ul><p>常用的 proto 协议类型有：</p><pre><code>static    Static configuration with fixed address and netmask    ip/ifconfig
dhcp    Address and netmask are assigned by DHCP    udhcpc (Busybox)
dhcpv6    Address and netmask are assigned by DHCPv6    odhcpc6c
ppp    PPP protocol - dialup modem connections    pppd
pppoe    PPP over Ethernet - DSL broadband connection    pppd + plugin rp-pppoe.so
pppoa    PPP over ATM - DSL connection using a builtin modem    pppd + plugin …</code></pre><p>更多协议介绍：<a href="https://openwrt.org/docs/guide-user/base-system/basic-networking#interfaces">interface</a></p><p>配置了协议后需要定义详细的 option 选项参数，下面是常用的适用于所有类型协议的 option 可选项：</p><table><thead><tr><th align="center">Name</th><th align="center">Type</th><th>Default Description</th></tr></thead><tbody><tr><td align="center">ifname</td><td align="center">物理网卡名称</td><td>如eth0 eth1 eth2，当定义 type 为 bridge 桥接时，可以是一个集合</td></tr><tr><td align="center">type</td><td align="center">字符串</td><td>如果设置为 bridge，会桥接在 ifname 中定义的物理网卡名称集合</td></tr><tr><td align="center">stp</td><td align="center">boolean</td><td>Only valid for type bridge, enables the Spanning Tree Protocol</td></tr><tr><td align="center">bridge_empty</td><td align="center">boolean</td><td>Only valid for type bridge, enables creating empty bridges</td></tr><tr><td align="center">igmp_snooping</td><td align="center">boolean</td><td>Only valid for type bridge, sets the multicast_snooping kernel setting for a bridge</td></tr><tr><td align="center">macaddr</td><td align="center">mac地址</td><td>Override MAC address of this interface. Example: 62:11:22:aa:bb:cc</td></tr><tr><td align="center">mtu</td><td align="center">number</td><td>Override the default MTU on this interface</td></tr></tbody></table><p>具体到某个 proto 协议会有各自特殊需要定义的 option 参数，下面介绍 static 模式下需要定义的参数：</p><table><thead><tr><th align="center">名称</th><th align="center">类型</th><th>描述</th></tr></thead><tbody><tr><td align="center">ipaddr</td><td align="center">ip address</td><td>IP address</td></tr><tr><td align="center">netmask</td><td align="center">netmask</td><td>子网掩码</td></tr><tr><td align="center">gateway</td><td align="center">ip address</td><td>Default gateway</td></tr><tr><td align="center">broadcast</td><td align="center">ip address</td><td>Broadcast address (autogenerated if not set)</td></tr><tr><td align="center">dns</td><td align="center">list of ip addresses</td><td>DNS server(s)</td></tr><tr><td align="center">dns_search</td><td align="center">list of domain names</td><td>Search list for host-name lookup</td></tr><tr><td align="center">metric</td><td align="center">integer</td><td>Specifies the default route metric to use</td></tr></tbody></table><p>关于 proto 协议的配置项参考：<a href="https://openwrt.org/docs/guide-user/network/ipv4/start#protocol_static_ipv4">openwrt IPv4</a></p><h3>示例</h3><p>下面通过示例来介绍一些典型配置模式。</p><p>lan 网络的 Downstream 下层流量配置：</p><pre><code>config interface 'lan'
        option ifname 'eth1'
        option proto 'static'
        option ipaddr '192.168.85.1'
        option netmask '255.255.255.0'
        option ip6assign '60'
        option gateway '27.168.1.1'</code></pre><p>lan 网络的下层链接会自动启用 dhcp 服务。</p><p>lan 网络配置多网卡桥接模式：</p><pre><code>config interface 'lan'
        option type 'bridge'
        option ifname 'eth1 eth2 eth3'
        option proto 'static'
        option ipaddr '192.168.85.1'
        option netmask '255.255.255.0'
        option ip6assign '60'
        option gateway '27.168.1.1'
        option dns '1.1.1.1'</code></pre><p>多 dns 配置：</p><pre><code>config interface 'example'
        option proto     'static'
        option ifname    'eth0'
        option ipaddr    '192.168.1.200'
        option netmask   '255.255.255.0'
        list   dns       '192.168.1.1'
        list   dns       '192.168.10.1'</code></pre><h3>参考链接</h3><p><a href="https://openwrt.org/docs/guide-user/base-system/basic-networking#interfaces">interface</a><br><a href="https://openwrt.org/docs/guide-user/network/ipv4/start#protocol_static_ipv4">IPv4</a></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/2291.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/Linux/" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[Linux 脚本中的 Shebang #!]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/2287.html" />
<id>https://blog.niekun.net/archives/2287.html</id>
<updated>2021-04-01T16:22:46+08:00</updated>
<published>2021-04-01T16:22:46+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<content type="html" xml:base="https://blog.niekun.net/archives/2287.html" xml:lang="zh-CN"><![CDATA[
<p>在 Linux 中，当我们准备运行一个可执行文件时，execve 程序会建立一个新的进程替代当前的进程(如终端下的 bash)，同时决定如何完成这个执行任务。</p><p>当我们执行一个文本文件时，execve 需要文本文件的开头两个字符为 <code>“#!</code> 读作：<strong>shebang</strong>，同时跟随一个解释器的路径用来解释后续的脚本文本内容。</p><p>下面我们举例说明。</p><!--more--><h3>shell 脚本</h3><p>最常用的就是在 shell 脚本中使用 shebang，下面是一个简单的示例：</p><pre><code>#!/bin/sh
echo &quot;Hello, ${USER}&quot;</code></pre><p>我们定义了此脚本的解释器为 <code>/bin/sh</code>，后续的脚本内容会通过此解释器来运行。</p><p>实际上 <code>/bin/sh</code> 是当前系统可执行 shell 命令的程序的软链接，大多数情况下它表示 bash，但为了不同系统的兼容性和安全性，我们直接使用此软链接来表示当前系统支持的 shell 可执行程序。</p><p>同时需要注意的是，可执行文本文件必须有执行权限，当创建一个新的脚本文件时，需要对其设置执行权限：</p><pre><code>chmod +x test.sh
</code></pre><h3>其他解释器</h3><p>当然我们可以根据需要定义其他的解释器，而不仅仅是 sh。下面的示例我们将 cat 作为解释器，这样就会输出脚本本身的内容：</p><pre><code>#!/bin/cat
Hello World!</code></pre><h3>调用 PATH</h3><p>上面的示例中，我们定义的解释器的绝对路径，但是当我们不知道一个程序的明确的路径时，我们可以通过将解释器定义为 env 程序，并传递实际需要的解释器程序名称，env 会自动在当前用户 PATH 环境变量中查询程序的路径并作为解释器执行脚本。</p><p>下面我们通过 env 来查询 node 并作为解释器执行 node 脚本：</p><pre><code>#!/usr/bin/env node
console.log('Hello world!');</code></pre><p>以上就是对 shebang 的简单解释。</p><h3>参考链接</h3><p><a href="https://www.baeldung.com/linux/shebang">Using Shebang #! in Linux Scripts</a></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/2287.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/Linux/" thr:count="0"/>
</entry>
</feed>