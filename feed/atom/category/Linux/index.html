<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"
xmlns:thr="http://purl.org/syndication/thread/1.0"
xml:lang="zh-CN"
xml:base="https://blog.niekun.net/category/Linux/"
>
<title type="text">Marco Nie - Linux</title>
<subtitle type="text"></subtitle>
<updated>2022-05-25T08:56:00+08:00</updated>
<generator uri="http://typecho.org/" version="1.2.0">Typecho</generator>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/category/Linux/" />
<id>https://blog.niekun.net/feed/atom/category/Linux/</id>
<link rel="self" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/Linux/" />
<entry>
<title type="html"><![CDATA[esxi 配置 GPU 显卡直通给虚拟机使用]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/2705.html" />
<id>https://blog.niekun.net/archives/2705.html</id>
<updated>2022-05-25T08:56:00+08:00</updated>
<published>2022-05-25T08:56:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[最近在我家里的 Ubuntu 上安装了 jellyfin 媒体中心，发现局域网内播放高码率视频卡顿严重，原因是默认设置的是软解码导致 cpu 负载很高，在设置里可以开启硬件解码，但是配置后发现播...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/2705.html" xml:lang="zh-CN"><![CDATA[
<p>最近在我家里的 Ubuntu 上安装了 jellyfin 媒体中心，发现局域网内播放高码率视频卡顿严重，原因是默认设置的是软解码导致 cpu 负载很高，在设置里可以开启硬件解码，但是配置后发现播放视频会报错：</p><blockquote>客户端配置文件存在问题，服务器未发送兼容的媒体格式</blockquote><p>看后台 log 日志，发现在 ffmpeg 解码时有如下报错信息：</p><pre><code>[AVHWDeviceContext @ 0x558b80b15a80] libva: vaGetDriverNameByIndex() failed with unknown libva error, driver_name = (null)
[AVHWDeviceContext @ 0x558b80b15a80] Failed to initialise VAAPI connection: -1 (unknown libva error).
Device creation failed: -5.
Failed to set value 'vaapi=va:/dev/dri/renderD128' for option 'init_hw_device': Input/output error
Error parsing global options: Input/output error</code></pre><!--more--><h3>查找原因</h3><p>测试在 docker-compose.yml 中开启全部权限，配置 root PUID PGID，以及映射 GPU 设备给 docker：</p><pre><code>    environment:
      - PUID=0
      - PGID=0
    devices:
      - /dev/dri:/dev/dri
    privileged: true</code></pre><p>重启容器后依然会报错。</p><p>报错信息显示无法读取 gpu 驱动名称，这应该不是 docker 的问题，在主机上测试 <code>vainfo</code> 也会报错：</p><pre><code>$ vainfo
error: can't connect to X server!
libva info: VA-API version 1.14.0
libva error: vaGetDriverNameByIndex() failed with unknown libva error, driver_name = (null)
vaInitialize failed with error code -1 (unknown libva error),exit</code></pre><p>报错内容和 jellyfin 的日志类似，测试添加环境变量强制指定驱动名称：</p><pre><code>export LIBVA_DRIVER_NAME=iHD</code></pre><p>再次 vainfo：</p><pre><code>$ vainfo
error: can't connect to X server!
libva info: VA-API version 1.14.0
libva info: User environment variable requested driver 'iHD'
libva info: Trying to open /usr/local/lib/dri/iHD_drv_video.so
libva info: Found init function __vaDriverInit_1_14
DRM_IOCTL_I915_GEM_APERTURE failed: Invalid argument
Assuming 131072kB available aperture size.
May lead to reduced performance or incorrect rendering.
get chip id failed: -1 [22]
param: 4, val: 0
libva error: /usr/local/lib/dri/iHD_drv_video.so init failed
libva info: va_openDriver() returns 18
vaInitialize failed with error code 18 (invalid parameter),exit</code></pre><p>现在看来应该是其他问题了，经过查询，esxi 默认是分配了虚拟显卡给虚拟机，导致虚拟机无法调用 gpu 底层的一些功能，从而导致 ffmpeg 等工具硬件解码失效。处理办法就是在 esxi 上配置显卡直通，然后添加给对应虚拟机直接调用硬件资源。</p><h3>显卡直通</h3><p>显卡直通应该就可以解决上面的问题，但是当我直接进入 esxi 控制台设备管理中却找不到 GPU 设备，原因是 esxi 本身也需要显卡来保证其图形界面的工作，所以在 pci 设备中就默认不可以配置它直通，我们需要通过 ssh 登录 esxi 后台，关闭 GPU 调用，然后手动添加 pci 设备信息，然后就可以在控制台配置直通了。</p><p>通过 ssh 登录 esxi，输入如下命令取消显卡占用，注意取消后就不能连接显示器访问 esxi 后台图形界面了：</p><pre><code>esxcli system settings kernel set -s vga -v FALSE</code></pre><p>后期如果需要取消显卡直通或者登录图形后台需要重新开启显卡调用：</p><pre><code>esxcli system settings kernel set -s vga -v TRUE</code></pre><p>然后修改 <strong>passthru.map</strong> 添加 PCIE 设备 ID 信息。</p><p>终端命令行执行：</p><pre><code>lspci -v
</code></pre><p>找到显卡设备ID，如图所示：<br><img src="https://blog.niekun.net/usr/uploads/2022/05/3352280738.png" alt="2022-05-25T00:39:59.png" title="2022-05-25T00:39:59.png"></p><p><strong>8086:9bc8</strong> 就是显卡设备 ID，其中 8086 是供应商 ID，也就是代表 Intel，9bc8 就是这块显卡的设备硬件 ID。</p><p>修改<strong>/etc/vmware/passthru.map</strong> 文件，在最底部增加以下信息：<br><img src="https://blog.niekun.net/usr/uploads/2022/05/244215120.png" alt="2022-05-25T00:41:31.png" title="2022-05-25T00:41:31.png"></p><p>完成后保存并退出，然后重启 esxi。</p><p>重启完成后就可以从控制台 pci 设备中找到显卡了：<br><img src="https://blog.niekun.net/usr/uploads/2022/05/1706081722.png" alt="2022-05-25T00:42:58.png" title="2022-05-25T00:42:58.png"></p><p>配置好直通后，给对应虚拟机配置显卡。</p><p>首先编辑虚拟机，CPU虚拟化这三个选项全部取消，未取消开启虚拟机会报错：由于硬件或软件支持不可用,因此无法为 0:2.0 注册设备 <strong>pciPassthru0</strong>：<br><img src="https://blog.niekun.net/usr/uploads/2022/05/3232202527.png" alt="2022-05-25T00:44:00.png" title="2022-05-25T00:44:00.png"></p><p>内存勾选<strong>预留所有客户机内存（全部锁定）</strong>选项，不勾选启动虚拟机会报错：<br><img src="https://blog.niekun.net/usr/uploads/2022/05/3432325478.png" alt="2022-05-25T00:44:56.png" title="2022-05-25T00:44:56.png"></p><p>最后添加显卡：<br><img src="https://blog.niekun.net/usr/uploads/2022/05/19783185.png" alt="2022-05-25T00:45:30.png" title="2022-05-25T00:45:30.png"><br><img src="https://blog.niekun.net/usr/uploads/2022/05/3251442515.png" alt="2022-05-25T00:45:40.png" title="2022-05-25T00:45:40.png"></p><p>然后配置虚拟机自定义参数：</p><p>进入<strong>虚拟机选项 → 高级 → 配置参数 → 编辑配置</strong>添加以下参数：</p><pre><code>  键                            值</code></pre><p>hypervisor.cpuid.v0                 FALSE</p><p>此参数的作用：不让操作系统识别是在虚拟机环境运行，一般直通独立显卡需要这样设置，核显可忽略，但设置也无妨。</p><p>如下图所示：<br><img src="https://blog.niekun.net/usr/uploads/2022/05/1105053334.png" alt="2022-05-25T00:47:09.png" title="2022-05-25T00:47:09.png"><br><img src="https://blog.niekun.net/usr/uploads/2022/05/1984221498.png" alt="2022-05-25T00:47:24.png" title="2022-05-25T00:47:24.png"><br><img src="https://blog.niekun.net/usr/uploads/2022/05/323988867.png" alt="2022-05-25T00:47:35.png" title="2022-05-25T00:47:35.png"></p><p>由于虚拟机默认有一个虚拟显卡，我们又添加了一个直通显卡，现在就有了两个显卡，但我们只想要直通的显卡工作，可以在配置参数里添加一行 <strong>svga.present to FALSE</strong>:<br><img src="https://blog.niekun.net/usr/uploads/2022/05/4078790044.png" alt="2022-05-25T00:52:18.png" title="2022-05-25T00:52:18.png"></p><p>这样操作后，我们开启虚拟机后再 <code>/dev/dri</code> 目录下就只会有一个 renderD128：</p><pre><code>&lt;&gt; ls -l /dev/dri/
total 0
crw-rw---- 1 root video 226,   0 Oct 23 20:41 card0
crw-rw---- 1 root video 226, 128 Oct 23 20:41 renderD128</code></pre><p>查看 pci 设备信息：</p><pre><code>&lt;&gt; sudo lspci -v -s  04:00.0
04:00.0 VGA compatible controller: Intel Corporation HD Graphics 530 (rev 06) (prog-if 00 [VGA controller])
    Subsystem: Hewlett-Packard Company Device 82bf
    Physical Slot: 161
    Flags: bus master, fast devsel, latency 64, IRQ 67
    Memory at fc000000 (64-bit, non-prefetchable) [size=16M]
    Memory at d0000000 (64-bit, prefetchable) [size=256M]
    I/O ports at 7000 [size=64]
    Expansion ROM at &lt;unassigned&gt; [disabled]
    Capabilities: [40] Vendor Specific Information: Len=0c &lt;?&gt;
    Capabilities: [70] Express Endpoint, MSI 00
    Capabilities: [ac] MSI: Enable+ Count=1/1 Maskable- 64bit-
    Capabilities: [d0] Power Management version 2
    Capabilities: [100] Process Address Space ID (PASID)
    Capabilities: [200] Address Translation Service (ATS)
    Capabilities: [300] Page Request Interface (PRI)
    Kernel driver in use: i915
    Kernel modules: i915</code></pre><p>这样显卡就直接直通给了虚拟机，注意这样配置后包括 esxi 本身和其他虚拟机就没有显卡可用了，导致没有图形界面。</p><h3>参考链接</h3><p><a href="https://nucfans.com/p/4622.html">ESXI 7.02 Intel 核心显卡直通开启3D加速</a><br><a href="https://elatov.github.io/2018/04/esxi-65-passthrough-video-card-to-plex-vm/#disabling-primary-video-card-on-a-vm">ESXi 6.5 Passthrough Video Card/GPU to Plex VM</a><br><a href="https://www.reddit.com/r/PleX/comments/n913ui/hw_transcoding_vaapi_intel_not_working/">HW Transcoding - VAAPI - Intel not working</a><br><a href="https://techzone.vmware.com/resource/deploying-hardware-accelerated-graphics-vmware-horizon-7">Deploying Hardware-Accelerated Graphics with VMware Horizon</a></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/2705.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/Linux/" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[Ubuntu 开启 RDP 远程连接]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/2703.html" />
<id>https://blog.niekun.net/archives/2703.html</id>
<updated>2022-05-23T10:18:00+08:00</updated>
<published>2022-05-23T10:18:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[之前介绍过通过安装 TightVNC vnc server 远程连接 Ubuntu 桌面的教程，Windows 下常用的是 RDP 方式远程，使用体验非常流畅，不占用带宽。Linux 下也可以通...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/2703.html" xml:lang="zh-CN"><![CDATA[
<p>之前介绍过通过安装 TightVNC vnc server 远程连接 Ubuntu 桌面的教程，Windows 下常用的是 RDP 方式远程，使用体验非常流畅，不占用带宽。Linux 下也可以通过安装 Xrdp 的方式实现 rdp 连接。</p><p>参考教程：<a href="https://blog.niekun.net/archives/2281.html">Ubuntu desktop 配置 vnc server</a></p><!--more--><p>xrdp 是对 Windows rdp 协议的开源实现。</p><h3>安装</h3><p>我的系统是 Ubuntu desktop 20.04，首先需要保证有一个已经安装的桌面环境，desktop 版默认是 genome，也可以安装其他的如 xfce：</p><pre><code>sudo apt install ubuntu-desktop</code></pre><p>安装 xrdp：</p><pre><code>sudo apt install xrdp</code></pre><p>安装完成后，xrdp 会自动启动，可以通过命令查看状态：</p><pre><code>$  sudo systemctl status xrdp
 
● xrdp.service - xrdp daemon
     Loaded: loaded (/lib/systemd/system/xrdp.service; enabled; vendor preset: enabled)
     Active: active (running) since Mon 2022-05-23 09:50:43 CST; 20min ago
       Docs: man:xrdp(8)
             man:xrdp.ini(5)
    Process: 83586 ExecStartPre=/bin/sh /usr/share/xrdp/socksetup (code=exited, status=0/SUCCESS)
    Process: 83594 ExecStart=/usr/sbin/xrdp $XRDP_OPTIONS (code=exited, status=0/SUCCESS)
   Main PID: 83595 (xrdp)
      Tasks: 2 (limit: 9459)
     Memory: 26.4M
     CGroup: /system.slice/xrdp.service
             ├─83595 /usr/sbin/xrdp
             └─83597 /usr/sbin/xrdp</code></pre><p>默认 rdp 端口为 3389.</p><h3>配置</h3><p>xrdp 安装后，会自动将一个 ssl key <code>ssl-cert-snakeoil.key</code> 放入 <code>/etc/ssl/private/</code> 文件夹，需要将 xrdp 用户添加到 ssl-cert 用户组确保 xrdp 可以读取这个 ssl key：</p><pre><code>sudo adduser xrdp ssl-cert</code></pre><p>默认配置测试访问会有黑屏问题，显示不出来界面，需要修改 <code>/etc/xrdp/startwm.sh</code> 文件，在文件最后的 <code>test -x /etc/X11/Xsession</code> 前面加入如下内容：</p><pre><code>unset DBUS_SESSION_BUS_ADDRESS
unset XDG_RUNTIME_DIR</code></pre><p>重启 xrdp 服务：</p><pre><code>sudo systemctl restart xrdp</code></pre><p>现在就可以正常通过 rdp 连接到 Ubuntu了。</p><p>在使用中，我出现了输入用户密码后停留在解锁界面无法登录进去的问题，经过查询 xdrp 目前不可以同时在多个设备上尝试登录。同时登录 xrdp 的用户如果和正常在主机上登录的是同一个用户，需要删除 <code>dbus-user-session</code> 包，用 <code>dbus-x11</code> 代替。第三点，需要保证 gdm3 运行，执行下面的命令：</p><pre><code>sudo apt remove dbus-user-session
sudo apt install dbus-x11

sudo systemctl set-default graphical
sudo systemctl isolate graphical</code></pre><p>重启 xrdp 服务：</p><pre><code>sudo systemctl restart xrdp</code></pre><p>此时应该就可以正常通过 rdp 客户端链接 ubuntu 界面了。</p><p>但是我测试发现，第一次登录进去没问题，关闭后过一会儿再次尝试链接发现卡在登录界面没反应了，尝试执行如下命令：</p><pre><code>echo xfce4-session &gt; $HOME/.xsession
chmod +x .xsession</code></pre><p>发现问题似乎解决了，但是调用的事 xfce 桌面环境。</p><h3>远程登录</h3><p>在局域网下访问比较流畅，但是在外网下发现没法达到 Windows rdp 流畅的效果。解决方法可以是在外网通过 rdp 链接一个局域网下 Windows 设备，然后在 Windows 设备下通过 rdp 链接局域网内的 ubuntu 设备。</p><h3>参考链接</h3><p><a href="https://www.tecmint.com/install-xrdp-on-ubuntu/">How to Install Xrdp on Ubuntu 20.04</a><br><a href="https://github.com/neutrinolabs/xrdp/issues/1795#issuecomment-859471779">Xrdp stuck on login, after password is entered, unblocked if I unlock from the ubuntu rdp server</a><br><a href="https://github.com/neutrinolabs/xrdp/wiki/Debian-dbus-user-session-package">Using the console and XRDP together in Debian / Ubuntu / Mint</a><br><a href="https://github.com/neutrinolabs/xrdp/issues/1412#issuecomment-730311330">XRDP session immediately closes after loggin in</a></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/2703.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/Linux/" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[systemd 服务加载 env 环境变量]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/2621.html" />
<id>https://blog.niekun.net/archives/2621.html</id>
<updated>2022-04-11T11:21:00+08:00</updated>
<published>2022-04-11T11:21:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[最近在测试中发现，通过 systemd service 启动的 python 脚本无法加载系统 bashrc 内定义的环境变量。需要在 uint 中定义自定义环境变量才能生效。首先建立自定义环境...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/2621.html" xml:lang="zh-CN"><![CDATA[
<p>最近在测试中发现，通过 systemd service 启动的 python 脚本无法加载系统 bashrc 内定义的环境变量。需要在 uint 中定义自定义环境变量才能生效。</p><p>首先建立自定义环境变量文件，如： <code>/etc/env_addon</code>，其中定义需要的环境变量：</p><pre><code>ENV1=abcd
ENV2=5678</code></pre><p>然后在 unit 的 service 块中加入 EnvironmentFile 指向建立的环境变量文件：</p><pre><code>[Unit]
Description=demo
After=network.target nss-lookup.target

[Service]
User=root
EnvironmentFile=/etc/env_addon
ExecStart=/usr/bin/python /path/main.py
Restart=on-failure

[Install]
WantedBy=multi-user.target</code></pre><p>重新加载并重启服务：</p><pre><code>sudo systemctl daemon-reload
sudo systemctl restart demo.service</code></pre><p>如果需要系统的 <strong>~/.bashrc</strong> 同时加载这个自定义的环境变量文件，可以在 bashrc 中加入下面内容：</p><pre><code>set -a; source /etc/env_addon; set +a</code></pre><p>重新加载环境：</p><pre><code>source ~/.bashrc</code></pre><p><strong>参考链接</strong>：<br><a href="https://stackoverflow.com/questions/49764993/using-a-users-bashrc-in-a-systemd-service">Using a user's .bashrc in a systemd service</a><br><a href="https://www.flatcar.org/docs/latest/setup/systemd/environment-variables/">Using environment variables in systemd units Environment directive</a></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/2621.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/Linux/" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[修改虚拟交换机 MTU 提高 esxi 虚拟机网络速度]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/2613.html" />
<id>https://blog.niekun.net/archives/2613.html</id>
<updated>2022-04-10T12:59:50+08:00</updated>
<published>2022-04-10T12:59:50+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[最近发现我的局域网内网下的网速很慢，只有500M左右，达不到 1000M 的速度。我是通过 ipert3 进行测速的。家里的网络是通过 esxi 下安装的 openwrt，ubuntu 等虚拟机...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/2613.html" xml:lang="zh-CN"><![CDATA[
<p>最近发现我的局域网内网下的网速很慢，只有500M左右，达不到 1000M 的速度。我是通过 ipert3 进行测速的。</p><p>家里的网络是通过 esxi 下安装的 openwrt，ubuntu 等虚拟机控制的，通过 esxi 管理页面可以看到接口都运行在 1000M 全双工模式下，说明网线链接是没有问题的：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/3148137121.jpg" alt="1.jpg" title="1.jpg"></p><p>经过查询发现可以通过修改虚拟交换机的 mtu 值到 9000 来提高网络吞吐量从而加快网速。</p><!--more--><h3>修改 mtu</h3><p>进入虚拟交换机栏：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/2344625687.jpg" alt="2.jpg" title="2.jpg"></p><p>点击每一个交换机进入设置界面，点击上面的 edit：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/663844784.jpg" alt="3.jpg" title="3.jpg"></p><p>将 mtu 设置为 9000，并保存配置：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/1003869571.jpg" alt="4.jpg" title="4.jpg"></p><p>虚拟交换机里修改完后，进入 vmkernel NICs 栏：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/520155881.jpg" alt="5.jpg" title="5.jpg"></p><p>点击 vmk0 进入设置界面，同样的点击 edit 修改其 mtu 为 9000 并保存：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/284326956.jpg" alt="6.jpg" title="6.jpg"></p><p>以上就完成了整个虚拟环境 mtu 值的修改，再次通过 iperf3 测速，速率能达到 800M。</p><h3>iperf3 使用</h3><p>下面简单介绍使用 iperf3 测试内网传输速率。</p><p>首先在接收端以下指令运行在服务模式：</p><pre><code>iperf3 -s</code></pre><p>然后再发送端执行以下指令启动测速：</p><pre><code>iperf3 -c xxx.xxx.xxx.xxx -t 30</code></pre><p>以上指令中将地址替换为接收端 IP 地址，<code>-t</code> 参数可以设置测速时间，单位为秒。</p><h3>参考链接</h3><p><a href="https://www.v2ex.com/t/696368">关于 ESXi 虚拟机间拷贝速度慢的问题</a><br><a href="https://www.slashroot.in/iperf-how-test-network-speedperformancebandwidth">IPERF: How to test network Speed,Performance,Bandwidth</a></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/2613.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/Linux/" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[esxi 配置自定义 ssl 证书]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/2611.html" />
<id>https://blog.niekun.net/archives/2611.html</id>
<updated>2022-04-10T12:39:50+08:00</updated>
<published>2022-04-10T12:39:50+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[我家里的主机使用 esxi 管理多个 vm 虚拟机，之前的文章介绍过 esxi 的安装及使用：ESXi 的安装与使用，需要安装的可以参考。通过浏览器访问  vcenter 管理界面默认会强制 h...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/2611.html" xml:lang="zh-CN"><![CDATA[
<p>我家里的主机使用 esxi 管理多个 vm 虚拟机，之前的文章介绍过 esxi 的安装及使用：<a href="https://blog.niekun.net/archives/2213.html">ESXi 的安装与使用</a>，需要安装的可以参考。</p><p>通过浏览器访问  vcenter 管理界面默认会强制 https 模式，但是访问端并没有安装 vcenter 管理网页的证书，所以会提示不安全的链接，下面介绍如何在 esxi 上安装自定义域名的 ssl 证书，并在客户机上安装。</p><!--more--><h3>开启 ssh</h3><p>esxi 上的操作是通过 ssh 的方式，所以首先需要打开 esxi 的 ssh 访问权限。</p><p>访问 esxi 管理界面，在 host 菜单栏，选择 action - sevices - enable ssh：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/1033022978.jpg" alt="1.jpg" title="1.jpg"></p><p><strong>打开 ssh 只对本次开机有效，重启 esxi 后会再次默认关闭。</strong></p><p>然后就可以通过 ssh 访问 esxi。</p><h3>创建证书</h3><p>首先备份当前证书文件，防止修改错误无法恢复，进入 <code>/etc/vmware/ssl</code> 目录，新建 bak 文件夹，将目录内的 rui.crt, rui.csr, rui.key 文件移动到 bak 文件夹内：</p><pre><code>cd /etc/vmware/ssl
mkdir bak
mv rui.* bak/</code></pre><p>然后在 <code>/etc/vmware/ssl</code> 下新建文件 <code>webclient.cnf</code> 编辑文件内容如下：</p><pre><code>[ req ]

default_bits = 2048

default_keyfile = rui.key

distinguished_name = req_distinguished_name

encrypt_key = no

prompt = no

string_mask = nombstr

req_extensions = v3_req

[ v3_req ]

basicConstraints = CA:FALSE

keyUsage = digitalSignature, keyEncipherment, dataEncipherment

extendedKeyUsage = serverAuth, clientAuth

subjectAltName = DNS:&lt;esxi.domain.name&gt;, DNS:&lt;esxi&gt;, IP:&lt;xxx.xxx.xxx.xxx&gt; 

[ req_distinguished_name ]

countryName = US

stateOrProvinceName = VA

localityName = SomeCity

0.organizationName = WOW

organizationalUnitName = Software

commonName = &lt;esxi.domain.name&gt;

[ alt_names ]

DNS.1 = &lt;esxi.domain.name&gt;

DNS.2 = &lt;esxi&gt;

IP.1 = &lt;xxx.xxx.xxx.xxx&gt;</code></pre><p>注意，将以上内容中尖括号<code>&lt;&gt;</code>中的内容替换为你实际的域名和IP地址，<strong>不需要保留尖括号</strong>。</p><p>文件修改并保存后，执行下面命令创建证书文件：</p><pre><code># 创建加密 key，它用来保证证书生效及运行
openssl genrsa -out /etc/vmware/ssl/rui.key 2048

# 创建一个证书注册请求文件，会用到上面创建的配置文件信息并保存到 key 中
openssl req -new -nodes -out /etc/vmware/ssl/rui.csr -keyout /etc/vmware/ssl/rui.key -config /etc/vmware/ssl/webclient.cnf

# 生成证书，使用了 x509 标准格式。其中定义了证书 730 天的有效期，也就是2年，可以根据需要自行更改时间
openssl x509 -req -days 730 -in /etc/vmware/ssl/rui.csr -signkey /etc/vmware/ssl/rui.key -out /etc/vmware/ssl/rui.crt -extensions v3_req -extfile /etc/vmware/ssl/webclient.cnf</code></pre><p>以上命令执行完成后，就在目录下生成了 <strong>rui.key, rui.csr, rui.crt</strong> 三个文件。我们只需要将 <strong>rui.crt</strong> 证书文件复制到客户机上安装，可以通过任何方式复制出来，例如 sftp，winscp 等。</p><p><strong>esxi 上需要重启系统后新的证书才能生效。</strong>注意重启后 ssh 功能可能需要重新打开。</p><h3>客户端安装证书</h3><p>在 macOS 上安装证书，双击复制出来的 rui.crt 安装即可。安装后需要设置为信任，进入 keychain access 中，在 system 栏点击 certificates 菜单项就能找到刚刚安装的证书，双击证书进入属性，点击 trust 菜单，将 when using this certificate 设置为 always trust 即可，关闭时会提示输入密码。</p><p>此时我们就可以以 https 访问 esxi web 管理页面并且不会报证书错误了。</p><h3>参考链接</h3><p><a href="https://www.vmwareblog.org/replace-default-esxi-ssl-certificate-self-signed-certificate-101-introduction/">How to Replace Your Default ESXi SSL Certificate With a Self-Signed Certificate</a></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/2611.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/Linux/" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[openwrt 修改进程 Socket 句柄数]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/2572.html" />
<id>https://blog.niekun.net/archives/2572.html</id>
<updated>2022-04-03T08:50:00+08:00</updated>
<published>2022-04-03T08:50:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[最近在使用中发现一个软件 log 中出现大量的报错：/core/transport/internet/tcp: failed to accepted raw connections &amp;gt; a...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/2572.html" xml:lang="zh-CN"><![CDATA[
<p>最近在使用中发现一个软件 log 中出现大量的报错：</p><pre><code>/core/transport/internet/tcp: failed to accepted raw connections &gt; accept tcp [::]:18919: accept4: too many open files</code></pre><p>查询后知道这是进程占用的句柄数超出了系统最大值导致的。由于我的系统是 openwrt 所以下面介绍如何修改某个进程的最大句柄数限制。</p><!--more--><p>首先查询当前系统当前的句柄限制值：</p><pre><code>ulimit -n

1024</code></pre><p>也可以查询当前系统的其他所有限制参数：</p><pre><code>ulimit -a</code></pre><p>返回 1024 表示当前系统每个进程的限制值是 1024。</p><p>然后我们查询下当前系统进程中占用情况：</p><pre><code>lsof -n |awk '{print $2}'|sort|uniq -c |sort -nr|more

     8790 2390
     41 2638
     27 1914
     26 1
     25 2127
     23 2166
     23 1976
     23 1704</code></pre><p>可以看到进程PID号 2390 就占用了 8790 个句柄，这肯定超出了系统限制，我们看看这个 2390 到底是那个程序：</p><pre><code>ps | grep 2390

 2390 root     5005m S    /usr/bin/v2ray -confdir /etc/v2ray/conf.d
 6815 root      1072 R    grep 2390</code></pre><p>发现的确是我报错的那个程序占用了这个进程。</p><p>然后我们查询系统可以设置的最大句柄数：</p><pre><code>cat /proc/sys/fs/file-max

101238</code></pre><p>返回值说明当前系统可以设置最大句柄数为 101238.</p><p>想要修改句柄数需要在对应进程的 procd init script 脚本修改内容，在 start_service 中增加：</p><pre><code>        procd_set_param limits core=&quot;unlimited&quot;
        procd_set_param limits nofile=&quot;101200&quot;
        procd_set_param limits nproc=&quot;101200&quot;</code></pre><p>limits 参数可以设置系统的一些限制值，openwrt 可用的限制值名称可以在官方文档找到：<a href="https://openwrt.org/docs/guide-developer/procd-init-scripts#service_parameters">https://openwrt.org/docs/guide-developer/procd-init-scripts#service_parameters</a></p><p>以上就将系统限制设置为一个较大的值，修改完成后重启这个进程即可。</p><h3>参考链接</h3><p><a href="https://www.cccitu.com/3827.html">Linux命令：TCP连接高并发时Socket句柄数的修改</a><br><a href="https://openwrt.org/docs/guide-developer/procd-init-scripts#service_parameters">procd-init-scripts#service_parameters</a><br><a href="https://openwrt.org/docs/guide-developer/procd-init-script-example#advanced_options">procd-init-script-example#advanced_options</a><br><a href="https://blog.niekun.net/archives/2277.html">openwrt procd init script 自启动脚本服务</a></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/2572.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/Linux/" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[iptables 配置透明代理注意事项]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/2570.html" />
<id>https://blog.niekun.net/archives/2570.html</id>
<updated>2022-04-03T08:33:00+08:00</updated>
<published>2022-04-03T08:33:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[之前介绍过通过 dnsmasq 配合 iptables 实现对 ip 地址的流量过滤，dnsmasq 获取到流量后标记 ipset 然后通过 iptables 识别 ipset 然后将流量送往指...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/2570.html" xml:lang="zh-CN"><![CDATA[
<p>之前介绍过通过 dnsmasq 配合 iptables 实现对 ip 地址的流量过滤，dnsmasq 获取到流量后标记 ipset 然后通过 iptables 识别 ipset 然后将流量送往指定地址。</p><p><a href="https://blog.niekun.net/archives/1872.html">通过 dnsmasq ipset 和 iptables 对域名流量的控制</a><br><a href="https://blog.niekun.net/archives/1863.html">iptables 使用教程</a></p><p>这里面存在一个问题就是流量回环问题，如果处理不好回导致 iptables 规则无限循环，尤其是在配置透明代理时候。</p><pre><code>iptables -t mangle -A PREROUTING -p tcp -m set --match-set gfwlist dst -j TPROXY --on-port 1081 --tproxy-mark 1
iptables -t mangle -A PREROUTING -p udp -m set --match-set gfwlist dst -j TPROXY --on-port 1081 --tproxy-mark 1
iptables -t mangle -A OUTPUT -p tcp -m set --match-set gfwlist dst -j MARK --set-mark 1
iptables -t mangle -A OUTPUT -p udp -m set --match-set gfwlist dst -j MARK --set-mark 1</code></pre><p>以上规则会将 指定 list 的流量发送到指定端口并打上 mark 标记，但是从目标地址返回数据后，数据流会再次匹配到以上规则导致再次将流量送往指定端口，导致无限循环。</p><p>处理方法就是在目标地址获取到流量后，给流量打上 mark 标记，然后在 iptables 的最前面加上一条规则识别从目标地址返回的流量，直接 return 流量即可。</p><p>例如目标地址处理后的流量标记为 mark 2，iptables 规则最前面增加一条规则：</p><pre><code>iptables -t mangle -I OUTPUT -j RETURN -m mark --mark 0x02</code></pre><p><code>-I</code> 参数就是将规则放在在路由链的最前面。</p><p>如果是通过脚本的方式配置 iptables，将开始的脚本内容修改如下即可：</p><pre><code>iptables -t mangle -A OUTPUT -j RETURN -m mark --mark 0x02

iptables -t mangle -A PREROUTING -p tcp -m set --match-set gfwlist dst -j TPROXY --on-port 1081 --tproxy-mark 1
iptables -t mangle -A PREROUTING -p udp -m set --match-set gfwlist dst -j TPROXY --on-port 1081 --tproxy-mark 1
iptables -t mangle -A OUTPUT -p tcp -m set --match-set gfwlist dst -j MARK --set-mark 1
iptables -t mangle -A OUTPUT -p udp -m set --match-set gfwlist dst -j MARK --set-mark 1</code></pre><p>这样就可以避免流量回环问题。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/2570.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/Linux/" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[安装 phpMyAdmin 管理 MySQL]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/2457.html" />
<id>https://blog.niekun.net/archives/2457.html</id>
<updated>2022-03-28T09:31:00+08:00</updated>
<published>2022-03-28T09:31:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[phpMyAdmin 是一个 php 的免费工具，用来在 web 端管理 MySQL 数据库。它支持大部分的 MySQL 功能，比如：创建数据库，修改数据，管理用户权限，导入导出数据等。官方网站...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/2457.html" xml:lang="zh-CN"><![CDATA[
<p>phpMyAdmin 是一个 php 的免费工具，用来在 web 端管理 MySQL 数据库。它支持大部分的 MySQL 功能，比如：创建数据库，修改数据，管理用户权限，导入导出数据等。</p><p>官方网站：<a href="https://www.phpmyadmin.net/">https://www.phpmyadmin.net/</a><br>GitHub 主页：<a href="https://github.com/phpmyadmin/phpmyadmin">https://github.com/phpmyadmin/phpmyadmin</a></p><p>下面介绍在 Ubuntu 20.04 的安装及使用过程。</p><!--more--><h3>安装</h3><p>首先确保已经安装好了 MySQL 和 php：</p><pre><code>apt install mysql-server php php-fpm php-mysql
</code></pre><p>然后安装 phpMyAdmin：</p><pre><code>apt install phpmyadmin
</code></pre><p>安装过程中会提示创建一个 mysql 管理账户 phpmyadmin，一般直接确认即可，然后设置账户密码。如果这一步跳过了创建账户，后期需要手动修改配置文件或手动创建一个 phpmyadmin 管理账户，否则登录可能会报错。</p><h3>配置 nginx</h3><p>安装完成后需要配置代理服务器，我使用的是 nginx，下面是 nginx 的配置文件部分：</p><pre><code>    location /phpmyadmin {
        root /usr/share/;
        index index.php index.html index.htm;
        location ~ ^/phpmyadmin/(.+\.php)$ {
            fastcgi_pass unix:/run/php/php7.4-fpm.sock;
            include fastcgi-php.conf;
        }
    }</code></pre><h3>使用</h3><p>配置完成后就可以登陆 phpmyadmin 页面了，登录对应的 mysql 管理账户，可以是安装 phpmyadmin 时创建的账户也可以是我们之前使用 mysql 自己的账户：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/109981368.png" alt="2022-03-28T01:25:37.png" title="2022-03-28T01:25:37.png"></p><p>如果登录后发现下面有报错信息：</p><pre><code>Access denied for user 'phpmyadmin'@'localhost' (using password: NO)
</code></pre><p>可能就是安装的时候跳过了创建 phpmyadmin MySQL 账户的步骤，这里我们可以在终端手动创建报错信息中提示的用户名或者直接修改配置文件中定义的 phpmyadmin 管理账户。</p><p>修改 <code>/etc/phpmyadmin/config.inc.php</code>，找到如下字段：</p><pre><code>$cfg['Servers'][$i]['controluser'] = 'user';
$cfg['Servers'][$i]['controlpass'] = 'password';</code></pre><p>将上面的用户名密码修改为 MySQL 中存在的账户即可。刷新页面之后应该就没有报错了。</p><p>手动创建 MySQL 用户可以参考教程：<a href="https://blog.niekun.net/archives/23.html#title-3">https://blog.niekun.net/archives/23.html#title-3</a></p><p>然后我们就可以正常使用 phpmyadmin 管理页面了，这里可以查看 database，导入导出数据等。</p><h3>参考链接</h3><p><a href="https://stackoverflow.com/questions/46736319/phpmyadmin-error-mysqli-real-connect-hy000-1045-access-denied-for-user-p">phpMyAdmin ERROR: mysqli_real_connect(): (HY000/1045): Access denied for user 'pma'@'localhost' (using password: NO)</a></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/2457.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/Linux/" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[使用 rclone 管理网盘文件]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/2454.html" />
<id>https://blog.niekun.net/archives/2454.html</id>
<updated>2022-03-14T11:35:31+08:00</updated>
<published>2022-03-14T11:35:31+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[之前介绍了通过 gdrive 在服务器上管理 Google drive 文件，实现服务器数据备份自动上传功能。最近发现有一个新的开源项目 rclone 支持更多的网盘，同时更新迭代速度也更快。G...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/2454.html" xml:lang="zh-CN"><![CDATA[
<p>之前介绍了通过 gdrive 在服务器上管理 Google drive 文件，实现服务器数据备份自动上传功能。最近发现有一个新的开源项目 rclone 支持更多的网盘，同时更新迭代速度也更快。</p><p>GitHub 主页：<a href="https://github.com/rclone/rclone">https://github.com/rclone/rclone</a></p><p>他支持的网盘列表：<a href="https://rclone.org/overview/">https://rclone.org/overview/</a></p><p>下面介绍它的安装使用方法。</p><!--more--><h3>安装</h3><p>Linux 下一键安装命令：</p><pre><code>curl https://rclone.org/install.sh | sudo bash
</code></pre><p>macos 通过 brew 安装：</p><pre><code>brew install rclone
</code></pre><h3>配置</h3><p>首次运行执行初始化配置：</p><pre><code>rclone config
</code></pre><p>根据提示创建新 remote：</p><pre><code>No remotes found - make a new one
n) New remote
r) Rename remote
c) Copy remote
s) Set configuration password
q) Quit config
n/r/c/s/q&gt; n</code></pre><p>然后设置此连接名称，后续就是通过这个名称来操作不同的网盘的：</p><pre><code>name&gt; remote
</code></pre><p>下一步选择网盘类型，如果是 Google drive 选择 16：</p><pre><code>Type of storage to configure.
Choose a number from below, or type in your own value
[snip]
16 / Google Drive
   \ &quot;drive&quot;
[snip]
Storage&gt; 16</code></pre><p>下面的 id 和 secret 都默认回车即可：</p><pre><code>Google Application Client Id - leave blank normally.
client_id&gt;
Google Application Client Secret - leave blank normally.
client_secret&gt;</code></pre><p>下面设置可访问全部网盘文件，选择 1：</p><pre><code>Scope that rclone should use when requesting access from drive.
Choose a number from below, or type in your own value
 1 / Full access all files, excluding Application Data Folder.
   \ &quot;drive&quot;
 2 / Read-only access to file metadata and file contents.
   \ &quot;drive.readonly&quot;
   / Access to files created by rclone only.
 3 | These are visible in the drive website.
   | File authorization is revoked when the user deauthorizes the app.
   \ &quot;drive.file&quot;
   / Allows read and write access to the Application Data folder.
 4 | This is not visible in the drive website.
   \ &quot;drive.appfolder&quot;
   / Allows read-only access to file metadata but
 5 | does not allow any access to read or download file content.
   \ &quot;drive.metadata.readonly&quot;
scope&gt; 1</code></pre><p>下面几步都默认回车即可。</p><p>注意到了 use auto config 的时候要选择 No，因为我们是远程 ssh 访问的服务器：</p><pre><code>Use auto config?
 * Say Y if not sure
 * Say N if you are working on a remote or headless machine or Y didn't work
y) Yes
n) No
y/n&gt; n</code></pre><p>下面会返回一个链接，复制链接到浏览器后，登录 google 账户给 rclone 授权。授权完成后会返回一个字符串码，粘贴回终端。</p><p>后续几步默认回车即可，最后输入 q 退出 config。</p><h3>使用</h3><p>配置完成后我们就可以使用了，下面介绍一些基本语法。下面示例中网盘配置名称为 remote。</p><p>列出网盘的所有文件：</p><pre><code>rclone ls remote:
</code></pre><p>列出一个文件夹内的所有文件：</p><pre><code>rclone ls remote:abc
</code></pre><p>创建一个文件夹：</p><pre><code>rclone mkdir remote:abc
rclone mkdir remote:abc/def
</code></pre><p>删除网盘内一个文件：</p><pre><code>rclone delete remote:abc/123.txt
</code></pre><p>删除一个文件夹：</p><pre><code>rclone rmdir remote:abc
</code></pre><p>复制本地一个文件到网盘：</p><pre><code>rclone copy 123.txt remote:abc
</code></pre><p>更多可用命令可以参考官方文档：<a href="https://rclone.org/docs/#subcommands">https://rclone.org/docs/#subcommands</a></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/2454.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/Linux/" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[Ubuntu 18.04 升级 Ubuntu 20.04 记录]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/2451.html" />
<id>https://blog.niekun.net/archives/2451.html</id>
<updated>2022-03-12T15:32:00+08:00</updated>
<published>2022-03-12T15:32:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[昨天决定把服务器的系统从 Ubuntu 18.04 升级到 Ubuntu 20.04，其中经历了不少问题点，下面记录下处理过程。首先就是升级当前系统所有包到最新：apt update &amp;amp;...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/2451.html" xml:lang="zh-CN"><![CDATA[
<p>昨天决定把服务器的系统从 Ubuntu 18.04 升级到 Ubuntu 20.04，其中经历了不少问题点，下面记录下处理过程。</p><p>首先就是升级当前系统所有包到最新：</p><pre><code>apt update &amp;&amp; apt upgrade -y
apt autoremove &amp;&amp; apt purge
</code></pre><p>然后安装升级需要的管理包，不过一般系统都是自带的：</p><pre><code>apt install update-manager-core
</code></pre><p>然后就可以更新系统了：</p><pre><code>do-release-upgrade
</code></pre><p>标准流程就是以上几步，但是在最后一步的时候问题就开始出现了。</p><!--more--><p>在执行升级命令后出现报警：</p><pre><code>Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings
</code></pre><p>在查询一些资料后，原来是 ssl certificates 验证问题，系统无法鉴定上面的 https 链接证书是否有效就返回错误了。</p><p>这个问题也是我这个系统的一个遗留问题，每次执行 wget 或 curl 下载东西的时候就会提示证书报错，需要通过附加指令跳过证书验证，但这就会存在安全问题了。</p><p>解决方法就是更新本地证书库后添加 <code>SSL_CERT_DIR</code> 环境变量指向系统证书目录：</p><pre><code>update-ca-certificates --verbose --fresh
export SSL_CERT_DIR=/etc/ssl/certs
</code></pre><p>为了方便以后使用，将环境变量添加到 <code>~/.bashrc</code> 文件中。这样就解决了 https 链接证书验证问题。</p><p>然后先删除之前执行升级命令后错误内容：</p><pre><code>rm /var/lib/ubuntu-release-upgrader/release-upgrade-available
/usr/lib/ubuntu-release-upgrader/release-upgrade-motd
</code></pre><p>之后再次执行升级命令 <code>do-release-upgrade</code>。</p><p>这时候报错信息变化了，这时候提示的是 python3 有问题，原因是我当前系统使用的是自己编译的 python 3.8，路径在 /opt 目录下。当时将系统软链接 <code>/usr/bin/python</code> 和 <code>/usr/bin/python3</code> 都指向了自己安装的 python，需要将他们恢复到指向系统内置的 python 程序。</p><p>下面需要介绍下系统内 python 主程序和软链接的分布：</p><pre><code>python2 主应用程序为 /usr/bin/python2.7
python3 主应用程序为 /usr/bin/python3.6
pip 主程序为 /usr/bin/pip
pip3 主程序为 /usr/bin/pip3</code></pre><p>下面是默认的软链接及指向的应用程序：</p><pre><code>/usr/bin/python  -&gt;  /usr/bin/python2.7
/usr/bin/python2  -&gt;  /usr/bin/python2.7
/usr/bin/python3  -&gt;  /usr/bin/python3.6
/usr/local/bin/pip  -&gt;  /usr/bin/pip
/usr/local/bin/pip3  -&gt;  /usr/bin/pip3</code></pre><p>如果你修改过这些软链接到自己的 python 版本，就需要修改回来：</p><pre><code>ln -sf /usr/bin/python2.7 /usr/bin/python
ln -sf /usr/bin/python2.7 /usr/bin/python2
ln -sf /usr/bin/python3.6 /usr/bin/python3
ln -sf /usr/bin/pip /usr/local/bin/pip
ln -sf /usr/bin/pip3 /usr/local/bin/pip3
ldconfig</code></pre><p>以上问题都处理完后，再次执行升级命令，一切都正常了。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/2451.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/category/Linux/" thr:count="0"/>
</entry>
</feed>