<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"
xmlns:thr="http://purl.org/syndication/thread/1.0"
xml:lang="zh-CN"
xml:base="https://blog.niekun.net/"
>
<title type="text">Marco Nie</title>
<subtitle type="text">you are the company you keep...</subtitle>
<updated>2020-12-08T21:37:00+08:00</updated>
<generator uri="http://typecho.org/" version="1.2/18.10.23">Typecho</generator>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/" />
<id>https://blog.niekun.net/feed/atom/</id>
<link rel="self" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/" />
<entry>
<title type="html"><![CDATA[c++ 字符串数组指针的研究]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1968.html" />
<id>https://blog.niekun.net/archives/1968.html</id>
<updated>2020-12-08T21:37:00+08:00</updated>
<published>2020-12-08T21:37:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[在实际使用中发现对字符串的运用是一个容易混乱的地方，尤其是使用指针指向一个字符串数组的时候。下面做一些简单分析。一个简单的测试：    const char* test1 = &amp;quot;abc...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/1968.html" xml:lang="zh-CN"><![CDATA[
<p>在实际使用中发现对字符串的运用是一个容易混乱的地方，尤其是使用指针指向一个字符串数组的时候。下面做一些简单分析。</p><p>一个简单的测试：</p><pre><code>    const char* test1 = &quot;abc&quot;;
    const string test2 = &quot;abc&quot;;

    cout &lt;&lt; test1 &lt;&lt; endl;
    cout &lt;&lt; *test1 &lt;&lt; endl;
    cout &lt;&lt; test2 &lt;&lt; endl;
    cout &lt;&lt; sizeof (test1) &lt;&lt; endl;
    cout &lt;&lt; sizeof (test2) &lt;&lt; endl;</code></pre><p>输出如下：</p><pre><code>abc
a
abc
8
24</code></pre><!--more--><p>以前我的教程里提到过，字符串就相当于一个字符数组。指针会指向它的首个字符地址。<code>test1</code> 指针理论上存储着字符串的首地址。</p><p>但我们可以看到直接输出 <code>test1</code> 会得到实际字符串内容，而不是首个字符地址。输出 <code>*test</code> 会得到正常的首字符内容。</p><p>字符串指针使用 sizeof 得到这个指针所占用内存大小，而不是字符串内容的大小。</p><p>下面测试 int 型数组：</p><pre><code>    const int test3[] = {1, 3 ,5};
    const int* test4 = test3;

    cout &lt;&lt; test3 &lt;&lt; endl;
    cout &lt;&lt; test4 &lt;&lt; endl;
    cout &lt;&lt; test4[0] &lt;&lt; endl;
    cout &lt;&lt; *test4 &lt;&lt; endl;
    cout &lt;&lt; sizeof(test4) &lt;&lt; endl;
    cout &lt;&lt; sizeof(test4[0]) &lt;&lt; endl;</code></pre><p>输出结果：</p><pre><code>0x7ffee8cbaa58
0x7ffee8cbaa58
1
1
8
4</code></pre><p>可以看到直接输出数组名称或指针名称得到的是数组所在地址。<code>*test</code> 和 <code>test[0]</code> 会得到数组第一位内容。</p><p>test4 是一个指针，所以 sizeof 得到的是这个指针做占用的内存空间而不是数组本身占用空间。无法通过 sizeof 计算出数组个数。</p><p>下面做最后一个测试：</p><pre><code>const char* test5[] = {
    &quot;abc&quot;,
    &quot;def&quot;,
    &quot;ohg&quot;,
    &quot;asdf&quot;
};

const string test6[] = {
    &quot;abc&quot;,
    &quot;def&quot;,
    &quot;ohg&quot;,
    &quot;asdf&quot;
};

int x = sizeof (test5)/sizeof(test5[0]);
cout &lt;&lt; sizeof(test5) &lt;&lt; endl;
cout &lt;&lt; sizeof(test5[0]) &lt;&lt; endl;
cout &lt;&lt; test5 &lt;&lt; endl;
cout &lt;&lt; *test5 &lt;&lt; endl;
cout &lt;&lt; test5[0] &lt;&lt; endl;
cout &lt;&lt; *test5[0] &lt;&lt; endl;
cout &lt;&lt; x &lt;&lt; endl;

cout &lt;&lt; &quot;*************\n&quot;;

x = sizeof (test6)/sizeof(test6[0]);
cout &lt;&lt; sizeof(test6) &lt;&lt; endl;
cout &lt;&lt; sizeof(test6[0]) &lt;&lt; endl;
cout &lt;&lt; test6 &lt;&lt; endl;
cout &lt;&lt; *test6 &lt;&lt; endl;
cout &lt;&lt; test6[0] &lt;&lt; endl;
cout &lt;&lt; x &lt;&lt; endl;</code></pre><p>输出结果如下：</p><pre><code>0x7ffee596ea40
abc
abc
a
4
32
8
*************
0x7ffee596e9e0
abc
abc
4
96
24</code></pre><p><strong>由于字符串本身就是一个字符数组，所以一个字符串数组相当于一个二维的数组。定义字符串数组的指针，就是数组中每个字符串对应的指针的集合。</strong>所以这个数组指针本身不是字符串类型的，而它的每个指针元素都是字符串指针类型的。</p><p>可以看到类似于第一组测试，非字符串的指针直接输出指针名称，所以 <code>test5</code> 得到字符串数组的地址。</p><p><code>*test5</code> 和 <code>test5[0]</code> 都表示指针数组第一个元素，也就是字符串类型的指针，根据第一组实验可以知道使用字符串指针名称输出本身字符串而不是地址，所以输出此指针可以直接得到字符串内容。</p><p><code>*test5[0]</code> 就是字符串指针的首字符地址内容，也就是得到第一个字符串第一个字符的内容。</p><p>test5 指针数组使用 sizeof 得到的是这个指针数组总共占用的内存大小，也就是每个指针大小的总和。除以单个指针大小就可以得到这个数组指针的个数，也就是对应指向的数组的元素个数。</p><p>test6 字符串数组使用 sizeof 得到的是这个字符串数组所有元素的占用内存大小，除以单个字符串大小就可以得到这个数组的元素个数。</p><p>我们可以看到 test5 和 test6 使用 sizeof 都可以得到数组的元素个数，但他们的原理是完全不同的，一个是使用指针的内存大小，一个是使用数组本身的内存大小。</p><p><strong>总结：</strong><br>字符串的指针名称可以直接输出字符串内容而不是地址。其他指针类型指向的数据，如字符，数字，字符串数组，number 型数组等，指针名输出的都是数据地址。</p><p>指针使用 sizeof 得到的是指针所占用的内存大小。可以使用 <code>sizeof(*Pointer)</code> 得到数据本身大小。</p><p>字符串数组的指针使用 sizeof 得到指针数组的总大小，可以用来间接计算数组元素个数。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1968.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/1968.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[macOS 下使用 QT 部署工具 macdeployqt]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1966.html" />
<id>https://blog.niekun.net/archives/1966.html</id>
<updated>2020-12-05T23:53:15+08:00</updated>
<published>2020-12-05T23:53:15+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[在 Windows 下可以使用 QT 部署工具：windeployqt 来自动提取可执行程序的依赖库，在 macOS 下同样有部署工具：macdeployqt 实现相同的功能。工具路径在 QT ...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/1966.html" xml:lang="zh-CN"><![CDATA[
<p>在 Windows 下可以使用 QT 部署工具：windeployqt 来自动提取可执行程序的依赖库，在 macOS 下同样有部署工具：macdeployqt 实现相同的功能。</p><p>工具路径在 QT 安装目录的对应编译器 bin 目录下，如：<code>/Users/marconie/Qt/5.15.2/clang_64/bin/macdeployqt</code></p><p>为了方便使用建议将 bin 目录添加到系统 PATH 中，我的终端是 zsh 添加方法如下：</p><p>打开 <code>~/.zshrc</code> 添加如下内容，可以使用 vim 来操作：</p><pre><code>export PATH=$PATH:/Users/marconie/Qt/5.15.2/clang_64/bin</code></pre><p>编辑完成后关闭文件，刷新源：</p><pre><code>source ~/.zshrc
</code></pre><p>现在就可以直接使用命令了：</p><pre><code>macdeployqt -h

</code></pre><!--more--><p>部署的方法是直接在 macdeployqt 后提供 app 路径：</p><pre><code>macdeployqt path/to/test.app
</code></pre><p>执行后会自动搜索此 app 需要的 QT 库并打包到 app 内，可以打开 app 包查看相关内容：<br><img src="https://blog.niekun.net/usr/uploads/2020/12/3770174957.jpg" alt="Screen Shot 2020-12-05 at 23.49.48.jpg" title="Screen Shot 2020-12-05 at 23.49.48.jpg"></p><p>如果项目中使用了其他第三方库，此部署工具不会自动提取相关文件，需要手动将相关库文件添加到 <code>app/Contents/Frameworks</code> 文件夹内。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1966.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/1966.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[QT 添加第三方库]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1958.html" />
<id>https://blog.niekun.net/archives/1958.html</id>
<updated>2020-12-02T11:52:00+08:00</updated>
<published>2020-12-02T11:52:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[如果要在 QT 中使用第三方库，需要将相关库文件路径写入项目 pro 文件内，有两种方式：GUI 对话框添加或直接编辑 pro 文件。GUI 添加使用 GUI 添加的好处是比较直观，使用鼠标点击...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/1958.html" xml:lang="zh-CN"><![CDATA[
<p>如果要在 QT 中使用第三方库，需要将相关库文件路径写入项目 pro 文件内，有两种方式：GUI 对话框添加或直接编辑 pro 文件。</p><h3>GUI 添加</h3><p>使用 GUI 添加的好处是比较直观，使用鼠标点击即可。</p><p>右键项目名称，点击 add library：<br><img src="https://blog.niekun.net/usr/uploads/2020/12/3998509933.jpg" alt="1.jpg" title="1.jpg"></p><!--more--><p>选中 external library 点击 next：<br><img src="https://blog.niekun.net/usr/uploads/2020/12/1625536441.jpg" alt="2.jpg" title="2.jpg"></p><p>选择头文件所在目录路径：<br><img src="https://blog.niekun.net/usr/uploads/2020/12/3830480933.jpg" alt="3.jpg" title="3.jpg"></p><p>如果有 lib 库文件的话需要链接进来，没有的话可以不设置：<br><img src="https://blog.niekun.net/usr/uploads/2020/12/1700799379.jpg" alt="4.jpg" title="4.jpg"></p><p>其他保持默认然后点击 next 完成添加。</p><p>我们打开 pro 文件可以看到在文件最后添加了相关内容：</p><pre><code>win32:CONFIG(release, debug|release): LIBS += -L$$PWD/../../../Library/boost_1_72_0/stage/lib/ -llibboost_filesystem-mgw81-mt-x32-1_72.dll
else:win32:CONFIG(debug, debug|release): LIBS += -L$$PWD/../../../Library/boost_1_72_0/stage/lib/ -llibboost_filesystem-mgw81-mt-x32-1_72.dlld
else:unix: LIBS += -L$$PWD/../../../Library/boost_1_72_0/stage/lib/ -llibboost_filesystem-mgw81-mt-x32-1_72.dll

INCLUDEPATH += $$PWD/../../../Library/boost_1_72_0
DEPENDPATH += $$PWD/../../../Library/boost_1_72_0</code></pre><h3>pro 文件添加</h3><p>根据添加一个第三方库所增加的语句，我们可以手动直接编辑 pro 文件完成添加：</p><ul><li><code>LIBS</code> 指定 lib 库文件路径，没有的话不需要定义</li><li><code>INCLUDEPATH</code> 指头文件所在目录</li><li><code>DEPENDPATH</code> 定义和头文件相同目录即可</li></ul><p>例如我们添加一个 boost filesystem 库到项目：</p><pre><code>LIBS += -L&quot;/path/to/boost_1_72_0/stage/lib/&quot; \
        -llibboost_filesystem-mgw81-mt-x32-1_72 \
        -llibboost_regex-mgw81-mt-x32-1_72

INCLUDEPATH += &quot;/path/to/boost_1_72_0&quot;
DEPENDPATH += &quot;/path/to/boost_1_72_0&quot;</code></pre><p><code>LIBS</code> 中，使用 <code>-L</code> 添加 lib 库目录，使用 <code>-l</code> 添加具体某个库文件，可以不写文件后缀。</p><p>以上就是 QT 中添加第三方库的方法。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1958.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/1958.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[Macros 聚集 in c++]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1956.html" />
<id>https://blog.niekun.net/archives/1956.html</id>
<updated>2020-12-01T11:37:00+08:00</updated>
<published>2020-12-01T11:37:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[在 c++ 中，一个 Macro 就是一段代码的聚合。使用这个 macro 名称就代表着对应的代码段。有两种常见的 macro：object 形式，function 形式。可以定义任意有效的字符...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/1956.html" xml:lang="zh-CN"><![CDATA[
<p>在 c++ 中，一个 Macro 就是一段代码的聚合。使用这个 macro 名称就代表着对应的代码段。</p><p>有两种常见的 macro：object 形式，function 形式。可以定义任意有效的字符作为 macro 名称，甚至是 c 关键词。</p><!--more--><h3>object 形式</h3><p>object 形式的 macro 就是简单的使用一个 identifier 代替代码片段。使用 <code>#define</code> 定义一个 macro：</p><pre><code>#define TESTINT 1024

void main() {
    int a = TESTINT;
    cout &lt;&lt; a &lt;&lt; endl;
}

//output:
//1024</code></pre><p>也可以定义一个片段：</p><pre><code>#define NUMBERS 1, 2, 3

void main() {
    int x[] = { NUMBERS };
    //int x[] = { 1, 2, 3 };这两句效果相同
}</code></pre><p>也可以多层定义：</p><pre><code>#define NUMBER1 1
#define NUMBER2 NUMBER1</code></pre><p>以上示例中 NUMBER2 等于 NUMBER1。</p><h3>function 形式</h3><p>可以定义 function 形式的 macro，需要在定义中 macro 名称后加上圆括号<code>()</code>。例如：</p><pre><code>#define lang_init()  c_init()</code></pre><p>定义后就可以使用 <code>lang_init()</code> 来调用 <code>c_init()</code> 了，类似于 alias。</p><p>object 类型的 macro 可以和 function 类型的 macro 同名，区别就是有没有圆括号：</p><pre><code>#define test 100
#define test() func()

void main() {
    int a = test;
    test();
}</code></pre><p>以上就是对 macro 的简单介绍。</p><p>参考链接：<br><a href="https://gcc.gnu.org/onlinedocs/cpp/Macros.html">https://gcc.gnu.org/onlinedocs/cpp/Macros.html</a></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1956.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/1956.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[c++ 中 string 字符串的含义]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1953.html" />
<id>https://blog.niekun.net/archives/1953.html</id>
<updated>2020-11-25T11:52:00+08:00</updated>
<published>2020-11-25T11:52:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[有如下代码：int main(){    char *s;    s = &amp;quot;hello&amp;quot;;    cout &amp;lt;&amp;lt; *s &amp;lt;&amp;lt; endl;    cou...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/1953.html" xml:lang="zh-CN"><![CDATA[
<p>有如下代码：</p><pre><code>int main()
{
    char *s;
    s = &quot;hello&quot;;

    cout &lt;&lt; *s &lt;&lt; endl;
    cout &lt;&lt; s &lt;&lt; endl;

    return 0;
}

//OUTPUT:
//h
//hello</code></pre><p>首先定义了一个指针，然后给指针赋值为一个字符串。看起来以上写法有错误，s 指针是一个地址，为什么给它赋值一个字符串？</p><p>因为在 c++ 中字符串类似于我们提到的数组，使用数组名就表示第一个数组元素的地址。例如：</p><pre><code>int main()
{
    int arr[] = {1, 3};
    int *p = arr;

    cout &lt;&lt; *p &lt;&lt; endl;
    cout &lt;&lt; *(p+1) &lt;&lt; endl;

    return 0;
}

//OUTPUT:
//1
//3</code></pre><p>同样在字符串中，<code>s = &quot;hello&quot;</code> 表示将首字母 <code>h</code> 的地址赋给指针。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1953.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/1953.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[c++ 中数组类型数据作为 function 参数时的注意事项]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1946.html" />
<id>https://blog.niekun.net/archives/1946.html</id>
<updated>2020-11-25T11:16:00+08:00</updated>
<published>2020-11-25T11:16:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[关于 function 的基础教程参考：C++ 入门教程之四 -- Functions当 function 的传入参数为数组时，如果我们想要得到数组元素个数可能会这样写：void testFun...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/1946.html" xml:lang="zh-CN"><![CDATA[
<p>关于 function 的基础教程参考：<a href="https://blog.niekun.net/archives/1915.html">C++ 入门教程之四 -- Functions</a></p><p>当 function 的传入参数为数组时，如果我们想要得到数组元素个数可能会这样写：</p><pre><code>void testFunc(int arr[]) {
    int count = sizeof(arr)/sizeof(arr[0]);
}

int main()
{
    int arr[] = {1, 3, 6, 8};
    cout &lt;&lt; testFunc(arr) &lt;&lt; endl;

    return 0;
}</code></pre><p>sizeof function 可以返回数据占用内存空间的大小。所以用整个 arr 大小除以第一个元素大小可以得到数组元素个数。</p><p>但是测试会发现以上得到的 count 值并不是 arr 数组元素个数 4 而是 2。这是因为当 function 传入数组数据时，会自动将其转换为 pointer 指针类型。这时候使用 <code>sizeof()</code> 得到的不是 arr 数据所在地址的内存大小，而是这个指向 arr 数组的指针所占用内存大小。</p><!--more--><p>我们做个实验：</p><pre><code>int main()
{
    int *arrP = new int[4];
    cout &lt;&lt; sizeof(arrP) &lt;&lt; endl;
    cout &lt;&lt; sizeof(arrP[0]) &lt;&lt; endl;
    return 0;
}

//output:
//8
//4</code></pre><p>以上建立了一个指针指向 4 个元素的数组，然后分别查看其整个指针和某个元素指针的内存大小，得到的结果是 8 和 4。所以他们两个相除结果为 2。</p><p>因为指针指向的是数组第一个元素，如果我们要通过指针给数组元素赋值，可以使用 <code>*(pointer + n)</code> 的方式完成，例如：</p><pre><code>int *arrP = new int[4];
*arrP = 1;
*(arrP+1) = 2;</code></pre><p><code>*(arrP+1)</code> 就是第 2 个数组元素。</p><p>可以用指针查询数组中某个元素的内存大小，数组名 arr 表示数组所在地址(不需要加地址转换符<code>&amp;</code>)：</p><pre><code>int main()
{
    int arr[] = {1, 3, 6, 8};
    int *arrP = arr;

    cout &lt;&lt; sizeof(*arrP) &lt;&lt; endl;
    cout &lt;&lt; sizeof(*(arrP+1)) &lt;&lt; endl;

    return 0;
}

//output:
//4
//4</code></pre><p>由于 arr 数组名表示此数组第一个元素所在地址的指针，所以我们可以直接使用此名称来用指针的方式地区元素数据：</p><pre><code>int main()
{
    int arr[] = {1, 3, 6, 8};
    cout &lt;&lt; *arr &lt;&lt; endl;
    cout &lt;&lt; *(arr+1) &lt;&lt; endl;

    return 0;
}

//output:
//1
//3</code></pre><p>那么如何在 function 使用数组作为传入数据时如何能够直接使用它的数据而不是指针类型呢？可以使用以下方法：</p><pre><code>template &lt;size_t N&gt;
int testFunc(int (&amp;arr)[N]) {
    int count = sizeof(arr) / sizeof(arr[0]);
    return count;
}

int main()
{
    int arr[] = {1, 3, 6, 8};
    int count = testFunc(arr);

    cout &lt;&lt; count &lt;&lt; endl;
    return 0;
}

//OUTPUT:
//4</code></pre><p>创建一个 function template，<code>size_t</code> 类型表示任意数据类型的元素占用内存大小，此处将其作为 generic data type 用来定义实际传入的数组所占用内存容量的 template，然后以传入数据的实际地址的模式将数组的元素都顺序都传入 function。这样传入数据就是实际数据地址而不是指针。</p><p>关于 function 的传入数据实际地址是使用指针形式 <code>*</code> 还是 <code>&amp;</code> 形式，在前面我介绍过，形式如下：</p><pre><code>void test1(int *a) {
    *a = 3;
}

void test2(int &amp;a) {
    a = 2;
}

int main()
{
    int a = 1;
    int *p = &amp;a;

    test1(p);
    cout &lt;&lt; a &lt;&lt; endl;

    test2(a);
    cout &lt;&lt; a &lt;&lt; endl;

    return 0;
}

//OUTPUT:
//3
//2</code></pre><p>function 中使用在指针类型的传入数据时需要传入一个指针，当定义为 <code>&amp;</code> 时可以直接传入数据名称。两种方法都是 by reference 会影响到对应内存地址的数据内容。可参考教程：<a href="https://blog.niekun.net/archives/1915.html">C++ 入门教程之四 -- Functions</a></p><p><strong>参考链接：</strong><br><a href="https://stackoverflow.com/questions/4839626/element-count-of-an-array-in-c">https://stackoverflow.com/questions/4839626/element-count-of-an-array-in-c</a><br><a href="https://www.tutorialspoint.com/cplusplus/cpp_pointer_to_an_array.htm">https://www.tutorialspoint.com/cplusplus/cpp_pointer_to_an_array.htm</a></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1946.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/1946.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[C++ 入门教程之八 -- Templates - Exceptions - Files]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1940.html" />
<id>https://blog.niekun.net/archives/1940.html</id>
<updated>2020-11-23T21:41:00+08:00</updated>
<published>2020-11-23T21:41:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[function template使用 function 和 class 使我们编程更加简单及易操作。但是它们仍然受限于 c++ 编程规范，在定义它们的参数时必须指定参数的类型。例如：int s...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/1940.html" xml:lang="zh-CN"><![CDATA[
<h3>function template</h3><p>使用 function 和 class 使我们编程更加简单及易操作。但是它们仍然受限于 c++ 编程规范，在定义它们的参数时必须指定参数的类型。例如：</p><pre><code>int sum(int a, int b) {
  return a+b;
}

int main () {
  int x=7, y=15;
  cout &lt;&lt; sum(x, y) &lt;&lt; endl;
}</code></pre><!--more--><p>以上示例中，需要我们定义sum function 需要传入两个 int 型数据，返回其相加结果。在 main 中调用 sum function。</p><p><code>sum()</code> 可以正确的执行指令，但它的限制是必须传入 int 类型的数据。</p><p>如果需要实现两个 double 类型数据相加，需要再次定义新 funtion：</p><pre><code>double sum(double a, double b) {
  return a+b;
}</code></pre><p>使用 <strong>function template</strong> 能够让我们只定义一个 <code>sum()</code> 来适用于所有类型的数据。</p><p>使用关键词 <code>template</code> 来定义一个 function template，在尖括号<code>&lt;&gt;</code>内定义通用数据类型：</p><pre><code>template &lt;class T&gt; 
</code></pre><p>关键词 <code>class</code> 表示一个申明要定义 generic 通用数据类型，注意不要和我之前学习的 <code>class</code> 混淆。</p><p>也可以使用关键词 <code>typename</code>：</p><pre><code>template &lt;typename T&gt; 
</code></pre><p><code>T</code> 表示我们的 generic 通用数据类型名称，在后续中可以使用此名称代表数据类型，<strong>可以是任意自定义字符</strong>。</p><p>修改我们的示例：</p><pre><code>#include &lt;iostream&gt;
using namespace std;

template &lt;class T&gt;
T sum(T a, T b)
{
    return a + b;
}

int main()
{
    int x=7, y=15;
    cout &lt;&lt; sum(x, y) &lt;&lt; endl;

    double a=7.15, b=15.54;
    cout &lt;&lt; sum(a, b) &lt;&lt; endl;

    return 0;
}</code></pre><p>我们在 function 中建立了一个 generic data type 通用数据类型 T，返回值和传入参数类型都为 T。在 mian 中调用时，会根据实际传入数据类型来动态确定 T 的实际类型。</p><p>function template 可以节省编程中很多时间，因为只需要一次定义就可以兼容不同的数据类型。</p><p>我们也可以同时定义多个 generic data type，使用逗号<code>,</code> 分隔多个定义类型：</p><pre><code>template &lt;class T, class U&gt;
T smaller(T a, U b) {
  return (a &lt; b ? a : b);
}

int main () {
  int x=72;
  double y=15.34;
  cout &lt;&lt; smaller(x, y) &lt;&lt; endl;
}</code></pre><p>以上示例定义了两个通用数据类型，返回值类型为第一种数据类型。<code>(a &lt; b ? a : b)</code> 表达式的意思是：判断 a 是否小于 b，如果结果为 true 则返回 a 的值，如果结果为 flase 返回 b 的值，两个参数可以是不同数据类型，如：int 和 double。</p><p>在 mian 中调用 smaller function，返回结果为两个参数中较大的那个的值，由于返回值类型为第一个定义数据类型 T，而我们调用时传入的第一个参数类型为 int，所以返回结果也为 int 型。</p><p>需要注意的是在一旦定义了 function template，在 function 中就一定要使用定义的那些通用数据类型，否则编译器会报错。</p><h3>class template</h3><p>同样也可以定义 class template，允许 class 的元素类型为 generic data type。语法如下：</p><pre><code>template &lt;class T&gt;
class MyClass {

};</code></pre><p>类似于 function template，多个 generic data type 使用逗号<code>,</code> 分隔：</p><pre><code>template &lt;class T,class U&gt;
</code></pre><p>下面举例说明使用方法：</p><pre><code>template &lt;class T&gt;
class Pair {
    public:
    Pair (T a, T b):
    first(a), second(b) {
    }
    
    private:
    T first, second;
};</code></pre><p>以上建立了一个 class template，类型为 T，通过构造器对 private 里的两个 T 类型的参数初始化数据。</p><p>在 class template 外定义 function，如 class 大括号外或一个单独文件，需要在 class 后标记 class template 内定义过的 generic type。例如在以上示例的 class 外建立 bigger function：</p><pre><code>template &lt;class T&gt;
class Pair {
    public:
    Pair (T a, T b):
    first(a), second(b) {
    }
    T bigger();

    private:
    T first, second;
};

template &lt;class T&gt;
T Pair&lt;T&gt;::bigger() {
    return (first&gt;second ? first : second);
}</code></pre><p>上面示例中使用了 scope resolution operator - 范围解析符<code>::</code> 来表示外部的 Pair() function 属于哪个 class，在头文件章节介绍过，具体参考：<a href="https://blog.niekun.net/archives/1920.html">C++ 入门教程之六 -- Classes 实践</a>。</p><p>bigger function 返回 class 两个属性变量中较大的值。</p><p>在 main 中实例化 Pair class 时需要使用尖括号定义当前实际要使用的数据类型，如 int 类型：</p><pre><code>void main() {
    Pair&lt;int&gt; obj(11, 22);
    cout &lt;&lt; obj.bigger() &lt;&lt; endl;
}</code></pre><p>也可以定义 double 类型：</p><pre><code>void main() {
    Pair&lt;double&gt; obj(11.23, 22.56);
    cout &lt;&lt; obj.bigger() &lt;&lt; endl;
}</code></pre><h3>template 特例</h3><p>在前面介绍的 class template 中，实例化 object 时定义不同的数据类型会执行同样的 function 指令内容。template specialization 特例允许当我们定义某些特定数据类型作为 template type 时执行和通用指令不同的内容。</p><p>下面举例说明，当定义数据类型为 char 时执行和其他数据类型不同的指令，先建立一个常规 class template：</p><pre><code>template &lt;class T&gt;
class MyClass {
public:
    MyClass(T x) {
        cout &lt;&lt; x &lt;&lt; &quot; - not a char&quot; &lt;&lt; endl;
    }
};</code></pre><p>以上 class 用来作为常规数据类型情况下的处理。</p><p>为了处理当数据类型为 char 时的情况，我们建立一个 class specialization 特例：</p><pre><code>template &lt;&gt;
class MyClass&lt;char&gt; {
public:
    MyClass(char x) {
        cout &lt;&lt; x &lt;&lt; &quot; - is a char&quot; &lt;&lt; endl;
    }
};</code></pre><p>以上代码中，首先在 class 前声明了一个没有参数的 <code>template &lt;&gt;</code>，这是为了区别于通用数据类型情况，表明此 class specialization 里的数据类型是已知的和特定的。而由于这个 class 依然是属于 class template 类型的，只是一个特例情况的处理，所以这句声明不能省略。</p><p>在 class template 名称后面的 <code>&lt;char&gt;</code> 定义了此 clas 属于对哪种 specialization 特例数据类型的处理。当我们实例化时，如果定义的数据类型是属于 template specialization 里定义的类型时，会将此 class 作为实例化对象。</p><p>需要注意得是对常规数据类型的 class template 和特定类型数据的 class template 两者的 body 内容是完全独立互不影响的，specialization template 并不从 generic template 里继承任何元素，如果需要的话可以编写完全不同的功能。</p><p>在 main 中使用不同数据类型进行实例化测试：</p><pre><code>int main() {
    MyClass&lt;int&gt; obj1(22);
    MyClass&lt;double&gt; obj2(11.34);
    MyClass&lt;char&gt; obj3('a');
    
    return 0;
}

//output:
//22 - not a char
//11.34 - not a char
//a - is a char</code></pre><p>可以看到 generic template 适用于数据类型：int 和 double，而 specialization template 适用于数据类型：char。</p><h3>exception 例外</h3><p>程序在执行中遇到问题叫做：exception 例外。</p><p>在 c++ 中，exception 是对程序遇到反常情况的反应。如：0做除数时。</p><p>c++ 的 exception handling 例外管理器是通过三个关键词：<code>try</code>，<code>catch</code> 和 <code>throw</code> 来建立的。<code>throw</code> 是用来当问题出现时调出某一个 exception 响应动作的。例如：</p><pre><code>int motherAge = 40;
int sonAge = 50;
if (sonAge &gt; motherAge) {
    throw 99;
}</code></pre><p>以上示例中，当 sonAge 大于 motherAge 时，程序首先会自动识别 throw 语句中元素的数据类型，然后根据这个数据类型去寻找处理这类数据类型的 exception 块。最后使用 throw 内的数据作为传入参数在 exception 中使用。</p><p>throw 中的数据类型可以是任意的，如 123 为 int 型，a 为 char 型，11.24 为 double 型，一下示例写法都是正确的：</p><pre><code>int motherAge = 40;
int sonAge = 50;
if (sonAge &gt; motherAge) {
    throw ‘a’;
}

if (sonAge = motherAge) {
    throw 12.45;
}</code></pre><h3>catching exception</h3><p>那么具体如何响应 exception 呢？需要使用 <code>try/catch</code> block 模块来构造完整的 throw 和 response 过程。一个 try block 块用来激活特殊情况的 exception 功能，在 try 后面需要跟一个或多个 catch block 块来执行某种特定 throw 类型的 exception 动作。在 catch 后需要定义特定的数据类型对应于 throw 的某种数据类型。</p><p>下面举例说明：</p><pre><code>try {
    int motherAge = 40;
    int sonAge = 50;
    if (sonAge &gt; motherAge) {
        throw 99;
    }
} catch (int x) {
    cout &lt;&lt; &quot;wrong age value - Error&quot; &lt;&lt; x &lt;&lt; endl;
} catch (char x) {
    cout &lt;&lt; &quot;example for other catch&quot; &lt;&lt; x &lt;&lt; endl;
}

//output: wrong age value - Error99</code></pre><p>以上例子中，try 块 throw 了一个 exception，throw 的数据 99 是 int 类型，所以匹配到 catch 中定义类型也为 int 型的 exception 块。然后将 99 作为传入数据在 exception 中使用。当只有一种 exception 情况是，只需要定义一个 throw 和一个 catch 块即可。</p><p>下面的示例是提示用户输入两个数字，然后将它们相除，exception 的情况是当第二个数为 0：</p><pre><code>try {
    int num1;
    cout &lt;&lt; &quot;enter the first number:&quot;;
    cin &gt;&gt; num1;
    
    int num2;
    cout &lt;&lt; &quot;enter the second number:&quot;;
    cin &gt;&gt; num2;
    
    if (num2 == 0) {
        throw 0;
    }
    cout &lt;&lt; &quot;result: &quot; &lt;&lt; num1 / num2 &lt;&lt; endl;
} catch (int x) {
    cout &lt;&lt; &quot;division by zero!&quot; &lt;&lt; endl;
}</code></pre><p><code>cin</code> 是 istream class 类型的 object 用来输入数据流，数据输入后会存在后面的变量中。当输入的第二个数字非零时不会触发 exception 响应，当为零时 throw 类型为 int，然后匹配到 exception 中类型也为 int 的块，然后执行其中指令。</p><p>如果以上程序中不考虑输入数据是否为 0，则当除数为 0 时程序会崩溃。</p><p>catch 块也可以管理在 try 块中任何类型的 throw exception，不同于catch 后定义某一种数据类型，使用省略号<code>(...)</code> 来表示响应任何类型的 throw，例如：</p><pre><code>try {
//...
} catch (...) {
    cout &lt;&lt; &quot;division by zero!&quot; &lt;&lt; endl;
}</code></pre><p>这样当 try 块 throw 一个 exception 时，无论 throw 类型为什么都会匹配到此通用 catch 块。</p><h3>Files 文件处理</h3><p>c++ 另一个常用的功能就是对文件的读写操作，需要用到 c++ 标准库：`<fstream>'</p><p>在 fstream 中定义了三种数据类型：</p><ul><li>ofstream：输出文件流，用来创建或写入文件</li><li>ifstream：输入文件流，用来读取文件信息</li><li>fstream：通用文件流，包含 ofsteam 和 ifstream 的内容，支持创建，读入，写入文件。</li></ul><p>在 c++ 中对文件操作需要 include <code>iostream</code> 和 <code>fstream</code>:</p><pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;</code></pre><p>对文件操作的一些 class 直接或间接继承自 istream 和 ostream，例如在上一节用到的 <code>cin</code> 就是 istream class 的一个 object，<code>cout</code> 是 ostream class 的一个 object。</p><h3>打开文件及写入</h3><p>在对文件进读写前，需要首先打开它。</p><p>ofstream 和 fstream 的 object 都可以用来打开文件然后进行写操作，我们打开一个 test.txt 文件然后写入内容最后关闭文件：</p><pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
using namespace std;

int main() {
    ofstream MyFile;
    MyFile.open(&quot;test.txt&quot;);
    MyFile &lt;&lt; &quot;some text.\n&quot;;
    MyFile.close();

    return 0;
}</code></pre><p>以上代码创建一个 ofstream 类型的 object，使用 open function 打开一个文件，然后给这个文件写入内容，最后关闭文件。如果此文件不存在则 open function 会自动创建。可以看到使用了和之前操作 iostream 同样的 stream 流操作符 <code>&lt;&lt;</code>。</p><p>open function 打开的文件可以是一个路径，如果只有文件名则默认在程序根目录。</p><p>也可以使用 ofstream 的构造器直接给 object 初始化定义文件路径：</p><pre><code>int main(int argc, const char * argv[]) {

    ofstream MyFile(&quot;test.txt&quot;);
    MyFile &lt;&lt; &quot;some text.\n&quot;;
    MyFile.close();
    
    return 0;
}</code></pre><p><strong>使用 open function 的区别是可以定义一个文件的绝对路径，可以和程序不在一个目录。</strong></p><p>在特定情况下，使用 open function 打开文件会无效，如：没有权限打开文件。这时候可以使用 is_open function 来确认文件是否已经被正确打开且可以被访问：</p><pre><code>int main(int argc, const char * argv[]) {

    ofstream MyFile(&quot;test.txt&quot;);
    if (MyFile.is_open()) {
        MyFile &lt;&lt; &quot;some text.\n&quot;;
    } else {
        cout &lt;&lt; &quot;somethin went wrong&quot; &lt;&lt; endl;
    }
    MyFile.close();
    
    return 0;
}</code></pre><p>is_open function 检查文件是否被正常打开，返回值为：true 或 false。</p><p>open function 的第二参数可以用来定义文件打开模式，一下是支持的模式列表：<br><img src="https://blog.niekun.net/usr/uploads/2020/11/3255690305.jpeg" alt="1.jpeg" title="1.jpeg"></p><p>以上的 flag 标记可以结合起来使用，用或操作符<code>|</code> 来分隔。例如使用 write 模式同时 truncate 文件，使用一下语句：</p><pre><code>ofstream outfile;
outfile.open(&quot;file.dat&quot;, ios::out | ios::trunc );</code></pre><h3>读取文件</h3><p>类似于写文件，读取文件需要一个 ifstream 或 fstream 的 object。示例如下：</p><pre><code>string line;
ifstream ReadFile(&quot;test.txt&quot;);
if (ReadFile.is_open()) {
    while (getline(ReadFile, line)) {
        cout &lt;&lt; line &lt;&lt; endl;
    }
} else {
    cout &lt;&lt; &quot;fail to open file&quot; &lt;&lt; endl;
}</code></pre><p>首先创建一个 ifstream class 的实例 ReadFile并初始化文件地址。如果文件打开正常则使用 getline function 来一行行的读取文件内容到字符串 line，然后打印到输出。</p><p>getline function 属于 istream class，会逐行读取来自 istream 输入流的内容到一个字符串变量，每次执行都会自动换行定位到下一行输入流 istream 的内容直到结尾会跳出 while 循环。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1940.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/1940.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[C++ 入门教程之七 -- 继承和多态]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1927.html" />
<id>https://blog.niekun.net/archives/1927.html</id>
<updated>2020-11-21T22:31:00+08:00</updated>
<published>2020-11-21T22:31:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[inheritance 继承inheritance 继承是面向对象编程最重要的概念之一。继承允许我们基于已有的 class 创建新的 class。这能够极大的方便我们创建应用程序。一个 clas...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/1927.html" xml:lang="zh-CN"><![CDATA[
<h3>inheritance 继承</h3><p><strong>inheritance 继承</strong>是面向对象编程最重要的概念之一。继承允许我们基于已有的 class 创建新的 class。这能够极大的方便我们创建应用程序。</p><p>一个 class 的属性被其他 class 继承，我们称这个 class 叫做 base class。一个从 base class 继承属性的 class 我们称其为 derived class。一个 derived class 获得所有 base class 的功能，且可以有自己独有的功能：<br><img src="https://blog.niekun.net/usr/uploads/2020/11/1471544588.png" alt="1.png" title="1.png"></p><!--more--><p><strong>继承</strong>的概念是 <code>is a 属于是什么</code> 的关系，例如：猫 is a 动物，狗 is a 动物。两者都继承了动物的属性。</p><p>我们来建立两个 class：Mother 和 Daughter：</p><pre><code>class Mother
{
 public:
 Mother() {};
 void sayHi() {
   cout &lt;&lt; &quot;Hi&quot;;
 } 
};

class Daughter 
{
 public: 
 Daughter() {};
};</code></pre><p>Mother 有一个 <code>sayHi()</code> function。下面我们让 Daughter 继承 Mother 的属性，Daughter class 名称修改如下：</p><pre><code>class Daughter : public Mother
{
 public: 
 Daughter() {};
};</code></pre><p>使用一个冒号<code>:</code> 标记 base class。access specifier 访问标记符 <code>public</code> 表示所有 base class 里 public 段下的内容继承给 derived class 里的 public 段下。</p><p>以上示例中 Daughter 继承了所有 Mother 的 public 下的元素，所以我们可以实例化一个 Daughter 的 object 然后调用 <code>sayHi()</code> function 了：</p><pre><code>#include &lt;iostream&gt;

using  namespace std;

class Mother
{
 public:
 Mother() {};
 void sayHi() {
   cout &lt;&lt; &quot;Hi&quot; &lt;&lt; endl;
 }
};

class Daughter: public Mother
{
 public:
 Daughter() {};
};

int main(int argc, const char * argv[]) {
    Daughter d;
    d.sayHi();
    return 0;
}</code></pre><p><strong>关于 access 访问标记符的使用，在下面会详细介绍使用方法。</strong></p><p>一个 derived class 可以继承所有 base class 的 function 出过一下几种特殊情况类型：</p><ul><li>constructor and destructor 构造器和销毁器</li><li>复用操作符 function</li><li>friend function</li></ul><p>一个 class 可以同时继承多个 base class，使用逗号<code>,</code> 分隔 base class，如：<code>class Daughter: public Mother, public Father</code>。</p><h3>protected 元素</h3><p>对于 class 中的元素的 access 访问表示符，我们前面使用了 public 和 private。public 里的元素可以被外界访问或修改，private 里的元素只能被 class 内部使用，或者通过 friend function 来读取。</p><p>除了以上两种识别符外，还有一种类型：<code>protected</code>。</p><p>在 protected 内的元素和 private 段内的很类似。唯一的区别是，protected 内的元素可以被 derived class 访问。</p><p>例如我们给 Mother 添加一个 protected 元素：</p><pre><code>class Mother {
 public:
 void sayHi() {
   cout &lt;&lt; var;
 }

 private:
 int var=0;

 protected:
 int someVar;
};</code></pre><p>someVar 变量可以被 Daughter 访问。</p><h3>继承的类型</h3><p>access 访问标记符能够用来定义继承类型。</p><p>在上面的示例中我们使用 public 作为访问标记符：<code>class Daughter: public Mother</code>。private 和 protected 同样可以被使用。</p><p><strong>三者的区别：</strong></p><ul><li>Public Inheritance: base class 里 public 段内的元素继承到 derived class 里的 public 段内，base class 里 protected 段内的元素继承到 derived class 里 protected 段内，base class 里 private 段内的元素永远不能能够被 derived class 直接访问，但可以通过 public 或 protected 内的 function 来间接获取数据。</li><li>Protected Inheritance: base class 里 public 和 protected 段内的元素继承到 derived class 里的 protected 段内。</li><li>Private Inheritance: base class 里 public 和 protected 段内的元素继承到 derived class 里的 private 段内。</li></ul><p>public 继承类型在<strong>继承</strong>中是最常用的。如果在程序中没有指定某个继承类型，则默认为 <strong>private</strong>。</p><h3>构造器和销毁器</h3><p>上面提到了 derived class 不会继承 base class 的构造器和销毁器。但是 derived class 的实例 object 在被建立和销毁时，base class 的构造器和销毁器会被自动调用。</p><p>我们建立 Mother class：</p><pre><code>class Mother
{
 public:
 Mother() {
   cout &lt;&lt; &quot;mother's constructor&quot; &lt;&lt; endl;
 }
 ~Mother() {
   cout &lt;&lt; &quot;mother's destructor&quot; &lt;&lt; endl;
 }
};

int main(int argc, const char * argv[]) {
    Mother m;
    return 0;
}</code></pre><p>实例化 Mother 后，输出如下：</p><pre><code>mother's constructor
mother's destructor</code></pre><p>然后我们建立 Daughter class：</p><pre><code>class Daughter: public Mother
{
 public:
 Daughter() {
    cout &lt;&lt; &quot;daughter's constructor&quot; &lt;&lt; endl;
 }
 ~Daughter() {
   cout &lt;&lt; &quot;daugther's destructor&quot; &lt;&lt; endl;
 }
};

int main(int argc, const char * argv[]) {
    Daughter d;
    return 0;
}</code></pre><p>实例化 Daughter 后，输出如下：</p><pre><code>mother's constructor
daughter's constructor
daugther's destructor
mother's destructor</code></pre><p>可以看到当 Daughter 的 object 创建时，首先 base class 的构造器被调用，然后调用 derived class 的构造器。<br>当 object 销毁时，首先 derived class 的销毁器被调用，然后 base class 的销毁器被调用。</p><p>你可以理解为 derived class 依赖于 base class 才能工作，所以 base class 需要首先被执行。</p><h3>多态性</h3><p>polymorphism 多态化意思是：拥有多种样式。通常多态化出现在那些有着继承关系的 class 中。在 c++ 中多态性意思是在调用同一个 function 时随着 object 类型的不同而有着不同的执行效果。</p><p>下面举例说明：我们创建一个游戏，有两种人物：monster 怪物和 ninja 忍者。他们都有一个共同的 function：<code>attack</code>，但是两者攻击的模式是不同的。在这个场景下，多态性能够实现不同的 objects 调用同样的 attack function 而有不同的实现效果。</p><p>首先创建一个 Enemy class：</p><pre><code>class Enemy {
 protected: 
 int attackPower;

 public:
 void setAttackPower(int a){
  attackPower = a;
 }
};</code></pre><p>Enemy class 有一个public function：setAttackPower 来设置 protected 里的参数：attackPower。</p><p>然后我们建立两个 derived class 以 Enemy 为 base class，各自有独立的 attack function：</p><pre><code>class Ninja: public Enemy {
 public:
 void attack() {
   cout &lt;&lt; &quot;Ninja! - &quot;&lt;&lt;attackPower&lt;&lt;endl;
 }
};

class Monster: public Enemy {
 public:
 void attack() {
   cout &lt;&lt; &quot;Monster! - &quot;&lt;&lt;attackPower&lt;&lt;endl;
 }
};</code></pre><p>在 main 中实例化：</p><pre><code>int main() {   
 Ninja n;
 Monster m;  
}</code></pre><p>由于 Monster 和 Ninja 都继承自 Enemy，所以他们的实例 object 也都是 Enemy 类型的 object。我们可以如下定义：</p><pre><code>Enemy *e1 = &amp;n;
Enemy *e2 = &amp;m;</code></pre><p>我们定义两个 Enemy 类型的指针指向两个 object。</p><p>在 main 中调用对应的 function：</p><pre><code>int main(int argc, const char * argv[]) {
    Ninja n;
    Monster m;
    Enemy *e1 = &amp;n;
    Enemy *e2 = &amp;m;
    
    e1-&gt;setAttackPower(20);
    e2-&gt;setAttackPower(80);
    
    n.attack();
    m.attack();
    return 0;
}</code></pre><p>两个指针都是 Enemy 类型的，所以可以用来使用 Enemy 中的 function 设置参数，然后分别调用 derived class 的 object 的 attack function。注意这里没法用这两个指针直接调用 <code>attack()</code>，因为 Enemy 中并没有定义这个 function。</p><h3>虚拟 function</h3><p>上面的示例中，我们使用 Enemy 类型的指针指向了 derived class 的 object。但是我们无法使用这个指针调用 attack function，因为在 base class 中不包含这个 function。为了实现这个功能，需要在 base class 中定义一个 attack 的 <code>virtual function</code>。</p><p>virtual function 的意义就是在 base class 里定义一个 function，在 derived class 内 override 重写这个 function，这样就可以实现多态化，使用 base class 类型的指针调用同一个 function 根据 derived class 的不同而实现不同的功能。</p><p>使用关键词 <code>virtual</code> 定义 virtual function：</p><pre><code>class Enemy {
    protected:
    int attackPower;
    
    public:
    virtual void attack() {}
    void setAttackPower(int a){
        attackPower = a;
    }
};</code></pre><p>在 Enemy class 中我们定义一个 attack 的 virtual function，然后在两个 derived class 中重写这个 function 使其有着不同的内容。</p><p>现在我们就可以使用 Enemy 类型的指针调用 attack function了：</p><pre><code>int main(int argc, const char * argv[]) {
    Ninja n;
    Monster m;
    Enemy *e1 = &amp;n;
    Enemy *e2 = &amp;m;
    
    e1-&gt;setAttackPower(20);
    e2-&gt;setAttackPower(80);
    
    e1-&gt;attack();
    e2-&gt;attack();
    return 0;
}</code></pre><p>virtual function 类似于一个模版，告诉 derived class 可以定义属于自己的这个 function 功能。指针在调用时会根据 object 属于哪个 derived class 而去具体完成指令。</p><p>一个包含有 virtual function 的 class 称之为<strong>多态化的 class</strong>。</p><p>当然在 base class 内的 virtual function 也可以给其具体的指令，我们给 Enemy class 里的 virtual attack function 定义内容：</p><pre><code>class Enemy {
    protected:
    int attackPower;
    
    public:
    virtual void attack() {
        cout &lt;&lt; &quot;Enemy! - &quot; &lt;&lt;attackPower &lt;&lt; endl;
    }
    void setAttackPower(int a){
        attackPower = a;
    }
};</code></pre><p>然后创建一个 Enemy 的 object 及其指针，尝试调用其 attack function：</p><pre><code>int main(int argc, const char * argv[]) {
    Ninja n;
    Monster m;
    Enemy e;
    
    Enemy *e1 = &amp;n;
    Enemy *e2 = &amp;m;
    Enemy *e3 = &amp;e;
    
    e1-&gt;setAttackPower(20);
    e2-&gt;setAttackPower(80);
    e3-&gt;setAttackPower(30);
    
    e1-&gt;attack();
    e2-&gt;attack();
    e3-&gt;attack();
    return 0;
}</code></pre><p>输出如下：</p><pre><code>Ninja! - 20
Monster! - 80
Enemy! - 30</code></pre><p>这就是多态化 class 的优势，不同的 derive class 使用同一名称的 function 在不同的场景下执行不同的指令。</p><h3>abstract class</h3><p>当我们在 base class 中定义 virtual function 时，在 base class 中并没有此 function 具体要实现的内容，只有在 derived class 中才需要做定义。这种情况下，可以将 base class 中的 virtual class 定义为 pure virtual functions 纯粹的虚拟 function 而不需要定义它的任何内容。使用 <code>=0</code> 来进行表示：</p><pre><code>class Enemy {
 public:
  virtual void attack() = 0;
}; </code></pre><p>如果 base class 中定义了 pure virtual functions，那么在 derived class 中必须重写此 function，否则在实例化 derived class 时编译器会报错。</p><p>这种包含有 pure virtual functions 的 class 叫做 abstract class 抽象化的 class，这种 class 不能直接实例化 object，会产生报错。必须实例化其 derived class 且重写了 virtual function。</p><p>现在实例化 Enemy 的 object 会报错：</p><pre><code>Enemy e; // Error
</code></pre><p>这种 pure virtual functions 的好处是，我们可以直接定义 base class 类型的指针指向不同的 derived class object，然后使用同样的 function 名称来执行不同的指令。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1927.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/1927.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[C++ 入门教程之六 -- Classes 实践]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1920.html" />
<id>https://blog.niekun.net/archives/1920.html</id>
<updated>2020-11-21T16:42:00+08:00</updated>
<published>2020-11-21T16:42:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[下面我们通过实际应用来介绍如果在真实环境下应用。我们使用 Code::Blocks IDE 来进行调试。这是一个免费的 c++ 开发环境，能够应用于绝大多数使用场景。官网：http://www....]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/1920.html" xml:lang="zh-CN"><![CDATA[
<p>下面我们通过实际应用来介绍如果在真实环境下应用。</p><p>我们使用 Code::Blocks IDE 来进行调试。这是一个免费的 c++ 开发环境，能够应用于绝大多数使用场景。</p><p>官网：<a href="http://www.codeblocks.org/">http://www.codeblocks.org/</a></p><p>在下载界面下载对应系统版本的安装包：<a href="http://www.codeblocks.org/downloads/26">http://www.codeblocks.org/downloads/26</a></p><p>最好安装带编译器的版本，这样就可以直接使用。</p><!--more--><h3>新建项目</h3><p>安装好 codeblock 后新建一个项目：<br><img src="https://blog.niekun.net/usr/uploads/2020/11/1876839618.jpg" alt="1.jpg" title="1.jpg"></p><p>选择 console application：<br><img src="https://blog.niekun.net/usr/uploads/2020/11/2657179757.jpg" alt="2.jpg" title="2.jpg"></p><p>根据提示设置项目名称等，完成项目建立。</p><p>然后添加一个 class：<br><img src="https://blog.niekun.net/usr/uploads/2020/11/1562291612.jpg" alt="3.jpg" title="3.jpg"></p><p>设置 class 名称，取消勾选 <strong>has destructor</strong>，勾选 <strong>headers and implementation file shall be in same folder</strong>：<br><img src="https://blog.niekun.net/usr/uploads/2020/11/896044646.jpg" alt="4.jpg" title="4.jpg"></p><p>完成后项目结构如下：<br><img src="https://blog.niekun.net/usr/uploads/2020/11/3323508351.jpg" alt="5.jpg" title="5.jpg"></p><ul><li><strong>main.cpp</strong> 项目主文件</li><li><strong>MyClass.cpp</strong> class source 源文件</li><li><strong>MyClass.h</strong> class header 头文件</li></ul><h3>头文件和源文件</h3><p>头文件 <code>.h</code> 申明了 class 的 function 和 variable 变量等元素，我们新建的 class 头文件内容如下：</p><pre><code>#ifndef MYCLASS_H
#define MYCLASS_H


class MyClass
{
    public:
        MyClass();

    protected:

    private:
};

#endif // MYCLASS_H</code></pre><p>里面只默认包含了一个 constructor 构造器 <code>MyClass()</code>。</p><p>源文件 <code>.cpp</code> 包含了这个 class 具体 function 和 variable 等元素的实现过程。当前只有一个空的构造器 function：</p><pre><code>#include &quot;myclass.h&quot;

MyClass::MyClass()
{
    //ctor
}</code></pre><p><strong>范围解析符：</strong><br>我们注意到源文件内构造器前的两个冒号<code>::</code>，叫做 scope resolution operator 范围解析符。这个符号是用来表示那些已经在头文件内申明过的 function 要在这里做具体实现了。用来和头文件内定义的元素进行关联的作用。</p><p>关于<code>::</code>和<code>.</code>的使用场景我的理解是，当在定义一个元素或功能时用范围解析符<code>::</code>，当实例化object后使用其一个元素或功能时用点<code>.</code>，例如：</p><pre><code>//定义一个元素为class内的一个att1类型：
MyClass1::att1 a;

//使用class的function：
MyClass2 obj;
obj.func();</code></pre><p>要在 main 总使用我们创建的 class，只需要在其中引用头文件名即可:</p><pre><code>#include &lt;iostream&gt;
#include &quot;myclass.h&quot;

using namespace std;

int main()
{
    MyClass obj;
    return 0;
}</code></pre><p><strong>总体来说，头文件用来定义 class 提供了哪些功能及元素，源文件用来具体实现这些功能。</strong></p><h3>destructor 销毁器</h3><p>和上一章我们讲到的 constructor 构造器类似，destructor 销毁器也是一个特殊的 function，他在 object 被销毁时自动执行。</p><p>销毁一个 object 一般是在跳出创建这个 object 的 scope 段或者使用 pointer 指针指向这个 object，使用 delete 指令清除此指针指向的数据。</p><p>销毁其的写法和构造器类似，使用 class 名作为 function 名字，前面加上一个波浪符<code>~</code>。当然也是没有返回值类型的。例如：</p><pre><code>class MyClass {
  public: 
    ~MyClass() {
     // some code
    }
};</code></pre><p><strong>使用销毁器能够方便的实现在关闭程序时释放资源，关闭文件，释放内存等功能。</strong></p><p>在头文件中声明一个销毁器：</p><pre><code>class MyClass
{
  public:
   MyClass();
   ~MyClass();
};</code></pre><p>然后再源文件内定义具体实现内容：</p><pre><code>#include &quot;MyClass.h&quot;
#include &lt;iostream&gt;
using namespace std;

MyClass::MyClass()
{
  cout&lt;&lt;&quot;Constructor&quot;&lt;&lt;endl;
}

MyClass::~MyClass()
{
  cout&lt;&lt;&quot;Destructor&quot;&lt;&lt;endl;
}</code></pre><p><strong>不同于构造器，销毁器不能使用参数，也不能被重写，也就是一个 class 只能有一个销毁器。销毁器不是必须有的，不需要的话可以不写</strong></p><p>返回我们的 main，我们已经定义了一个 object <code>MyClass obj</code>，编译运行程序，会在终端输出以下：</p><pre><code>Constructor
Destructor</code></pre><h3>选择符</h3><p>使用选择符 <code>-&gt;</code> 可以访问一个指针指向的 object 的元素。例如：</p><pre><code>MyClass obj;
MyClass *ptr = &amp;obj;
ptr-&gt;myPrint();</code></pre><p>我们创建了 object <code>obj</code> 然后定义一个指针 <code>ptr</code> 指向这个 object 的地址，然后我们可以使用选择符来访问 object 的元素。</p><p><strong>object 元素访问基本原则：</strong></p><ul><li>如果直接面对 object，使用<strong>点</strong><code>.</code> 来访问 object 的元素，如：<code>obj.myPrint()</code></li><li>如果使用面对指针指向的 object，使用<strong>选择符</strong><code>-&gt;</code> 来访问 object 的元素，如：<code>ptr-&gt;myPrint()</code></li></ul><h3>constants 常数</h3><p>常数就是一个有固定值的表达式，它的只在程序运行期间不能够被改变，使用关键词<code>const</code> 定义一个有固定值的变量：</p><pre><code>const int a=2;
</code></pre><p>注意所有 const 类型的变量必须在创建时给其赋值。</p><p>我们可以创建一个 const 类型的 object：</p><pre><code>const MyClass obj;
</code></pre><p>object 内所有的 variable 变量必须在初始化时赋值，一般在 constructor 构造器内完成，实例化的时候直接给其传递数据。如果没有提供构造器完成参数初始化赋值，会引起编译器报错。</p><p>一旦一个 const 类型的 object 被创建，它内部的所有 variable 变量的值都不可以被改变了，包括直接修改 public 段的变量或者使用 function 修改 private 的变量都不可以。</p><p>只有非 const 的 object 才可以调用非 const 的 function。对于 const 的 object 不能只能调用 const 的 function，定义一个 const 的 function 只需要在后面加上关键词 const，头文件定义示例如下：</p><pre><code>class MyClass
{
  public:
    void myPrint() const;
};</code></pre><p>源文件同样的方式：</p><pre><code>#include &quot;MyClass.h&quot;
#include &lt;iostream&gt;
using namespace std;

void MyClass::myPrint() const {
  cout &lt;&lt;&quot;Hello&quot;&lt;&lt;endl;
}</code></pre><p>然后我们就可以实例化一个 const 的 object 使用厘米俺的 const function：</p><pre><code>int main() {
  const MyClass obj;
  obj.myPrint();
}
// Outputs &quot;Hello&quot;</code></pre><p>在一个 const object 调用常规的 function 会引起报错。同时在 const function 内尝试修改 object 内某变量数据也会报错。</p><h3>元素初始化器</h3><p>const 类型的元素数据不能够被改变，且必须在创建时赋值。c++ 提供了一个语法结构来给 class 内元素进行初始化叫做：constructor initializer list 构造器初始化列表。</p><p>以下示例执行会引起报错，因为在 function 中操作的元素有 const 类型的元素：</p><pre><code>class MyClass {
  public:
   MyClass(int a, int b) {
    regVar = a;
    constVar = b;
   }
  private:
    int regVar;
    const int constVar;
};</code></pre><p>const 类型元素在申明后不能再对其修改。</p><p>这时候就需要使用 构造器初始化列表来对其初始化赋值：</p><pre><code>class MyClass {
 public:
  MyClass(int a, int b)
  : regVar(a), constVar(b)
  {
  }
 private:
  int regVar;
  const int constVar;
};</code></pre><p>需要初始化的元素列表下载构造器后，前面使用一个冒号<code>:</code>，每个元素间使用逗号<code>,</code> 分隔。使用语法 <code>variable(value)</code> 来对其赋值。<strong>结尾不需要加分号<code>;</code></strong>。</p><p>使用构造器初始化列表可以用来避免将需要初始化的 const 类型参数放在其 body 内处理而引起错误。</p><p><strong>修改我们的项目文件：</strong></p><p>MyClass.h:</p><pre><code>#ifndef MYCLASS_H
#define MYCLASS_H


class MyClass
{
    public:
        MyClass(int a, int b);
        ~MyClass();

    protected:

    private:
        int regVar;
        const int constVar;
};

#endif // MYCLASS_H</code></pre><p>MyClass.cpp:</p><pre><code>#include &quot;myclass.h&quot;
#include &lt;iostream&gt;

using namespace std;

MyClass::MyClass(int a, int b)
: regVar(a), constVar(b)
{
    cout &lt;&lt; regVar &lt;&lt; endl;
    cout &lt;&lt; constVar &lt;&lt; endl;
}

MyClass::~MyClass()
{
    cout &lt;&lt; &quot;destructor&quot; &lt;&lt; endl;
}</code></pre><p>main.cpp：</p><pre><code>#include &lt;iostream&gt;
#include &quot;myclass.h&quot;

using namespace std;

int main()
{
    MyClass obj(42, 33);

    return 0;
}</code></pre><p>输出结果为：</p><pre><code>42
33
destructor</code></pre><p>注意构造器初始化列表也可以应用于常规变量，但是必须应用于 const 变量。</p><h3>结构化</h3><p>在真实世界中一个 object 可能是很复杂的，由很多其他简单的 objects 构成。例如一辆汽车的组成部分有车身，发动机，轮胎等。这一组合过程叫做结构化。</p><p>在 c++ 中，一个 class 可能作为另一个 class 的元素。下面的例子中我们构建两个 class：Person 和 birthday，且 Person 中包含 Birthday 作为一个元素。</p><p>birthday.h:</p><pre><code>#ifndef BIRTHDAY_H
#define BIRTHDAY_H

class Birthday
{
    public:
        Birthday(int m, int d, int y);
        void printDate();

    protected:

    private:
        int month;
        int day;
        int year;
};

#endif // BIRTHDAY_H</code></pre><p>birthday.cpp: 注意将 function 返回类型放在范围解析符前</p><pre><code>#include &quot;birthday.h&quot;
#include &lt;iostream&gt;

using namespace std;

Birthday::Birthday(int m, int d, int y)
: month(m), day(d), year(y)
{
}

void Birthday::printDate()
{
    cout &lt;&lt; month &lt;&lt; &quot;/&quot; &lt;&lt; day &lt;&lt; &quot;/&quot; &lt;&lt; year &lt;&lt; endl;
}</code></pre><p>persion.h:</p><pre><code>#ifndef PERSON_H
#define PERSON_H
#include &quot;birthday.h&quot;
#include &lt;string&gt;

using namespace std;

class Person
{
    public:
        Person(string n, Birthday b);
        void printInfo();

    protected:

    private:
        string name;
        Birthday bd;
};

#endif // PERSON_H</code></pre><p>persion.cpp:</p><pre><code>#include &quot;person.h&quot;
#include &lt;iostream&gt;

using namespace std;

Person::Person(string n, Birthday b)
: name(n), bd(b)
{
}

void Person::printInfo()
{
    cout &lt;&lt; name &lt;&lt; endl;
    bd.printDate();
}</code></pre><p>Person 包含 name 和 Birthday 两个元素，且在构造器内对其初始化。</p><p>结构化的意义是建立一种<code>包含</code>关系，即 Person 中包含一个 Birthday。在 Person 中有一个 <code>printInfo()</code> 来输出信息，bd 是 Birthday 的实例，所以可以直接使用其 function。</p><p>在 main 中实例化测试：</p><pre><code>#include &quot;person.h&quot;
#include &quot;birthday.h&quot;

using namespace std;

int main()
{
    Birthday bd(11, 25, 1989);
    Person p(&quot;Marco&quot;, bd);
    p.printInfo();

    return 0;
}</code></pre><p>以上示例中，我们首先创建一个 Birthday 的 object 并初始化参数，然后创建一个 Person 的 object 并初始化参数，其中第二个参数使用第一步创建的 object 作为数据，最后调用 Person object 的 function 来输出信息。</p><p>结构化的优势是保持每个 class 相对简单，专注于一个任务。同时让每个各个 object 保持独立性，和可复用性。</p><h3>friend 关键词</h3><p>位于 private 段的 class 里的元素默认无法被外界直接访问，但可以通过在 class 内申明一个并非 class 内部的 friend function 来实现对 private 元素的读取。</p><p>使用关键词 <code>friend</code> 来定义，在 MyClass 头文件中修改如下：</p><pre><code>#ifndef MYCLASS_H
#define MYCLASS_H

class MyClass
{
    public:
        MyClass(int a, int b);
        ~MyClass();

    protected:

    private:
        int regVar;
        const int constVar;

    friend void readPriv(MyClass *obj);
};

#endif // MYCLASS_H
};</code></pre><p>我们在 class 中申明一个 function，传入参数为 class 本身，注意传入的模式是 by reference 也就是传入 object 的地址。详细说明参考：<a href="https://blog.niekun.net/archives/1915.html">C++ 入门教程 -- Functions</a></p><p>然后再外部定义 someFunc 的内容，我直接在 main 中定义，并测试读取 private 参数：</p><pre><code>#include &quot;myclass.h&quot;
#include &lt;iostream&gt;

using namespace std;

void readPriv(MyClass *obj)
{
    cout &lt;&lt; obj-&gt;constVar &lt;&lt; endl;
}

int main()
{
    MyClass a(42, 33);
    MyClass *b = &amp;a;
    readPriv(&amp;a);

    return 0;
}</code></pre><p>输出结果为：</p><pre><code>33
</code></pre><p>再定义 friend function 时，传入 by reference 参数可以写成 <code>*obj</code> 也可以写成 <code>&amp;obj</code>。只是在后续 function 内容中使用 <code>.</code> 还是 <code>-&gt;</code> 调用内部功能。然后再调用 friend function 时是传入 object 地址还是直接传入 object 本身。</p><p><strong>friend function 不属于任何 class。</strong></p><h3>this 关键词</h3><p>每个 c++ object 都有一个指向本身的指针叫做：this。在 object 内部 function 中，可以通过使用 this 指针来引用 object 自身。</p><p>我们建立一个简单的 class：</p><pre><code>class MyClass {
 public:
  MyClass(int a)
  : var(a)
  { }
  void printInfo() {
   cout &lt;&lt; var &lt;&lt; endl;
   cout &lt;&lt; this-&gt;var &lt;&lt; endl;
   cout &lt;&lt; (*this).var &lt;&lt; endl; 
  }
 private:
  int var;
};</code></pre><p><code>printInfo()</code> 中的三条指令会得到相同的结果。this 是一个指针，所以使用 <code>-&gt;</code> 来读取对应地址的数据，也可以使用 <code>*this</code> 数据查询符来表示此地址下的数据。可以参考教程：<a href="https://blog.niekun.net/archives/1898.html">C++ 入门教程 -- 数据类型，数组及指针</a></p><h3>操作符复用</h3><p>大多数 c++ 中的操作符都可以被重新定义。因此让我们自定义的数据类型进行运算操作，比如将两个 object <code>+</code> 加起来。</p><p>以下列表中的操作符可以被复用：<br><img src="https://blog.niekun.net/usr/uploads/2020/11/2807033593.png" alt="1.png" title="1.png"></p><p>不能被复用的符号有：<code>: | .* | . | ?:</code></p><p>我们定义一个简单的 class：</p><pre><code>class MyClass {
 public:
  int var;
  MyClass(int a)
  : var(a)
  { }
};</code></pre><p>下面示例我们将重新定义加号<code>+</code> 来让两个 object 可以加起来。</p><p>定义复用操作符其实是一个 function，通过关键词 operator 和操作符来定义，类似于普通 function，这里也有返回类型和传入数据项需要定义，以下示例中，我们复用加号<code>+</code>，然后返回值为一个此 class 本身的 object，传入数据为一个 object 地址：</p><pre><code>class MyClass {
 public:
  int var;
  MyClass(int a)
  : var(a) { }

  MyClass operator+(MyClass &amp;obj) {
   MyClass res;
   res.var = this-&gt;var+obj.var;
   return res; 
  }
};</code></pre><p>再复用操作符 function 中，我们定义了一个 新的 object，然后使用 <code>this</code> 调用此 object 本身的参数 <code>var</code> 和传入 object 的 <code>var</code> 相加，结果放入新建立的 object 的 <code>var</code> 内，最后返回这个新 object。</p><p>这样定义后，我们就可以直接使用操作符来做运算了：</p><pre><code>int main() {
  MyClass obj1(12), obj2(55);
  MyClass res = obj1 + obj2;

  cout &lt;&lt; res.var;
}

//Outputs 67</code></pre><p>以上就是 class 的基本使用方法。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1920.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/1920.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[C++ 入门教程之五 -- Classes and Objects]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1918.html" />
<id>https://blog.niekun.net/archives/1918.html</id>
<updated>2020-11-20T11:32:00+08:00</updated>
<published>2020-11-20T11:32:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<summary type="html"><![CDATA[object 对象Object Oriented Programming 面向对象编程是为了让编程更加接近于真实世界的理解方式。在程序中，每个 object 是一个独立的 unite 单元，拥有...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/1918.html" xml:lang="zh-CN"><![CDATA[
<h3>object 对象</h3><p>Object Oriented Programming 面向对象编程是为了让编程更加接近于真实世界的理解方式。在程序中，每个 object 是一个独立的 unite 单元，拥有自己的 identify 标识，就像真实世界的某个独立物体一样。</p><p>例如一个苹果就是一个 object，它的 identify 就是名称 <code>苹果</code>，每个苹果都有自己独立的 attributes 属性，如颜色，大小。一个属性就是这个 object 当前状态的描述。不同 object 的 attributes 属性是不一样的，例如一个苹果是绿色的，另一个是红色的。</p><p>在正式世界中 object 都有其 behave 行为，例如汽车的 move 移动，手机的 ring 响铃。这种 object 的行为叫做 object 的 type 类型。</p><p><strong>描述一个 object需要的元素：identify 标识，attributes 属性，behavior 行为</strong></p><!--more--><p>在程序中每个 object 是独立的，拥有独立的 identify 用来区分其他的 object：<br><img src="https://blog.niekun.net/usr/uploads/2020/11/786595094.png" alt="1.png" title="1.png"></p><h3>class</h3><p>我们通过创建 class 来表示 object，一个 class 描述了一个 object 的形象，但是它并不是一个真正的 object，他只是一个对某种 object 结构的定义。一个 class 可以用来建立多个 object。例如一套设计图纸可以用来作为蓝图修建多栋楼房。</p><p>一个 class 包含：identify，attributes，behavior</p><p>程序中，一个对象的 type 就是 class 的 name 名称；Attributes 属性可以是 properties 或 data 数据；behavior 行为通常是一个 function。</p><p>例如我们建立一个银行系统程序：</p><ul><li>name: BankAccount</li><li>attributes: accountNumber, balance, dateOpened</li><li>behavior: open(), close(), deposit()</li></ul><p>一个 class 定义了某种 object 需要的属性和行为。但是它并不直接定义具体的属性值是多少，她只是一个框架的描述。</p><p>当我们写好了一个 class，可以基于这个 class 来创建 objects，这个 object 就是 instance of class，就是 class 的实例。</p><h3>建立 class</h3><p>使用关键字 <code>class</code> 来建立 class，然后定义 class 名称，class 内容写在大括号<code>{}</code> 内。注意每个 class 结尾必须写分号<code>;</code>。例如：</p><pre><code>class BankAccount {

};</code></pre><p>一个 class 的 attributes 和 behaviors 可以设置 access 访问级别。定义时使用关键词 <code>public</code> 不仅可以在 class 内部使用，也可以在 class 外部访问这个属性。也可以是使用关键词 <code>private</code> 或 <code>protected</code>，下面做详细介绍。</p><p>建立一个 class：</p><pre><code>class BankAccount {
  public:
    void sayHi() {
      cout &lt;&lt; &quot;Hi&quot; &lt;&lt; endl;
    }
};</code></pre><p>然后 instance 实例化这个 class：</p><pre><code>int main() 
{
  BankAccount test;
  test.sayHi();
}</code></pre><p>实例化的 object test 拥有其 class 所有的属性和行为。使用点分割符<code>.</code> 来访问 object 的各种属性和 function。</p><h3>抽象化</h3><p>数据抽象化的理念是给外部环境提供最核心的信息，而不用提供具体的细节。比如我们抽象化一本书，我们不用知道他具体有多少也，多少个字，什么颜色。我们只需要知道它是一本书就行了。</p><p>抽象化的理念是面向对象编程最基础的模块。可以让我们建立一个 class 模型，然后基于这个模型创建具体的 objects 对象。</p><h3>封装</h3><p>encapsulation 封装意味着将一个整体包围起来，不仅仅是将其内容放在一起，也可以将其保护起来。它的设计原则就是让外部程序只能够访问其开放的元素，其他内容保持隐藏状态。</p><p>例如我们上面的 BankAccount class，我们不想要外部直接访问修改 balance 余额属性，我们需要其使用 <code>deposit()</code> 或 <code>withdraw()</code> 方法来对其进行操作。所以我们需要将 balance 属性对外隐藏掉，只能通过内部 function 来访问。</p><p>封装的优势有：</p><ul><li>控制内部数据的访问和修改</li><li>代码更加灵活，方便后续根据情况修改</li><li>修改一个地方，不影响其他地方</li></ul><p>下面举例说明如何使用封装来控制内部数据的可访问性，使用 public，private，protected 关键词。</p><p><strong>注意如果没有使用关键词，默认 class 内所有都是 private 类型的。</strong></p><p><strong>访问 public 的数据：</strong></p><pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

class myClass {
  public:
    string name;
};

int main() {
  myClass myObj;
  myObj.name = &quot;SoloLearn&quot;;
  cout &lt;&lt; myObj.name;
  return 0;
}

//Outputs &quot;SoloLearn&quot;</code></pre><p>使用 public 关键词定义可被外部访问的属性，注意关键词后的冒号<code>:</code>。</p><p><strong>使用 private 保护内部数据：</strong></p><pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

class myClass {
  public:
    void setName(string x) {
      name = x;
    }
  private:
    string name;
};

int main() {
  myClass myObj;
  myObj.setName(&quot;John&quot;);

  return 0;
}</code></pre><p>name 不可以被外部直接访问修改，但是通过 <code>setName()</code> 就可以间接修改 name 的值。</p><p><strong>也可以通过 function 间接读取 private 的某些属性：</strong></p><pre><code>class myClass {
  public:
    void setName(string x) {
      name = x;
    }
    string getName() {
      return name;
    }
  private:
    string name;
};</code></pre><p>以上示例，通过建立 public 里的 <code>getName()</code> 方法来读取 name 的值。</p><h3>constructor 构造器</h3><p>constructor 是 class 中特殊的 function，这个 function 的名称和 class 名称一样且没有返回类型，甚至没有 void，它会在 instance 实例化 object 时自动被执行，例如：</p><pre><code>class myClass {
  public:
    myClass() {
      cout &lt;&lt;&quot;Hey&quot;;
    }
    void setName(string x) {
      name = x;
    }
    string getName() {
      return name;
    }
  private:
    string name;
};

int main() {
  myClass myObj;

  return 0;
}

//Outputs &quot;Hey&quot;</code></pre><p>以上示例中，在实例化 myObj 时，会自动执行构造器 function。</p><p>构造器 function 可以方便的让我们在实例化 class 时设置 initial 初始化参数。默认构造器没有参数，如果需要的话我们可以加入参数。例如：</p><pre><code>class myClass {
  public:
    myClass(string nm) {
      setName(nm);
    }
    void setName(string x) {
      name = x;
    }
    string getName() {
      return name;
    }
  private:
    string name;
};

int main() {
  myClass ob1(&quot;David&quot;);
  myClass ob2(&quot;Amy&quot;);
  cout &lt;&lt; ob1.getName();
}
//Outputs &quot;David&quot;</code></pre><p>以上示例中，构造器的作用是使用一个参数给 private name 赋值。当实例化这个 class 时，需要传入构造器需要的参数。</p><p><strong>注意我们可以在一个 class 中建立多个 constructor 构造器，来使用不同的参数。</strong></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1918.html#comments" thr:count="1" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/1918.html" thr:count="1"/>
</entry>
</feed>