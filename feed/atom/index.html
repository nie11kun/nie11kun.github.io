<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"
xmlns:thr="http://purl.org/syndication/thread/1.0"
xml:lang="zh-CN"
xml:base="https://blog.niekun.net/"
>
<title type="text">Marco Nie</title>
<subtitle type="text">you are the company you keep...</subtitle>
<updated>2024-04-02T10:26:03+08:00</updated>
<generator uri="https://typecho.org/" version="1.3.0">Typecho</generator>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/" />
<id>https://blog.niekun.net/feed/atom/</id>
<link rel="self" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/" />
<entry>
<title type="html"><![CDATA[openwrt 系统升级]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/openwrt-1.html" />
<id>https://blog.niekun.net/archives/openwrt-1.html</id>
<updated>2024-04-02T10:26:03+08:00</updated>
<published>2024-04-02T10:26:03+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<category scheme="https://blog.niekun.net/category/Linux/" term="Linux" />
<category scheme="https://blog.niekun.net/category/other/" term="other" />
<summary type="html"><![CDATA[小版本升级小版本升级，例如 19.05-&amp;gt; 19.07。这种小版本的升级最方便的就是通过 Attended Sysupgrade 功能，可以保留已安装的包和系统设置。最大限度地无缝过渡。官...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/openwrt-1.html" xml:lang="zh-CN"><![CDATA[
<h3>小版本升级</h3><p>小版本升级，例如 19.05-&gt; 19.07。</p><p>这种小版本的升级最方便的就是通过 Attended Sysupgrade 功能，可以保留已安装的包和系统设置。最大限度地无缝过渡。官方介绍：<a href="https://openwrt.org/docs/guide-user/installation/attended.sysupgrade">https://openwrt.org/docs/guide-user/installation/attended.sysupgrade</a></p><p>需要先安装 Attended Sysupgrade luci 界面包：</p><pre><code>opkg install luci-app-attendedsysupgrade
</code></pre><p>建议使用此功能前依然做一次数据备份。</p><p>然后重新登录 luci，在 system - Attended Sysupgrade 找到入口，点击 search for firmware upgrade 即可在线搜索可更新的系统。</p><!--more--><h3>大版本升级</h3><p>最方便的就是通过 luci 界面升级系统，目前支持直接升级的大版本顺序是：<strong>19.07 &gt; 21.02 &gt; 22.03 &gt; 23.05</strong>。</p><h3>大版本升级改动</h3><p><strong>openwrt 21</strong>：<a href="https://openwrt.org/releases/21.02/notes-21.02.0">https://openwrt.org/releases/21.02/notes-21.02.0</a></p><ul><li>WPA3 support included by default</li><li>TLS and HTTPS support included by default</li><li>LuCI is now available over HTTPS</li><li>Initial DSA support replaces the swconfig system</li><li>New network configuration syntax and board.json change</li><li>Kernel with container support</li></ul><p><strong>openwrt 22：</strong><a href="https://openwrt.org/releases/22.03/notes-22.03.0">https://openwrt.org/releases/22.03/notes-22.03.0</a></p><ul><li>Firewall4 based on nftables，superseding the iptables-based firewall3</li><li>Dark mode in LuCI</li></ul><p><strong>openwrt 23：</strong><a href="https://openwrt.org/releases/23.05/notes-23.05.0">https://openwrt.org/releases/23.05/notes-23.05.0</a></p><ul><li>Switch from wolfssl to mbedtls as default，TLS 1.3 Support</li><li>Rust Package Support</li></ul><h3>数据备份</h3><p>每个版本升级实际上就是重新刷入了一次固件，所以之前的配置文件什么的基本上都会被覆盖，所以系统内修改过的配置最好做一次备份。</p><p>打开 luci 界面，选择 <strong>system - backup/flash firmware</strong>，在 <strong>configuration</strong> 菜单栏中将需要保存的文件或目录定义出来，然后在 <strong>action</strong> 菜单栏中选择 backup - generate archive 即可保存备份到本地。</p><h3>已安装包列表</h3><p>可以通过 awk 脚本识别出自己手动安装的包列表，方便更新系统后安装回去，下载脚本：<a href="https://github.com/richb-hanover/OpenWrtScripts/blob/main/opkgscript.sh">https://github.com/richb-hanover/OpenWrtScripts/blob/main/opkgscript.sh</a></p><p>执行以下命令会保存已安装的包列表到 <strong>/etc/config/opkg.installed</strong>：</p><pre><code>opkgscript.sh -v write
</code></pre><p>执行以下命令会识别并安装 <strong>/etc/config/opkg.installed</strong> 列表中的包：</p><pre><code>opkgscript.sh -v install
</code></pre><p>也可以执行以下 awk 脚本可以单独列出自己手动安装的包列表：</p><pre><code>#!/usr/bin/awk -f
BEGIN {
    ARGV[ARGC++] = &quot;/usr/lib/opkg/status&quot;
    cmd=&quot;opkg info busybox | grep '^Installed-Time: '&quot;
    cmd | getline FLASH_TIME
    close(cmd)
    FLASH_TIME=substr(FLASH_TIME,17)
}
/^Package:/{PKG= $2}
/^Installed-Time:/{
    INSTALLED_TIME= $2
    # Find all packages installed after FLASH_TIME
    if ( INSTALLED_TIME &gt; FLASH_TIME ) {
        cmd=&quot;opkg whatdepends &quot; PKG &quot; | wc -l&quot;
        cmd | getline WHATDEPENDS
        close(cmd)
        # If nothing depends on the package, it is installed by user
        if ( WHATDEPENDS == 3 ) print PKG
    }
}
EOF</code></pre><p>保存以上内容到 listuserpackages.awk 文件中并执行即可列出用户自行安装包列表。</p><h3>下载升级固件</h3><p>x86 版本的 openwrt 的升级固件就是全新安装时候用的固件，直接在官网下载需要版本的 gz 压缩包即可。</p><p>下载地址：<a href="https://downloads.openwrt.org/releases/">https://downloads.openwrt.org/releases/</a></p><p>我下载的是：<strong>generic-ext4-combined.img.gz</strong>，注意不要解压出来，保留压缩包即可。</p><p>进入 luci 的 <strong>system - backup/flash firmware</strong> 选择 Flash image ，然后选择刚才下载的压缩包即可上传更新，会提示是否保留设置和配置，<strong>跨大版本的升级必须取消选择保留数据，否则可能升级失败</strong>：<br><img src="https://blog.niekun.net/usr/uploads/2024/04/23408611.png" alt="image.png" title="image.png"></p><p>如果升级后卡在 <strong>grub</strong> 界面说明可能是由于选择了保留配置导致升级失败了，可以参考官方教程通过 failsafe mode 恢复默认配置：<a href="https://openwrt.org/docs/guide-user/troubleshooting/failsafe_and_factory_reset">Failsafe mode, factory reset, and recovery mode</a>，或者直接重新安装系统。</p><h3>网络配置</h3><p>稍等几分钟安装好后你可能会发现 luci 无法在局域网中访问了，这是由于新安装的固件恢复了 network 配置，需要直接到 openwrt 设备上配置网络。</p><p>配置教程参考：<a href="https://blog.niekun.net/archives/2291.html">openwrt network 配置</a></p><p>配置好网络后在局域网设备中可以用 ssh 登录了，此时会发现提示：</p><pre><code>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the RSA key sent by the remote host is
SHA256:U9XODs/7A4k065pxSMyEtQ2m98v2P0bf/ML0MfzU.
Please contact your system administrator.
Add correct host key in C:\\Users\\Marco Nie/.ssh/known_hosts to get rid of this message.
Offending RSA key in C:\\Users\\Marco Nie/.ssh/known_hosts:6
Host key for 192.168.244.1 has changed and you have requested strict checking.
Host key verification failed.</code></pre><p>这是由于更新系统后 ssh 指纹发生了变化，需要删除本地缓存的 openwrt 设备的指纹在登陆，windows 系统 ssh 指纹保存地址为当前用户目录下的 <strong>.ssh</strong> 文件夹。</p><h3>升级后续</h3><p>升级后可以通过之前的脚本列出的已安装包的列表将自己需要的包安装回去，同时将备份数据按照新系统的格式恢复回去。</p><p>从 openwrt 21 开始修改了 network 配置文件格式，参考：<a href="https://blog.niekun.net/archives/2291.html">https://blog.niekun.net/archives/2291.html</a><br>从 openwrt 22 开始替换 iptables 为 nftables，需要原始工具的话可以自行安装回去：<strong>opkg install iptables</strong></p><h3>参考链接</h3><p><a href="https://openwrt.org/docs/guide-user/additional-software/opkg#upgrading_packages">Opkg package manager</a><br><a href="https://lowtek.ca/roo/2021/openwrt-19-07-to-21-02-0-upgrade/">OpenWRT 19.07 to 21.02.0 upgrade</a></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/openwrt-1.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/openwrt-1.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[Linux 查询及编辑用户及用户组]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/Linux.html" />
<id>https://blog.niekun.net/archives/Linux.html</id>
<updated>2024-04-01T16:20:00+08:00</updated>
<published>2024-04-01T16:20:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<category scheme="https://blog.niekun.net/category/Linux/" term="Linux" />
<category scheme="https://blog.niekun.net/category/other/" term="other" />
<summary type="html"><![CDATA[查询当前所有用户compgen -u查询当前所有用户组compgen -g添加一个用户到某个组sudo usermod -a -G groupName userNamenewgrp groupN...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/Linux.html" xml:lang="zh-CN"><![CDATA[
<h3>查询当前所有用户</h3><pre><code>compgen -u
</code></pre><h3>查询当前所有用户组</h3><pre><code>compgen -g
</code></pre><h3>添加一个用户到某个组</h3><pre><code>sudo usermod -a -G groupName userName
newgrp groupName
</code></pre><h3>删除一个用户从某个组</h3><pre><code>sudo usermod -G groupName userName
newgrp groupName
</code></pre><p>用户和组对文件的权限管理参考：<a href="https://blog.niekun.net/archives/224.html">chown 和 chmod 管理文件权限</a></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/Linux.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/Linux.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[openwrt 添加新用户]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/openwrt.html" />
<id>https://blog.niekun.net/archives/openwrt.html</id>
<updated>2024-03-29T11:19:26+08:00</updated>
<published>2024-03-29T11:19:26+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<category scheme="https://blog.niekun.net/category/Linux/" term="Linux" />
<summary type="html"><![CDATA[安装好 openwrt 后默认有一个 root 用户，需要添加新用户也很简单，只需要在 /etc/passwd 文件最后按照格式增加一个用户即可，然后可以修改这个新用户的密码。下面使用一条命令快...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/openwrt.html" xml:lang="zh-CN"><![CDATA[
<p>安装好 openwrt 后默认有一个 root 用户，需要添加新用户也很简单，只需要在 <code>/etc/passwd</code> 文件最后按照格式增加一个用户即可，然后可以修改这个新用户的密码。</p><p>下面使用一条命令快速添加新用户：</p><pre><code>grep -qw new_user /etc/passwd || echo &quot;new_user:x:0:23333:::&quot; &gt;&gt; /etc/passwd
</code></pre><p>命令先检查是否在文件中存在需要添加的用户名，如果不存在则在文件最后一行添加用户。</p><p>其中 <strong>new_user</strong> 是用户名，0 是 <strong>uid</strong>，23333 是 <strong>gid</strong>。</p><p>如果需要修改这个新用户的密码，执行命令即可：</p><pre><code>passwd new_user
</code></pre><p>以上就是创建新用户简单方法。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/openwrt.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/openwrt.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[Linux 获取本地网关所有 ip 段地址]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/Linux-ip.html" />
<id>https://blog.niekun.net/archives/Linux-ip.html</id>
<updated>2024-03-28T15:35:07+08:00</updated>
<published>2024-03-28T15:35:07+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<category scheme="https://blog.niekun.net/category/Linux/" term="Linux" />
<category scheme="https://blog.niekun.net/category/other/" term="other" />
<summary type="html"><![CDATA[执行下面命令即可获取本地网关所有的 ip 段地址：$ ip address | grep -w inet | awk '{print $2}'127.0.0.1/8192.168.122.2/2...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/Linux-ip.html" xml:lang="zh-CN"><![CDATA[
<p>执行下面命令即可获取本地网关所有的 ip 段地址：</p><pre><code>$ ip address | grep -w inet | awk '{print $2}'
127.0.0.1/8
192.168.122.2/24
172.18.0.1/16
172.17.0.1/16
172.19.0.1/16</code></pre>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/Linux-ip.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/Linux-ip.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[windows 相对路径快捷方式]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/windows.html" />
<id>https://blog.niekun.net/archives/windows.html</id>
<updated>2024-03-18T10:09:15+08:00</updated>
<published>2024-03-18T10:09:15+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<category scheme="https://blog.niekun.net/category/Windows/" term="Windows" />
<summary type="html"><![CDATA[一般系统默认创建的都是指向某个文件绝对路径的快捷方式，如果移动原始文件位置后，快捷方式就失效了。可以自己修改快捷方式的属性来建立一个以快捷方式所在地址为准的指向一个相对路径的文件。这样适用于需要...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/windows.html" xml:lang="zh-CN"><![CDATA[
<p>一般系统默认创建的都是指向某个文件绝对路径的快捷方式，如果移动原始文件位置后，快捷方式就失效了。</p><p>可以自己修改快捷方式的属性来建立一个以快捷方式所在地址为准的指向一个相对路径的文件。这样适用于需要同时移动原始文件与快捷方式的情况。</p><p>首先右键创建一个文件的快捷方式，然后右键选择快捷方式的属性，将目标位置地址改为：<code>explorer.exe path/to/file.exe</code>。注意 <strong>explorer.exe</strong> 后面的空格：<br><img src="https://blog.niekun.net/usr/uploads/2024/03/3004501885.png" alt="image.png" title="image.png"></p><p>后面的路径就是相对于快捷方式地址的相对路径。</p><p>确认后默认快捷方式图标会变成资源管理器的图标，可以在属性里修改为其他图标。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/windows.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/windows.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[codesys enum 枚举数据类型单元的使用]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/codesys-enum.html" />
<id>https://blog.niekun.net/archives/codesys-enum.html</id>
<updated>2024-03-07T08:21:07+08:00</updated>
<published>2024-03-07T08:21:07+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<category scheme="https://blog.niekun.net/category/other/" term="other" />
<category scheme="https://blog.niekun.net/category/codesys/" term="CODESYS" />
<summary type="html"><![CDATA[enum 类型的 dut 可以定义一组属性及其值，调用的时候可以方便的通过写其属性名称得到属性的值，也可以获取到属性本身的名称。下面举一个例子说明：{attribute 'qualified_o...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/codesys-enum.html" xml:lang="zh-CN"><![CDATA[
<p>enum 类型的 dut 可以定义一组属性及其值，调用的时候可以方便的通过写其属性名称得到属性的值，也可以获取到属性本身的名称。</p><p>下面举一个例子说明：</p><pre><code>{attribute 'qualified_only'}            // 必须先写类型名称再写属性名称 (例如 eColor.Red)
// {attribute 'strict'}                 //取消 'strict' 以允许转换 UDINT 数据类型
{attribute 'to_string'}                 // 运行字符串转换 (例如 TO_STRING(eColor.Red) = 'Red')
TYPE eColor :
(
    Red         := 16#FFFF0000,
    Green       := 16#FF00FF00,
    Blue        := 16#FF0000FF
    Yellow      := 16#FFFFFF00,
) UDINT;                                // 声明 UDINT 作为 int 整形类型
END_TYPE

// 定义一些变量
    ColorVar1   : eColor;
    ColorVar2   : eColor;
    ColorName   : STRING;
    ColorValue  : UDINT;

    ColorVar1 := eColor.Green;            // ColorVar1 = 16#FF00FF00
    ColorName := TO_STRING(ColorVar1);    // ColorName = 'Green';
    ColorValue := TO_UDINT(ColorVar1);    // ColorValue = 16#FF00FF00

    ColorVar2 := 16#FF00FF00;             // ColorVar2.Green
    ColorName := TO_STRING(ColorVar2);    // ColorName = 'Green';
    ColorValue := TO_UDINT(ColorVar2);    // ColorValue = 16#FF00FF00

    ColorVar1 := ColorVar2 OR eColor.Red; // 按位相与得到 Yellow=16#FFFFFF00
    ColorName := TO_STRING(ColorVar1);    // ColorName = 'Yellow';
    ColorValue := TO_UDINT(ColorVar1);    // ColorValue = 16#FFFFFF00</code></pre><p>以上示例列举了常用的 enum 类型可进行的数据交互方式。</p><p><code>eColor.Green</code> 可以获取enum类型属性的值，并可以赋值给其他对应 enum 实例<br><code>TO_STRING(ColorVar1)</code> 可以转换获取 enum 实例当前值对应属性名称字符串</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/codesys-enum.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/codesys-enum.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[codesys 常见编译及下载时报错解决方法]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/codesys.html" />
<id>https://blog.niekun.net/archives/codesys.html</id>
<updated>2024-03-06T16:35:00+08:00</updated>
<published>2024-03-06T16:35:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<category scheme="https://blog.niekun.net/category/other/" term="other" />
<category scheme="https://blog.niekun.net/category/codesys/" term="CODESYS" />
<summary type="html"><![CDATA[No source code available for this object下载时出现此报警，原因是 task 任务中对 gou 的排序有问题，放在前面的 pou 中使用了后面 pou 才设...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/codesys.html" xml:lang="zh-CN"><![CDATA[
<h3>No source code available for this object</h3><p>下载时出现此报警，原因是 task 任务中对 gou 的排序有问题，放在前面的 pou 中使用了后面 pou 才设定好的数据，需要重新排列 task 任务序列：<br><img src="https://blog.niekun.net/usr/uploads/2024/03/1281212428.png" alt="image.png" title="image.png"></p><h3>SMC_FB_CALLED_FROM_WRONG_TASK</h3><p><code>mc_power</code> <code>mc_jog</code> 等控制轴的功能块，一运行就报错 <strong>SMC_FB_CALLED_FROM_WRONG_TASK</strong>，可能是不同的 pou 放在了多个 task 任务中，循环中内部有了冲突，将所有的 pou 放在同一个 task 中就可以解决问题。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/codesys.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/codesys.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[服务器部署 immich 照片备份工具]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/immich.html" />
<id>https://blog.niekun.net/archives/immich.html</id>
<updated>2024-03-04T09:30:00+08:00</updated>
<published>2024-03-04T09:30:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<category scheme="https://blog.niekun.net/category/ubuntu/" term="ubuntu" />
<category scheme="https://blog.niekun.net/category/other/" term="other" />
<summary type="html"><![CDATA[目前有很多的云备份服务可以使用，比如 icloud，google photos 等。immich 是一款实现类似功能的本地部署工具，将数据都存储在自己本地服务器上，拥有完善的手机端 app 可以...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/immich.html" xml:lang="zh-CN"><![CDATA[
<p>目前有很多的云备份服务可以使用，比如 icloud，google photos 等。immich 是一款实现类似功能的本地部署工具，将数据都存储在自己本地服务器上，拥有完善的手机端 app 可以方便的同步备份手机图片。</p><p>GitHub 主页：<a href="https://github.com/immich-app/immich">https://github.com/immich-app/immich</a><br>官网教程：<a href="https://immich.app/docs/overview/introduction/">https://immich.app/docs/overview/introduction/</a></p><!--more--><h3>安装服务端</h3><p>使用 docker compose 安装，新建一个 immich 文件夹，下载 <strong>docker-compose.yml</strong> 和 <strong>.env</strong> 文件到文件夹：</p><pre><code>wget https://github.com/immich-app/immich/releases/latest/download/docker-compose.yml
wget -O .env https://github.com/immich-app/immich/releases/latest/download/example.env</code></pre><p>打开 <strong>.env</strong> 文件配置环境变量，主要就是配置备份路径和数据库密码，修改 <strong>UPLOAD_LOCATION</strong> 和 <strong>DB_PASSWORD</strong>。</p><p>启动容器：</p><pre><code>docker compose up -d</code></pre><p>后续更新只需要进入 immich 文件夹执行下面命令即可：</p><pre><code>docker compose pull &amp;&amp; docker compose up -d
</code></pre><p><strong>docker-compose.yml</strong> 文件中默认将 3001 端口映射到了本地 2283 端口，3001就是服务端访问端口号。</p><p>下面是所有可用的端口，根据需要可以修改 docker-compose 文件映射到本地：</p><table><tbody><tr><td align="center">PORT</td><td align="center">Web Port</td><td>3000</td><td>web</td></tr><tr><td align="center">SERVER_PORT</td><td align="center">Server Port</td><td>3001</td><td>server</td></tr><tr><td align="center">MICROSERVICES_PORT</td><td align="center">Microservices Port</td><td>3002</td><td>microservices</td></tr><tr><td align="center">MACHINE_LEARNING_HOST</td><td align="center">Machine Learning Host</td><td>0.0.0.0</td><td>machine learning</td></tr><tr><td align="center">MACHINE_LEARNING_PORT</td><td align="center">Machine Learning Port</td><td>3003</td><td>machine learning</td></tr></tbody></table><h3>配置账户</h3><p>网页端访问：<strong><a href="http://you.machine.ip:2283">http://you.machine.ip:2283</a></strong> 进入配置页面，根据提示建立一个管理员账户，后续可以在管理员账户中建立其他子账户供其他人使用。</p><h3>登录 app</h3><p>下载手机端 app，ios 直接在 app store 搜索 immich 下载，安卓在 github 发布页下载 apk：<a href="https://github.com/immich-app/immich/releases">https://github.com/immich-app/immich/releases</a></p><p>在手机端输入以下网址进入：<strong><a href="http://you.machine.ip:2283/api">http://you.machine.ip:2283/api</a></strong></p><p>然后就可以配置需要备份的手机端图片文件夹了。</p><h3>外网访问</h3><p>服务器在本地，如果要外网域名远程访问图库，需要一些额外的配置，我这里是通过 cloudflare 配置子域名，nginx 配置反向代理到 frps，最后本地服务器 frpc 配置本地 2283 端口绑定到远程域名访问即可。</p><p>可以参考我之前的关于 frp 的教程：<a href="https://blog.niekun.net/archives/539.html">https://blog.niekun.net/archives/539.html</a></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/immich.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/immich.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[RTE runtime添加 ethercat master 的步骤]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/ethercat.html" />
<id>https://blog.niekun.net/archives/ethercat.html</id>
<updated>2024-02-23T15:41:00+08:00</updated>
<published>2024-02-23T15:41:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<category scheme="https://blog.niekun.net/category/codesys/" term="CODESYS" />
<summary type="html"><![CDATA[codesys 配置 rte runtime 添加 ethercat 组件的方法。主要步骤为：安装 RTE runtime安装适配网卡驱动添加 ethercat master 设备]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/ethercat.html" xml:lang="zh-CN"><![CDATA[
<p>codesys 配置 rte runtime 添加 ethercat 组件的方法。</p><p>主要步骤为：</p><ul><li>安装 RTE runtime</li><li>安装适配网卡驱动</li><li>添加 ethercat master 设备</li></ul><!--more--><h3>安装 RTE runtime</h3><p>首先需要配置工控机啊 BIOS 设置，将一些超线程，电源管理等选项关掉：</p><ul><li>关闭超线程：<br><img src="https://blog.niekun.net/usr/uploads/2024/02/3799761613.png" alt="image.png" title="image.png"></li><li><p>关闭BIOS 中激活的所有节能选项</p><ul><li>Intel Speed Step动态节能技术</li><li>EIST智能降频</li><li>C-States省电模式</li><li>PowerNow动态调整CPU的工作频率和电压</li><li>Hibernation休眠</li><li>MWAIT</li></ul></li><li><p>停用可能导致系统管理中断的所有内容</p><ul><li>BIOS self tests BIOS自检</li><li>USB Legacy Device Support 传统USB设备支持</li></ul><p><img src="https://blog.niekun.net/usr/uploads/2024/02/1587511684.png" alt="image.png" title="image.png"></p></li></ul><p>然后就可以安装 RTE，官网下载需要的 runtime 安装包，注意区分 x86 还是 x64 设备。我下载的是 **CODESYS Control RTE SL （×86Windows 实时）。</p><p>官网下载地址：<a href="http://store.codesys.cn/codesys/store/index.html">http://store.codesys.cn/codesys/store/index.html</a></p><p>在工控机上解压并安装需要的 RTE runtime，基本都是直接下一步即可，期间注意选择带不带 softmotion：<br><img src="https://blog.niekun.net/usr/uploads/2024/02/4109829724.png" alt="image.png" title="image.png"></p><p>Control RTE 文件路径：<strong>C:\Program Files\CODESYS\CODESYS Control RTE3</strong><br>Control RTE 安装路径：<strong>C:\ProgramData\CODESYS\CODESYSControlRTEV3</strong></p><h3>网卡驱动</h3><p>支持的网卡：<br>Systems with Windows and CODESYS Control RTE (Real-time SoftPLC):</p><ul><li>Realtek® 8139 (CmpRTL81x9Mpd)</li><li>Realtek RTL8139 and compatible Ethernet-Controller, as well 8100/8110</li><li>Realtek 8169 (CmpRTL8169Mpd)</li><li>Realtek 8169/810, RTL8111B / RTL8111D</li><li>Intel® EtherExpressPro1000 (CmpEt1000Drv) --- All gigabit adapters from Intel</li><li>Intel EtherExpress PRO/100 (CmpEt100Drv)  --- All 100 Mbit adapters from Intel</li></ul><p>一般情况下 intel 的千兆网卡都可以安装 CmpEt1000Drv 驱动。</p><p>首先进入设备管理器，选择需要更新 codesys 驱动的网卡，右键选择更新驱动：<br><img src="https://blog.niekun.net/usr/uploads/2024/02/526443326.png" alt="image.png" title="image.png"></p><p>选择从本地查找驱动程序：<br><img src="https://blog.niekun.net/usr/uploads/2024/02/445439546.png" alt="image.png" title="image.png"></p><p>选择从磁盘安装，从 RTE 文件路径找到对应的驱动目录并安装：<br><img src="https://blog.niekun.net/usr/uploads/2024/02/4143604295.png" alt="image.png" title="image.png"><br><img src="https://blog.niekun.net/usr/uploads/2024/02/1468480814.png" alt="image.png" title="image.png"></p><p>右键选择 plc configuration：<br><img src="https://blog.niekun.net/usr/uploads/2024/02/1814919560.png" alt="image.png" title="image.png"></p><p>在 components manager 中在最后一个空行中填入安装的驱动名称，这里我填的是 CmpEt1000Drv：<br><img src="https://blog.niekun.net/usr/uploads/2024/02/2838203674.png" alt="image.png" title="image.png"></p><p>确定并重启 plc 即可完成网卡驱动的安装及配置。</p><h3>添加 ethercat master</h3><p>在codesys 开发项目中进行以下操作。</p><ul><li>建立一个支持 softmotion 的设备</li><li>添加 ethercat master softmotion 主站  （会自动添加 ethercat_task 任务 不可删除)</li><li>扫描并连接到控制器</li><li>配置 ethercat master 网卡，RTE 版 runtime 需要选择适配 codesys 的网卡<br><img src="https://blog.niekun.net/usr/uploads/2024/02/1566796952.png" alt="image.png" title="image.png"><br><img src="https://blog.niekun.net/usr/uploads/2024/02/3608593676.png" alt="image.png" title="image.png"></li><li>下载程序到控制器，如果上面没有在 components manager 中添加网卡组件的话，这里下载会报错</li><li>退出登录 扫描从站并添加<br><img src="https://blog.niekun.net/usr/uploads/2024/02/232930198.png" alt="image.png" title="image.png"><br><img src="https://blog.niekun.net/usr/uploads/2024/02/205582750.png" alt="image.png" title="image.png"></li><li>如果设备描述文件没有在系统内置库中 需要手动导入描述文件然后才能扫描识别<br><img src="https://blog.niekun.net/usr/uploads/2024/02/137766102.png" alt="image.png" title="image.png"><br><img src="https://blog.niekun.net/usr/uploads/2024/02/3769356211.png" alt="image.png" title="image.png"><br><img src="https://blog.niekun.net/usr/uploads/2024/02/1816416840.png" alt="image.png" title="image.png"></li><li>给扫描到的从站添加 cia402 轴<br><img src="https://blog.niekun.net/usr/uploads/2024/02/2632555381.png" alt="image.png" title="image.png"></li><li>配置电子齿轮比<br><img src="https://blog.niekun.net/usr/uploads/2024/02/3358342902.png" alt="image.png" title="image.png"></li></ul><p>以上就是 RTE runtime 版添加 ethercat master 主站的简单方法。</p><h3>参考链接：</h3><p><a href="https://forge.codesys.com/forge/talk/Runtime/thread/e16d310712/">Control RTE SL and profinet connections</a></p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/ethercat.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/ethercat.html" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[Ubuntu 20.04 添加第三方 ppa]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/Ubuntu-20-04-ppa.html" />
<id>https://blog.niekun.net/archives/Ubuntu-20-04-ppa.html</id>
<updated>2024-02-22T09:18:33+08:00</updated>
<published>2024-02-22T09:18:33+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<category scheme="https://blog.niekun.net/category/ubuntu/" term="ubuntu" />
<category scheme="https://blog.niekun.net/category/other/" term="other" />
<summary type="html"><![CDATA[我服务器目前安装的是 Ubuntu 20.04 系统，很多新的软件包并没有在官方维护的源中提供，所以为了方便需要可以添加第三方的源。添加需要用到的命令是：add-apt-repository，但...]]></summary>
<content type="html" xml:base="https://blog.niekun.net/archives/Ubuntu-20-04-ppa.html" xml:lang="zh-CN"><![CDATA[
<p>我服务器目前安装的是 Ubuntu 20.04 系统，很多新的软件包并没有在官方维护的源中提供，所以为了方便需要可以添加第三方的源。</p><p>添加需要用到的命令是：<strong>add-apt-repository</strong>，但是默认系统并没有安装这个环境，需要先手动安装 package software-properties-common：</p><pre><code>sudo apt install software-properties-common
</code></pre><p>然后就可以安装需要的源了，推荐两个：<br><a href="https://launchpad.net/%7Esavoury1/+archive/ubuntu/backports?field.series_filter=bionic">https://launchpad.net/%7Esavoury1/+archive/ubuntu/backports?field.series_filter=bionic</a><br><a href="https://launchpad.net/%7Esavoury1/+archive/ubuntu/utilities?field.series_filter=bionic">https://launchpad.net/%7Esavoury1/+archive/ubuntu/utilities?field.series_filter=bionic</a></p><p>安装方法很简单：</p><pre><code>sudo add-apt-repository ppa:savoury1/backports
sudo add-apt-repository ppa:savoury1/utilities
sudo apt-get update</code></pre><p>执行 apt update 后会发现很多可更新的软件了。</p>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/Ubuntu-20-04-ppa.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/archives/Ubuntu-20-04-ppa.html" thr:count="0"/>
</entry>
</feed>