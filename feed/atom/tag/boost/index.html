<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"
xmlns:thr="http://purl.org/syndication/thread/1.0"
xml:lang="zh-CN"
xml:base="https://blog.niekun.net/tag/boost/"
>
<title type="text">Marco Nie - boost</title>
<subtitle type="text"></subtitle>
<updated>2020-02-27T13:39:00+08:00</updated>
<generator uri="http://typecho.org/" version="1.2.0">Typecho</generator>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/tag/boost/" />
<id>https://blog.niekun.net/feed/atom/tag/boost/</id>
<link rel="self" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/tag/boost/" />
<entry>
<title type="html"><![CDATA[编译 boost lib 库]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/1174.html" />
<id>https://blog.niekun.net/archives/1174.html</id>
<updated>2020-02-27T13:39:00+08:00</updated>
<published>2020-02-27T13:39:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<content type="html" xml:base="https://blog.niekun.net/archives/1174.html" xml:lang="zh-CN"><![CDATA[
<div id="md_content_1" class="md_content" style="min-height: 50px;"><textarea id="append-test" style="display:none;">![2020-02-27T01:06:24.png][1]

boost 是很流行的一个 c++ 库，他的部分模块使用只需要引用 head 文件即可，部分需要编译链接库才能使用。下面介绍如何编译模块的静态链接库。

官方网站：https://www.boost.org/
开始教程：https://www.boost.org/doc/libs/1_72_0/more/getting_started/windows.html
官方编译教程：https://www.boost.org/doc/libs/1_72_0/more/getting_started/windows.html#prepare-to-use-a-boost-library-binary
关于 B2 编译系统：https://boostorg.github.io/build/
关于 Microsoft Visual C++(MSVC) 版本号：https://en.wikipedia.org/wiki/Microsoft_Visual_C%2B%2B#Internal_version_numbering
关于静态库和动态库：
<!--more-->

### boost 库下载

从官方链接下载最新版 boost 库：https://www.boost.org/users/download/

解压到磁盘目录，最好放置在单独管理软件环境库的目录，方便管理。

需要编译库文件才能使有的模块如下：
```
    - atomic
    - chrono
    - container
    - context
    - contract
    - coroutine
    - date_time
    - exception
    - fiber
    - filesystem
    - graph
    - graph_parallel
    - headers
    - iostreams
    - locale
    - log
    - math
    - mpi
    - program_options
    - python
    - random
    - regex
    - serialization
    - stacktrace
    - system
    - test
    - thread
    - timer
    - type_erasure
    - wave
```
### Windows 编译

#### 编译器配置

各平台支持的编译器类型：https://www.boost.org/doc/libs/1_72_0/more/getting_started/windows.html#identify-your-toolset

Windows 下支持的编译器是：gcc 和 msvc，我 windows 电脑安装的是 visual studio 2019 的 c++ 开发包，所以我使用 msvc 作为编译器。

使用 msvc 编译，需要在 c++ 开发包的基础上在 visual studio installer 里安装 Windows CRT SDK，不然在执行 bootstrap 时会报错：
![2020-02-27T01:24:42.png][2]

booost 支持指定 msvc 版本，所以首先查看我安装的 msvc 版本，可以在 visual studio installer 里查看当前安装的 msvc：
![2020-02-27T01:23:36.png][3]

或者可以通过 VS 版本号来查询 msvc 版本：https://en.wikipedia.org/wiki/Microsoft_Visual_C%2B%2B#Internal_version_numbering

打开 boost 文件夹目录下的 bootstrap.bat 可以看到在执行脚本时也可以通过参数指定 msvc 版本：
```
SET TOOLSET=msvc

IF "%1"=="gcc" SET TOOLSET=gcc

IF "%1"=="vc71" SET TOOLSET=msvc : 7.1
IF "%1"=="vc8" SET TOOLSET=msvc : 8.0
IF "%1"=="vc9" SET TOOLSET=msvc : 9.0
IF "%1"=="vc10" SET TOOLSET=msvc : 10.0
IF "%1"=="vc11" SET TOOLSET=msvc : 11.0
IF "%1"=="vc12" SET TOOLSET=msvc : 12.0
IF "%1"=="vc14" SET TOOLSET=msvc : 14.0
IF "%1"=="vc141" SET TOOLSET=msvc : 14.1
IF "%1"=="vc142" SET TOOLSET=msvc : 14.2
```

#### 编译模块

首先通过 boost 文件夹目录下的 **bootstrap.bat** 来安装 Boost.Build (b2) 编译工具。

关于什么是 Boost.Build (b2) 参考：https://boostorg.github.io/build/

使用 vc++ 的终端来执行脚本如 **native tool cmd**，也可以在终端下指定 msvc 版本来编译。

将目录 cd 到 boost 目录然后运行 bootstrap，使用 vc142 作为参数：
![2020-02-27T01:34:41.png][4]

如果出错，会在 boost 目录下生成 bootstrap.log 文件，查看具体出错信息。

成功执行后在 boost 目录会有一个 b2.exe 文件，执行 .\\b2 --help 可以查看帮助，下面需要这个 b2 来编辑模块库文件。

再次打开终端，切换到 boost 目录，运行下面的命令：
    cd \TOYOURBOOSTPATH
    b2 --toolset=msvc-14.2 link=static runtime-link=static --build-type=complete stage

- **--toolset=msvc-14.2**       定义了编译器名称
- **link=static**               定义了链接库为静态，就是将链接库本身编译为静态的，动态设置为 **shared**
- **runtime-link=static**       定义了运行链接库为静态，就是程序使用此库打包时为静态的，动态设置为 **shared**
- **--build-type=complete**     定义了编译所有支持的变种库
- **stage**                     定义了库文件路径：**.\\stage\\lib**。想要更换其他路径使用 **--stagedir=directory** 参数来定义

关于 link 和 runtime-link 参考：https://www.quora.com/What-is-the-difference-between-static-runtime-and-dynamic-linking

其他可用的参数使用 **b2 --help** 来查看。

成功编译完成后，链接库文件在 **.\\stage\\lib\\** 目录下。

### macOS 编译

macOS 下默认使用 Clang 编译器。编译方法和 Windows 类似。

终端切换到 boost 目录，运行：
    ./bootstrap.sh

生成 b2 文件后就可以进行编译，可以不指定编译器，默认为 Clang：
        b2 link=static runtime-link=static stage

### boost 库的使用

使用 boost 库需要将 head 头文件文件夹和 lib 链接库文件夹在编译器里指定。

官方手册：https://www.boost.org/doc/libs/1_72_0/more/getting_started/windows.html#link-your-program-to-a-boost-library

head 文件夹路径：PathTo\\boost_1_72_0\\boost
lib 库文件夹路径：PathTo\\boost_1_72_0\\stage\\lib

**下面介绍在 visual studio 2019 如何使用 boost。**

打开 c++ 项目文件，在右侧 **solution explorer** 中，在项目名右键点击 **properties** 或者 快捷键 alt + enter：
![2020-02-27T05:27:40.png][5]

选择 **c/c++ - general**，右侧菜单 **additional include directories** 中输入 boost 根路径：
![2020-02-27T05:29:56.png][6]

选择 **linker - general**，右侧菜单 **additional library directories** 中输入 lib 路径，来包含 lib 库文件：
![2020-02-27T05:33:05.png][7]

由于我们编译的是静态链接库，所以需要将 runtime library 设置为静态，选择 **c/c++ - code generation**，右侧菜单 **runtime library** 选择 **MT/MTD**，MT 代表 release，MTD 代表 debug：
![2020-02-27T05:36:13.png][8]

以上就把 boost 连接到了环境中，使用只需要 include 需要的模块即可，例如：
    #include "boost/filesystem.hpp"


  [1]: https://niekun.net/usr/uploads/2020/02/2617505775.png
  [2]: https://niekun.net/usr/uploads/2020/02/2125873377.png
  [3]: https://niekun.net/usr/uploads/2020/02/67995277.png
  [4]: https://niekun.net/usr/uploads/2020/02/3871338465.png
  [5]: https://niekun.net/usr/uploads/2020/02/1425466925.png
  [6]: https://niekun.net/usr/uploads/2020/02/2349038897.png
  [7]: https://niekun.net/usr/uploads/2020/02/1912327834.png
  [8]: https://niekun.net/usr/uploads/2020/02/2344815031.png</textarea></div>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/1174.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/tag/boost/" thr:count="0"/>
</entry>
<entry>
<title type="html"><![CDATA[boost库里使用path的指针问题]]></title>
<link rel="alternate" type="text/html" href="https://blog.niekun.net/archives/95.html" />
<id>https://blog.niekun.net/archives/95.html</id>
<updated>2019-02-21T14:03:00+08:00</updated>
<published>2019-02-21T14:03:00+08:00</published>
<author>
    <name>admin</name>
    <uri>https://niekun.net</uri>
</author>
<content type="html" xml:base="https://blog.niekun.net/archives/95.html" xml:lang="zh-CN"><![CDATA[
<div id="md_content_2" class="md_content" style="min-height: 50px;"><textarea id="append-test" style="display:none;">近期在开发过程中遇到一个奇怪的问题，当我复制一个文件夹到新目录时候总是失败，查看日志发现是传递地址出错了。
我是使用的是Boost的filesystem C++库处理文件，下面是代码片段，将path类型的地址放入一个指针，然后调用其他function：

    fs::path childDir = np;
    childDir += "/\\" + dir_itr->path().filename().string();
    const char* c_childDir = childDir.string().c_str();

我在本机实验是没有问题，但在他人电脑上提示directory error。
我将path里的地址先存放到一个string里然后在转换为char*，发现问题解决了。
我想可能的原因就是path不能直接使用其指针地址。下面是修改后的程序片段：

    string s_childDir = newDir;
    s_childDir += "/\\" + dir_itr->path().filename().string();
    const char* c_childDir = s_childDir.c_str();

以上就是关于boost库里使用path的指针问题的解决方法。</textarea></div>
]]></content>
<link rel="replies" type="text/html" href="https://blog.niekun.net/archives/95.html#comments" thr:count="0" />
<link rel="replies" type="application/atom+xml" href="https://blog.niekun.net/feed/atom/tag/boost/" thr:count="0"/>
</entry>
</feed>