<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
xmlns:content="http://purl.org/rss/1.0/modules/content/"
xmlns:dc="http://purl.org/dc/elements/1.1/"
xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
xmlns:atom="http://www.w3.org/2005/Atom"
xmlns:wfw="http://wellformedweb.org/CommentAPI/">
<channel>
<title>Marco Nie - media process</title>
<link>https://blog.niekun.net/category/media/</link>
<atom:link href="https://blog.niekun.net/feed/category/media/" rel="self" type="application/rss+xml" />
<language>zh-CN</language>
<description></description>
<lastBuildDate>Sat, 09 Apr 2022 11:19:00 +0800</lastBuildDate>
<pubDate>Sat, 09 Apr 2022 11:19:00 +0800</pubDate>
<item>
<title>快速色彩矫正 in Photoshop</title>
<link>https://blog.niekun.net/archives/2589.html</link>
<guid>https://blog.niekun.net/archives/2589.html</guid>
<pubDate>Sat, 09 Apr 2022 11:19:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[一张照片是否好看，首先要保证色彩没有偏色，也就是白平衡要正确，白平衡的调整之前介绍过通过 curve 曲线工具的，下面介绍精确匹配白平衡的方法，以及快速处理动作。胶卷底片复原照片 in Phot...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p><img src="https://blog.niekun.net/usr/uploads/2022/04/3013645743.png" alt="2022-04-09T02:27:56.png" title="2022-04-09T02:27:56.png"></p><p>一张照片是否好看，首先要保证色彩没有偏色，也就是白平衡要正确，白平衡的调整之前介绍过通过 curve 曲线工具的，下面介绍精确匹配白平衡的方法，以及快速处理动作。</p><p><a href="https://blog.niekun.net/archives/548.html">胶卷底片复原照片 in Photoshop</a></p><p>用到的技术：曲线，白场灰场黑场、auto option</p><!--more--><p>原图如下：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/2215360856.png" alt="2022-04-09T02:34:47.png" title="2022-04-09T02:34:47.png"></p><p>可以看到颜色有点偏色。</p><h3>手动处理</h3><p>新建曲线图层，作为调整图层，然后在曲线图层上新建一个空白图层作为标记图层：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/1672009746.png" alt="2022-04-09T02:36:40.png" title="2022-04-09T02:36:40.png"></p><p>我们的目的是通过曲线图层找出图片中的<strong>最亮、最黑、灰度</strong>的部分，然后通过曲线的白场黑场灰场设置来恢复色彩平衡。</p><p>首先找到图片最黑的地方，调整曲线右侧拉刀左边，直到图片中保留最小的黑色区域：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/1311732250.png" alt="2022-04-09T02:42:59.png" title="2022-04-09T02:42:59.png"></p><p>找出一个区域，用画笔工具在最上面的图层做一个标记：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/1157584171.png" alt="2022-04-09T02:44:07.png" title="2022-04-09T02:44:07.png"></p><p>然后找图片最亮的地方，恢复曲线，从右边向左边拉，直到图片中保留最小区域的白色区域：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/777166748.png" alt="2022-04-09T02:45:44.png" title="2022-04-09T02:45:44.png"></p><p>最上面图层做出标记：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/1551401310.png" alt="2022-04-09T02:46:18.png" title="2022-04-09T02:46:18.png"></p><p>然后找到图片中的灰色区域，方法就是建立一个50度灰图层，混合模式改为 difference，这样最接近灰色的图像就会显示为黑色，先将曲线图层关闭：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/295084910.png" alt="2022-04-09T02:48:21.png" title="2022-04-09T02:48:21.png"></p><p>在最上面图层做出标记：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/3387390219.png" alt="2022-04-09T02:49:43.png" title="2022-04-09T02:49:43.png"></p><p>下面我们开始匹配颜色。</p><p>关闭灰度图层，将曲线图层打开并恢复默认，然后分别双击左侧三个吸管，确保都恢复为默认的黑场灰场白场的默认颜色：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/1279689009.png" alt="2022-04-09T02:53:06.png" title="2022-04-09T02:53:06.png"></p><p>点击第一个黑场的吸管，在图像标记为黑色的区域点击：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/3803780167.png" alt="2022-04-09T02:54:37.png" title="2022-04-09T02:54:37.png"></p><p>可以看到黑色颜色正确了，但是黑色区域细节有丢失，将左侧曲线向上稍微提高，恢复黑色细节：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/1336539960.png" alt="2022-04-09T02:56:02.png" title="2022-04-09T02:56:02.png"></p><p>然后点击第三个白场吸管，在图像标记为白色的区域点击：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/2360073508.png" alt="2022-04-09T02:57:10.png" title="2022-04-09T02:57:10.png"></p><p>同样的，调整右侧曲线向下，恢复高光区域细节：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/3103911770.png" alt="2022-04-09T02:58:08.png" title="2022-04-09T02:58:08.png"></p><p>最后点击第二个灰场吸管，点击灰色标记区域：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/25292787.png" alt="2022-04-09T02:59:47.png" title="2022-04-09T02:59:47.png"></p><p>这样白平衡基本就匹配了，关闭观察标记图层。</p><p>可以看到饱和度有点高了，新建 hue 图层，手型工具点击面部饱和度过高区域：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/3906852984.png" alt="2022-04-09T03:01:37.png" title="2022-04-09T03:01:37.png"></p><p>先将区域缩小，将hue 和 饱和度调到最大，如果区域不合适，拖动下方滑块调节：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/852354062.png" alt="2022-04-09T03:03:09.png" title="2022-04-09T03:03:09.png"></p><p>恢复调整参数，适当扩展滑块过渡区域，然后降低饱和度：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/4013151058.png" alt="2022-04-09T03:04:38.png" title="2022-04-09T03:04:38.png"></p><p>以上我们就手动完成了图片的色彩矫正，核心规则就是找到图片的黑白灰区域，然后通过曲线来匹配它们到标准颜色。</p><h3>自动处理</h3><p>但是手动做这个过程比较繁琐麻烦，起始 Photoshop 提供了自动化执行以上过程的工具，就在 curve 曲线工具中。</p><p>我们重新开始项目，在图像上建立曲线图层，点击曲线设置菜单中的 auto option：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/3467875716.png" alt="2022-04-09T03:11:48.png" title="2022-04-09T03:11:48.png"></p><p>选中 snap neutral midtone，然后点击上面的各个选项，观察哪个处理的最好：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/124139002.png" alt="2022-04-09T03:13:56.png" title="2022-04-09T03:13:56.png"></p><p>确认后，曲线就自动完成了色彩校正，之后根据情况做相应调整。这里我感觉自动处理后，地面有点偏绿，正常应该是灰色的，所以在此使用灰场吸管点击地面区域，这样地面颜色就正常了：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/4181821182.png" alt="2022-04-09T03:16:40.png" title="2022-04-09T03:16:40.png"></p><p>面部饱和度过高，和上面手动处理同样的方法降低面部饱和度：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/3890138417.png" alt="2022-04-09T03:18:02.png" title="2022-04-09T03:18:02.png"></p><p>这样就快速完成了色彩修复。</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2589.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/category/media/</wfw:commentRss>
</item>
<item>
<title>快速皮肤修复 in Photoshop</title>
<link>https://blog.niekun.net/archives/2576.html</link>
<guid>https://blog.niekun.net/archives/2576.html</guid>
<pubDate>Sat, 09 Apr 2022 09:49:46 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[人像处理中皮肤修复是很重要也很浪费时间的步骤，之前介绍了通过频率分离的方法处理，下面介绍一种快速有效的皮肤修复方法。PHP频率分离处理皮肤 in PhotoshopPhotoshop 皮肤处理进...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p><img src="https://blog.niekun.net/usr/uploads/2022/04/1393907339.png" alt="2022-04-09T01:45:18.png" title="2022-04-09T01:45:18.png"><br>人像处理中皮肤修复是很重要也很浪费时间的步骤，之前介绍了通过频率分离的方法处理，下面介绍一种快速有效的皮肤修复方法。</p><p><a href="https://blog.niekun.net/archives/2502.html">PHP频率分离处理皮肤 in Photoshop</a><br><a href="https://blog.niekun.net/archives/234.html">Photoshop 皮肤处理进阶</a></p><p>使用到的技术：反转图像、vivid light、high pass 高反差保留、高斯模糊</p><!--more--><p>原图如下：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/470269642.png" alt="2022-04-09T01:33:34.png" title="2022-04-09T01:33:34.png"></p><p>复制原图图层，转换为 smart object 方便后期调整，快捷键 ctrl I 反转图像：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/2455846906.png" alt="2022-04-09T01:36:00.png" title="2022-04-09T01:36:00.png"></p><p>混合模式改为 vivid light：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/85049859.png" alt="2022-04-09T01:36:18.png" title="2022-04-09T01:36:18.png"></p><p>选择 filter - other - high pass：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/2466724394.png" alt="2022-04-09T01:37:39.png" title="2022-04-09T01:37:39.png"></p><p>设置合适数值，使面部细节模糊，痘痘消失：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/2460340086.png" alt="2022-04-09T01:39:22.png" title="2022-04-09T01:39:22.png"></p><p>选择 gilter - blur - 高斯模糊，调整数值使得面部细节纹理恢复，但面部瑕疵消失：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/3862475052.png" alt="2022-04-09T01:41:47.png" title="2022-04-09T01:41:47.png"></p><p>此时这个图层就完成了面部瑕疵的修复，但我们只需要这种处理对面部需要的地方生效，所以按住 alt 点击建立图层蒙版，然后用白色笔刷工具刷出需要处理的皮肤部分：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/2036473136.png" alt="2022-04-09T01:44:45.png" title="2022-04-09T01:44:45.png"></p><p>最终效果如下：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/41428720.png" alt="2022-04-09T01:49:15.png" title="2022-04-09T01:49:15.png"></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2576.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/category/media/</wfw:commentRss>
</item>
<item>
<title>给T恤添加图案 in Photoshop</title>
<link>https://blog.niekun.net/archives/2522.html</link>
<guid>https://blog.niekun.net/archives/2522.html</guid>
<pubDate>Fri, 01 Apr 2022 15:56:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[图像中的衣服是一个立体空间，如果想要将一个二维图像添加到衣服表面需要进行一些处理。下面就介绍简单的过程。之前介绍过如果给一面旗帜添加文字信息可以参考：https://blog.niekun.ne...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p><img src="https://blog.niekun.net/usr/uploads/2022/04/2042380042.png" alt="2022-04-01T07:29:40.png" title="2022-04-01T07:29:40.png"><br>图像中的衣服是一个立体空间，如果想要将一个二维图像添加到衣服表面需要进行一些处理。下面就介绍简单的过程。</p><p>之前介绍过如果给一面旗帜添加文字信息可以参考：<a href="https://blog.niekun.net/archives/261.html">https://blog.niekun.net/archives/261.html</a></p><p>用到的主要技术：扭曲工具、通道选区、multiply 混合、screen 混合、curve 曲线、quick selection tool</p><!--more--><p>原图如下：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/114702101.png" alt="2022-04-01T07:30:34.png" title="2022-04-01T07:30:34.png"></p><p>首先导入需要添加的图案：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/3405908190.png" alt="2022-04-01T07:33:03.png" title="2022-04-01T07:33:03.png"></p><p>将图案转换为 smart object，首先使用扭曲工具调整图案的立体感，需要根据衣服褶皱的变化去调整图案的不同区域，可以设置将背景显示出来方便观察调整：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/3109982303.png" alt="2022-04-02T00:33:10.png" title="2022-04-02T00:33:10.png"></p><p>调整后如下：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/3946940411.png" alt="2022-04-02T00:35:36.png" title="2022-04-02T00:35:36.png"></p><p><strong>如果图案清晰度过高，和背景相比差异太大，可以使用高斯模糊适当降低图案清晰度。</strong></p><p>按 ctrl 点击图层选取图案部分选取，然后在图案下面新建 hue saturation 图层将图案背后的衣服部分饱和度降低，避免以后影响图案部分颜色效果：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/1816281875.png" alt="2022-04-01T07:37:39.png" title="2022-04-01T07:37:39.png"></p><p>复制 dragon 图层，然后屏蔽原始 dragon 图层作为备份，将复制的图层重命名为 multiply，混合模式改为 multiply：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/1135705732.png" alt="2022-04-01T07:39:41.png" title="2022-04-01T07:39:41.png"></p><p>这个图层是用来处理暗部区域，由于我们只想衣服的暗部区域加载这个暗部图案，所以我们需要分离衣服暗部和亮部区域。</p><p>之前的教程中，介绍了使用 sytle 中的 blend if 来过滤暗部亮部，达到预期效果：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/2123691173.png" alt="2022-04-01T07:48:31.png" title="2022-04-01T07:48:31.png"></p><p>但是这个方法也有缺陷，第二个调整栏会将当前图层下面的所有图层作为整体对待，而不能单独选取某一个图层进行混合，如果我们需要连续建立了多个进行 blend if 混合的图形对最下面的某个图片进行混合，那么这些混合图层之间互相也会影响。</p><p>下面介绍如果通过选区来独立处理暗部亮部区域。</p><p>先将<strong>除背景图层外的所有图层屏蔽</strong>，然后选中背景图层，注意一定要先关闭其他图层不然下面的选区会受到影响：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/1625922481.png" alt="2022-04-02T00:39:10.png" title="2022-04-02T00:39:10.png"></p><p>进入通道菜单栏，选择一个对比大的通道，按住 ctrl 点击通道获取选区，这里选择 red 通道，注意<strong>这里看到的通道不能包含除背景图层外的其他图层</strong>，否则选区会不准确：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/1346500547.png" alt="2022-04-02T00:43:46.png" title="2022-04-02T00:43:46.png"></p><p>这里的选区选区的就是图像的亮部区域。</p><p>回到图层，选择 multiply 图层添加蒙版：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/1616205531.png" alt="2022-04-02T00:53:39.png" title="2022-04-02T00:53:39.png"></p><p>由于选取部分是亮部区域，但是我们的 multiply 处理的是暗部区域，所以选中图层蒙版点击 ctrl I 反转蒙版即可：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/3600463570.png" alt="2022-04-02T00:54:04.png" title="2022-04-02T00:54:04.png"></p><p>这样蒙版白色区域就表示暗部区域。</p><p>观察蒙版，整体是灰色的，这样暗部亮部分离就不是很明显，为了获得选区更大的对比度，可以对蒙版进行曲线操作，选中蒙版点击 image - adjustment - curve：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/1018549820.png" alt="2022-04-01T07:59:30.png" title="2022-04-01T07:59:30.png"></p><p>此时，我们期望将亮部区域排除，也就是蒙版的暗部区域让他更暗，我们对比图片调整曲线：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/4288124020.png" alt="2022-04-02T00:54:50.png" title="2022-04-02T00:54:50.png"></p><p>曲线中将左侧向右调整蒙版的黑色区域增加，这样图像亮部就过滤掉了，同时我们将右侧曲线也向右调整是为了更加提高对比。</p><p>然后复制 multiply 图层，重命名为 screen，同时将混合模式改为 screen：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/498955037.png" alt="2022-04-02T00:55:14.png" title="2022-04-02T00:55:14.png"></p><p>screen图层用来处理图章的亮部区域，但是这里的蒙版白色区域还是表示暗部区域，所以点击 ctrl I 反转图层蒙版，这样图层就只对作用于亮部区域：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/4097281617.png" alt="2022-04-02T00:55:34.png" title="2022-04-02T00:55:34.png"></p><p>根据实际情况，可以对 screen 图层蒙版调整曲线，使其之影响亮部区域：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/3339325055.png" alt="2022-04-02T00:56:25.png" title="2022-04-02T00:56:25.png"></p><p>这样基本框架就完成了，下面增加更多的对比使整体更加有立体感。</p><p>复制 multiply 图层，使暗部更暗，调整蒙版曲线使图层只作用于最暗的地方，根据情况调整不透明度：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/295185865.png" alt="2022-04-02T00:57:25.png" title="2022-04-02T00:57:25.png"><br><img src="https://blog.niekun.net/usr/uploads/2022/04/2039392734.png" alt="2022-04-02T00:57:59.png" title="2022-04-02T00:57:59.png"></p><p>同样的复制 screen 图层，使亮部更量，调整蒙版曲线使图层只作用域最量的地方：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/3128906501.png" alt="2022-04-02T00:58:38.png" title="2022-04-02T00:58:38.png"><br><img src="https://blog.niekun.net/usr/uploads/2022/04/3741620936.png" alt="2022-04-02T00:59:09.png" title="2022-04-02T00:59:09.png"></p><p>这样图案立体感就更突出了一些，可以根据实际情况复制更多的 multiply 和 screen 图层进行调整。</p><p>然后根据实际情况我们调整图案的色相饱和度，按住 ctrl 点击图案图层获取选区，在最上边新建 hue saturation 图层，这样调整饱和度只影响图案部分：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/373626570.png" alt="2022-04-02T01:05:38.png" title="2022-04-02T01:05:38.png"></p><p>最后我们处理图案多余部分，将图案调整图层都放在一个 group中：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/1635192553.png" alt="2022-04-02T01:07:13.png" title="2022-04-02T01:07:13.png"></p><p>选中背景图层，使用 quick selection tool 快速选区工具或者其他你熟悉的工具，将手臂部分选出来：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/285121387.png" alt="2022-04-02T01:08:36.png" title="2022-04-02T01:08:36.png"></p><p>选中 dragon group 添加蒙版，然后 ctrl I 反转蒙版，如果还有哪里有多余部分，使用画笔工具涂抹蒙版调整即可：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/3711126892.png" alt="2022-04-02T01:10:20.png" title="2022-04-02T01:10:20.png"></p><p>最终效果如下：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/1081423978.png" alt="2022-04-02T01:12:09.png" title="2022-04-02T01:12:09.png"></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2522.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/category/media/</wfw:commentRss>
</item>
<item>
<title>PHP频率分离处理皮肤 in Photoshop</title>
<link>https://blog.niekun.net/archives/2502.html</link>
<guid>https://blog.niekun.net/archives/2502.html</guid>
<pubDate>Thu, 31 Mar 2022 14:23:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[频率分离在处理人像或需要平滑表面的地方非常有效，在之前的教程中介绍过频率分离的方法，下面介绍在实际应用中，在频率分离后如何进行下一步处理。Photoshop 皮肤处理进阶通过频率分离修复褶皱衣服...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p><img src="https://blog.niekun.net/usr/uploads/2022/03/1445182711.png" alt="2022-03-31T07:01:16.png" title="2022-03-31T07:01:16.png"><br>频率分离在处理人像或需要平滑表面的地方非常有效，在之前的教程中介绍过频率分离的方法，下面介绍在实际应用中，在频率分离后如何进行下一步处理。</p><p><a href="https://blog.niekun.net/archives/234.html">Photoshop 皮肤处理进阶</a><br><a href="https://blog.niekun.net/archives/2480.html">通过频率分离修复褶皱衣服 in Photoshop</a></p><p>频率分离 action：<a href="https://blog.niekun.net/usr/uploads/2022/03/3505141817.atn">PiX - Frequency Separation.atn</a></p><p>PHP 表示：<strong>patching修补，healing修复，polishing抛光</strong></p><!--more--><p>关于频率分离的原理和过程请参考上面的链接，下面直接使用 action 快速完成。</p><p>原图如下：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/2227247445.png" alt="2022-03-31T06:03:55.png" title="2022-03-31T06:03:55.png"></p><p>在分离图像前，我们首先简单处理皮肤明显的痘痕等瑕疵部分，使用污点修复工具即可，新建一个图层，选择 healing brush tool：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/3990515347.png" alt="2022-03-31T06:08:25.png" title="2022-03-31T06:08:25.png"></p><p>alt 选取痘痘周边皮肤，点击修复所有的痘痘，注意 sample 选择 current and below：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/3156588273.png" alt="2022-03-31T06:13:27.png" title="2022-03-31T06:13:27.png"></p><p>我们通过 action 快速分离图像，我们图像是 8 bit 模式的所以使用 FS 8bit动作(image - mode 可以查看当前图片模式)：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/2566558770.png" alt="2022-03-31T06:05:30.png" title="2022-03-31T06:05:30.png"></p><p>执行 action 过程中弹出手动设置高斯模糊值，先拉到最小，然后一点点调大直到皮肤细节消失：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/3672291004.png" alt="2022-03-31T06:25:52.png" title="2022-03-31T06:25:52.png"></p><p>action 会自动创建好分离图像图层：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/3706681730.png" alt="2022-03-31T06:26:56.png" title="2022-03-31T06:26:56.png"></p><p>下面进行 PHP 第一步 patching，将皮肤上大块的色差区域修复，使用了 patch tool。</p><p>首先关闭上面的 texture 图层，然后复制 color 图层命名为 patching：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/435202253.png" alt="2022-03-31T06:29:53.png" title="2022-03-31T06:29:53.png"></p><p>使用 patch tool 将皮肤上有明显下次和色差的部分修复：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/3892234277.png" alt="2022-03-31T06:31:44.png" title="2022-03-31T06:31:44.png"></p><p>处理完成后打开 texture 图层查看效果：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/3847355496.png" alt="2022-03-31T06:36:58.png" title="2022-03-31T06:36:58.png"></p><p>然后第二部 healing，也就是通过 heal tool 修复一些小瑕疵部分，复制 patching 图层，使用 heal tool 进行下一步修复，同样的需要临时关闭 texture 图层。</p><p>例如我们通过 heal tool 修复额头多余的头发和面部细微部分的色差区域：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/2558594.png" alt="2022-03-31T06:43:05.png" title="2022-03-31T06:43:05.png"></p><p>处理完成后打开 texture 图层查看效果：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/1817357442.png" alt="2022-03-31T06:44:01.png" title="2022-03-31T06:44:01.png"></p><p>第三步 polishing，也就是对皮肤高光阴影的平滑处理，让整体光线过渡更加均匀，复制 healing 图层重命名为 polishing，同样的暂时关闭 texture 图层。</p><p>这里使用笔刷工具，流量调到 2 左右即可：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/206378435.png" alt="2022-03-31T06:47:40.png" title="2022-03-31T06:47:40.png"></p><p>我们先处理嘴唇的阴影部分，按住 alt 点击阴影部分选取颜色，然后在需要过渡的地方进行涂抹：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/3490742444.png" alt="2022-03-31T06:52:34.png" title="2022-03-31T06:52:34.png"></p><p>然后鼻子上的亮度分布我们使用同样的方法进行调整，让光线更加平顺：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/569513820.png" alt="2022-03-31T06:56:22.png" title="2022-03-31T06:56:22.png"></p><p>根据情况调整其他地方的光线，完成后打开 texture 图层查看效果：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/1910910714.png" alt="2022-03-31T06:57:18.png" title="2022-03-31T06:57:18.png"></p><p>最终效果对比如下：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/474750464.png" alt="2022-03-31T06:59:10.png" title="2022-03-31T06:59:10.png"></p>
]]></content:encoded>
<slash:comments>1</slash:comments>
<comments>https://blog.niekun.net/archives/2502.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/category/media/</wfw:commentRss>
</item>
<item>
<title>通过频率分离修复褶皱衣服 in Photoshop</title>
<link>https://blog.niekun.net/archives/2480.html</link>
<guid>https://blog.niekun.net/archives/2480.html</guid>
<pubDate>Tue, 29 Mar 2022 17:07:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[之前介绍过通过高低频率分离可以处理皮肤柔化，它可以方便的单独处理颜色和反差部分。下面介绍通过高低频分离将褶皱的衣服平顺化，同时保持其原有的真实过渡部分。用到的技术主要有：高斯模糊、apply i...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p><img src="https://blog.niekun.net/usr/uploads/2022/03/4069145759.png" alt="2022-03-29T06:05:20.png" title="2022-03-29T06:05:20.png"></p><p>之前介绍过通过高低频率分离可以处理皮肤柔化，它可以方便的单独处理颜色和反差部分。下面介绍通过高低频分离将褶皱的衣服平顺化，同时保持其原有的真实过渡部分。</p><p>用到的技术主要有：高斯模糊、apply image、linear light、mixer brush tool、patch tool</p><!--more--><p>原图如下，可以看到衣服褶皱很明显：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/2440759349.png" alt="2022-03-29T09:08:08.png" title="2022-03-29T09:08:08.png"></p><p>首先复制两个图层，分别命名为 color 和 texture：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/1204853365.png" alt="2022-03-29T08:26:51.png" title="2022-03-29T08:26:51.png"></p><p>先临时关闭 texture 图层，将 color 图层执行高斯模糊：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/1213210024.png" alt="2022-03-29T08:29:40.png" title="2022-03-29T08:29:40.png"></p><p>根据实际情况，调节滑块将主体的布料细节等杂乱色彩柔化，最终基本看不出明显细节：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/2181621932.png" alt="2022-03-29T08:32:15.png" title="2022-03-29T08:32:15.png"></p><p>然后打开 texture 图层，执行 image - apply image。layer 选择 下方的 color 图层，混合模式选择 subtract，scale 选择 2，offset 设置为 128，上面设置的意思就是将 texture 图层每个像素都减去下方的 color 图层，将结果减为 0 的部分填充为 50度灰色，scale 影响轮廓范围：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/2255720486.png" alt="2022-03-29T08:33:17.png" title="2022-03-29T08:33:17.png"></p><p>然后将 texture 混合模式改为 linear light，我们会发现现在显示的图像和原图是一样的：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/2429814177.png" alt="2022-03-29T08:36:54.png" title="2022-03-29T08:36:54.png"></p><p>以上我们就将原图拆解为 color 和 texture 两部分，可以对其进行分别调整。</p><p>下面我们开始处理褶皱问题，关闭 texture 图层，然后使用 mixer brush tool 将 color 图层颜色分布均匀化处理，这个笔刷可以选取周围图片某个地方的像素，然后在其他地方可以涂抹出相似的颜色。</p><p>由于需要使用色彩选取功能，首先我们确保选取颜色的时候是 3<em>3 或 5</em>5 范围而不是单个像素。</p><p>点击色彩选取工具，将上面的设置为合适数据：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/3250683780.png" alt="2022-03-29T08:43:36.png" title="2022-03-29T08:43:36.png"></p><p>然后点击 mixer brush tool，在上面的默认数据基础上将流量调到30左右，将平滑处理降到0：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/136779272.png" alt="2022-03-29T08:44:53.png" title="2022-03-29T08:44:53.png"></p><p>然后使用柔边笔刷，选择一个有褶皱的区域，点击 alt 选取周边一个颜色，开始涂抹需要处理的区域，处理过程中注意不同区域需要尽量选取其周边颜色进行涂抹，这样过度更加自然。涂抹过程中可以打开背景图层观察效果：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/3092609583.png" alt="2022-03-29T08:55:36.png" title="2022-03-29T08:55:36.png"></p><p>涂抹完成后打开 texture 查看效果：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/2533149555.png" alt="2022-03-29T08:56:14.png" title="2022-03-29T08:56:14.png"></p><p>可以看到很明显的效果，大部分的褶皱都没有了，但是还是可以看到一些线条：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/2659390146.png" alt="2022-03-29T08:57:15.png" title="2022-03-29T08:57:15.png"></p><p>但是在 color 图层却不明显，这些线条就是存在于 texture 图层的高频部分，需要在 texture 图层处理它们。</p><p>使用的方法就是通过污点修复工具将这些线条去掉，选中 texture 图层，这里我使用 patch tool：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/4123661308.png" alt="2022-03-29T09:00:02.png" title="2022-03-29T09:00:02.png"></p><p>选取一个需要去除的线条，拖拽到其他完好区域，查看效果：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/2338892645.png" alt="2022-03-29T09:01:51.png" title="2022-03-29T09:01:51.png"></p><p><img src="https://blog.niekun.net/usr/uploads/2022/03/1838316854.png" alt="2022-03-29T09:02:25.png" title="2022-03-29T09:02:25.png"></p><p>同样的步骤处理其他所有区域，最终效果如下：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/3982807076.png" alt="2022-03-29T09:10:31.png" title="2022-03-29T09:10:31.png"></p><p>以上就完成了折痕的处理。</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2480.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/category/media/</wfw:commentRss>
</item>
<item>
<title>彩图转黑白 in Photoshop</title>
<link>https://blog.niekun.net/archives/2472.html</link>
<guid>https://blog.niekun.net/archives/2472.html</guid>
<pubDate>Mon, 28 Mar 2022 14:04:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[黑白图片在某些场景下有其独特的风格，在人像摄影中可以体现出一种另类的雕塑感，下面通过实例介绍如何从一个彩色图片处理为一张黑白效果。使用的工具主要是 gradient map 和 camera r...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p><img src="https://blog.niekun.net/usr/uploads/2022/03/3939178568.png" alt="2022-03-28T05:38:15.png" title="2022-03-28T05:38:15.png"></p><p>黑白图片在某些场景下有其独特的风格，在人像摄影中可以体现出一种另类的雕塑感，下面通过实例介绍如何从一个彩色图片处理为一张黑白效果。使用的工具主要是 gradient map 和 camera raw。</p><p>下面是原始图片：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/4128302864.jpg" alt="Black and White - Gradient Map - Sample Image.jpg" title="Black and White - Gradient Map - Sample Image.jpg"></p><p>首先在原图上方建立 gradient map 图层，gradient map 的作用是根据图像的亮度分布进行颜色替换：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/4117532377.png" alt="2022-03-28T05:43:51.png" title="2022-03-28T05:43:51.png"></p><p>首先将下方的 method 改为 classic，这样过渡效果更加平顺一些：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/389677896.png" alt="2022-03-28T05:47:49.png" title="2022-03-28T05:47:49.png"></p><p>默认是一个反色效果渐变，点击渐变条，修改其属性为左边黑色右边白色：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/3910938814.png" alt="2022-03-28T05:46:56.png" title="2022-03-28T05:46:56.png"></p><p>下面我们增加黑白色差效果，调节左侧下方滑块可以使得黑色区域更黑，调节右侧下方滑块可以使得白色区域更白，调节中间滑块可以调节黑白区域范围：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/1041442527.png" alt="2022-03-28T05:50:16.png" title="2022-03-28T05:50:16.png"></p><p>调节到合适效果后确认即可，这样我们初步就有了一个效果。</p><p>下面为了让背景更加黑，我们通过选取提取出背景，创建一个纯黑背景。选中图像图层，选区工具下选中 select and mask：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/2572737743.png" alt="2022-03-28T05:54:09.png" title="2022-03-28T05:54:09.png"></p><p>点击 select subject 可以自动选中主体：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/4005078115.png" alt="2022-03-28T05:55:10.png" title="2022-03-28T05:55:10.png"></p><p>点击 color aware 和 shift edge 调节选区边沿：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/2779694229.png" alt="2022-03-28T05:56:49.png" title="2022-03-28T05:56:49.png"></p><p>确认后可以获取到主体的选取，创建一个 solid color 黑色图层，选中蒙版，ctrl I 反转选区即可：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/3398572673.png" alt="2022-03-28T05:58:39.png" title="2022-03-28T05:58:39.png"></p><p>放大我们可以发现主体边沿和背景没有完美的融合，这时可以通过复制刚才的 gradient map 图层强化黑白效果，然后通过笔刷工具将复制的图层只保留主体边沿部分，注意使用笔刷的时候不透明度调节稍微低一些：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/4030393213.png" alt="2022-03-28T06:10:16.png" title="2022-03-28T06:10:16.png"></p><p>基本效果已经可以了，下面调节细节部分，首先眼睛需要提亮，新建 curves 图层，提亮曲线后反转蒙版，使用笔刷工具涂抹出眼睛的亮度：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/1597724556.png" alt="2022-03-28T06:15:36.png" title="2022-03-28T06:15:36.png"></p><p>黑白图片效果一般在提高锐度的时候会更加具有特点，下面我们通过 camera raw 来做调整。</p><p>首先快捷键 ctrl shift alt E 盖印图层，然后转换为 smart object 方便后期返回来调整参数：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/4247719213.png" alt="2022-03-28T06:19:44.png" title="2022-03-28T06:19:44.png"></p><p>然后点击 filter - camera raw filter 进入编辑模式。</p><p>为了更加强烈的反差，我首先调节了亮度参数：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/2963793412.png" alt="2022-03-28T06:24:52.png" title="2022-03-28T06:24:52.png"></p><p>然后就是锐化的重点 - 提高 clarity 清晰度参数，注意不要调的过高而失真：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/3214151862.png" alt="2022-03-28T06:25:57.png" title="2022-03-28T06:25:57.png"></p><p>完成后保存返回 Photoshop，适当调节不透明度使图片更加自然：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/867381413.png" alt="2022-03-28T06:27:27.png" title="2022-03-28T06:27:27.png"></p><p>最终效果如下：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/4039780371.png" alt="2022-03-28T06:27:53.png" title="2022-03-28T06:27:53.png"></p><!--more-->
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2472.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/category/media/</wfw:commentRss>
</item>
<item>
<title>FFmpeg 简单用法</title>
<link>https://blog.niekun.net/archives/1752.html</link>
<guid>https://blog.niekun.net/archives/1752.html</guid>
<pubDate>Fri, 18 Sep 2020 15:03:12 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[FFmpeg 是视频处理最常用的开源软件。它功能强大，用途广泛，大量用于视频网站和商业软件（比如 Youtube 和 iTunes），也是许多音频和视频格式的标准编码/解码实现。官方网站：htt...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>FFmpeg 是视频处理最常用的开源软件。</p><p>它功能强大，用途广泛，大量用于视频网站和商业软件（比如 Youtube 和 iTunes），也是许多音频和视频格式的标准编码/解码实现。</p><p>官方网站：<a href="https://www.ffmpeg.org/">https://www.ffmpeg.org/</a></p><!--more--><h3>安装</h3><p>最简单的方法就是用包管理工具如：apt 安装：</p><pre><code>apt update
apt install ffmpeg
</code></pre><p>或者也可以从源码安装，可以参考我之前的教程：<a href="https://blog.niekun.net/archives/891.html">https://blog.niekun.net/archives/891.html</a></p><h3>常用指令</h3><p>查看 ffmpeg 版本：</p><pre><code>ffmpeg -version
</code></pre><p>查看支持的编码格式：如 h.264, h.265</p><pre><code>ffmpeg -codecs
</code></pre><p>查看支持的容器：如 mp4, mp3, mkv</p><pre><code>ffmpeg -formats
</code></pre><p>查看已安装的编码器：如 libx264, libx265, libvpx, aac</p><pre><code>ffmpeg -encoders
</code></pre><h3>使用格式</h3><p>FFmpeg 的命令行参数非常多，可以分成五个部分。</p><pre><code>ffmpeg {1} {2} -i {3} {4} {5}
</code></pre><p>上面命令中，五个部分的参数依次如下：</p><pre><code>全局参数
输入文件参数
输入文件
输出文件参数
输出文件</code></pre><p>参数太多的时候，为了便于查看，ffmpeg 命令可以写成多行:</p><pre><code>$ ffmpeg \
[全局参数] \
[输入文件参数] \
-i [输入文件] \
[输出文件参数] \
[输出文件]</code></pre><p>下面是一个例子:</p><pre><code>ffmpeg \
-y \ # 全局参数
-c:a libfdk_aac -c:v libx264 \ # 输入文件参数
-i input.mp4 \ # 输入文件
-c:v libvpx-vp9 -c:a libvorbis \ # 输出文件参数
output.webm # 输出文件</code></pre><p>上面的命令将 mp4 文件转成 webm 文件，这两个都是容器格式。输入的 mp4 文件的音频编码格式是 aac，视频编码格式是 H.264；输出的 webm 文件的视频编码格式是 VP9，音频格式是 Vorbis。</p><p>如果不指明编码格式，FFmpeg 会自己判断输入文件的编码。<strong>一般可以省略输入文件参数。</strong></p><h3>常用命令参数</h3><pre><code>-c：指定编码器
-c copy：直接复制，不经过重新编码（这样比较快）
-c:v：指定视频编码器
-c:a：指定音频编码器
-i：指定输入文件
-an：去除音频流
-vn： 去除视频流
-preset：指定输出的视频质量，会影响文件的生成速度，有以下几个可用的值 ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow。
-y：不经过确认，输出时直接覆盖同名文件。</code></pre><h3>常规使用方法</h3><p>查看元数据信息，如时长，比特率等：</p><pre><code>ffmpeg -i test.mp4
</code></pre><p>输出的信息较多，可以通过 -hide_banner 只显示媒体文件信息：</p><pre><code>ffmpeg -i test.mp4 -hide_banner
</code></pre><p>转码，如 avi to h.264:</p><pre><code>ffmpeg -i test.avi -c:v libx264 test.mp4
</code></pre><p>转换容器：</p><pre><code>ffmpeg -i test.mp4 -c copy test.webm</code></pre><p>转换容器不需要转码，所以直接 copy 即可。</p><p>转换码率，转换成固定码率：</p><pre><code>ffmpeg -i test.mp4 -b:v 500k test_out.mp4
</code></pre><p>转换码率，转换成一个码率范围：</p><pre><code>ffmpeg -i test.mp4 -minrate 964K -maxrate 3856K -bufsize 2000K test_out.mp4
</code></pre><p>改变分辨率：转换成 480p</p><pre><code>ffmpeg \
-i input.mp4 \
-vf scale=480:-1 \
output.mp4</code></pre><p>视频中提取音频：</p><pre><code>ffmpeg \
-i input.mp4 \
-vn -c:a copy \
output.aac</code></pre><p>上面例子中，<code>-vn</code> 表示去掉视频，<code>-c:a copy</code> 表示不改变音频编码，直接拷贝。</p><p>视频截图：下面的例子是从指定时间开始，连续对1秒钟的视频进行截图</p><pre><code>ffmpeg \
-y \
-i input.mp4 \
-ss 00:01:24 -t 00:00:01 \
output_%3d.jpg</code></pre><p><code>%3d</code> 在 shell 里表示至少输出3个字符空间的数字：</p><pre><code>% means &quot;Print a variable here&quot;
3 means &quot;use at least 3 spaces to display, padding as needed&quot;
d means &quot;The variable will be an integer&quot;</code></pre><p>如果只需要截一张图，可以指定只截取一帧。</p><pre><code>$ ffmpeg \
-ss 01:23:45 \
-i input \
-vframes 1 -q:v 2 \
output.jpg</code></pre><p>上面例子中，<code>-vframes 1</code> 指定只截取一帧，<code>-q:v 2</code> 表示输出的图片质量，一般是1到5之间（1 为质量最高）。</p><p><strong>裁剪:</strong><br>裁剪（cutting）指的是，截取原始视频里面的一个片段，输出为一个新视频。可以指定开始时间（start）和持续时间（duration），也可以指定结束时间（end）。</p><pre><code>$ ffmpeg -ss [start] -i [input] -t [duration] -c copy [output]
$ ffmpeg -ss [start] -i [input] -to [end] -c copy [output]</code></pre><p>下面是实际的例子。</p><pre><code># 从1分50秒开始截取10.5秒
ffmpeg -ss 00:01:50 -i test.mp4 -t 10.5 -c copy out.mp4

# 从25秒开始截取10秒
ffmpeg -ss 25 -i test.mp4 -to 10 -c copy out.mp4
ffmpeg -i test.mp4 -ss 25 -to 10 -c copy out.mp4</code></pre><p>上面例子中，<code>-c copy</code> 表示不改变音频和视频的编码格式，直接拷贝，这样会快很多。</p><h3>高级用法</h3><h4>压缩视频内容到指定容量大小</h4><p>使用的技术主要是 ffmpeg 的 2 pass 方法和 ffprobe 得到码率和时长信息。</p><p>bash脚本：</p><pre><code>#!/bin/bash

target_video_size_MB=&quot;$2&quot;
origin_duration_s=$(ffprobe -v error -show_streams -select_streams a &quot;$1&quot; | grep -Po &quot;(?&lt;=^duration\=)\d*\.\d*&quot;)
origin_audio_bitrate_kbit_s=$(ffprobe -v error -pretty -show_streams -select_streams a &quot;$1&quot; | grep -Po &quot;(?&lt;=^bit_rate\=)\d*\.\d*&quot;)
target_audio_bitrate_kbit_s=$origin_audio_bitrate_kbit_s # TODO for now, make audio bitrate the same
target_video_bitrate_kbit_s=$(\
    awk \
    -v size=&quot;$target_video_size_MB&quot; \
    -v duration=&quot;$origin_duration_s&quot; \
    -v audio_rate=&quot;$target_audio_bitrate_kbit_s&quot; \
    'BEGIN { print  ( ( size * 8192.0 ) / ( 1.048576 * duration ) - audio_rate ) }')

ffmpeg \
    -y \
    -i &quot;$1&quot; \
    -c:v libx264 \
    -b:v &quot;$target_video_bitrate_kbit_s&quot;k \
    -pass 1 \
    -an \
    -f mp4 \
    /dev/null \
&amp;&amp; \
ffmpeg \
    -i &quot;$1&quot; \
    -c:v libx264 \
    -b:v &quot;$target_video_bitrate_kbit_s&quot;k \
    -pass 2 \
    -c:a aac \
    -b:a &quot;$target_audio_bitrate_kbit_s&quot;k \
    &quot;${1%.*}-$2mB.mp4&quot;</code></pre><p><strong>使用方法：</strong>压缩视频到 50 MB 大小</p><pre><code>./script.sh test.mp4 50
</code></pre><h4>切割视频到指定时长的多个视频</h4><p>使用的技术主要是 python，ffprobe 得到视频时长，然后计算需要切割为几个视频。<br>python 脚本：</p><pre><code>#!/usr/bin/env python

import csv
import subprocess
import math
import json
import os
import shlex
from optparse import OptionParser


def split_by_manifest(filename, manifest, vcodec=&quot;copy&quot;, acodec=&quot;copy&quot;,
                      extra=&quot;&quot;, **kwargs):

    if not os.path.exists(manifest):
        print(&quot;File does not exist: %s&quot; % manifest)
        raise SystemExit

    with open(manifest) as manifest_file:
        manifest_type = manifest.split(&quot;.&quot;)[-1]
        if manifest_type == &quot;json&quot;:
            config = json.load(manifest_file)
        elif manifest_type == &quot;csv&quot;:
            config = csv.DictReader(manifest_file)
        else:
            print(&quot;Format not supported. File must be a csv or json file&quot;)
            raise SystemExit

        split_cmd = [&quot;ffmpeg&quot;, &quot;-i&quot;, filename, &quot;-vcodec&quot;, vcodec,
                     &quot;-acodec&quot;, acodec, &quot;-y&quot;] + shlex.split(extra)
        try:
            fileext = filename.split(&quot;.&quot;)[-1]
        except IndexError as e:
            raise IndexError(&quot;No . in filename. Error: &quot; + str(e))
        for video_config in config:
            split_str = &quot;&quot;
            split_args = []
            try:
                split_start = video_config[&quot;start_time&quot;]
                split_length = video_config.get(&quot;end_time&quot;, None)
                if not split_length:
                    split_length = video_config[&quot;length&quot;]
                filebase = video_config[&quot;rename_to&quot;]
                if fileext in filebase:
                    filebase = &quot;.&quot;.join(filebase.split(&quot;.&quot;)[:-1])

                split_args += [&quot;-ss&quot;, str(split_start), &quot;-t&quot;,
                               str(split_length), filebase + &quot;.&quot; + fileext]
                print(&quot;########################################################&quot;)
                print(&quot;About to run: &quot;+&quot; &quot;.join(split_cmd+split_args))
                print(&quot;########################################################&quot;)
                subprocess.check_output(split_cmd+split_args)
            except KeyError as e:
                print(&quot;############# Incorrect format ##############&quot;)
                if manifest_type == &quot;json&quot;:
                    print(&quot;The format of each json array should be:&quot;)
                    print(&quot;{start_time: &lt;int&gt;, length: &lt;int&gt;, rename_to: &lt;string&gt;}&quot;)
                elif manifest_type == &quot;csv&quot;:
                    print(&quot;start_time,length,rename_to should be the first line &quot;)
                    print(&quot;in the csv file.&quot;)
                print(&quot;#############################################&quot;)
                print(e)
                raise SystemExit


def get_video_length(filename):

    output = subprocess.check_output((&quot;ffprobe&quot;, &quot;-v&quot;, &quot;error&quot;, &quot;-show_entries&quot;,
                                      &quot;format=duration&quot;, &quot;-of&quot;, &quot;default=noprint_wrappers=1:nokey=1&quot;, filename)).strip()
    video_length = int(float(output))
    print(&quot;Video length in seconds: &quot;+str(video_length))

    return video_length


def ceildiv(a, b):
    return int(math.ceil(a / float(b)))


def split_by_seconds(filename, split_length, vcodec=&quot;copy&quot;, acodec=&quot;copy&quot;,
                     extra=&quot;&quot;, video_length=None, **kwargs):
    if split_length and split_length &lt;= 0:
        print(&quot;Split length can't be 0&quot;)
        raise SystemExit

    if not video_length:
        video_length = get_video_length(filename)
    split_count = ceildiv(video_length, split_length)
    if(split_count == 1):
        print(&quot;Video length is less then the target split length.&quot;)
        raise SystemExit

    split_cmd = [&quot;ffmpeg&quot;, &quot;-i&quot;, filename, &quot;-vcodec&quot;,
                 vcodec, &quot;-acodec&quot;, acodec] + shlex.split(extra)
    try:
        filebase = &quot;.&quot;.join(filename.split(&quot;.&quot;)[:-1])
        fileext = filename.split(&quot;.&quot;)[-1]
    except IndexError as e:
        raise IndexError(&quot;No . in filename. Error: &quot; + str(e))
    for n in range(0, split_count):
        split_args = []
        if n == 0:
            split_start = 0
        else:
            split_start = split_length * n

        split_args += [&quot;-ss&quot;, str(split_start), &quot;-t&quot;, str(split_length),
                       filebase + &quot;-&quot; + str(n+1) + &quot;-of-&quot; +
                       str(split_count) + &quot;.&quot; + fileext]
        print(&quot;About to run: &quot;+&quot; &quot;.join(split_cmd+split_args))
        subprocess.check_output(split_cmd+split_args)


def main():
    parser = OptionParser()

    parser.add_option(&quot;-f&quot;, &quot;--file&quot;,
                      dest=&quot;filename&quot;,
                      help=&quot;File to split, for example sample.avi&quot;,
                      type=&quot;string&quot;,
                      action=&quot;store&quot;
                      )
    parser.add_option(&quot;-s&quot;, &quot;--split-size&quot;,
                      dest=&quot;split_length&quot;,
                      help=&quot;Split or chunk size in seconds, for example 10&quot;,
                      type=&quot;int&quot;,
                      action=&quot;store&quot;
                      )
    parser.add_option(&quot;-c&quot;, &quot;--split-chunks&quot;,
                      dest=&quot;split_chunks&quot;,
                      help=&quot;Number of chunks to split to&quot;,
                      type=&quot;int&quot;,
                      action=&quot;store&quot;
                      )
    parser.add_option(&quot;-S&quot;, &quot;--split-filesize&quot;,
                      dest=&quot;split_filesize&quot;,
                      help=&quot;Split or chunk size in bytes (approximate)&quot;,
                      type=&quot;int&quot;,
                      action=&quot;store&quot;
                      )
    parser.add_option(&quot;--filesize-factor&quot;,
                      dest=&quot;filesize_factor&quot;,
                      help=&quot;with --split-filesize, use this factor in time to&quot;
                      &quot; size heuristics [default: %default]&quot;,
                      type=&quot;float&quot;,
                      action=&quot;store&quot;,
                      default=0.95
                      )
    parser.add_option(&quot;--chunk-strategy&quot;,
                      dest=&quot;chunk_strategy&quot;,
                      help=&quot;with --split-filesize, allocate chunks according to&quot;
                      &quot; given strategy (eager or even)&quot;,
                      type=&quot;choice&quot;,
                      action=&quot;store&quot;,
                      choices=['eager', 'even'],
                      default='eager'
                      )
    parser.add_option(&quot;-m&quot;, &quot;--manifest&quot;,
                      dest=&quot;manifest&quot;,
                      help=&quot;Split video based on a json manifest file. &quot;,
                      type=&quot;string&quot;,
                      action=&quot;store&quot;
                      )
    parser.add_option(&quot;-v&quot;, &quot;--vcodec&quot;,
                      dest=&quot;vcodec&quot;,
                      help=&quot;Video codec to use. &quot;,
                      type=&quot;string&quot;,
                      default=&quot;copy&quot;,
                      action=&quot;store&quot;
                      )
    parser.add_option(&quot;-a&quot;, &quot;--acodec&quot;,
                      dest=&quot;acodec&quot;,
                      help=&quot;Audio codec to use. &quot;,
                      type=&quot;string&quot;,
                      default=&quot;copy&quot;,
                      action=&quot;store&quot;
                      )
    parser.add_option(&quot;-e&quot;, &quot;--extra&quot;,
                      dest=&quot;extra&quot;,
                      help=&quot;Extra options for ffmpeg, e.g. '-e -threads 8'. &quot;,
                      type=&quot;string&quot;,
                      default=&quot;&quot;,
                      action=&quot;store&quot;
                      )
    (options, args) = parser.parse_args()

    def bailout():
        parser.print_help()
        raise SystemExit

    if not options.filename:
        bailout()

    if options.manifest:
        split_by_manifest(**(options.__dict__))
    else:
        video_length = None
        if not options.split_length:
            video_length = get_video_length(options.filename)
            file_size = os.stat(options.filename).st_size
            split_filesize = None
            if options.split_filesize:
                split_filesize = int(
                    options.split_filesize * options.filesize_factor)
            if split_filesize and options.chunk_strategy == 'even':
                options.split_chunks = ceildiv(file_size, split_filesize)
            if options.split_chunks:
                options.split_length = ceildiv(
                    video_length, options.split_chunks)
            if not options.split_length and split_filesize:
                options.split_length = int(
                    split_filesize / float(file_size) * video_length)
        if not options.split_length:
            bailout()
        split_by_seconds(video_length=video_length, **(options.__dict__))


if __name__ == '__main__':
    main()</code></pre><p><strong>使用方法：</strong>将视频切割为单个视频100秒</p><pre><code>./split.py -f test.mp4 -s 100
</code></pre><h3>ffprobe 使用</h3><p>ffprobe 可以用来得到视频信息。</p><p>视频时长：秒</p><pre><code>ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 input.mp4
</code></pre><p>视频码率：bit</p><pre><code>ffprobe -v error -show_entries format=bit_rate -of default=noprint_wrappers=1:nokey=1 input.mp4
</code></pre><h3>参考链接</h3><p><a href="http://www.ruanyifeng.com/blog/2020/01/ffmpeg.html">http://www.ruanyifeng.com/blog/2020/01/ffmpeg.html</a><br><a href="https://stackoverflow.com/questions/29082422/ffmpeg-video-compression-specific-file-size">https://stackoverflow.com/questions/29082422/ffmpeg-video-compression-specific-file-size</a><br><a href="https://github.com/c0decracker/video-splitter">https://github.com/c0decracker/video-splitter</a><br><a href="https://trac.ffmpeg.org/wiki/FFprobeTips">https://trac.ffmpeg.org/wiki/FFprobeTips</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/1752.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/category/media/</wfw:commentRss>
</item>
<item>
<title>自由填充 Pattern in Photoshop</title>
<link>https://blog.niekun.net/archives/1720.html</link>
<guid>https://blog.niekun.net/archives/1720.html</guid>
<pubDate>Tue, 18 Aug 2020 12:09:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[对于单个 pattern 模型，如果想要在 layer 内以随机的角度或大小填充来实现更加自然的效果可以使用 script 脚本方便的实现。]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p><img src="https://blog.niekun.net/usr/uploads/2020/08/1117148355.jpg" alt="1.jpg" title="1.jpg"></p><p>对于单个 pattern 模型，如果想要在 layer 内以随机的角度或大小填充来实现更加自然的效果可以使用 script 脚本方便的实现。</p><!--more--><p>我们从如何定一个 pattern 开始，下面是一张 1 美元图片：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/2275032220.jpg" alt="2.jpg" title="2.jpg"></p><p>使用 object selection tool 快速将主体选出来：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/547813215.jpg" alt="3.jpg" title="3.jpg"></p><p>选区边沿如果有多余的或者缺失的部分，通过 按住 shift 和 alt 键来增加/减去选区：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/1909413931.jpg" alt="5.jpg" title="5.jpg"></p><p>点击添加图层蒙版，边沿如果需要调整，可以使用画笔工具来进一步修整蒙版。如果蒙版边沿有锯齿，可以双击蒙版打开属性框，调整 smooth 和 contract 来优化蒙版：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3707703993.jpg" alt="6.jpg" title="6.jpg"></p><p>使用选区工具框出一个矩形框包含我们的主体：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/1689003146.jpg" alt="7.jpg" title="7.jpg"></p><p>选择 edit - define pattern：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3798048595.jpg" alt="8.jpg" title="8.jpg"></p><p>定义一个名称，点击 ok：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/2156770301.jpg" alt="9.jpg" title="9.jpg"></p><p>新建图层，快捷键 shift backspace/shift delete 调出填充框：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3400954114.jpg" alt="10.jpg" title="10.jpg"></p><p>content 选择 pattern：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/1708881397.jpg" alt="11.jpg" title="11.jpg"></p><p>custom pattern 里选中我们刚才新建的模型：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/234781752.jpg" alt="12.jpg" title="12.jpg"></p><p>script 前打勾，然后右侧菜单里选择 random fill：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/2358508818.jpg" alt="13.jpg" title="13.jpg"></p><p>点击 ok 后进入调整菜单，首先将 下面的 color randomness 设为 0 避免图形的染色改变，brightness randomness 设置为 0.02 左右使亮度轻微可以随机改变，形成层次感：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/1452674295.jpg" alt="14.jpg" title="14.jpg"></p><p>将 density 设置为最大 10，将 minimum/maximum scale factor 设置为 1，这样 pattern 会以 1:1 比例显示：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/912797465.jpg" alt="15.jpg" title="15.jpg"></p><p>将 rotate pattern 打勾，这样模型会随机旋转：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/1309014316.jpg" alt="16.jpg" title="16.jpg"></p><p>设置完成后点击 ok，可以看到效果：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/186378886.jpg" alt="17.jpg" title="17.jpg"></p><p><strong>还可以做一些优化来使层叠效果更加真实，过程就是降低 density 和 scale，添加图层阴影效果。</strong></p><p>新建图层，使用上面的方法填充 pattern，在设置中将 density 设置为 9，scale 设置为 0.25：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/651526338.jpg" alt="18.jpg" title="18.jpg"></p><p>确认后可以看到效果，单个图形变小，填充密度变小：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/223800845.jpg" alt="19.jpg" title="19.jpg"></p><p>我们给图层添加阴影效果，双击图层打开 layer style，下方点击添加阴影：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3623006525.jpg" alt="20.jpg" title="20.jpg"></p><p>再次新建图层，使用上面图层的填充设置填充 pattern，可以将空缺的部分进一步补充完整：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/1465392084.jpg" alt="21.jpg" title="21.jpg"></p><p>按住 alt 键拖拽刚才的阴影特效到新图层，可以快速复制效果：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/1601765537.jpg" alt="22.jpg" title="22.jpg"></p><p>可以看到还是有空白的区域没有填充完整，继续重复上面的步骤，建立多个图层，直到完全充满整个区域为止，最终效果如下：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3607587483.jpg" alt="23.jpg" title="23.jpg"></p><p>以上就是使用 script 来实现 pattern 自由填充的过程。</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/1720.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/category/media/</wfw:commentRss>
</item>
<item>
<title>眼睛进阶处理 in Photoshop</title>
<link>https://blog.niekun.net/archives/1690.html</link>
<guid>https://blog.niekun.net/archives/1690.html</guid>
<pubDate>Fri, 14 Aug 2020 11:16:27 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[在人像照片中，一双炯炯有神的眼睛会让照片整体突出，下面我们来尝试通过提升亮度，增加细节等过程来实现。]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p><img src="https://blog.niekun.net/usr/uploads/2020/08/480024501.jpg" alt="26.jpg" title="26.jpg"><br>在人像照片中，一双炯炯有神的眼睛会让照片整体突出，下面我们来尝试通过提升亮度，增加细节等过程来实现。</p><!--more--><p>下图是我们的原图：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/1396099294.jpg" alt="1.jpg" title="1.jpg"></p><p>放大眼睛细节：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3561747204.jpg" alt="2.jpg" title="2.jpg"></p><p>原图已经很好了，很清晰。下面我们进行调整。</p><h3>强化亮部细节</h3><p>需要提亮的部分是光源点的对面，再此图中就是眼睛光斑的下方，新建图层，画笔工具画圆：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3017674335.jpg" alt="3.jpg" title="3.jpg"></p><p>擦除多余部分，笔刷选择软笔刷，可以先降低不透明度来看到背景：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3764677799.jpg" alt="4.jpg" title="4.jpg"></p><p>高斯模糊使过度自然：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3996858297.jpg" alt="5.jpg" title="5.jpg"><br><img src="https://blog.niekun.net/usr/uploads/2020/08/501671708.jpg" alt="6.jpg" title="6.jpg"></p><p>混合模式改为 overlay 实现提亮：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/335821335.jpg" alt="7.jpg" title="7.jpg"></p><p>blend option 去掉影响阴影部分：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3804539933.jpg" alt="8.jpg" title="8.jpg"></p><p>如果想要加强效果可以再次复制图层，调整不透明度。</p><h3>增加高光点</h3><p>新建曲线图层，拉高曲线：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/1354307723.jpg" alt="9.jpg" title="9.jpg"></p><p>ctrl I 反转图层蒙版，白色画笔工具软笔刷在瞳孔下方点击一下：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3285907289.jpg" alt="10.jpg" title="10.jpg"></p><p>可以看到效果太强了，调低不透明度到合适：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/295434221.jpg" alt="11.jpg" title="11.jpg"></p><h3>增加明暗细节</h3><p>新建曲线图层，提高曲线，反转图层蒙版：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/4087592833.jpg" alt="12.jpg" title="12.jpg"></p><p>白色画笔工具使用软笔刷沿着瞳孔在亮部区域画出射线，这一步注意如果有数位板来画的话会更好：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/1796541048.jpg" alt="13.jpg" title="13.jpg"></p><p>降低不透明度到合适：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3436373763.jpg" alt="14.jpg" title="14.jpg"></p><p>下面增加暗部细节，再次新建曲线，然后降低曲线，反转蒙版：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/691635148.jpg" alt="15.jpg" title="15.jpg"></p><p>同样的方法画出射线：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/1700268067.jpg" alt="16.jpg" title="16.jpg"></p><p>降低不透明度：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3272285669.jpg" alt="17.jpg" title="17.jpg"></p><h3>眼白清理</h3><p>首先清理红血丝，新建图层，选择修复画笔工具混合模式设置为 screen，这样可以只处理暗部血丝：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/912985796.jpg" alt="18.jpg" title="18.jpg"><br><img src="https://blog.niekun.net/usr/uploads/2020/08/3994121998.jpg" alt="19.jpg" title="19.jpg"></p><p>按 alt 键采样眼白，涂抹血丝区域：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/2541180553.jpg" alt="20.jpg" title="20.jpg"></p><p>然后进行 dogding and burning 明暗调节，首先建立 soild color 观察图层，混合模式改为 color 来只显示亮度情况：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/2919767102.jpg" alt="21.jpg" title="21.jpg"></p><p>新建图层，混合模式改为 soft light，选择笔刷工具软笔刷流量改为 1，快捷键 D 恢复颜色为黑/白，根据实际用白色笔刷涂抹暗部，黑色笔刷涂抹过亮部分：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3803864790.jpg" alt="22.jpg" title="22.jpg"></p><p>然后修复亮度调整后的颜色变化，新建图层，混合模式改为 color，快捷键 I 拾取眼白正常部分的颜色，然后在新图层上涂抹出需要修复的区域：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/825482316.jpg" alt="23.jpg" title="23.jpg"></p><h3>复制效果</h3><p>将亮部细节处理/高光点/明暗细节处理部分建立分组然后复制一份，安住 ctrl 拖动分组到另一只眼睛部分，可以配合蒙版清理多余部分：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/3182465625.jpg" alt="24.jpg" title="24.jpg"></p><p>可以使用同样的方法清理另一只眼睛的眼白部分最终效果如下：<br><img src="https://blog.niekun.net/usr/uploads/2020/08/2262252084.jpg" alt="25.jpg" title="25.jpg"></p>
]]></content:encoded>
<slash:comments>1</slash:comments>
<comments>https://blog.niekun.net/archives/1690.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/category/media/</wfw:commentRss>
</item>
<item>
<title>cinema 4D 快捷键</title>
<link>https://blog.niekun.net/archives/1677.html</link>
<guid>https://blog.niekun.net/archives/1677.html</guid>
<pubDate>Mon, 20 Jul 2020 09:03:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[1视角移动2视野放大/缩小3视角旋转  Eobject 移动Robject 旋转Tobject 放大/缩小  object 编辑 U线段功能菜单U + L选择闭合曲线U + U取消区域曲线选择M...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<table><tbody><tr><td align="center">1</td><td align="center">视角移动</td></tr><tr><td align="center">2</td><td align="center">视野放大/缩小</td></tr><tr><td align="center">3</td><td align="center">视角旋转</td></tr><tr><td align="center"> </td><td align="center"> </td></tr><tr><td align="center">E</td><td align="center">object 移动</td></tr><tr><td align="center">R</td><td align="center">object 旋转</td></tr><tr><td align="center">T</td><td align="center">object 放大/缩小</td></tr><tr><td align="center"> </td><td align="center"> </td></tr><tr><td align="center"><strong>object 编辑</strong></td><td align="center"> </td></tr><tr><td align="center">U</td><td align="center">线段功能菜单</td></tr><tr><td align="center">U + L</td><td align="center">选择闭合曲线</td></tr><tr><td align="center">U + U</td><td align="center">取消区域曲线选择</td></tr><tr><td align="center">M</td><td align="center">块功能菜单</td></tr><tr><td align="center">M + T</td><td align="center">块生成工具</td></tr><tr><td align="center"> </td><td align="center"> </td></tr><tr><td align="center">Q</td><td align="center">隐藏 subdivision surface</td></tr><tr><td align="center"> </td><td align="center"> </td></tr><tr><td align="center">alt + R</td><td align="center">区域渲染</td></tr><tr><td align="center"> </td><td align="center"> </td></tr></tbody></table>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/1677.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/category/media/</wfw:commentRss>
</item>
</channel>
</rss>