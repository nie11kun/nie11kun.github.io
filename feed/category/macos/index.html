<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
xmlns:content="http://purl.org/rss/1.0/modules/content/"
xmlns:dc="http://purl.org/dc/elements/1.1/"
xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
xmlns:atom="http://www.w3.org/2005/Atom"
xmlns:wfw="http://wellformedweb.org/CommentAPI/">
<channel>
<title>Marco Nie - macOS</title>
<link>https://blog.niekun.net/category/macos/</link>
<atom:link href="https://blog.niekun.net/feed/category/macos/" rel="self" type="application/rss+xml" />
<language>zh-CN</language>
<description></description>
<lastBuildDate>Fri, 26 Nov 2021 20:31:37 +0800</lastBuildDate>
<pubDate>Fri, 26 Nov 2021 20:31:37 +0800</pubDate>
<item>
<title>使用 OpenCore Legacy Patcher 为 2015 款 MacBook Pro 激活 AirPlay</title>
<link>https://blog.niekun.net/archives/2353.html</link>
<guid>https://blog.niekun.net/archives/2353.html</guid>
<pubDate>Fri, 26 Nov 2021 20:31:37 +0800</pubDate>
<dc:creator>admin</dc:creator>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>今年发布的 macOS Monterey 增加了很多新功能，其中一个就是可以通过 AirPlay 将手机屏幕投放到 Mac 上。这个功能挺有意思的，但是当我把我的 MacBook Pro 升级系统后，发现无法使用这个功能，经过查询后发现这些新功能只对较新款的设备开放，这就有点让人吐槽了。<br>但是不放弃的我开始查询是否有大神给不支持的设备添加上这些功能，果然被我找到了，而且是一个挺有名的项目：<strong>OpenCore Legacy Patcher</strong>。</p><!--more--><p><strong>OpenCore Legacy Patcher</strong> 是一个旨在帮助不被苹果官方支持的老版本 Mac 升级到最新系统及特殊功能的项目。为这些老设备提供接近于原生的体验。</p><p>GitHub 地址：<a href="https://github.com/dortania/OpenCore-Legacy-Patcher/">https://github.com/dortania/OpenCore-Legacy-Patcher/</a></p><p>我的是 2015 款 MacBook Pro，系统是支持直接升级到 Monterey 的，就是缺失了一些新功能，也可以使用这个工具来解锁这些限制。</p><h3>下载安装</h3><p>首先在 release 页面下载最新版，下载 TUI 即可也就是 terminal 版：<br><a href="https://github.com/dortania/OpenCore-Legacy-Patcher/releases">https://github.com/dortania/OpenCore-Legacy-Patcher/releases</a></p><p>下载解压后拖放到 application 文件夹即可完成安装。</p><h3>配置</h3><p>注意在操作前最好做一次 Time Machine 备份系统，以免操作失败后数据丢失。</p><p>打开OpenCore-Patcher 进入配置界面：<br><img src="https://blog.niekun.net/usr/uploads/2021/11/771952879.jpg" alt="1.jpg" title="1.jpg"></p><p>上面提示此设备并不在这个 patcher 列表中，因为它依然可以收到苹果官方的系统支持。但我们依然想利用这个 patcher 来解锁一些功能，所以首先我们需要允许 opencore 运行在此设备上。</p><p>选择 4. patcher settings 回车：<br><img src="https://blog.niekun.net/usr/uploads/2021/11/1199003523.jpg" alt="2.jpg" title="2.jpg"></p><p>选择 8. allow opencore on native models 回车后输入 y 确认，修改后 8 选项变为 currently true：<br><img src="https://blog.niekun.net/usr/uploads/2021/11/4193487915.jpg" alt="3.jpg" title="3.jpg"></p><p>输入 q 返回主菜单，可以看到显示当前设备已被支持：<br><img src="https://blog.niekun.net/usr/uploads/2021/11/3356615953.jpg" alt="4.jpg" title="4.jpg"></p><p>如果你的设备本来就已经进入了 opencore 的支持列表，这不需要进行以上操作。</p><p>下一步设置 opencore 的默认启动模式，默认情况下安装 opencore 后每次启动系统会自动跳入引导选择界面，用来选择正常启动还是通过 pathcer 启动。但是这样比较麻烦，一般情况下配置好后，我们希望自动进入 patcher 后的系统，所以我们将自动跳入引导选择界面功能关闭，这样后续依然可以通过启动时按住 option 键来进入引导选择。</p><p>主界面选择 5. patcher settings，然后选择 5. miscellaneous settings：<br><img src="https://blog.niekun.net/usr/uploads/2021/11/573877562.jpg" alt="5.jpg" title="5.jpg"></p><p>选择 1. set showpicker mode:<br><img src="https://blog.niekun.net/usr/uploads/2021/11/2801299974.jpg" alt="14.jpg" title="14.jpg"></p><p>上面会提示此选项的含义，这里输入 n 关闭此功能：<br><img src="https://blog.niekun.net/usr/uploads/2021/11/818715180.jpg" alt="6.jpg" title="6.jpg"></p><p>输入 q 回到主界面。</p><p>下面我们需要将上面的配置的结果 bulid 到系统临时路径中，选择 1. bulid opencore，完成 build 后输入 enter 返回：<br><img src="https://blog.niekun.net/usr/uploads/2021/11/3345384447.jpg" alt="7.jpg" title="7.jpg"></p><p>最后，就需要将刚才 build 的数据写入到 usb 或内部存储器中。</p><p>如果写入到 usb 中，如果需要系统加载那些隐藏功能，就需要插入写好数据的 usb 然后启动系统时按住 option 选择 opencore 引导系统。如果写入系统内部存储器，就无须外部设备了，可以做到正常启动自动加载 patcher。这里介绍直接安装到设备内部存储器。</p><p>主界面选择 2. install opencore to usb/internal drive:<br><img src="https://blog.niekun.net/usr/uploads/2021/11/1527068884.jpg" alt="8.jpg" title="8.jpg"></p><p>输入 0 选择内部存储器：<br><img src="https://blog.niekun.net/usr/uploads/2021/11/1700583359.jpg" alt="9.jpg" title="9.jpg"></p><p>在此输入 0 选择 EFI 分区：<br><img src="https://blog.niekun.net/usr/uploads/2021/11/3610085083.jpg" alt="10.jpg" title="10.jpg"></p><p>确认后 opencore 就写入系统中。</p><p>等待完成写入后手动重启系统，启动时按住 option 键进入引导选择界面：<br><img src="https://blog.niekun.net/usr/uploads/2021/11/1349064389.jpg" alt="11.jpg" title="11.jpg"></p><p>这里默认是选中系统默认引导的，如果需要后续每次启动都自动进入 opencore boot 引导的话，使用方向键选择到 opencore 图标的 boot 项，然后按住 control 键，此时引导下面会出现一个圆圈，鼠标点击此圆圈代表设置此选项为默认引导项：<br><img src="https://blog.niekun.net/usr/uploads/2021/11/2495783972.jpg" alt="12.jpg" title="12.jpg"></p><p>选择 opencore boot 进入系统后，打开 system preference - sharing：<br><img src="https://blog.niekun.net/usr/uploads/2021/11/4202134834.jpg" alt="15.jpg" title="15.jpg"></p><p>可以看到菜单中多了一个 AirPlay receiver，表明 AirPlay 功能已经成功启动，此时就可以测试手机的 screen mirror 能否监测到 Mac 了。</p><p>后续 OpenCore-Legacy-Patcher 如果有更新了，下载安装最新的 app 后再次通过以上同样的方法来更新补丁即可。</p><h3>卸载</h3><p>如果通过 USB 加载 opencore 那么只需要拔出 usb 即可删除 opencore。</p><p>如果安装到内部存储器中，卸载稍微麻烦些，具体参考：<a href="https://dortania.github.io/OpenCore-Legacy-Patcher/UNINSTALL.html">Uninstalling OpenCore</a></p><h3>参考链接</h3><p><a href="https://www.youtube.com/watch?v=sO0yc3_hOE8">Airplay BLOCKED on Monterey? How to unlock it!</a><br><a href="https://dortania.github.io/OpenCore-Legacy-Patcher/">OpenCore Legacy Patcher</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2353.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/category/macos/</wfw:commentRss>
</item>
<item>
<title>配置外部网络存储器作为 Time Machine 备份</title>
<link>https://blog.niekun.net/archives/2305.html</link>
<guid>https://blog.niekun.net/archives/2305.html</guid>
<pubDate>Fri, 30 Apr 2021 08:59:42 +0800</pubDate>
<dc:creator>admin</dc:creator>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>最近搬进新家，配置好了局域网环境并使用海康 h99 作为存储中心共享资源给各个设备使用。它支持 smb 和 afp 协议共享文件，通常情况下 smb 就足够了。</p><p>之前我的 MacBook 是通过 usb 直接连接外部硬盘来进行 Time Machine 的，需要将硬盘格式化为 macOS 扩展格式。既然有了网络存储中心，那么为什么不将 Time Machine 也放在网络驱动器上呢？</p><p>研究了下果然有解决方案的，基本原理就是<strong>通过在网络驱动器上创建一个 macOS 格式的虚拟磁盘，然后再 MacBook 上挂载这个虚拟磁盘</strong>就可以正常进行备份及还原了。</p><!--more--><h3>创建虚拟磁盘</h3><p>打开 MacBook 的 disk 应用，菜单选择：文件 - 新建镜像 - 空白镜像：<br><img src="https://blog.niekun.net/usr/uploads/2021/04/3390003757.png" alt="2021-04-30T00:36:06.png" title="2021-04-30T00:36:06.png"></p><p>设置镜像合适大小，也就是虚拟磁盘的空间，我这里配置 1TB，注意磁盘格式为 macOS 扩展，镜像格式为稀疏磁盘镜像：<br><img src="https://blog.niekun.net/usr/uploads/2021/04/4157435921.png" alt="2021-04-30T00:38:02.png" title="2021-04-30T00:38:02.png"></p><p>点击 <strong>存储</strong> 就生成了磁盘镜像文件了，默认会自动挂载这个镜像，我们手动将其推出。</p><p>也可以通过命令行的方式直接生成镜像文件：</p><pre><code>hdiutil create -size 1024g -type SPARSEBUNDLE -fs &quot;HFS+J&quot; TimeMachine.sparsebundle
</code></pre><p>这里不需要担心 MacBook 上没有 1TB 这么大的空间，因为空白镜像只有 400MB 左右。</p><h3>配置 Time Machine</h3><p>镜像生成好后，我们需要将其移动到网络驱动器中，可以通过 finder 通过 smb 的方式连接网络驱动器，然后移动 <strong>TimeMachine.sparsebundle</strong> 文件到合适的目录。</p><p>然后我们在 finder 中双击网络驱动器中的 <strong>TimeMachine.sparsebundle</strong> 会自动 mount 虚拟镜像。此时在 finder 中我们就可以看到挂载的 TimeMachine 磁盘了。</p><p>然后我们就可以设置 <strong>TimeMachine</strong> 绑定到这个磁盘：</p><pre><code>sudo tmutil setdestination /Volumes/TimeMachine
</code></pre><p>注意磁盘路径需要根据你自己实际定义的虚拟磁盘名称来处理。</p><p>此时我们打开 TimeMachine 就可以看到已经绑定到我们的网络驱动器上的虚拟磁盘了：<br><img src="https://blog.niekun.net/usr/uploads/2021/04/2641215091.png" alt="2021-04-30T00:49:26.png" title="2021-04-30T00:49:26.png"></p><p>我测试了下它的传输速度在千兆内网下能达到 50MB/s 左右，不是太快但基本能用。</p><h3>备份与还原</h3><p>备份的时候和直接连接 usb 没有什么区别，注意在重启系统后需要手动挂载下虚拟磁盘才可以正常备份。</p><p>我实际测试过开机 cmd + R 进入恢复模式后，在 TimeMachine 中能够正常识别到虚拟磁盘并进行系统还原。所以所有 TimeMachine 的功能都可以正常进行。</p><h3>自动挂载</h3><p>如果需要实现系统启动后自动挂载网络驱动器上的虚拟镜像，可以通过 apple script 的方式实现，脚本如下：</p><pre><code>try
    mount volume &quot;smb://xxx.xxx.xxx.xxx/&quot;
end try

do shell script &quot;hdiutil attach -mountpoint /Volumes/TimeMachine/ /Volumes/网络驱动器名/PATH/TO/TimeMachine.sparsebundle&quot;</code></pre><p>脚本另存为 application 格式并 system preference 中加入开机自启动项即可。</p><h3>参考链接</h3><p><a href="https://www.douban.com/note/614980869/">添加Mac的Time Machine备份到smb网络硬盘（windows 共享文件夹）</a><br><a href="https://yanke.info/?id=78">自建Mac TimeMachine局域网无线备份环境</a><br><a href="https://apple.stackexchange.com/questions/162544/how-to-restore-system-from-network-drive">How to restore system from network drive</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2305.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/category/macos/</wfw:commentRss>
</item>
<item>
<title>升级 command line tool 后 QT 编译 boost 库报错问题</title>
<link>https://blog.niekun.net/archives/2198.html</link>
<guid>https://blog.niekun.net/archives/2198.html</guid>
<pubDate>Wed, 03 Mar 2021 21:03:37 +0800</pubDate>
<dc:creator>admin</dc:creator>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>今天打开一个 QT 项目后进行编译发现报错了，查看了下什么都没有修改就比较奇怪了。根据日志是 boost 库出了问题，报错为：<strong>Undefined symbols for architecture x86_64</strong>，但是 boost 库是以前编译好的从来没动过。回想起来前几天重新安装了下 command line tool 会不会有关系。</p><!--more--><p>看了下 QT kit 配置里面发现 clang 的设置居然有叹号。重新识别了下系统编译器：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/2815337861.png" alt="2021-03-03T12:54:53.png" title="2021-03-03T12:54:53.png"></p><p>然后重建下项目配置：<br><img src="https://blog.niekun.net/usr/uploads/2021/03/4082452549.png" alt="2021-03-03T13:01:04.png" title="2021-03-03T13:01:04.png"></p><p>重新编译项目依然有报错。</p><p>最后就是 boost 库的确有问题了。于是我重新编译了一次。居然问题就解决了。</p><p>原来真的是由于系统的 Clang 更新后原来编译的 boost 库不兼容了，在此使用当前系统的 Clang 编译一次就行了。</p><p>boost 库编译方法参考：<a href="https://blog.niekun.net/archives/1174.html">https://blog.niekun.net/archives/1174.html</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2198.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/category/macos/</wfw:commentRss>
</item>
<item>
<title>修复 parallels desktop 16 网络无法连接问题</title>
<link>https://blog.niekun.net/archives/2040.html</link>
<guid>https://blog.niekun.net/archives/2040.html</guid>
<pubDate>Sun, 03 Jan 2021 22:40:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>随着升级到 macOS Big Sur 后，虚拟机 parallels desktop 也更新到了 16 版本。我当然是继续安装破解版啦。</p><p>但是安装好后，启动虚拟机会有一个报错：<strong>Network Initialization Failed</strong>，启动后会发现虚拟机无法联网，网络设置中无法正常在各种模式中切换。</p><p>在寻找解决方案期间，了解到了这可能是由于破解的原因，正版用户没有这个问题。网上有人提供了一个方法，执行一条命令就启动虚拟机就可以正常联网了。但是会导致虚拟机无法访问主机的共享目录及无法访问 USB 设备。而且一旦重启 parallels desktop 后又回恢复之前的状态，我也就没有去做。</p><p>这两天看到网上终于有人找到的解决方法，测试后的确可用，所以介绍给大家参考。</p><!--more--><p>解决的方法都是通过修改相关配置文件实现的。首先需要彻底退出 parallels desktop。</p><h3>网络问题</h3><p>修改 <code>/Library/Preferences/Parallels/network.desktop.xml</code> 文件。</p><p>在终端或者 vs code 中打开这个文件，找到 <code>&lt;UseKextless&gt;</code> 标签，将其中的内容改为 0：</p><pre><code>&lt;UseKextless&gt;0&lt;/UseKextless&gt;
</code></pre><p>注意如果你的这个文件内没有这个标签，则需要在 <code>&lt;ParallelsNetworkConfig&gt;</code> 根标签内手动创建它即可。</p><p>修改完成后保存文件，需要输入账户密码。</p><h3>USB 问题</h3><p>修改 <code>/Library/Preferences/Parallels/dispatcher.desktop.xml</code> 文件。</p><p>在终端或者 vs code 中打开这个文件，找到 <code>&lt;Usb&gt;</code> 标签，将其中的内容改为 1：</p><pre><code>&lt;Usb&gt;1&lt;/Usb&gt;
</code></pre><p>修改完成后保存文件，需要输入账户密码。</p><p>修改完以上两个文件后，重启 parallels desktop 就会发现一切都正常了。</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2040.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/category/macos/</wfw:commentRss>
</item>
<item>
<title>brew 安装路径</title>
<link>https://blog.niekun.net/archives/1977.html</link>
<guid>https://blog.niekun.net/archives/1977.html</guid>
<pubDate>Wed, 16 Dec 2020 22:04:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>brew 是 macOS 下流行的包管理工具，可以方便的安装各种工具。</p><p>brew 默认安装路径为：<code>/usr/local/Cellar</code>，然后会在 <code>/usr/local/opt/</code> 建立所安装的包的软连接。</p><p>包安装好后如果不能正常执行，可以建立包的可执行程序的软连接到：<code>/usr/local/bin/</code> 目录。</p><p>比如安装 openssl：</p><pre><code>brew install openssl
</code></pre><p>安装后包的路径为：<code>/usr/local/Cellar/openssl@1.1/1.1.1h</code>。同时包的软连接在：<code>/usr/local/Cellar/openssl</code>。</p><p>这时候执行命令：</p><pre><code>openssl version
</code></pre><p>返回的并不是刚才安装的版本，而是系统自带的老版本的。这时候可以建立可执行程序的软连接到对应路径：</p><pre><code>ln -s /usr/local/opt/openssl/bin/openssl /usr/local/bin/openssl
</code></pre><p>这时候执行命令就可以得到正确的返回：</p><pre><code>openssl version
//OpenSSL 1.1.1h  22 Sep 2020
</code></pre><p>其他包的模式和此类似。</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/1977.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/category/macos/</wfw:commentRss>
</item>
<item>
<title>macOS 下使用 QT 部署工具 macdeployqt</title>
<link>https://blog.niekun.net/archives/1966.html</link>
<guid>https://blog.niekun.net/archives/1966.html</guid>
<pubDate>Sat, 05 Dec 2020 23:53:15 +0800</pubDate>
<dc:creator>admin</dc:creator>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>在 Windows 下可以使用 QT 部署工具：windeployqt 来自动提取可执行程序的依赖库，在 macOS 下同样有部署工具：macdeployqt 实现相同的功能。</p><p>工具路径在 QT 安装目录的对应编译器 bin 目录下，如：<code>/Users/marconie/Qt/5.15.2/clang_64/bin/macdeployqt</code></p><p>为了方便使用建议将 bin 目录添加到系统 PATH 中，我的终端是 zsh 添加方法如下：</p><p>打开 <code>~/.zshrc</code> 添加如下内容，可以使用 vim 来操作：</p><pre><code>export PATH=$PATH:/Users/marconie/Qt/5.15.2/clang_64/bin</code></pre><p>编辑完成后关闭文件，刷新源：</p><pre><code>source ~/.zshrc
</code></pre><p>现在就可以直接使用命令了：</p><pre><code>macdeployqt -h

</code></pre><!--more--><p>部署的方法是直接在 macdeployqt 后提供 app 路径：</p><pre><code>macdeployqt path/to/test.app
</code></pre><p>执行后会自动搜索此 app 需要的 QT 库并打包到 app 内，可以打开 app 包查看相关内容：<br><img src="https://blog.niekun.net/usr/uploads/2020/12/3770174957.jpg" alt="Screen Shot 2020-12-05 at 23.49.48.jpg" title="Screen Shot 2020-12-05 at 23.49.48.jpg"></p><p>如果项目中使用了其他第三方库，此部署工具不会自动提取相关文件，需要手动将相关库文件添加到 <code>app/Contents/Frameworks</code> 文件夹内。</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/1966.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/category/macos/</wfw:commentRss>
</item>
<item>
<title>macOS 下命令行控制显示系统通知</title>
<link>https://blog.niekun.net/archives/1773.html</link>
<guid>https://blog.niekun.net/archives/1773.html</guid>
<pubDate>Sat, 26 Sep 2020 21:42:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>在使用 aira2 的 rpc 下载功能时，默认没有下载完成提示，所以需要手动打开 webui 进行查看。</p><p>关于 aria2 的使用参考我的教程：<a href="https://blog.niekun.net/archives/1199.html">https://blog.niekun.net/archives/1199.html</a></p><p>注意到配置文件里有一个：<code>on-download-complete</code> 选项，可以在下载完成后执行脚本，具体解释参考<a href="https://aria2.github.io/manual/en/html/aria2c.html#cmdoption-on-download-complete">官方网页</a></p><p>可以利用这一点，编写一个脚本来触发系统通知，这样就可以知道文件下载完成了。</p><!--more--><h3>on-download-complete</h3><p>在 aria2 下载完成后，执行 <code>on-download-complete</code> 脚本时会自动传递三个参数：</p><ul><li>GID <em>GID is an ID of a download which aria2c uses to identify a particular download</em></li><li>下载文件个数</li><li>文件路径</li></ul><p>示例：</p><pre><code>$ cat hook.sh
#!/bin/sh
echo &quot;Called with [$1] [$2] [$3]&quot;
$ aria2c --on-download-complete hook.sh http://example.org/file.iso
Called with [1] [1] [/path/to/file.iso]</code></pre><h3>osascript</h3><p>这里使用 AppleScript 来编写简单的系统通知，使用 osascript 可以在 terminal 终端执行 AppleScript 脚本。</p><p>语法结构：</p><pre><code>osascript [-l language] [-i] [-s flags] [-e statement | programfile] [argument ...]
</code></pre><p>这里主要使用 <code>-e</code>选项 来执行 AppleScript 脚本。</p><h4>显示通知</h4><p>显示一个简单的通知很简单：</p><pre><code>osascript -e 'display notification &quot;hello world!&quot;'
</code></pre><p>引号内的就是纯 AppleScript 脚本，很简单。</p><h4>显示带标题的通知</h4><pre><code>osascript -e 'display notification &quot;hello world!&quot; with title &quot;This is the title&quot;'
</code></pre><h4>显示带主副标题的通知</h4><pre><code>osascript -e 'display notification &quot;hello world!&quot; with title &quot;Greeting&quot; subtitle &quot;More text&quot;'
</code></pre><h4>显示带声音提醒的通知</h4><p>系统内置的声音音频在：<code>/System/Library/Sounds</code> 目录：</p><pre><code>$ ls /System/Library/Sounds
Basso.aiff    Frog.aiff    Hero.aiff    Pop.aiff    Submarine.aiff
Blow.aiff    Funk.aiff    Morse.aiff    Purr.aiff    Tink.aiff
Bottle.aiff    Glass.aiff    Ping.aiff    Sosumi.aif</code></pre><p><code>Pop.aiff</code> 这个声音就是默认的提示音。</p><pre><code>osascript -e 'display notification &quot;hello world!&quot; with title &quot;Greeting&quot; subtitle &quot;More text&quot; sound name &quot;Pop.aiff&quot;'
</code></pre><h4>显示需要点击确认的提示框</h4><pre><code>osascript -e 'display alert &quot;Hello World!&quot; message &quot;longer text can be added in the message field.&quot;'
</code></pre><h4>音频提示</h4><p>除了显示系统通知外，也可以用音频提示，使用 <code>say</code> 命令来完成。</p><pre><code>osascript -e 'say &quot;Hello World!&quot;'
</code></pre><p>提示信息将不显示而是语音播报出来。</p><h4>aria2 下载完成提示脚本</h4><p><code>download-complete.sh</code></p><pre><code>#!/bin/sh
osascript -e 'display notification &quot;download complete&quot; sound name &quot;Pop.aiff&quot;'</code></pre><p>参考连接：<br><a href="https://code-maven.com/display-notification-from-the-mac-command-line">https://code-maven.com/display-notification-from-the-mac-command-line</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/1773.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/category/macos/</wfw:commentRss>
</item>
<item>
<title>xattr 命令清除 app 的隔离属性</title>
<link>https://blog.niekun.net/archives/1680.html</link>
<guid>https://blog.niekun.net/archives/1680.html</guid>
<pubDate>Tue, 21 Jul 2020 12:37:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>macOS 中如果安装一些修改版或破解版软件，通过拖拽方式放到 application 目录，在打开 app 的时候可能提示程序无法运行，通常我们在系统 preference - security 里可以手动允许运行，但是有时候使用这种方法也无法打开，这是由于系统识别到这个 app 可能有问题所以给它加上了 <code>com.apple.quarantine</code> 隔离属性阻止了他的运行。</p><p>如果我们需要运行它，就需要删除 app 的 <code>com.apple.quarantine</code> 属性，可以使用 <code>xattr</code> 来处理。</p><!--more--><p>macOS 上的文件不只有 "normal" 属性，也有 "读", "写", "执行" 等其他属性。常规属性可以用 <code>ls -l myfile</code> 命令来查看。除此之外还可以定义<strong>扩展属性</strong>，扩展属性的修改可以用 <code>xattr</code> 来处理。</p><p>命令语法如下：</p><pre><code>xattr [options] attributes [files]
</code></pre><p>可用 option：</p><pre><code>   -c  CLear all Atrributes.
   -d  Delete the given attribute.
   -h  Help.
   -l  By default, the first two command forms either display just the attribute names or
       values, respectively. The -l option causes both the attribute names and corresponding
       values to be displayed. For hex display of values, the output is preceeded with the hex
       offset values and followed by ASCII display, enclosed by '|'.
   -p  Print the value associated with the given attribute.
   -r  If a file argument is a directory, act as if the entire contents of the directory
       recursively were also specified (so that every file in the directory tree is acted upon).
   -s  If a file argument is a symbolic link, act on the symbolic link itself, rather than
       the file that the symbolic link points at.
   -v  Force the the file name to be displayed, even for a single file.
   -w  Write a given attribute name with a value.
   -x  Force the attribute value to be displayed in the hexadecimal representation.   </code></pre><p>显示一个文件的存在的扩展属性：</p><pre><code>xattr myfile
</code></pre><p>显示一个文件的存在的扩展属性及这个属性的值：</p><pre><code>xattr -l myfile
</code></pre><p>给一个文件添加 <code>com.example.color</code> 属性：</p><pre><code>xattr -w com.example.color myfile
</code></pre><p>清除一个文件的 <code>com.example.color</code> 属性：</p><pre><code>xattr -d com.example.color myfile
</code></pre><p>清除一个文件夹内所有文件的 <code>com.example.color</code> 属性：</p><pre><code>xattr -d -r com.example.color mydir
</code></pre><p>清除一个文件的所有扩展属性：</p><pre><code>xattr -c myfile
</code></pre><hr><p>对于被屏蔽的 app 需要清除<code>com.apple.quarantine</code>  这一属性，处理过程如下：</p><p>首先查看 app 的现有属性：</p><pre><code>xattr /path/to/MyApp.app
</code></pre><p>如果返回的结果有 <code>com.apple.quarantine</code> 属性则执行下面命令删除：</p><pre><code>sudo xattr -r -d com.apple.quarantine /path/to/MyApp.app
</code></pre><p>执行后就可以正常打开 app 了。</p>
]]></content:encoded>
<slash:comments>2</slash:comments>
<comments>https://blog.niekun.net/archives/1680.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/category/macos/</wfw:commentRss>
</item>
<item>
<title>MacBook Pro 2015 升级 SSD</title>
<link>https://blog.niekun.net/archives/1640.html</link>
<guid>https://blog.niekun.net/archives/1640.html</guid>
<pubDate>Mon, 13 Jul 2020 14:15:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>最近升级了我的 2015 款 MacBook Pro 13，期间遇到一些问题，这里做一些流水记录：</p><ul><li>使用 time machine 备份系统</li><li>拆掉背壳</li><li>断开电源接口</li><li>拆掉硬盘螺丝，拿下原装硬盘</li><li>先在电脑上安装好转接模块</li><li>插上新 SSD，上好螺丝</li><li>接上电源</li><li>按住 cmd option R + 电源键进入恢复系统工具</li><li>连上 WiFi 等待网络下载工具包，大概 2Gb</li><li>进入 disk utility 硬盘工具</li><li>格式化新 SSD，格式 apfs，分区表 guid</li><li>连上 time machine 硬盘，进入恢复工具恢复系统到新 SSD</li></ul><p>关于安装新 SSD 后待机耗电增加参考：<a href="https://blog.niekun.net/archives/1622.html">https://blog.niekun.net/archives/1622.html</a></p>
]]></content:encoded>
<slash:comments>2</slash:comments>
<comments>https://blog.niekun.net/archives/1640.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/category/macos/</wfw:commentRss>
</item>
<item>
<title>macOS 使用终端命令设置系统代理</title>
<link>https://blog.niekun.net/archives/1629.html</link>
<guid>https://blog.niekun.net/archives/1629.html</guid>
<pubDate>Tue, 07 Jul 2020 23:38:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>在平时使用中，我一般是在浏览器内设置代理服务器，还有就是终端设置了代理切换脚本来实现快速切换，系统默认没有代理。关于 macOS/Windows 下设置终端代理可以参考我之前的文章：<a href="https://blog.niekun.net/archives/97.html">https://blog.niekun.net/archives/97.html</a></p><p>如果想要设置系统级的代理，需要在 system preference - network - proxies 里设置，常用的需要设置 http/https/socks 代理，基本覆盖大多数应用的流量了：<br><img src="https://blog.niekun.net/usr/uploads/2020/07/600970559.png" alt="2020-07-07T14:34:57.png" title="2020-07-07T14:34:57.png"></p><!--more--><p>但是每次需要让其他应用走代理时都要进入系统设置项里打开代理开关很麻烦，可以通过设置 terminal 命令来实现快速切换。</p><h3>networksetup</h3><p>这里需要使用的命令是 <code>networksetup</code>，它可以查看及设置系统网络配置。</p><p>man page：<a href="https://www.unix.com/man-page/osx/8/networksetup/">https://www.unix.com/man-page/osx/8/networksetup/</a></p><p><strong>查看设备可用的网络服务：</strong></p><pre><code>marconie@marco-mbp ~ % networksetup -listallnetworkservices
An asterisk (*) denotes that a network service is disabled.
Apple USB Ethernet Hub
iPhone USB
Wi-Fi
Bluetooth PAN
Thunderbolt Bridge</code></pre><p>可以看到设备支持的有线和无线网络服务，<strong>后续设置中需要使用对应的服务名</strong>。</p><p><strong>查看各个网络服务的端口名：</strong></p><pre><code>marconie@marco-mbp ~ % networksetup -listallhardwareports

Hardware Port: Wi-Fi
Device: en0
Ethernet Address: a0:99:9b:04:a6:9d

Hardware Port: Bluetooth PAN
Device: en3
Ethernet Address: a0:99:9b:04:a6:9e

Hardware Port: Thunderbolt 1
Device: en1
Ethernet Address: 82:13:07:10:b9:80

Hardware Port: Thunderbolt 2
Device: en2
Ethernet Address: 82:13:07:10:b9:81

Hardware Port: Thunderbolt Bridge
Device: bridge0
Ethernet Address: 82:13:07:10:b9:80

VLAN Configurations
===================</code></pre><p>在后续的设置中会用到 device 名称，可以用以上命令来查询。</p><p><strong>查看某个网络服务的信息：</strong></p><pre><code>marconie@marco-mbp ~ % networksetup -getinfo Wi-Fi
DHCP Configuration
IP address: 192.168.123.25
Subnet mask: 255.255.255.0
Router: 192.168.123.1
Client ID: 
IPv6: Automatic
IPv6 IP address: none
IPv6 Router: none
Wi-Fi ID: a0:99:9b:04:a6:9d</code></pre><p><strong>查看系统记录的可连接的无线信号，可以使用命令来查看，需要用到上面得到的 device name：</strong></p><pre><code>marconie@marco-mbp ~ % networksetup -listpreferredwirelessnetworks en0
Preferred networks on en0:
    zhang_4lou
    Phicomm_A196D8
    TP-LINK_27BB
    MERCURY_F610
    iPhone (MISS)
    Marco Nie’s 8
    Office_Diagnosis</code></pre><p><strong>查看当前连接的无线接入点名称：</strong></p><pre><code>marconie@marco-mbp ~ % networksetup -getairportnetwork en0
Current Wi-Fi Network: My2.4G</code></pre><p><strong>关闭无线连接：</strong></p><pre><code>networksetup -setairportpower en0 off
</code></pre><p><strong>打开无线连接：</strong></p><pre><code>networksetup -setairportpower en0 on
</code></pre><p><strong>查询当前无线连接是否打开状态：</strong></p><pre><code>marconie@marco-mbp ~ % networksetup -getairportpower en0
Wi-Fi Power (en0): On
</code></pre><p><strong>设置系统 http 代理：</strong></p><pre><code>networksetup -setwebproxy networkservices address port
</code></pre><p><strong>设置系统 https 代理：</strong></p><pre><code>networksetup -setsecurewebproxy networkservices address port
</code></pre><p><strong>设置系统 socks 代理：</strong></p><pre><code>networksetup -setsocksfirewallproxy networkservices address port
</code></pre><p>打开/关闭系统代理：</p><pre><code>networksetup [-setwebproxystate | -setsecurewebproxystate | -setsocksfirewallproxystate] networkservices [on | off]
</code></pre><h3>应用</h3><p>上面介绍的常用的 <code>networksetup</code> 命令，下面介绍具体如何设置系统代理。这里以 Wi-Fi 网络服务举例。我的 http 代理地址为：127.0.0.1:1082，socks 代理地址为：127.0.0.1:1080。</p><p>首先设置代理地址：</p><pre><code>networksetup -setwebproxy Wi-Fi 127.0.0.1 1082
networksetup -setsecurewebproxy Wi-Fi 127.0.0.1 1082
networksetup -setsocksfirewallproxy Wi-Fi 127.0.0.1 1080</code></pre><p>以上设置只需要设置一次，以后使用只需要执行打开/关闭代理操作即可。</p><p>打开系统代理：</p><pre><code>networksetup -setwebproxystate Wi-Fi on
networksetup -setsecurewebproxystate Wi-Fi on
networksetup -setsocksfirewallproxystate Wi-Fi on</code></pre><p>关闭系统代理：</p><pre><code>networksetup -setwebproxystate Wi-Fi off
networksetup -setsecurewebproxystate Wi-Fi off
networksetup -setsocksfirewallproxystate Wi-Fi off</code></pre><p>可以在终端执行上述命令，然后打开系统代理设置界面验证是否设置成功。</p><h3>设置 alias 快捷命令</h3><p>如果需要频繁的打开/关闭代理，每次都需要输入以上命令比较麻烦，比较好的方法是设置 alias。关于 alias 我在<a href="https://blog.niekun.net/archives/97.html">macOS/Linux/windows设置终端 proxy 代理</a>里有详细介绍。</p><p>编辑 ~/.bash_frofile 添加如下并保存文件：</p><pre><code>alias pset='networksetup -setwebproxy Wi-Fi 127.0.0.1 1082 &amp;&amp; networksetup -setsecurewebproxy Wi-Fi 127.0.0.1 1082 &amp;&amp; networksetup -setsocksfirewallproxy Wi-Fi 127.0.0.1 1080'
alias psystem='networksetup -setwebproxystate Wi-Fi on &amp;&amp; networksetup -setsecurewebproxystate Wi-Fi on &amp;&amp; networksetup -setsocksfirewallproxystate Wi-Fi on'
alias upsystem='networksetup -setwebproxystate Wi-Fi off &amp;&amp; networksetup -setsecurewebproxystate Wi-Fi off &amp;&amp; networksetup -setsocksfirewallproxystate Wi-Fi off'</code></pre><p>更新缓存，macOS 终端使用的是 zsh，所有要先在 <code>~/.zshrc</code> 里添加一句 <code>source ~/.bash_profile</code>，具体查看我上面提到的文章：</p><pre><code>source ~/.zshrc
</code></pre><p>设置完成后，执行 <code>pset</code> 设置代理地址，执行 <code>psystem</code> 打开系统代理，执行 <code>upsystem</code> 关闭系统代理。</p><h3>参考连接：</h3><p><a href="http://support.moonpoint.com/os/os-x/networksetup-wifi.php">http://support.moonpoint.com/os/os-x/networksetup-wifi.php</a><br><a href="https://superuser.com/questions/316502/how-to-change-proxy-setting-using-command-line-in-mac-os">https://superuser.com/questions/316502/how-to-change-proxy-setting-using-command-line-in-mac-os</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/1629.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/category/macos/</wfw:commentRss>
</item>
</channel>
</rss>