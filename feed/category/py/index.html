<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
xmlns:content="http://purl.org/rss/1.0/modules/content/"
xmlns:dc="http://purl.org/dc/elements/1.1/"
xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
xmlns:atom="http://www.w3.org/2005/Atom"
xmlns:wfw="http://wellformedweb.org/CommentAPI/">
<channel>
<title>Marco Nie - python</title>
<link>https://blog.niekun.net/category/py/</link>
<atom:link href="https://blog.niekun.net/feed/category/py/" rel="self" type="application/rss+xml" />
<language>zh-CN</language>
<description></description>
<lastBuildDate>Thu, 14 Aug 2025 16:10:00 +0800</lastBuildDate>
<pubDate>Thu, 14 Aug 2025 16:10:00 +0800</pubDate>
<item>
<title> 使用 Cython 对 python 代码加密打包</title>
<link>https://blog.niekun.net/archives/Cython-python.html</link>
<guid>https://blog.niekun.net/archives/Cython-python.html</guid>
<pubDate>Thu, 14 Aug 2025 16:10:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<category><![CDATA[python]]></category>
<description><![CDATA[目前我在使用 cx_Freeze 对 python 程序打包成可执行文件，但是 cx_Freeze 的核心功能是将 Python 脚本、Python 解释器以及所有依赖的库文件打包到一个独立的可...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>目前我在使用 cx_Freeze 对 python 程序打包成可执行文件，但是 cx_Freeze 的核心功能是将 Python 脚本、Python 解释器以及所有依赖的库文件打包到一个独立的可执行文件（如 Windows 下的 .exe 文件）或一个包含所有文件的目录中。打包后的文件中包含的是 Python 的字节码 <code>.pyc</code> 文件，这个文件是可以被反编译回近似的源代码的。</p><p>通过使用 Cython 将 Python 源代码编译成 C 语言，然后再生成本地二进制文件（.pyd）。然后正常使用 cx_Freeze 打包，这样做可以极大地提高代码的保护级别，防止被轻易逆向。</p><!--more--><h3>安装必要的 Python 包</h3><p>需要安装 Cython 和 Numpy，在终端或命令行中运行：</p><pre><code>pip install Cython numpy
</code></pre><h3>安装 C/C++ 编译器</h3><p>Cython 将 Python 代码转换成 C 代码，但最终需要一个 C 编译器来将 C 代码编译成机器码。这是最关键的一步。</p><p>对于 Windows 用户：</p><ul><li>访问 Visual Studio 下载页面：<a href="https://visualstudio.microsoft.com/zh-hans/downloads/">https://visualstudio.microsoft.com/zh-hans/downloads/</a>。</li><li>在 "Tools for Visual Studio" (所有下载 -&gt; Visual Studio 工具) 中找到并下载 "Build Tools for Visual Studio"。</li><li>运行安装程序，在 "工作负荷" 标签页中，勾选 "使用 C++ 的桌面开发"。</li><li>点击安装。安装完成后，您可能需要重启电脑。</li></ul><p>对于 macOS 用户：<br>打开终端并运行 <code>xcode-select --install</code>。这会安装苹果的命令行开发者工具，其中包含了 Clang 编译器。</p><p>对于 Linux 用户 (例如 Ubuntu/Debian)：<br>打开终端并运行 <code>sudo apt update &amp;&amp; sudo apt install build-essential</code>。</p><h3>修改 setup.py 文件</h3><p>如果项目目录结构如下：</p><pre><code>/my_project
    |-- main.py           # 你的主程序文件
    |-- /src              # 你的其他模块目录
    |   |-- func1.py
    |   |-- func2.py
    |-- setup.py            # cx_Freeze 的配置文件</code></pre><p>根据以上目录结构，下面是一个配置文件示例：</p><pre><code>from cx_Freeze import setup, Executable
import sys, os, io

# =============================================================================
# Cython 自动化编译集成
# =============================================================================
try:
    from Cython.Build import cythonize
    from setuptools import Extension
    import numpy
except ImportError:
    print(&quot;\n[错误] 缺少必要的库。请先安装 Cython 和 Numpy:&quot;)
    print(&quot;pip install Cython numpy&quot;)
    sys.exit(1)

sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')  # 修复非中文系统打包时报错

# 增加递归调用深度限制
sys.setrecursionlimit(1500)

# 定义相关路径
ROOT_DIR = os.path.dirname(os.path.abspath(__file__))
ENTRY_POINT = &quot;main.py&quot;

# 检查是否为打包命令
build_commands = {&quot;build&quot;, &quot;bdist_msi&quot;, &quot;bdist_dmg&quot;, &quot;bdist_mac&quot;}
is_building = any(cmd in sys.argv for cmd in build_commands)

# --- Cython 编译配置 ---
# 此函数会自动查找 src 目录下的所有 .py 文件并准备将它们编译
def find_extensions_to_compile(dir_path=&quot;src&quot;):
    &quot;&quot;&quot;Find all .py files to be compiled by Cython.&quot;&quot;&quot;
    extensions = []
    # 添加 numpy 的头文件路径，这对于编译依赖 numpy/scipy 的代码至关重要
    numpy_include = numpy.get_include()
    
    for root, dirs, files in os.walk(dir_path):
        for file in files:
            # 我们只编译 .py 文件，但跳过 __init__.py 文件
            if file.endswith(&quot;.py&quot;) and file != &quot;__init__.py&quot;:
                path = os.path.join(root, file)
                # 将文件路径转换为模块路径，例如 &quot;src/library/function.py&quot; -&gt; &quot;src.library.function&quot;
                module_path = path.replace(os.sep, '.')[:-3]
                
                extensions.append(
                    Extension(
                        name=module_path,
                        sources=[path],
                        include_dirs=[numpy_include]  # 包含 numpy 头文件
                    )
                )
    print(f&quot;--- 找到 {len(extensions)} 个模块准备通过 Cython 编译...&quot;)
    return extensions

# 仅在执行打包命令时才准备编译列表
extensions = []
if is_building:
    # 1. 编译 src 目录下的所有模块
    extensions.extend(find_extensions_to_compile(&quot;src&quot;))
    
    # 2. 明确地将 main.py 添加到编译列表
    print(f&quot;--- 添加入口文件 '{ENTRY_POINT}' 到编译列表...&quot;)
    main_extension = Extension(
        name=&quot;main&quot;,  # 编译后的模块名
        sources=[ENTRY_POINT],
        include_dirs=[numpy.get_include()]
    )
    extensions.append(main_extension)

# =============================================================================
# cx_Freeze 配置
# =============================================================================

# 安装依赖
build_exe_options = {
    &quot;packages&quot;: [
    ],
    &quot;excludes&quot;: [&quot;email&quot;] + [ext.name for ext in extensions], # 排除 Cython 编译的模块
    &quot;include_files&quot;: [
        ],
    &quot;includes&quot;: [],

    # 性能优化选项
    &quot;optimize&quot;: 2,           # 使用Python优化
    &quot;include_msvcr&quot;: False,  # 不包含MSVC运行库
}

# 基础设置
base = &quot;Win32GUI&quot; if sys.platform == &quot;win32&quot; else None

directory_table = [
    # ...
]

shortcut_table = [
    (
        # ...
    ),
    (
        # ...
    ),
]

msi_data = {&quot;Directory&quot;: directory_table, &quot;Shortcut&quot;: shortcut_table}

bdist_msi_options = {
    # ...
}

executables = [
    Executable(
        &quot;main.py&quot;, # 入口文件 依然调用 py 程序，cx_Freeze 会自动识别并使用加密后的文件
        # ...
    )
]

# =============================================================================
# 清理函数
# =============================================================================
def cleanup_generated_files():
    &quot;&quot;&quot;查找并删除由 Cython 生成的所有 .c 文件。&quot;&quot;&quot;
    print(&quot;\n--- 正在运行清理程序：删除生成的 C 文件... ---&quot;)
    for root, dirs, files in os.walk(ROOT_DIR):
        # 避免进入不相关的目录
        if 'myenv' in root or '.git' in root or 'build' in root or 'dist' in root:
            continue
        for file in files:
            if file.endswith('.c'):
                file_path = os.path.join(root, file)
                try:
                    os.remove(file_path)
                    print(f&quot;--- 已删除: {file_path}&quot;)
                except OSError as e:
                    print(f&quot;--- 删除失败 {file_path}: {e}&quot;)

# =============================================================================
# 执行打包
# =============================================================================

try:
    setup(
        # ...
        # 关键步骤：将找到的 .py 文件交给 Cythonize 进行编译
        ext_modules=cythonize(
            extensions,
            compiler_directives={'language_level': &quot;3&quot;}, # 使用 Python 3 语法
            quiet=True # 减少不必要的编译输出
        ) if is_building else [],
        # ...
    )
finally:
    # 只有在执行打包命令时才运行清理
    if is_building:
        cleanup_generated_files()</code></pre><p>运行打包命令打包即可，如：</p><pre><code>python setup.py bdist_msi
</code></pre><h3>检查加密情况</h3><p>安装完成后，进入安装路径的 <strong>Lib/site-packages</strong> 文件夹，会看到加密后的 <code>.pyd</code> 程序文件。<code>.pyd</code> 文件是 Windows 上的二进制动态链接库，本质上和 .dll 文件一样。如果加密失败：会在这里看到 <code>.pyc</code> 文件或者甚至原始的 <code>.py</code> 文件。</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/Cython-python.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/category/py/archives/Cython-python.html</wfw:commentRss>
</item>
<item>
<title>使用虚拟环境 env 开发 python</title>
<link>https://blog.niekun.net/archives/env-python.html</link>
<guid>https://blog.niekun.net/archives/env-python.html</guid>
<pubDate>Mon, 01 Jul 2024 10:17:13 +0800</pubDate>
<dc:creator>admin</dc:creator>
<category><![CDATA[python]]></category>
<description><![CDATA[使用虚拟环境进行Python开发有助于隔离项目的依赖，避免不同项目之间的库版本冲突。以下是如何创建和使用虚拟环境的详细步骤。Python 3.3 及以上版本自带 venv 模块，可以直接使用。使...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>使用虚拟环境进行Python开发有助于隔离项目的依赖，避免不同项目之间的库版本冲突。以下是如何创建和使用虚拟环境的详细步骤。</p><p><strong>Python 3.3 及以上版本自带 venv 模块，可以直接使用。</strong></p><h3>使用 venv 创建虚拟环境</h3><h4>创建虚拟环境</h4><p>在你的项目目录下，运行以下命令来创建一个虚拟环境，这将在项目目录下创建一个名为 <strong>myenv</strong> 的文件夹，其中包含虚拟环境的所有文件：</p><pre><code>python -m venv myenv
</code></pre><h4>激活虚拟环境</h4><p>Windows：</p><pre><code>myenv\Scripts\activate
</code></pre><p>macOS 和 Linux：</p><pre><code>source myenv/bin/activate
</code></pre><h4>安装依赖</h4><p>在虚拟环境中，你可以使用 pip 来安装项目所需的库：</p><pre><code>pip install requests
</code></pre><p>安装的库将只会影响当前虚拟环境，而不会影响系统的 Python 环境或其他项目。</p><h4>冻结依赖</h4><p>为了确保你的项目依赖可以在其他环境中重现，你可以使用以下命令将当前环境的依赖写入 <strong>requirements.txt</strong> 文件：</p><pre><code>pip freeze &gt; requirements.txt
</code></pre><p>requirements.txt 文件将包含所有当前环境中的安装包及其版本信息。</p><h4>使用 requirements.txt 安装依赖</h4><p>在新的环境中，你可以使用 <strong>requirements.txt</strong> 文件来安装所需的所有依赖：</p><pre><code>pip install -r requirements.txt
</code></pre><h4>退出虚拟环境</h4><p>当你完成工作时，可以通过以下命令退出虚拟环境：</p><pre><code>deactivate
</code></pre><p>使用虚拟环境进行Python开发可以有效地隔离项目依赖，避免版本冲突。通过创建和激活虚拟环境、安装依赖、冻结依赖并在新环境中重新安装依赖，可以确保你的项目在不同环境中具有一致的运行表现。</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/env-python.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/category/py/archives/env-python.html</wfw:commentRss>
</item>
<item>
<title>从源码编译安装 python</title>
<link>https://blog.niekun.net/archives/1758.html</link>
<guid>https://blog.niekun.net/archives/1758.html</guid>
<pubDate>Mon, 21 Sep 2020 16:35:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<category><![CDATA[Linux]]></category>
<category><![CDATA[python]]></category>
<description><![CDATA[从源码编译程序的好处是可以使用最新版本，下面介绍如何在 Linux 下编译安装 python 和 pip 环境。下载源码包python 官网：https://www.python.org/当前最...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>从源码编译程序的好处是可以使用最新版本，下面介绍如何在 Linux 下编译安装 python 和 pip 环境。</p><h3>下载源码包</h3><p>python 官网：<a href="https://www.python.org/">https://www.python.org/</a></p><p>当前最新版是 3.8.5，在这个页面找到地址：<a href="https://www.python.org/downloads/release/python-385/">https://www.python.org/downloads/release/python-385/</a></p><p><img src="https://blog.niekun.net/usr/uploads/2020/09/3204471917.jpg" alt="1.jpg" title="1.jpg"></p><!--more--><p>下载 tgz 压缩包到本地并解压：</p><pre><code>cd /tmp
wget https://www.python.org/ftp/python/3.8.5/Python-3.8.5.tgz
tar xvf Python-3.8.5.tgz</code></pre><h3>环境安装</h3><p>编译需要安装一些依赖：</p><pre><code>apt install libffi-dev libgdbm-dev libsqlite3-dev libssl-dev zlib1g-dev
</code></pre><h3>编译</h3><p>python 源码使用标准 GNU 编译系统，详细说明参考：<a href="https://blog.niekun.net/archives/883.html">https://blog.niekun.net/archives/883.html</a></p><p>将 python 安装到 <code>/opt</code> 目录，先创建文件夹：</p><pre><code>mkdir /opt/python3.8.5
</code></pre><p>然后配置 configure：</p><pre><code>cd /tmp/Python-3.8.5

./configure \
--prefix=/opt/python3.8.5 \
--enable-optimizations \</code></pre><p>没有错误提示的话就开始编译和安装：</p><pre><code>make
make install
</code></pre><p>安装完成后测试执行：</p><pre><code>/opt/python3.8.5/bin/python3 --version
</code></pre><p>返回版本信息则安装完成。</p><p>下面将可执行文件加入系统路径，创建软连接：</p><pre><code>ln -s /opt/python3.8.5/bin/python3 /usr/bin/python
</code></pre><p>测试运行：</p><pre><code>python --version
</code></pre><h3>安装 pip</h3><p>源码编译安装的 python 不自带 pip，需要自己安装，可以使用 get-pip.py 脚本来安装。</p><p>官网：<a href="https://pip.pypa.io/en/stable/installing/">https://pip.pypa.io/en/stable/installing/</a></p><p>下载脚本到本地：</p><pre><code>curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py</code></pre><p>使用刚才安装的 python 执行脚本：</p><pre><code>/opt/python3.8.5/bin/python3 get-pip.py
</code></pre><p>pip 的安装路径是 <code>/opt/python3.8.5/bin/</code>，测试命令：</p><pre><code>/opt/python3.8.5/bin/pip3 --version
</code></pre><p>返回版本信息则安装完成。</p><p>添加软连接到系统路径：</p><pre><code>ln -s /opt/python3.8.5/bin/pip3 /usr/bin/pip
</code></pre><p>测试命令：</p><pre><code>pip --version
</code></pre><h3>参考链接</h3><p><a href="https://docs.rstudio.com/resources/install-python-source/">https://docs.rstudio.com/resources/install-python-source/</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/1758.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/category/py/archives/1758.html</wfw:commentRss>
</item>
<item>
<title>使用 subprocess.check_output 执行cmd命令并返回结果到字符串</title>
<link>https://blog.niekun.net/archives/1753.html</link>
<guid>https://blog.niekun.net/archives/1753.html</guid>
<pubDate>Fri, 18 Sep 2020 15:13:51 +0800</pubDate>
<dc:creator>admin</dc:creator>
<category><![CDATA[python]]></category>
<description><![CDATA[语法：subprocess.check_output(args, *, stdin=None, stderr=None, shell=False, universal_newlines=Fals...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>语法：</p><pre><code>subprocess.check_output(args, *, stdin=None, stderr=None, shell=False, universal_newlines=False)
</code></pre><p>执行cmd命令并返回结果到字符串。</p><p>用法：</p><pre><code>import subprocess

output = check_output([&quot;cat&quot;, &quot;/etc/hostname&quot;]).strip()
print(output)</code></pre><p>以上脚本会执行 <code>cat /etc/hostname</code> 命令然后将结果赋值给 <code>output</code> 变量。<br><code>strip()</code> 可以将 string 的前后空格去掉。</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/1753.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/category/py/archives/1753.html</wfw:commentRss>
</item>
<item>
<title>argparse and struct in python</title>
<link>https://blog.niekun.net/archives/1718.html</link>
<guid>https://blog.niekun.net/archives/1718.html</guid>
<pubDate>Fri, 14 Aug 2020 11:20:39 +0800</pubDate>
<dc:creator>admin</dc:creator>
<category><![CDATA[python]]></category>
<description><![CDATA[https://docs.python.org/3/library/argparse.htmlhttps://docs.python.org/3/library/struct.html]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p><a href="https://docs.python.org/3/library/argparse.html">https://docs.python.org/3/library/argparse.html</a><br><a href="https://docs.python.org/3/library/struct.html">https://docs.python.org/3/library/struct.html</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/1718.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/category/py/archives/1718.html</wfw:commentRss>
</item>
<item>
<title>string &amp;lt;-&amp;gt; byte in python</title>
<link>https://blog.niekun.net/archives/1688.html</link>
<guid>https://blog.niekun.net/archives/1688.html</guid>
<pubDate>Wed, 12 Aug 2020 14:08:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<category><![CDATA[python]]></category>
<description><![CDATA[To transform a unicode string to a byte string in Python do this:&gt;&gt;&gt; 'foo'.encode('utf_8...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>To transform a unicode string to a byte string in Python do this:</p><pre><code>&gt;&gt;&gt; 'foo'.encode('utf_8')
b'foo'
</code></pre><p>To transform a byte string to a unicode string:</p><pre><code>&gt;&gt;&gt; b'foo'.decode('utf_8')
'foo'

</code></pre><ol><li><p>To convert a string to bytes.</p><pre><code>data = &quot;&quot;               #string
data = &quot;&quot;.encode()      #bytes
data = b&quot;&quot;              #bytes</code></pre></li><li><p>To convert bytes to a String.</p><pre><code>data = b&quot;&quot;              #bytes
data = b&quot;&quot;.decode()     #string
data = str(b&quot;&quot;)         #string</code></pre></li></ol>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/1688.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/category/py/archives/1688.html</wfw:commentRss>
</item>
<item>
<title>winreg 操作 Windows 注册表 in python</title>
<link>https://blog.niekun.net/archives/1685.html</link>
<guid>https://blog.niekun.net/archives/1685.html</guid>
<pubDate>Wed, 12 Aug 2020 13:56:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<category><![CDATA[python]]></category>
<description><![CDATA[https://docs.python.org/3/library/winreg.html#https://stackoverflow.com/questions/15128225/python...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p><a href="https://docs.python.org/3/library/winreg.html#">https://docs.python.org/3/library/winreg.html#</a><br><a href="https://stackoverflow.com/questions/15128225/python-script-to-read-and-write-a-path-to-registry">https://stackoverflow.com/questions/15128225/python-script-to-read-and-write-a-path-to-registry</a></p><pre><code>import winreg

REG_PATH = r&quot;Control Panel\Mouse&quot;

def set_reg(name, value):
    try:
        winreg.CreateKey(winreg.HKEY_CURRENT_USER, REG_PATH)
        registry_key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, REG_PATH, 0, 
                                       winreg.KEY_WRITE)
        winreg.SetValueEx(registry_key, name, 0, winreg.REG_SZ, value)
        winreg.CloseKey(registry_key)
        return True
    except WindowsError:
        return False

def get_reg(name):
    try:
        registry_key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, REG_PATH, 0,
                                       winreg.KEY_READ)
        value, regtype = winreg.QueryValueEx(registry_key, name)
        winreg.CloseKey(registry_key)
        return value
    except WindowsError:
        return None

#Example MouseSensitivity
#Read value 
print (get_reg('MouseSensitivity'))

#Set Value 1/20 (will just write the value to reg, the changed mouse val requires a win re-log to apply*)
set_reg('MouseSensitivity', str(10))

#*For instant apply of SystemParameters like the mouse speed on-write, you can use win32gui/SPI
#http://docs.activestate.com/activepython/3.4/pywin32/win32gui__SystemParametersInfo_meth.html</code></pre>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/1685.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/category/py/archives/1685.html</wfw:commentRss>
</item>
<item>
<title>使用 opencv 处理图像</title>
<link>https://blog.niekun.net/archives/1684.html</link>
<guid>https://blog.niekun.net/archives/1684.html</guid>
<pubDate>Fri, 07 Aug 2020 11:37:51 +0800</pubDate>
<dc:creator>admin</dc:creator>
<category><![CDATA[python]]></category>
<description><![CDATA[安装：https://pypi.org/project/opencv-python/使用：https://opencv-python-tutroals.readthedocs.io/en/lat...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>安装：<a href="https://pypi.org/project/opencv-python/">https://pypi.org/project/opencv-python/</a><br>使用：<a href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_setup/py_table_of_contents_setup/py_table_of_contents_setup.html">https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_setup/py_table_of_contents_setup/py_table_of_contents_setup.html</a><br>示例：<a href="https://www.askaswiss.com/2016/01/how-to-create-pencil-sketch-opencv-python.html">https://www.askaswiss.com/2016/01/how-to-create-pencil-sketch-opencv-python.html</a><br>打包 exe：<a href="https://pypi.org/project/auto-py-to-exe/">https://pypi.org/project/auto-py-to-exe/</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/1684.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/category/py/archives/1684.html</wfw:commentRss>
</item>
<item>
<title>使用 TelegramBot 键盘 InlineKeyboardButton 提示 BUTTON_DATA_INVALID 报错原因分析</title>
<link>https://blog.niekun.net/archives/880.html</link>
<guid>https://blog.niekun.net/archives/880.html</guid>
<pubDate>Sat, 01 Feb 2020 18:06:06 +0800</pubDate>
<dc:creator>admin</dc:creator>
<category><![CDATA[python]]></category>
<description><![CDATA[今天在测试 telegram Bot 的时候，发现 keyboard 不能正确弹出来，后台查看发现报错了，提示 Bad Request: BUTTON_DATA_INVALID反复检查代码没有发...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>今天在测试 telegram Bot 的时候，发现 keyboard 不能正确弹出来，后台查看发现报错了，提示 <code>Bad Request: BUTTON_DATA_INVALID</code></p><p>反复检查代码没有发现语法错误，查找之后了解到 <strong>InlineKeyboardButton</strong> 响应后返回的 <strong>Callback Data</strong> 有大小限制，最大64位：</p><p><img src="https://niekun.net/usr/uploads/2020/02/2328405825.png" alt="2020-02-01T10:02:48.png" title="2020-02-01T10:02:48.png"></p><p>的确我想返回的内容长度的确超过了大小限制，优化源码后问题解决了。</p><p>参考链接：<br><a href="https://core.telegram.org/bots/api#inlinekeyboardbutton">https://core.telegram.org/bots/api#inlinekeyboardbutton</a><br><a href="https://stackoverflow.com/questions/46389040/inlinekeyboardbutton-are-limited-in-inlinekeyboardmarkup-telegram-bot-c-sharp">https://stackoverflow.com/questions/46389040/inlinekeyboardbutton-are-limited-in-inlinekeyboardmarkup-telegram-bot-c-sharp</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/880.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/category/py/archives/880.html</wfw:commentRss>
</item>
<item>
<title>python 常用语法收集</title>
<link>https://blog.niekun.net/archives/438.html</link>
<guid>https://blog.niekun.net/archives/438.html</guid>
<pubDate>Thu, 17 Oct 2019 14:52:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<category><![CDATA[python]]></category>
<description><![CDATA[在我使用过程中遇到的常用语法，这里做一些记录。]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>在我使用过程中遇到的常用语法，这里做一些记录。</p><!--more--><h1>os.system()</h1><p>可以用来运行终端命令：</p><pre><code>import os
os.system('date')
-----------------------
The current date is: 10/17/2019 Thu </code></pre><h1>glob</h1><p>用来将匹配的文件放入数组：</p><pre><code>import glob
import os
CWD = os.getcwd()#当前目录路径
for name in glob.glob(CWD+'/*'):
    print(name)</code></pre><p>以上输出当前目录下所有文件的文件名。</p><pre><code>for name in glob.glob(CWD+'/file?.txt'):
    print(name)</code></pre><p>以上输出  filea.txt, fileb.txt filec.txt 等文件名。</p><p>可以使用类似正则表达式的方式匹配文件名：</p><pre><code>glob.glob(CWD+'/*[12].*')
</code></pre><p>从python3.5开始，支持使用一下方法进行递归搜索目录内文件及文件夹：</p><pre><code>for name in glob.glob(CWD+'/**/*', recursive=True):
    print(name)</code></pre><p>以上会输出目录内文件及子文件夹内文件。</p><h1>split()</h1><p>字符串分割：</p><p><strong>按空格分割，注意两个部分之间的空格可以是1个或多个，不影响分割效果：</strong></p><pre><code>txt = &quot;welcome to the jungle&quot;
x = txt.split()</code></pre><p>将 txt 字符串按空格来分成4个部分，x 是数组。</p><p><strong>分割成设定的个数：</strong></p><pre><code>txt = &quot;welcome to the jungle&quot;
x = txt.split(' ', 1)</code></pre><p>输出结果：x = ['welcome', 'to the jungle']</p><p><strong>按特定字符分割：</strong></p><pre><code>txt = &quot;apple#banana#cherry#orange&quot;
x = txt.split(&quot;#&quot;, 1)</code></pre><p>输出结果：x = ['apple', 'banana#cherry#orange']</p><h1>next()</h1><p>用于 iterator 的顺序提取。</p><pre><code>mylist = iter([&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;])
x = next(mylist)
print(x)
y = next(mylist)
print(x)
z = next(mylist)
print(x)</code></pre><p>输出结果：x = 'apple' y = 'banana' z = 'cherry'</p><h1>format()</h1><p><strong>用于字符串内的赋值：</strong></p><pre><code>print (&quot;{}, A computer science portal for geeks&quot;.format(&quot;GeeksforGeeks&quot;))</code></pre><p>输出：GeeksforGeeks, A computer science portal for geeks</p><p><strong>多个输入参数：</strong></p><pre><code>print (&quot;Hi ! My name is {} and I am {} years old&quot;
                            .format(&quot;User&quot;, 19)) </code></pre><p>带索引的多参数输入：</p><pre><code>print(&quot;Every {3} should know the use of {2} {1} programming and {0}&quot;
        .format(&quot;programmer&quot;, &quot;Open&quot;, &quot;Source&quot;, &quot;Operating Systems&quot;)) </code></pre><p>输出结果：Every Operating Systems should know the use of Source Open programming and programmer</p><h1>strip()</h1><p><strong>删除字符串前和后的空格：</strong></p><pre><code>txt = &quot;     banana     &quot;
x = txt.strip()</code></pre><p>输出：x = 'banana'</p><p>删除字符串前和后的自定义字符：</p><pre><code>txt = &quot;,,,,,rrttgg.....banana....rrr&quot;
x = txt.strip(&quot;,.grt&quot;)</code></pre><p>输出： x = 'banana'</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/438.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/category/py/archives/438.html</wfw:commentRss>
</item>
</channel>
</rss>