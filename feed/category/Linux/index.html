<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
xmlns:content="http://purl.org/rss/1.0/modules/content/"
xmlns:dc="http://purl.org/dc/elements/1.1/"
xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
xmlns:atom="http://www.w3.org/2005/Atom"
xmlns:wfw="http://wellformedweb.org/CommentAPI/">
<channel>
<title>Marco Nie - Linux</title>
<link>https://blog.niekun.net/category/Linux/</link>
<atom:link href="https://blog.niekun.net/feed/category/Linux/" rel="self" type="application/rss+xml" />
<language>zh-CN</language>
<description></description>
<lastBuildDate>Sun, 10 Apr 2022 12:59:50 +0800</lastBuildDate>
<pubDate>Sun, 10 Apr 2022 12:59:50 +0800</pubDate>
<item>
<title>修改虚拟交换机 MTU 提高 esxi 虚拟机网络速度</title>
<link>https://blog.niekun.net/archives/2613.html</link>
<guid>https://blog.niekun.net/archives/2613.html</guid>
<pubDate>Sun, 10 Apr 2022 12:59:50 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[最近发现我的局域网内网下的网速很慢，只有500M左右，达不到 1000M 的速度。我是通过 ipert3 进行测速的。家里的网络是通过 esxi 下安装的 openwrt，ubuntu 等虚拟机...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>最近发现我的局域网内网下的网速很慢，只有500M左右，达不到 1000M 的速度。我是通过 ipert3 进行测速的。</p><p>家里的网络是通过 esxi 下安装的 openwrt，ubuntu 等虚拟机控制的，通过 esxi 管理页面可以看到接口都运行在 1000M 全双工模式下，说明网线链接是没有问题的：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/3148137121.jpg" alt="1.jpg" title="1.jpg"></p><p>经过查询发现可以通过修改虚拟交换机的 mtu 值到 9000 来提高网络吞吐量从而加快网速。</p><!--more--><h3>修改 mtu</h3><p>进入虚拟交换机栏：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/2344625687.jpg" alt="2.jpg" title="2.jpg"></p><p>点击每一个交换机进入设置界面，点击上面的 edit：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/663844784.jpg" alt="3.jpg" title="3.jpg"></p><p>将 mtu 设置为 9000，并保存配置：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/1003869571.jpg" alt="4.jpg" title="4.jpg"></p><p>虚拟交换机里修改完后，进入 vmkernel NICs 栏：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/520155881.jpg" alt="5.jpg" title="5.jpg"></p><p>点击 vmk0 进入设置界面，同样的点击 edit 修改其 mtu 为 9000 并保存：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/284326956.jpg" alt="6.jpg" title="6.jpg"></p><p>以上就完成了整个虚拟环境 mtu 值的修改，再次通过 iperf3 测速，速率能达到 800M。</p><h3>iperf3 使用</h3><p>下面简单介绍使用 iperf3 测试内网传输速率。</p><p>首先在接收端以下指令运行在服务模式：</p><pre><code>iperf3 -s</code></pre><p>然后再发送端执行以下指令启动测速：</p><pre><code>iperf3 -c xxx.xxx.xxx.xxx -t 30</code></pre><p>以上指令中将地址替换为接收端 IP 地址，<code>-t</code> 参数可以设置测速时间，单位为秒。</p><h3>参考链接</h3><p><a href="https://www.v2ex.com/t/696368">关于 ESXi 虚拟机间拷贝速度慢的问题</a><br><a href="https://www.slashroot.in/iperf-how-test-network-speedperformancebandwidth">IPERF: How to test network Speed,Performance,Bandwidth</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2613.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/category/Linux/</wfw:commentRss>
</item>
<item>
<title>esxi 配置自定义 ssl 证书</title>
<link>https://blog.niekun.net/archives/2611.html</link>
<guid>https://blog.niekun.net/archives/2611.html</guid>
<pubDate>Sun, 10 Apr 2022 12:39:50 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[我家里的主机使用 esxi 管理多个 vm 虚拟机，之前的文章介绍过 esxi 的安装及使用：ESXi 的安装与使用，需要安装的可以参考。通过浏览器访问  vcenter 管理界面默认会强制 h...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>我家里的主机使用 esxi 管理多个 vm 虚拟机，之前的文章介绍过 esxi 的安装及使用：<a href="https://blog.niekun.net/archives/2213.html">ESXi 的安装与使用</a>，需要安装的可以参考。</p><p>通过浏览器访问  vcenter 管理界面默认会强制 https 模式，但是访问端并没有安装 vcenter 管理网页的证书，所以会提示不安全的链接，下面介绍如何在 esxi 上安装自定义域名的 ssl 证书，并在客户机上安装。</p><!--more--><h3>开启 ssh</h3><p>esxi 上的操作是通过 ssh 的方式，所以首先需要打开 esxi 的 ssh 访问权限。</p><p>访问 esxi 管理界面，在 host 菜单栏，选择 action - sevices - enable ssh：<br><img src="https://blog.niekun.net/usr/uploads/2022/04/1033022978.jpg" alt="1.jpg" title="1.jpg"></p><p><strong>打开 ssh 只对本次开机有效，重启 esxi 后会再次默认关闭。</strong></p><p>然后就可以通过 ssh 访问 esxi。</p><h3>创建证书</h3><p>首先备份当前证书文件，防止修改错误无法恢复，进入 <code>/etc/vmware/ssl</code> 目录，新建 bak 文件夹，将目录内的 rui.crt, rui.csr, rui.key 文件移动到 bak 文件夹内：</p><pre><code>cd /etc/vmware/ssl
mkdir bak
mv rui.* bak/</code></pre><p>然后在 <code>/etc/vmware/ssl</code> 下新建文件 <code>webclient.cnf</code> 编辑文件内容如下：</p><pre><code>[ req ]

default_bits = 2048

default_keyfile = rui.key

distinguished_name = req_distinguished_name

encrypt_key = no

prompt = no

string_mask = nombstr

req_extensions = v3_req

[ v3_req ]

basicConstraints = CA:FALSE

keyUsage = digitalSignature, keyEncipherment, dataEncipherment

extendedKeyUsage = serverAuth, clientAuth

subjectAltName = DNS:&lt;esxi.domain.name&gt;, DNS:&lt;esxi&gt;, IP:&lt;xxx.xxx.xxx.xxx&gt; 

[ req_distinguished_name ]

countryName = US

stateOrProvinceName = VA

localityName = SomeCity

0.organizationName = WOW

organizationalUnitName = Software

commonName = &lt;esxi.domain.name&gt;

[ alt_names ]

DNS.1 = &lt;esxi.domain.name&gt;

DNS.2 = &lt;esxi&gt;

IP.1 = &lt;xxx.xxx.xxx.xxx&gt;</code></pre><p>注意，将以上内容中尖括号<code>&lt;&gt;</code>中的内容替换为你实际的域名和IP地址，<strong>不需要保留尖括号</strong>。</p><p>文件修改并保存后，执行下面命令创建证书文件：</p><pre><code># 创建加密 key，它用来保证证书生效及运行
openssl genrsa -out /etc/vmware/ssl/rui.key 2048

# 创建一个证书注册请求文件，会用到上面创建的配置文件信息并保存到 key 中
openssl req -new -nodes -out /etc/vmware/ssl/rui.csr -keyout /etc/vmware/ssl/rui.key -config /etc/vmware/ssl/webclient.cnf

# 生成证书，使用了 x509 标准格式。其中定义了证书 730 天的有效期，也就是2年，可以根据需要自行更改时间
openssl x509 -req -days 730 -in /etc/vmware/ssl/rui.csr -signkey /etc/vmware/ssl/rui.key -out /etc/vmware/ssl/rui.crt -extensions v3_req -extfile /etc/vmware/ssl/webclient.cnf</code></pre><p>以上命令执行完成后，就在目录下生成了 <strong>rui.key, rui.csr, rui.crt</strong> 三个文件。我们只需要将 <strong>rui.crt</strong> 证书文件复制到客户机上安装，可以通过任何方式复制出来，例如 sftp，winscp 等。</p><p><strong>esxi 上需要重启系统后新的证书才能生效。</strong>注意重启后 ssh 功能可能需要重新打开。</p><h3>客户端安装证书</h3><p>在 macOS 上安装证书，双击复制出来的 rui.crt 安装即可。安装后需要设置为信任，进入 keychain access 中，在 system 栏点击 certificates 菜单项就能找到刚刚安装的证书，双击证书进入属性，点击 trust 菜单，将 when using this certificate 设置为 always trust 即可，关闭时会提示输入密码。</p><p>此时我们就可以以 https 访问 esxi web 管理页面并且不会报证书错误了。</p><h3>参考链接</h3><p><a href="https://www.vmwareblog.org/replace-default-esxi-ssl-certificate-self-signed-certificate-101-introduction/">How to Replace Your Default ESXi SSL Certificate With a Self-Signed Certificate</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2611.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/category/Linux/</wfw:commentRss>
</item>
<item>
<title>openwrt 修改进程 Socket 句柄数</title>
<link>https://blog.niekun.net/archives/2572.html</link>
<guid>https://blog.niekun.net/archives/2572.html</guid>
<pubDate>Sun, 03 Apr 2022 08:50:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[最近在使用中发现一个软件 log 中出现大量的报错：/core/transport/internet/tcp: failed to accepted raw connections &gt; a...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>最近在使用中发现一个软件 log 中出现大量的报错：</p><pre><code>/core/transport/internet/tcp: failed to accepted raw connections &gt; accept tcp [::]:18919: accept4: too many open files</code></pre><p>查询后知道这是进程占用的句柄数超出了系统最大值导致的。由于我的系统是 openwrt 所以下面介绍如何修改某个进程的最大句柄数限制。</p><!--more--><p>首先查询当前系统当前的句柄限制值：</p><pre><code>ulimit -n

1024</code></pre><p>也可以查询当前系统的其他所有限制参数：</p><pre><code>ulimit -a</code></pre><p>返回 1024 表示当前系统每个进程的限制值是 1024。</p><p>然后我们查询下当前系统进程中占用情况：</p><pre><code>lsof -n |awk '{print $2}'|sort|uniq -c |sort -nr|more

     8790 2390
     41 2638
     27 1914
     26 1
     25 2127
     23 2166
     23 1976
     23 1704</code></pre><p>可以看到进程PID号 2390 就占用了 8790 个句柄，这肯定超出了系统限制，我们看看这个 2390 到底是那个程序：</p><pre><code>ps | grep 2390

 2390 root     5005m S    /usr/bin/v2ray -confdir /etc/v2ray/conf.d
 6815 root      1072 R    grep 2390</code></pre><p>发现的确是我报错的那个程序占用了这个进程。</p><p>然后我们查询系统可以设置的最大句柄数：</p><pre><code>cat /proc/sys/fs/file-max

101238</code></pre><p>返回值说明当前系统可以设置最大句柄数为 101238.</p><p>想要修改句柄数需要在对应进程的 procd init script 脚本修改内容，在 start_service 中增加：</p><pre><code>        procd_set_param limits core=&quot;unlimited&quot;
        procd_set_param limits nofile=&quot;101200&quot;
        procd_set_param limits nproc=&quot;101200&quot;</code></pre><p>limits 参数可以设置系统的一些限制值，openwrt 可用的限制值名称可以在官方文档找到：<a href="https://openwrt.org/docs/guide-developer/procd-init-scripts#service_parameters">https://openwrt.org/docs/guide-developer/procd-init-scripts#service_parameters</a></p><p>以上就将系统限制设置为一个较大的值，修改完成后重启这个进程即可。</p><h3>参考链接</h3><p><a href="https://www.cccitu.com/3827.html">Linux命令：TCP连接高并发时Socket句柄数的修改</a><br><a href="https://openwrt.org/docs/guide-developer/procd-init-scripts#service_parameters">procd-init-scripts#service_parameters</a><br><a href="https://openwrt.org/docs/guide-developer/procd-init-script-example#advanced_options">procd-init-script-example#advanced_options</a><br><a href="https://blog.niekun.net/archives/2277.html">openwrt procd init script 自启动脚本服务</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2572.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/category/Linux/</wfw:commentRss>
</item>
<item>
<title>iptables 配置透明代理注意事项</title>
<link>https://blog.niekun.net/archives/2570.html</link>
<guid>https://blog.niekun.net/archives/2570.html</guid>
<pubDate>Sun, 03 Apr 2022 08:33:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[之前介绍过通过 dnsmasq 配合 iptables 实现对 ip 地址的流量过滤，dnsmasq 获取到流量后标记 ipset 然后通过 iptables 识别 ipset 然后将流量送往指...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>之前介绍过通过 dnsmasq 配合 iptables 实现对 ip 地址的流量过滤，dnsmasq 获取到流量后标记 ipset 然后通过 iptables 识别 ipset 然后将流量送往指定地址。</p><p><a href="https://blog.niekun.net/archives/1872.html">通过 dnsmasq ipset 和 iptables 对域名流量的控制</a><br><a href="https://blog.niekun.net/archives/1863.html">iptables 使用教程</a></p><p>这里面存在一个问题就是流量回环问题，如果处理不好回导致 iptables 规则无限循环，尤其是在配置透明代理时候。</p><pre><code>iptables -t mangle -A PREROUTING -p tcp -m set --match-set gfwlist dst -j TPROXY --on-port 1081 --tproxy-mark 1
iptables -t mangle -A PREROUTING -p udp -m set --match-set gfwlist dst -j TPROXY --on-port 1081 --tproxy-mark 1
iptables -t mangle -A OUTPUT -p tcp -m set --match-set gfwlist dst -j MARK --set-mark 1
iptables -t mangle -A OUTPUT -p udp -m set --match-set gfwlist dst -j MARK --set-mark 1</code></pre><p>以上规则会将 指定 list 的流量发送到指定端口并打上 mark 标记，但是从目标地址返回数据后，数据流会再次匹配到以上规则导致再次将流量送往指定端口，导致无限循环。</p><p>处理方法就是在目标地址获取到流量后，给流量打上 mark 标记，然后在 iptables 的最前面加上一条规则识别从目标地址返回的流量，直接 return 流量即可。</p><p>例如目标地址处理后的流量标记为 mark 2，iptables 规则最前面增加一条规则：</p><pre><code>iptables -t mangle -I OUTPUT -j RETURN -m mark --mark 0x02</code></pre><p><code>-I</code> 参数就是将规则放在在路由链的最前面。</p><p>如果是通过脚本的方式配置 iptables，将开始的脚本内容修改如下即可：</p><pre><code>iptables -t mangle -A OUTPUT -j RETURN -m mark --mark 0x02

iptables -t mangle -A PREROUTING -p tcp -m set --match-set gfwlist dst -j TPROXY --on-port 1081 --tproxy-mark 1
iptables -t mangle -A PREROUTING -p udp -m set --match-set gfwlist dst -j TPROXY --on-port 1081 --tproxy-mark 1
iptables -t mangle -A OUTPUT -p tcp -m set --match-set gfwlist dst -j MARK --set-mark 1
iptables -t mangle -A OUTPUT -p udp -m set --match-set gfwlist dst -j MARK --set-mark 1</code></pre><p>这样就可以避免流量回环问题。</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2570.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/category/Linux/</wfw:commentRss>
</item>
<item>
<title>安装 phpMyAdmin 管理 MySQL</title>
<link>https://blog.niekun.net/archives/2457.html</link>
<guid>https://blog.niekun.net/archives/2457.html</guid>
<pubDate>Mon, 28 Mar 2022 09:31:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[phpMyAdmin 是一个 php 的免费工具，用来在 web 端管理 MySQL 数据库。它支持大部分的 MySQL 功能，比如：创建数据库，修改数据，管理用户权限，导入导出数据等。官方网站...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>phpMyAdmin 是一个 php 的免费工具，用来在 web 端管理 MySQL 数据库。它支持大部分的 MySQL 功能，比如：创建数据库，修改数据，管理用户权限，导入导出数据等。</p><p>官方网站：<a href="https://www.phpmyadmin.net/">https://www.phpmyadmin.net/</a><br>GitHub 主页：<a href="https://github.com/phpmyadmin/phpmyadmin">https://github.com/phpmyadmin/phpmyadmin</a></p><p>下面介绍在 Ubuntu 20.04 的安装及使用过程。</p><!--more--><h3>安装</h3><p>首先确保已经安装好了 MySQL 和 php：</p><pre><code>apt install mysql-server php php-fpm php-mysql
</code></pre><p>然后安装 phpMyAdmin：</p><pre><code>apt install phpmyadmin
</code></pre><p>安装过程中会提示创建一个 mysql 管理账户 phpmyadmin，一般直接确认即可，然后设置账户密码。如果这一步跳过了创建账户，后期需要手动修改配置文件或手动创建一个 phpmyadmin 管理账户，否则登录可能会报错。</p><h3>配置 nginx</h3><p>安装完成后需要配置代理服务器，我使用的是 nginx，下面是 nginx 的配置文件部分：</p><pre><code>    location /phpmyadmin {
        root /usr/share/;
        index index.php index.html index.htm;
        location ~ ^/phpmyadmin/(.+\.php)$ {
            fastcgi_pass unix:/run/php/php7.4-fpm.sock;
            include fastcgi-php.conf;
        }
    }</code></pre><h3>使用</h3><p>配置完成后就可以登陆 phpmyadmin 页面了，登录对应的 mysql 管理账户，可以是安装 phpmyadmin 时创建的账户也可以是我们之前使用 mysql 自己的账户：<br><img src="https://blog.niekun.net/usr/uploads/2022/03/109981368.png" alt="2022-03-28T01:25:37.png" title="2022-03-28T01:25:37.png"></p><p>如果登录后发现下面有报错信息：</p><pre><code>Access denied for user 'phpmyadmin'@'localhost' (using password: NO)
</code></pre><p>可能就是安装的时候跳过了创建 phpmyadmin MySQL 账户的步骤，这里我们可以在终端手动创建报错信息中提示的用户名或者直接修改配置文件中定义的 phpmyadmin 管理账户。</p><p>修改 <code>/etc/phpmyadmin/config.inc.php</code>，找到如下字段：</p><pre><code>$cfg['Servers'][$i]['controluser'] = 'user';
$cfg['Servers'][$i]['controlpass'] = 'password';</code></pre><p>将上面的用户名密码修改为 MySQL 中存在的账户即可。刷新页面之后应该就没有报错了。</p><p>手动创建 MySQL 用户可以参考教程：<a href="https://blog.niekun.net/archives/23.html#title-3">https://blog.niekun.net/archives/23.html#title-3</a></p><p>然后我们就可以正常使用 phpmyadmin 管理页面了，这里可以查看 database，导入导出数据等。</p><h3>参考链接</h3><p><a href="https://stackoverflow.com/questions/46736319/phpmyadmin-error-mysqli-real-connect-hy000-1045-access-denied-for-user-p">phpMyAdmin ERROR: mysqli_real_connect(): (HY000/1045): Access denied for user 'pma'@'localhost' (using password: NO)</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2457.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/category/Linux/</wfw:commentRss>
</item>
<item>
<title>使用 rclone 管理网盘文件</title>
<link>https://blog.niekun.net/archives/2454.html</link>
<guid>https://blog.niekun.net/archives/2454.html</guid>
<pubDate>Mon, 14 Mar 2022 11:35:31 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[之前介绍了通过 gdrive 在服务器上管理 Google drive 文件，实现服务器数据备份自动上传功能。最近发现有一个新的开源项目 rclone 支持更多的网盘，同时更新迭代速度也更快。G...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>之前介绍了通过 gdrive 在服务器上管理 Google drive 文件，实现服务器数据备份自动上传功能。最近发现有一个新的开源项目 rclone 支持更多的网盘，同时更新迭代速度也更快。</p><p>GitHub 主页：<a href="https://github.com/rclone/rclone">https://github.com/rclone/rclone</a></p><p>他支持的网盘列表：<a href="https://rclone.org/overview/">https://rclone.org/overview/</a></p><p>下面介绍它的安装使用方法。</p><!--more--><h3>安装</h3><p>Linux 下一键安装命令：</p><pre><code>curl https://rclone.org/install.sh | sudo bash
</code></pre><p>macos 通过 brew 安装：</p><pre><code>brew install rclone
</code></pre><h3>配置</h3><p>首次运行执行初始化配置：</p><pre><code>rclone config
</code></pre><p>根据提示创建新 remote：</p><pre><code>No remotes found - make a new one
n) New remote
r) Rename remote
c) Copy remote
s) Set configuration password
q) Quit config
n/r/c/s/q&gt; n</code></pre><p>然后设置此连接名称，后续就是通过这个名称来操作不同的网盘的：</p><pre><code>name&gt; remote
</code></pre><p>下一步选择网盘类型，如果是 Google drive 选择 16：</p><pre><code>Type of storage to configure.
Choose a number from below, or type in your own value
[snip]
16 / Google Drive
   \ &quot;drive&quot;
[snip]
Storage&gt; 16</code></pre><p>下面的 id 和 secret 都默认回车即可：</p><pre><code>Google Application Client Id - leave blank normally.
client_id&gt;
Google Application Client Secret - leave blank normally.
client_secret&gt;</code></pre><p>下面设置可访问全部网盘文件，选择 1：</p><pre><code>Scope that rclone should use when requesting access from drive.
Choose a number from below, or type in your own value
 1 / Full access all files, excluding Application Data Folder.
   \ &quot;drive&quot;
 2 / Read-only access to file metadata and file contents.
   \ &quot;drive.readonly&quot;
   / Access to files created by rclone only.
 3 | These are visible in the drive website.
   | File authorization is revoked when the user deauthorizes the app.
   \ &quot;drive.file&quot;
   / Allows read and write access to the Application Data folder.
 4 | This is not visible in the drive website.
   \ &quot;drive.appfolder&quot;
   / Allows read-only access to file metadata but
 5 | does not allow any access to read or download file content.
   \ &quot;drive.metadata.readonly&quot;
scope&gt; 1</code></pre><p>下面几步都默认回车即可。</p><p>注意到了 use auto config 的时候要选择 No，因为我们是远程 ssh 访问的服务器：</p><pre><code>Use auto config?
 * Say Y if not sure
 * Say N if you are working on a remote or headless machine or Y didn't work
y) Yes
n) No
y/n&gt; n</code></pre><p>下面会返回一个链接，复制链接到浏览器后，登录 google 账户给 rclone 授权。授权完成后会返回一个字符串码，粘贴回终端。</p><p>后续几步默认回车即可，最后输入 q 退出 config。</p><h3>使用</h3><p>配置完成后我们就可以使用了，下面介绍一些基本语法。下面示例中网盘配置名称为 remote。</p><p>列出网盘的所有文件：</p><pre><code>rclone ls remote:
</code></pre><p>列出一个文件夹内的所有文件：</p><pre><code>rclone ls remote:abc
</code></pre><p>创建一个文件夹：</p><pre><code>rclone mkdir remote:abc
rclone mkdir remote:abc/def
</code></pre><p>删除网盘内一个文件：</p><pre><code>rclone delete remote:abc/123.txt
</code></pre><p>删除一个文件夹：</p><pre><code>rclone rmdir remote:abc
</code></pre><p>复制本地一个文件到网盘：</p><pre><code>rclone copy 123.txt remote:abc
</code></pre><p>更多可用命令可以参考官方文档：<a href="https://rclone.org/docs/#subcommands">https://rclone.org/docs/#subcommands</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2454.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/category/Linux/</wfw:commentRss>
</item>
<item>
<title>Ubuntu 18.04 升级 Ubuntu 20.04 记录</title>
<link>https://blog.niekun.net/archives/2451.html</link>
<guid>https://blog.niekun.net/archives/2451.html</guid>
<pubDate>Sat, 12 Mar 2022 15:32:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[昨天决定把服务器的系统从 Ubuntu 18.04 升级到 Ubuntu 20.04，其中经历了不少问题点，下面记录下处理过程。首先就是升级当前系统所有包到最新：apt update &amp;...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>昨天决定把服务器的系统从 Ubuntu 18.04 升级到 Ubuntu 20.04，其中经历了不少问题点，下面记录下处理过程。</p><p>首先就是升级当前系统所有包到最新：</p><pre><code>apt update &amp;&amp; apt upgrade -y
apt autoremove &amp;&amp; apt purge
</code></pre><p>然后安装升级需要的管理包，不过一般系统都是自带的：</p><pre><code>apt install update-manager-core
</code></pre><p>然后就可以更新系统了：</p><pre><code>do-release-upgrade
</code></pre><p>标准流程就是以上几步，但是在最后一步的时候问题就开始出现了。</p><!--more--><p>在执行升级命令后出现报警：</p><pre><code>Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings
</code></pre><p>在查询一些资料后，原来是 ssl certificates 验证问题，系统无法鉴定上面的 https 链接证书是否有效就返回错误了。</p><p>这个问题也是我这个系统的一个遗留问题，每次执行 wget 或 curl 下载东西的时候就会提示证书报错，需要通过附加指令跳过证书验证，但这就会存在安全问题了。</p><p>解决方法就是更新本地证书库后添加 <code>SSL_CERT_DIR</code> 环境变量指向系统证书目录：</p><pre><code>update-ca-certificates --verbose --fresh
export SSL_CERT_DIR=/etc/ssl/certs
</code></pre><p>为了方便以后使用，将环境变量添加到 <code>~/.bashrc</code> 文件中。这样就解决了 https 链接证书验证问题。</p><p>然后先删除之前执行升级命令后错误内容：</p><pre><code>rm /var/lib/ubuntu-release-upgrader/release-upgrade-available
/usr/lib/ubuntu-release-upgrader/release-upgrade-motd
</code></pre><p>之后再次执行升级命令 <code>do-release-upgrade</code>。</p><p>这时候报错信息变化了，这时候提示的是 python3 有问题，原因是我当前系统使用的是自己编译的 python 3.8，路径在 /opt 目录下。当时将系统软链接 <code>/usr/bin/python</code> 和 <code>/usr/bin/python3</code> 都指向了自己安装的 python，需要将他们恢复到指向系统内置的 python 程序。</p><p>下面需要介绍下系统内 python 主程序和软链接的分布：</p><pre><code>python2 主应用程序为 /usr/bin/python2.7
python3 主应用程序为 /usr/bin/python3.6
pip 主程序为 /usr/bin/pip
pip3 主程序为 /usr/bin/pip3</code></pre><p>下面是默认的软链接及指向的应用程序：</p><pre><code>/usr/bin/python  -&gt;  /usr/bin/python2.7
/usr/bin/python2  -&gt;  /usr/bin/python2.7
/usr/bin/python3  -&gt;  /usr/bin/python3.6
/usr/local/bin/pip  -&gt;  /usr/bin/pip
/usr/local/bin/pip3  -&gt;  /usr/bin/pip3</code></pre><p>如果你修改过这些软链接到自己的 python 版本，就需要修改回来：</p><pre><code>ln -sf /usr/bin/python2.7 /usr/bin/python
ln -sf /usr/bin/python2.7 /usr/bin/python2
ln -sf /usr/bin/python3.6 /usr/bin/python3
ln -sf /usr/bin/pip /usr/local/bin/pip
ln -sf /usr/bin/pip3 /usr/local/bin/pip3
ldconfig</code></pre><p>以上问题都处理完后，再次执行升级命令，一切都正常了。</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2451.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/category/Linux/</wfw:commentRss>
</item>
<item>
<title>解决 wget 下载时 certificates 证书报错问题</title>
<link>https://blog.niekun.net/archives/2448.html</link>
<guid>https://blog.niekun.net/archives/2448.html</guid>
<pubDate>Fri, 11 Mar 2022 16:48:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[我的服务器上在使用 wget 或者 curl 等网络工具时，每次都提示类似下面的报错：ERROR: cannot verify github.com's certificate, issued ...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>我的服务器上在使用 wget 或者 curl 等网络工具时，每次都提示类似下面的报错：</p><pre><code>ERROR: cannot verify github.com's certificate, issued by ‘CN=DigiCert High Assurance TLS Hybrid ECC SHA256 2020 CA1,O=DigiCert\\, Inc.,C=US’:
  Unable to locally verify the issuer's authority.
To connect to github.com insecurely, use `--no-check-certificate'.</code></pre><p>需要通过参数跳过证书检查，但是这样又有了安全风险。</p><p>首先尝试更新本地证书文件：</p><pre><code>update-ca-certificates --verbose --fresh</code></pre><p>发现问题没有解决，原来是系统缺少了一个指向证书路径 <code>/etc/ssl/certs</code> 的环境变量，尝试添加：</p><pre><code>export SSL_CERT_DIR=/etc/ssl/certs</code></pre><p>再次测试 wget 命令，发现问题的确没有了。</p><p>可以将上面的环境变量添加到系统 shell 配置文件中，我这里是 <code>~/.bashrc</code>，添加后刷新一下即可：</p><pre><code>source ~/.bashrc</code></pre><p><strong>在更新 Ubuntu18.04 到 20.04 时，也是这个问题导致的报错。</strong></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2448.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/category/Linux/</wfw:commentRss>
</item>
<item>
<title>openwrt 扩展根目录空间</title>
<link>https://blog.niekun.net/archives/2321.html</link>
<guid>https://blog.niekun.net/archives/2321.html</guid>
<pubDate>Tue, 22 Jun 2021 21:40:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[我在软路由上通过 esxi 安装了 openwrt 作为路由系统。虚拟机分配了 5 GB 作为存储空间，但是安装完成后通过命令查看发现系统识别到的空间只有很小：root@OpenWrt:~# d...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>我在软路由上通过 esxi 安装了 openwrt 作为路由系统。虚拟机分配了 5 GB 作为存储空间，但是安装完成后通过命令查看发现系统识别到的空间只有很小：</p><pre><code>root@OpenWrt:~# df -h
Filesystem                Size      Used Available Use% Mounted on
/dev/root               252.0M    241.4M      5.5M  98% /rom
tmpfs                   496.5M     68.0K    496.4M   0% /tmp
/dev/sda1                15.7M      3.8M     11.6M  25% /boot
/dev/sda1                15.7M      3.8M     11.6M  25% /boot
tmpfs                   512.0K         0    512.0K   0% /dev</code></pre><p>其中 <code>/dev/root</code> 是系统固件目录，不用考虑。<code>/dev/sda*</code> 就是系统实际可用的硬盘空间。我明明分配了 5 GB 空间给 openwrt 但是由于系统分区是在下载的固件中定义好的，所以其余空间就没有被识别。由于默认存储空间过小，当安装了过多的插件后，会提示空间不足导致无法安装更多插件：</p><pre><code>verify_pkg_installable: Only have 0kb available on filesystem /overlay, pkg luci-app-openvpn needs 9
opkg_install_cmd: Cannot install package luci-app-openvpn</code></pre><p>下面介绍如何将剩余空间挂在到 openwrt 中。</p><!--more--><p>首先安装需要的插件，注意顺序不能错：</p><pre><code>opkg update
opkg install block-mount e2fsprogs
opkg update
opkg install fdisk blkid</code></pre><p>然后配置存储空间，注意 fdisk 指令后的几个选项：</p><pre><code>fdisk -l

fdisk /dev/sda
m
n
p
&lt;默认,回车&gt; //–&gt;分区号为3
&lt;默认,回车&gt;
&lt;默认,回车&gt;
w

reboot</code></pre><p>重启后，格式化刚才建立的分区：</p><pre><code>mkfs.ext4 /dev/sda3
reboot</code></pre><p>重启后配置 fstab：</p><pre><code>uci add fstab mount

# 将下面第一行命令输出的 UUID 替换第二行命令后的 UUID
blkid -s UUID /dev/sda3 | cut -d\&quot; -f2
uci set fstab.@mount[-1].uuid=UUID

uci set fstab.@mount[-1].options=rw,sync,noatime
uci set fstab.@mount[-1].fstype=ext4
uci set fstab.@mount[-1].enabled_fsck=1
uci set fstab.@mount[-1].enabled=1
uci set fstab.@mount[-1].target=/
uci set fstab.@mount[-1].device=/dev/sda3
uci commit fstab</code></pre><p>然后根目录复制到新的分区下：</p><pre><code>mkdir /mnt/sda3
mount /dev/sda3 /mnt/sda3
mkdir -p /tmp/cproot
mount --bind / /tmp/cproot
tar -C /tmp/cproot -cvf - . | tar -C /mnt/sda3 -xf -

umount /tmp/cproot
umount /mnt/sda3</code></pre><p>然后启用引导：</p><pre><code>/etc/init.d/fstab enable
/etc/init.d/fstab start

reboot</code></pre><p>重启后再次查看系统分区信息：</p><pre><code>root@OpenWrt:~# df -h
Filesystem                Size      Used Available Use% Mounted on
/dev/root               252.0M    241.4M      5.5M  98% /rom
tmpfs                   496.5M      1.0M    495.5M   0% /tmp
/dev/sda3                 4.6G    257.2M      4.1G   6% /
/dev/sda1                15.7M      3.8M     11.6M  25% /boot
/dev/sda1                15.7M      3.8M     11.6M  25% /boot
tmpfs                   512.0K         0    512.0K   0% /dev</code></pre><p>可以看到 sda3 分区已经正常挂载了，后续可以继续安装需要的各种插件了。</p><h3>参考链接</h3><p><a href="https://blog.csdn.net/duandao123/article/details/99689383">Vmware下openwrt虚拟机扩展根目录大小</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2321.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/category/Linux/</wfw:commentRss>
</item>
<item>
<title>理解 Linux shell 脚本的 2&amp;gt;&amp;amp;1</title>
<link>https://blog.niekun.net/archives/2320.html</link>
<guid>https://blog.niekun.net/archives/2320.html</guid>
<pubDate>Mon, 31 May 2021 18:33:51 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[我们在编程中经常会使用一些固定语句来解决对应固定的问题，在 shell 脚本中一个被经常使用但不太好理解的短句就是 2&gt;&amp;1，例如：ls foo &gt; /dev/null 2&...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>我们在编程中经常会使用一些固定语句来解决对应固定的问题，在 shell 脚本中一个被经常使用但不太好理解的短句就是 <code>2&gt;&amp;1</code>，例如：</p><pre><code>ls foo &gt; /dev/null 2&gt;&amp;1
</code></pre><p>下面我们一步步了解下这种结构的含义。</p><!--more--><h3>I/O redirection 重定向</h3><p>简单理解，redirection 重定向就是将一个命令的 output 输出发送到另一个地方。例如，我们通过 <code>cat</code> 命令打印一个文件的内容到屏幕：</p><pre><code>$ cat foo.txt
foo
bar
baz</code></pre><p>我们也可以将输出的内容发送到其他地方，例如将内容重定向到另一个文件 file.txt:</p><pre><code>$ cat foo.txt &gt; output.txt

$ cat output.txt
foo
bar
baz</code></pre><p>执行第一条 cat 命令，我们不会看到任何输出信息，因为我们修改了 <strong>standard output (stdout)标准输出</strong>到一个文件，所以它就不会输出到屏幕了。</p><p>需要注意的是还有另一个地方：<strong>standard error (stderr)标准错误</strong>，当有错误时会输出信息。所以当我们通过 cat 命令输出一个不存在的文件内容时：</p><pre><code>$ cat nop.txt &gt; output.txt
cat: nop.txt: No such file or directory</code></pre><p>以上示例中即使我们将 <strong>stdout</strong> 重定向到一个文件了，由于 output.txt 不存在，<strong>stderr</strong> 依然会输出错误信息到屏幕。因为我们重定向的只是 <strong>stdout</strong> 而不包括 <strong>stderr</strong>。</p><h3>file descriptors 文件描述器</h3><p>一个文件描述器是一个正整数，用来表示一个打开文件的。每个文件都有其各自的文件描述器。这里我们只需要知道 <strong>stdout</strong> 和 <strong>stderr</strong> 有其各自的文件描述器 id 定义了它们各自的地址。</p><p><strong>stdout</strong> 是 <strong>1</strong>，<strong>stderr</strong> 是 <strong>2</strong>。</p><p>在之前的示例中，我们可以修改命令为如下结构：</p><pre><code>cat foo.txt 1&gt; output.txt
</code></pre><p>这里的 <strong>1</strong> 就是 <strong>stdout</strong> 的文件描述器，通过重定向语法 <code>[FILE_DESCRIPTOR]&gt;</code> 将 <strong>stdout</strong> 重定向到另一个文件。注意 <code>1&gt;</code> 可以简写为 <code>&gt;</code>。</p><p>类似的，可以将 stderr 重定向到指定的目的地：</p><pre><code>$ cat nop.txt 2&gt; error.txt

$ cat error.txt
cat: nop.txt: No such file or directory</code></pre><p>这样就会将 error 存入 error.txt 文件，屏幕上不会输出任何信息。</p><p>下面我们理解下 <code>2&gt;&amp;1</code> 的意义。我们使用 <code>&amp;1</code> 来指向 <strong>stdout</strong> 的重定向地址，所以 <code>2&gt;&amp;1</code> 表示重定向 <strong>stderr</strong> 到和 <strong>stdout</strong> 同样的重定向位置上。所以我们就可以通过下面示例的方法同时将 <strong>stdout</strong> 和 <strong>stderr</strong> 重定向到同一个文件中：</p><pre><code>$ cat foo.txt &gt; output.txt 2&gt;&amp;1

$ cat output.txt
foo
bar
baz

$ cat nop.txt &gt; output.txt 2&gt;&amp;1

$ cat output.txt
cat: nop.txt: No such file or directory</code></pre><h3>总结</h3><ul><li>有两个地方用来让程序发送输出内容：<strong>stdout</strong>，<strong>stderr</strong></li><li>可以单独定义两个输出的重定向目的地</li><li>文件描述器用来识别 <strong>stdout (1)</strong> 和 <strong>stderr (2)</strong></li><li><code>command &gt; output</code> 是 <code>command 1&gt; output</code> 的简写</li><li>通过 <code>&amp;[FILE_DESCRIPTOR]</code> 指向一个文件描述器的重定向目标地址上</li><li><code>2&gt;&amp;1</code> 可以将 <strong>stderr</strong> 重定向到 <strong>stdout</strong> 同样的重定向地址上。反之亦然。</li></ul><h3>参考链接</h3><p><a href="https://www.brianstorti.com/understanding-shell-script-idiom-redirect/">Understanding Shell Script's idiom: 2&gt;&1</a><br><a href="https://stackoverflow.com/questions/818255/in-the-shell-what-does-21-mean">In the shell, what does “ 2&gt;&1 ” mean?</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2320.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/category/Linux/</wfw:commentRss>
</item>
</channel>
</rss>