<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
xmlns:content="http://purl.org/rss/1.0/modules/content/"
xmlns:dc="http://purl.org/dc/elements/1.1/"
xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
xmlns:atom="http://www.w3.org/2005/Atom"
xmlns:wfw="http://wellformedweb.org/CommentAPI/">
<channel>
<title>Marco Nie - javascript</title>
<link>https://blog.niekun.net/category/js/</link>
<atom:link href="https://blog.niekun.net/feed/category/js/" rel="self" type="application/rss+xml" />
<language>zh-CN</language>
<description></description>
<lastBuildDate>Sun, 07 Feb 2021 17:17:30 +0800</lastBuildDate>
<pubDate>Sun, 07 Feb 2021 17:17:30 +0800</pubDate>
<item>
<title>node.js 入门教程之六 -- FileSystem</title>
<link>https://blog.niekun.net/archives/2140.html</link>
<guid>https://blog.niekun.net/archives/2140.html</guid>
<pubDate>Sun, 07 Feb 2021 17:17:30 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[File descriptor 文件描述器当需要访问文件系统里的某个文件时，需要首先得到这个文件的 file descriptor 文件描述器。一个 file descriptor 就是通过 f...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<h3>File descriptor 文件描述器</h3><p>当需要访问文件系统里的某个文件时，需要首先得到这个文件的 file descriptor 文件描述器。</p><p>一个 file descriptor 就是通过 <strong>fs</strong> 模块的 <code>open()</code> method 打开对应文件的返回数据。它的结构如下：</p><pre><code>const fs = require('fs')

fs.open('./test.txt', 'r', (err, data) =&gt; {
    if (err) {
        console.log('open fail')
        return
    }
    console.log('open success')
})</code></pre><p>如果文件打开成功，callback 中的 <strong>data</strong> 数据就是一个 file descriptor。这种方式是异步处理的，文件打开过程中系统会执行其他任务。</p><!--more--><p>在上面的示例中，<code>fs.open()</code> 的第三个参数使用了 <code>'f'</code> 标记，它的意思就是以<strong>只读模式</strong>打开文件。我们可以通过使用不同的标记来以不同的方式打开文件：</p><ul><li><strong>r</strong> 只读模式，文件不存在会报错</li><li><strong>a</strong> 只写模式，streaming 流定位到文件结尾位置，如果文件不存在则创建文件</li><li><strong>r+</strong> 读写模式，文件不存在会报错</li><li><strong>w+</strong> 读写模式，streaming 流定位到文件起始位置，如果文件不存在则创建文件</li><li><strong>a+</strong> 读写模式，streaming 流定位到文件结尾位置，如果文件不存在则创建文件</li></ul><p>更多 flag 的使用参考：<a href="https://nodejs.org/api/fs.html#fs_file_system_flags">https://nodejs.org/api/fs.html#fs_file_system_flags</a></p><p>也可以使用 <code>fs.openSync()</code> method 打开文件，其返回值为 file descriptor 而不是通过 callback 的方式：</p><pre><code>try {
    const data = fs.openSync('./test.txt', 'r')
    console.log('open success')
} catch (error) {
    console.log('open fail')
}</code></pre><p>这种方式是同步模式的，程序会等待接收到 file descriptor 或者 error 后才执行后面的指令。</p><h3>File stats 文件信息</h3><p>每个文件都包含独自的属性信息，可以通过 node.js 查看。通常我们使用 fs 模块的 <code>stat()</code> method。</p><p>以下是一个简单示例：</p><pre><code>const fs = require('fs')

fs.stat('./test.txt', (err, stats) =&gt; {
    if (err) {
        console.log('read fail')
        return
    }
    console.log(stats)
})</code></pre><p>同样的，node.js 也提供了同步模式 method，在读取 stats 过程中会阻塞进程知道读取结束：</p><pre><code>try {
    const stats = fs.statSync('./test.txt')
    console.log(stats)
} catch (error) {
    console.log(error)
}</code></pre><p>文件信息存储在 stats 变量中，可以读取其中的需要的信息，常用的有以下：</p><ul><li>是否是文件或文件夹：<code>stats.isFile()</code>，<code>stats.isDirectory()</code></li><li>是否是一个链接文件：<code>stats.isSymbolicLink()</code></li><li>文件大小(单位为字节)：<code>stats.size</code></li></ul><h3>File Path 文件路径</h3><p>每个文件在系统中都有一个路径。在 Linux 中路径格式如：<code>/users/joe/file.txt</code>，在 Windows 中路径格式如：<code>C:\users\joe\file.txt</code>。在程序中引用路径时需要特别注意路径的格式。</p><p>node.js 中可以使用 <strong>path</strong> 模块来处理文件路径相关数据。</p><p>如果给定一个路径，可以提取其相关数据，如：</p><ul><li><strong>path.dirname</strong>: 获取文件的上级文件夹路径</li><li><strong>path.basename</strong>: 获取文件名部分</li><li><strong>path.extname</strong>: 获取文件扩展名</li></ul><pre><code>const path = require('path')

const file = '/home/marco/file.txt'
console.log(path.dirname(file))
console.log(path.basename(file))
console.log(path.extname(file))

//output:
/home/marco
file.txt
.txt</code></pre><p>可以获取文件名不包含扩展名部分，通过给 <code>path.basename()</code> 设置第二个参数：</p><pre><code>console.log(path.basename(file, path.extname(file)))

//output:
file</code></pre><p>可以组合多个部分为一个 path：</p><pre><code>const dir = 'home/marco/'
p = path.join('/' + dir + 'test.txt')
console.log(p)

//output:
/home/marco/test.txt</code></pre><p>使用 <code>path.resolve()</code> 可以从一个相对路径获取到绝对路径：</p><pre><code>p = path.resolve('file.txt')
console.log(p)
p = path.resolve('./test/file.txt')
console.log(p)

//OUTPUT:
/mnt/hgfs/Development/node.js/filesystem/file.txt
/mnt/hgfs/Development/node.js/filesystem/test/file.txt</code></pre><p>以上示例中，会将程序当前执行路径作为绝对路径添加给后面定义的文件相对路径。</p><p>也可以将文件的相对目录单独定义，会自动组合它们：</p><pre><code>p = path.resolve('tmp', 'file.txt')
console.log(p)

//output:
/mnt/hgfs/Development/node.js/filesystem/tmp/file.txt</code></pre><p>如果在路径前加斜杠<code>/</code> 表明这就是一个绝对路径：</p><pre><code>p = path.resolve('/tmp', 'file.txt')
console.log(p)

//output:
/tmp/file.txt</code></pre><p>如果路径中包含相对关系标记符如: <code>..</code>, <code>//</code>等，可以使用 <code>path.normalize()</code> 得到常规形式的路径：</p><pre><code>p = path.normalize('/home/../test/file.txt')
console.log(p)

//output:
/test/file.txt</code></pre><p>path.resolve 和 path.normalize <strong>都不会检查路径是否真实存在</strong>，它们仅仅是根据提供的数据计算路径结果。</p><h3>reading file 读取文件</h3><p>最简单的方式读取文件内容就是通过 <code>fs.readFile()</code> method，需要给它传入文件路径，编码格式，callback function:</p><pre><code>const fs = require('fs')

fs.readFile('./test.txt', 'utf-8', (err, data) =&gt; {
    if (err) {
        console.log('read fail')
        return
    }
    console.log(data)
})</code></pre><p>或者也可以使用同步模式的 <code>fs.readFileSync()</code>：</p><pre><code>try {
    data = fs.readFileSync('./test.txt', 'utf-8')
    console.log(data)
} catch (error) {
    console.log('read error')
}</code></pre><p><code>fs.readFile()</code> 和 <code>fs.readFileSync()</code> 都会先将文件内容读取到内存中，然后返回数据。这就意味着读取大文件会影响系统内存的占用量，所以一个比较好的选择是使用 stream 流读取文件内容。后续章节会介绍 stream 模块。</p><h3>writing file 文件写入</h3><p>最简单的写入文件的方法就是使用 <code>fs.writeFile()</code> method。</p><p>示例如下：</p><pre><code>const fs = require('fs')

const content = 'some new words'
fs.writeFile('./test.txt', content, err =&gt; {
    if (err) {
        console.log('write error')
        return
    }
    console.log('write success')
})</code></pre><p>或者使用同步模式的版本 <code>fs.writeFileSync()</code>：</p><pre><code>try {
    fs.writeFileSync('./test.txt', content)
    console.log('write success')
} catch (error) {
    console.log('write error')
}</code></pre><p>默认情况下，如果这个文件已经存在，API 会替换掉这个文件中已有的内容。我们可以通过定义 <strong>flag</strong> 来修改这个设置：</p><pre><code>fs.writeFile('./test.txt', content, {flag: 'a+'}, err =&gt; {
    if (err) {
        console.log('write error')
        return
    }
    console.log('write success')
})</code></pre><p>flag 的定义和上面的 <code>fs.open</code> 中定义的 flag 一样，可以参考设置。</p><h3>append to a file 给文件添加内容</h3><p>给已有文件附加内容更加方便的方法是使用 <code>fs.appendFile()</code>和 <code>fs.appendFileSync()</code>，例如：</p><pre><code>const fs = require('fs')

content = '\nnew line\n'
fs.appendFile('./test.txt', content, err =&gt; {
    if (err) {
        console.log('write error')
        return
    }
    console.log('write success')
})</code></pre><p>上面了方法都会在将数据完全写入文件后在执行 callback，这种情况下使用 stream 是一个更好的方法。</p><h3>working with folder 文件夹操作</h3><p>node.js 的 fs 模块提供了很多实用的 method 来对文件夹进行操作。</p><h4>检查文件夹是否存在</h4><p>使用 <code>fs.access()</code> 可以检查文件夹是否存在，以及 node.js 是否有访问它的权限：</p><pre><code>const fs = require('fs')

fs.access('./tmp', err =&gt; {
    console.log(err ? 'not exist' : 'exist')
})

//output:
//not exist</code></pre><h4>创建新文件夹</h4><p>使用 <code>fs.mkdir()</code> 或 <code>fs.mkdirSync()</code> 创建新文件夹：</p><pre><code>const fs = require('fs')

const fd = 'tmp'
try {
    if (!fs.existsSync(fd)) {
        fs.mkdirSync(fd)
        console.log('create success')
    }
} catch (error) {
    console.log('create fail')
}</code></pre><p>上面使用了同步模式 method 创建文件夹，看起来更加直观。</p><h3>read content of a directory 读取目录内容</h3><p>使用 <code>fs.readdir()</code> 或 <code>fs.readdirSync()</code> 可以读取某个目录中的内容，包括其中的文件和文件夹。返回值为一个数组：</p><pre><code>const fs = require('fs')

const p = '/usr'
const d = fs.readdirSync(p)
console.log(d)</code></pre><p>输出为：</p><pre><code>[
  'bin',     'games',
  'include', 'lib',
  'lib32',   'lib64',
  'libexec', 'libx32',
  'local',   'sbin',
  'share',   'src'
]</code></pre><p>通过 <strong>path</strong> 模块的 <strong>join</strong> 或 <strong>resolve</strong> method 可以输出每个元素的绝对路径，修改以上示例：</p><pre><code>const fs = require('fs')
const path = require('path')

const p = '/usr'
const d = fs.readdirSync(p).map(f =&gt; {
    return path.resolve(p, f)
})
console.log(d)</code></pre><p>输出如下：</p><pre><code>[
  '/usr/bin',     '/usr/games',
  '/usr/include', '/usr/lib',
  '/usr/lib32',   '/usr/lib64',
  '/usr/libexec', '/usr/libx32',
  '/usr/local',   '/usr/sbin',
  '/usr/share',   '/usr/src'
]</code></pre><p>如果只想获取目录下的文件而不包含文件夹，可以定义一个 filter 过滤元素：</p><pre><code>const fs = require('fs')
const path = require('path')

const isFile = fileName =&gt; {
    return fs.statSync(fileName).isFile()
}
const p = '/usr'
const d = fs.readdirSync(p).map(f =&gt; {
    return path.resolve(p, f)
}).filter(isFile)

console.log(d)</code></pre><h3>rename folder 重命名文件夹</h3><p>使用 <code>fs.rename()</code> 或 <code>fs.renameSync()</code> 重命名文件夹。第一个参数定义当前路径，第二个参数定义新路径：</p><pre><code>const fs = require('fs')

fs.rename('./tmp', './new', err =&gt; {
    if (err) {
        console.log('rename error')
        return
    }
    console.log('rename success')
})</code></pre><h3>remove folder 删除文件夹</h3><p>使用 <code>fs.rmdir()</code> 或 <code>fs.rmdirSync()</code> 可以删除文件夹。</p><p>但删除文件夹相比其他操作稍微复杂，用到的工具可能超出你需要的部分。所以最简单的方法就是使用第三方模块：<strong>fs-extra</strong> 来处理。它是 fs 的替代品，在 fs 模块的基础上提供了很多新功能。</p><p>使用 <strong>fs-extra</strong> 的 <code>remove()</code> method 可以实现删除文件夹的功能：</p><pre><code>const fs = require('fs-extra')

const p = './new'
fs.remove(p, err =&gt; {
    if (err) {
        console.log('remove error')
        return
    }
    console.log('remove success')
})</code></pre><p>也可以使用 promise 模式：</p><pre><code>fs.remove(p)
.then(() =&gt; console.log('remove success'))
.catch((err) =&gt; console.log(err))</code></pre><p>还可以使用 async/await 模式：</p><pre><code>const rm = async (p) =&gt; {
    try {
        await fs.remove(p)
        console.log('remove success')
    } catch (error) {
        console.log('remove error')
    }
}
rm(p)</code></pre>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2140.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/2140.html</wfw:commentRss>
</item>
<item>
<title>Windows 主机使用 VMware 虚拟机在共享文件夹调试 node.js 时 npm install 报错问题的处理</title>
<link>https://blog.niekun.net/archives/2139.html</link>
<guid>https://blog.niekun.net/archives/2139.html</guid>
<pubDate>Sun, 07 Feb 2021 11:07:10 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[由于 node.js 在 Windows 下会有各种问题，最好的开发环境还是 Linux，所以我通过 VMware 内安装 Ubuntu 虚拟机的方式学习 node.js。我的流程是：VMwar...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>由于 node.js 在 Windows 下会有各种问题，最好的开发环境还是 Linux，所以我通过 VMware 内安装 Ubuntu 虚拟机的方式学习 node.js。</p><p>我的流程是：</p><ul><li>VMware 安装 Ubuntu</li><li>共享 Windows 下的文件夹给 Ubuntu 作为开发目录</li><li>Windows 下使用 vs code 通过 ssh 方式远程连接 Ubuntu</li></ul><p>通过远程连接的方式在 Windows 下做 node.js 开发实际体验很好。但是在通过 npm 安装某些包时常常会有报错出现，错误日志大概意思就是说无法给 node_modules 文件夹内安装的库文件添加软连接到系统路径。</p><p>网上查询后发现了问题原因，我的开发目录实际是在 Windows 下的，Windows 和 Linux 有着不一样的文件系统和路径格式，所以 npm 在安装某些包含 bin 可执行文件的第三方库时，会默认自动创建相关文件的软链接到 Linux 系统路径，这样就就报错了。</p><p>如果要坚持使用共享目录的形式做开发，那么需要设置在 npm 安装新库时使用参数 <code>--no-bin-links</code> 告诉系统不要自动创建软连接，语法如下：</p><pre><code>npm install cowsay --no-bin-links
</code></pre><p>这样就会跳过相关步骤。</p><p>也可以设置到 npm 配置中，这样以后安装的包都会默认不创建 bin 的软连接了：</p><pre><code>npm config set bin-links false
</code></pre><p>当然最理想的方式就是将开发路径放置在 Linux 系统中，而不是通过共享目录的形式。这样就是一个纯原生的环境。</p><p>参考链接：<a href="https://github.com/npm/npm/issues/2221">https://github.com/npm/npm/issues/2221</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2139.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/2139.html</wfw:commentRss>
</item>
<item>
<title>node.js 入门教程之五 -- HTTP request and response</title>
<link>https://blog.niekun.net/archives/2137.html</link>
<guid>https://blog.niekun.net/archives/2137.html</guid>
<pubDate>Sat, 06 Feb 2021 16:50:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[搭建 http server下面是一个 http server 的示例：const http = require('http')process.env.PORT = 3000const port...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<h3>搭建 http server</h3><p>下面是一个 http server 的示例：</p><pre><code>const http = require('http')
process.env.PORT = 3000
const port = process.env.PORT

const server = http.createServer((req, res) =&gt; {
    res.statusCode = 200
    res.setHeader('Content-Type', 'text/html')
    res.end('&lt;h1&gt;hello world&lt;/h1&gt;')
})
server.listen(port, () =&gt; console.log(`server running at port ${port}`))</code></pre><p>访问 <a href="http://localhost">http://localhost</a>:3000 就会看到页面显示 <strong>hello world</strong>。</p><!--more--><p>下面我们简单解释下以上示例的执行过程：</p><ul><li>首先引入 <strong>http</strong> module</li><li>设置环境变量 PORT 为 3000，然后赋值给 port 变量</li><li>创建一个 server，其中含有一个 callback function，用户访问 server 时会被调用</li><li>设置监听端口并启动 server，当 server 启动成功后，会执行 server.listen 内定义的 callback function</li></ul><p>当 server 收到用户的请求时，会触发 <strong>request event</strong> 并提供了两个数据：一个 <strong>request</strong>(http.IncomingMessage object) 和一个 <strong>response</strong>(http.ServerResponse object)。</p><ul><li><strong>request</strong> 提供了 request 的详细信息，可以用来获取请求 hreaders 和请求数据。</li><li><strong>response</strong> 用来操作将要发送给客户端的数据。</li></ul><p><strong>在上面的示例中，我们修改了 response 相关信息：</strong></p><ul><li>设置 statusCode 为 200</li><li>设置一个 header</li><li>结束 response 并将响应内容作为数据传入 <code>end()</code></li></ul><h3>发起 GET 请求</h3><p>下面示例发起一个 GET 请求：</p><pre><code>const https = require('https')
const options = {
    hostname: 'niekun.net',
    port: 443,
    path: '/',
    method: 'GET'
}

const req = https.request(options, res =&gt; {
    console.log(`statusCode is：${res.statusCode}`);
    res.on('data', d =&gt; {
        process.stdout.write(d)
    })
})

req.on('error', err =&gt; console.log(err))
req.end()</code></pre><p><strong>以上示例执行过程为：</strong></p><ul><li>首先引入 https 模块。</li><li>创建一个 <strong>options</strong> object 存储请求的信息。</li><li>创建一个 <strong>https</strong> request，使用 options 作为请求信息，当请求成功后会执行后面定义的 callback function。</li><li>定义一个 event handler 事件管理器来处理当 error 被触发时的响应。</li><li>最后结束这个 request</li></ul><p>下面是一个 POST 请求示例：</p><pre><code>const https = require('https')

const data = JSON.stringify({
    todo: 'go to sleep'
})

const options = {
    hostname: 'niekun.net',
    port: 443,
    path: '/',
    method: 'POST',
    Headers: {
        'Content-Type': 'application/json',
        'Content-Length': data.length
    }
}

const req = https.request(options, res =&gt; {
    console.log(`statusCode is：${res.statusCode}`);
    res.on('data', d =&gt; {
        process.stdout.write(d)
    })
})
req.on('error', err =&gt; console.log(err))

req.write(data)
req.end()</code></pre><p>POST 请求相比 GET 请求多了 <code>request.write(data)</code> 部分，因为 POST 是把数据消息放在 body 中的。</p><p>PUT 和 DELETE 请求和 POST 格式相同，只需要修改 request.method 即可。</p><h3>使用 Axios 库发起 POST 请求</h3><p>上面介绍了是应用 https 模块来发起 POST 请求，我们也可以使用第三方库使代码更加简洁，这里介绍 axios 库实现(需要通过 npm 安装)：</p><pre><code>const axios = require('axios')

axios
.post('http://localhost:3000', {
    todo: 'go to sleep'
})
.then(res =&gt; {
    console.log(`statusCode is: ${res.status}`)
    process.stdout.write(res.data)
})
.catch(err =&gt; console.log(err))</code></pre><h3>获取 http request body 数据</h3><p>下面介绍 server 端如何提取在 http request body 中的 json 数据。</p><p>如果你使用 <strong>Express</strong> 模块创建 http server，那么只需要使用它的 body-parser 内容拆分模块即可实现提取 json 数据，<strong>Express</strong> 模块在第一章做过示例，如果客户端使用上面的 axios 示例发起请求，服务端代码如下：</p><pre><code>const express = require('express');
const app = express();

process.env.PORT = 3000
const port = process.env.PORT

app.use(
    express.urlencoded({
        extended: true
    })
)
app.use(express.json())

app.get('/', (req, res) =&gt; {
    res.statusCode = 200
    res.setHeader('Content-Type', 'text/html')
    res.end('&lt;h1&gt;hello world&lt;/h1&gt;')
})

app.post('/', (req, res) =&gt; {
  console.log(req.body.todo)
  res.statusCode = 200
  res.setHeader('Content-Type', 'text/html')
  res.end('hello world\n')
});

const server = app.listen(port, () =&gt; console.log('Server ready'));</code></pre><p>我们使用 express 模块创建了一个 server，并同时监听 GET 和 POST 请求并定义了 callback 响应，通过 <code>app.use</code> 设置了对请求 body 数据的 json 支持。</p><p>当启动上面实例中使用 axios 开启的服务端的程序后，server 端收到 POST 请求后就会提取请求 body 中的 todo 对应内容并输出到终端。客户端成功收到 response 后会输出 200 状态码和响应内容。</p><p>我们通过浏览器直接访问 <code>localhost:3000</code> 会发起一个 GET 请求，浏览器会显示 hello world。</p><p>如果你不想使用 express 模块创建 server，那么 server 端要提取 POST request body 中的 json 数据就稍微麻烦一些。</p><p>首先需要理解的是当我们通过 <code>http.createServer()</code> 创建了一个 http 服务后，callback function 会在所有的 request headers 内容都接收到后被调用，而不是 request body。</p><p><strong>connection callback</strong> 中传递的完整的 <strong>request</strong> object 数据是在 stream 流中。所以我们必须监听传输的 request body 的内容，它们是在一些 chunks 数据块中的。</p><p>首先我们通过监听 <strong>data</strong> event 获取 body 数据，<strong>data</strong> event 在传输过程中会被多次触发，当 request 数据传输完毕后 end event 会被触发。</p><p>通过下面的代码可以获取到完整的 body 数据：</p><pre><code>const server = http.createServer((req, res) =&gt; {
    let data = '';
    req.on('data', chunk =&gt; {
        data += chunk;
    })
    req.on('end', () =&gt; {
        console.log(JSON.parse(data).todo)
    })
})</code></pre><p>以上代码中，data 最终存储了 request body 的数据，然后通过 <code>JSON.parse</code> method 可以解析 json 内容。</p><p>server 端完整的代码如下：</p><pre><code>const http = require('http')
process.env.PORT = 3000
const port = process.env.PORT

const server = http.createServer((req, res) =&gt; {
    let data = '';
    req.on('data', chunk =&gt; {
        data += chunk;
    })
    req.on('end', () =&gt; {
        console.log(JSON.parse(data).todo)
    })

    res.statusCode = 200
    res.setHeader('Content-Type', 'text/html')
    res.end('&lt;h1&gt;hello world&lt;/h1&gt;')
})
server.listen(port, () =&gt; console.log(`server running at port ${port}`))</code></pre><p>以上就是 <strong>http</strong> request 和 response 部分的简单介绍。</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2137.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/2137.html</wfw:commentRss>
</item>
<item>
<title>node.js 入门教程之四 -- Event Loop 和 asynchronous</title>
<link>https://blog.niekun.net/archives/2100.html</link>
<guid>https://blog.niekun.net/archives/2100.html</guid>
<pubDate>Thu, 04 Feb 2021 21:36:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[Event Loop 事件循环event loop 是我们学习 node.js 中最重要的方面之一。因为它解释了 node.js 如何进行异步动作，同时不会出现 IO 阻塞问题。这也是 node...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<h3>Event Loop 事件循环</h3><p><strong>event loop</strong> 是我们学习 node.js 中最重要的方面之一。因为它解释了 node.js 如何进行异步动作，同时不会出现 IO 阻塞问题。这也是 node.js 能够变得如此流行的原因之一。</p><p>node.js 代码运行在单进程中，也就是说它在一刻只能执行一个任务。这一限制特性使得我们不用担心任务间冲突问题。我们在变开发中只需要专注于代码本身，同时应避免进程阻塞，例如同步方式等待网络请求，死循环等。</p><p>通常情况下，浏览器中的每个 tab 页面都是都有各自独立的 event loop，防止某个页面的死循环或过高的资源消耗影响到整个浏览器的体验。我们只需要关注于我们的代码运行在一个单一的 event loop 中，编程中要注意到这一点，防止进程阻塞。</p><!--more--><p>JavaScript 代码中如果有长时间等待 return 返回给 event loop 控制时，任何其他代码将会被阻塞，也会阻塞页面 UI 单元，用户在此期间无法进行点击，滚动等操作。</p><p>几乎所有的 JavaScript 原生 IO 指令都是 non-blocking 非阻塞式的，例如：网络请求，文件读写等，阻塞是一种 exception 例外情况，这也是 JavaScript 大量的使用 callback 方式，以及最近引入的 promise 和 async/await。</p><h4>call stack 调用结构</h4><p>JavaScript 的 call 调用过程的结构遵循 LIFO (Last In, First Out)，也就是总是先响应最近的任务。</p><p>event loop 总是连续的检查 call stack 看是否有任务需要执行。在这个过程中，它会将发现的任务添加到 call stack 中并按顺序执行。</p><p>下面是一个简单的示例：</p><pre><code>const bar = () =&gt; console.log('bar');
const baz = () =&gt; console.log('baz');

const foo = () =&gt; {
    console.log('foo');
    bar();
    baz();
}

foo();
console.log('END');

//output:
//foo
//bar
//baz
//END</code></pre><p>在以上示例中，首先会调用 foo()，在 foo 中首先会调用 bar()，然后调用 baz()。call stack 执行过程如下：<br><img src="https://blog.niekun.net/usr/uploads/2021/02/2945905311.png" alt="2021-02-02T13:21:33.png" title="2021-02-02T13:21:33.png"></p><p>在 event loop 的每次 iteration 递归执行中会查询 call stack 中是否有需要执行的任务，如果有则执行它，直到 loop 结束为止，如下是循环中的全过程：<br><img src="https://blog.niekun.net/usr/uploads/2021/02/627372670.png" alt="2021-02-02T13:23:25.png" title="2021-02-02T13:23:25.png"></p><p>以上示例说明了 JavaScript 在一般情况下按顺序执行代码的过程。下面介绍如何将一个 function 推迟到 call stack 递归到最后时再被调用。</p><p>需要使用以下的代码指令：</p><pre><code>setTimeout(() =&gt; {}, 0)
</code></pre><p>以上代码调用了 setTimeout 延时 function，但是将延时设置为 <code>0</code>，这样的意义就是要求它在可以执行的时候立刻执行其中定义的 function。那么如何才能让其在层级的最后再执行 function 呢？下面是一个完整的片段：</p><pre><code>const bar = () =&gt; console.log('bar');
const baz = () =&gt; console.log('baz');

const foo = () =&gt; {
    console.log('foo');
    setTimeout(bar, 0);
    baz();
}

foo();
console.log('END');

//output:
//foo
//baz
//END
//bar</code></pre><p>以上示例中，我们在 foo 中先调用 setTimeout function，并将时间设置为 0，要求其在可以执行时立刻执行内部定义的指令，以上示例循环的 call stack 过程如下：<br><img src="https://blog.niekun.net/usr/uploads/2021/02/281898740.png" alt="2021-02-04T12:49:01.png" title="2021-02-04T12:49:01.png"></p><p>下面时循环的顺序执行全过程：<br><img src="https://blog.niekun.net/usr/uploads/2021/02/2606253446.png" alt="2021-02-04T12:50:30.png" title="2021-02-04T12:50:30.png"></p><p>为什么会是这样的执行顺序呢？为什么 setTimeout 时间设置为 0 反而最后才执行其 function？下面做介绍。</p><h4>Message Queue 消息队列</h4><p>当 <code>setTimeout()</code> 被调用时，浏览器或 node.js 会开启一个定时器，当定时时间到达时，这里我们设置为 0 也就是立刻到达了时间，callback 响应的 function 会被放到 Message Queue 消息队列中。</p><p>Message Queue 消息队列也管理着用户主动触发的一些事件如鼠标点击键盘输入等，或者 fetch 获取响应信息，这些消息按顺序排列着等待被代码执行。</p><p><strong>call stack</strong> 和 <strong>Message Queue</strong> 是互相独立的，event loop 循环时 call stack 中的任务是优先的，它会首先查找 call stack 中需要执行的代码并按顺序执行，当 satck 执行完成后再去查看 Message Queue 中需要处理的任务。</p><p>我们并不需要等待一些 functions 如 setTimeout 或 fetch 这些任务的执行过程，因为这些工作由浏览器提供且这些任务运行在它们单独的线程中。例如当我们设置了 setTimeout 2 秒的定时，我们并不需要停下来等待这 2 秒钟，而是会执行层级中接下来的指令。</p><h4>Job Queue 任务队列</h4><p>ES6 中引入了一种新的 <strong>Job Queue</strong> 任务队列概念，也就是 <strong>Promise</strong>。提供了在条件到达后立刻执行被调用 function 的方法，而不是等待到 call stack 结束。</p><p>当 <strong>Promise</strong> 定义的 <strong>resolve</strong> 条件满足时，会在当前 call stack 执行结束后立刻执行 <strong>resolve</strong> function。</p><p>简单的区分 <strong>Message Queue</strong> 和 <strong>Job Queue</strong>：<strong>Message Queue</strong> 会将出现的每个任务按顺序排列到队列最后，等待排队执行。而 <strong>Job Queue</strong> 就像拿到了快捷车票，会在 stack 中的指令结束后立刻跳转到这个任务上来。</p><p>下面是一个示例：</p><pre><code>const bar = () =&gt; console.log('bar');
const baz = () =&gt; console.log('baz');

const foo = () =&gt; {
    console.log('foo');
    setTimeout(bar, 0);
    new Promise((resolve, reject) =&gt;
            resolve(&quot;should be right after baz, before bar&quot;))
        .then(resolve =&gt; console.log(resolve));
    baz();
}

foo();
console.log('END');

//output:
//foo
//baz
//END
//should be right after baz, before bar
//bar</code></pre><p>以上示例可以看到，<strong>promise</strong> 定义之后会继续运行 stack 中接下来的常规指令，然后 <strong>promise</strong> 的 <strong>resolve</strong> 条件会立刻得到满足，此时异步任务会在 stack 中的任务执行结束后立刻被响应而不是排列到队列最后。</p><h3>理解 process.nextTick()</h3><p>上面我们介绍了 event loop 的相关概念，一次的 event loop 循环叫做一个 <strong>tick</strong>，注意此循环只包含常规 call stack 中的任务。当我们给 <code>process.nextTick()</code> 传递一个 function 时，就是告诉 engine 在本次循环 tick 结束下次循环开始前执行这个 function。</p><p>语法如下：</p><pre><code>process.nextTick(() =&gt; {
  //do something
})</code></pre><p>当 call stack 中的任务执行完毕后，js engine 会优先查询是否在 nextTick 中定义了 function，如果有就会优先执行它们，然后是 <strong>Job Queue</strong> 的异步响应，最后才是 <strong>Message Queue</strong> 队列中的任务。</p><p>请看下面的示例：</p><pre><code>const bar = () =&gt; console.log('bar');
const baz = () =&gt; console.log('baz');

const foo = () =&gt; {
    console.log('foo');
    setTimeout(bar, 0);
    new Promise((resolve, reject) =&gt;
            resolve(&quot;should be right after baz, before bar&quot;))
        .then(resolve =&gt; console.log(resolve));
    baz();
}

foo();
console.log('END');

process.nextTick(() =&gt; console.log(&quot;next tick&quot;));

//output:
//foo
//baz
//END
//next tick
//should be right after baz, before bar
//bar</code></pre><h3>理解 setImmediate()</h3><p><strong>setImmediate</strong> function 用来定义在下次 event loop 循环开始前执行的 function。语法如下：</p><pre><code>setImmediate(() =&gt; {
  //run something
})</code></pre><p><code>setImmediate()</code> 和上面讲到的 <code>setTimeout(() =&gt; {}, 0)</code>，<code>Promise</code>，<code>process.nextTick()</code>，不同点是它是执行在下个循环中的，而其它几种都是属于当前循环的，所以它是最后被执行的。</p><p>下面是一个包含这几种类型的异步任务的完整示例：</p><pre><code>const bar = () =&gt; console.log('bar');
const baz = () =&gt; console.log('baz');

const foo = () =&gt; {
    console.log('foo');
    setTimeout(bar, 0);
    new Promise((resolve, reject) =&gt;
            resolve(&quot;should be right after baz, before bar&quot;))
        .then(resolve =&gt; console.log(resolve));
    baz();
}

foo();
console.log('END');

process.nextTick(() =&gt; console.log(&quot;next tick&quot;));
setImmediate(() =&gt; console.log(&quot;immediate&quot;));

//output:
//foo
//baz
//END
//next tick
//should be right after baz, before bar
//bar
//immediate</code></pre><h3>timers 定时器</h3><h4>setTimeout()</h4><p>当需要延时执行一个 function 时，可以使用 <strong>setTimeout</strong> function 实现。使用它定义需要延时执行的任务以及延时的具体时间，以毫秒为单位。示例如下：</p><pre><code>setTimeout(() =&gt; {
    console.log('delay 1s')
}, 1000);

console.log('start')</code></pre><p>以上示例会延时一秒输出对应信息。</p><p>也可以传入预定义的 function 以及传递数据给 setTimeout：</p><pre><code>const test = (a, b) =&gt; console.log(a + b);
setTimeout(test, 2000, 1, 2);</code></pre><p>以上示例中，<strong>setTimeout</strong> 调用 <strong>test</strong> function，1 和 2 为 <strong>test</strong> 的传入数据。</p><p>setTimeout 会返回一个 timer ID，你可以存储这个它，可以通过 id 清除对应的定时器以取消对应的计划任务：</p><pre><code>const t1 = setTimeout(() =&gt; {
    console.log('delay 1s')
}, 1000);
clearTimeout(t1);</code></pre><p>以上示例中由于通过 id 清除了 t1 定时器，所以任务不会被执行。</p><p>一个特殊情况就是将延时设置为 0 也就是上一节介绍的内容，这是定义的任务会排列在 message queue 中并在本次循环结束后按顺序被执行。</p><h4>setInterval()</h4><p><strong>setInterval</strong> 和 <strong>setTimeout</strong> 功能类似，但区别是 setInterval 会连续响应定义的任务，响应的间隔时间以毫秒为单位，在 setInterval 中自定义。</p><p>下面是一个简单的示例：</p><pre><code>setInterval(() =&gt; {
    console.log('wow');
}, 500);</code></pre><p>程序运行后会每隔 500 毫秒连续输出信息。</p><p>同样的通过 timer ID 使用 clearInterval 可以清除对应的 setInterval 定时任务：</p><pre><code>const t2 = setInterval(() =&gt; {
    console.log('wow');
}, 500);

setTimeout(() =&gt; {
    clearInterval(t2);
}, 2000);</code></pre><p>以上程序执行后，会每隔 500 毫秒输出 <code>wow</code>，两秒后停止输出。</p><p>setInterval 会在指定的时间间隔下连续执行定义的 function 而不会考虑这个定义的 function 运行需要多少时间。</p><p>如果这个 function 一直保持固定的执行时间，不会有什么问题：<br><img src="https://blog.niekun.net/usr/uploads/2021/02/3551443188.png" alt="2021-02-05T03:21:16.png" title="2021-02-05T03:21:16.png"></p><p>如果这个 function 在一些情况下执行时间大于设定的间隔时间，则前一个任务还没结束下一个任务已经要开始，就会造成冲突问题：<br><img src="https://blog.niekun.net/usr/uploads/2021/02/584595761.png" alt="2021-02-05T03:22:09.png" title="2021-02-05T03:22:09.png"></p><p>为了避免这种情况发生，可以在需要连续调用的 function 执行结束时调用递归 setTimeout 来避免：</p><pre><code>const test2 = () =&gt; {
    console.log('wow');
    setTimeout(test2, 1000);
}

test2();</code></pre><p>以上示例中，我们在 function 定义中在指令结束后定义一个 setTimeout 调用其本身，这样可以实现连续对自身的调用且能保证每个任务都是被完整执行后才开始下一次执行的：<br><img src="https://blog.niekun.net/usr/uploads/2021/02/3663076236.png" alt="2021-02-05T03:29:17.png" title="2021-02-05T03:29:17.png"></p><h3>Asynchronous and Callbacks 异步与响应</h3><p>在目前的电脑中，应用程序在特定的时间在占用系统资源运行任务，然后结束程序释放资源给其他程序使用。这个过程在以极快的速度循环进行着以至于我们以为这些程序在同时进行处理(多处理器设备除外)。</p><p>程序内部通过 interrupts 中断：一个发送给处理器的信号，来获得系统的注意及时处理相关响应动作。这使得系统可以在某个任务等待回应过程中去处理其他事情，例如当程序在等待某个网络回应时，不能要求整个系统都停下来等待。</p><p>通常情况下，编程语言都是默认以 synchronous 同步的方式执行代码的，部分编程语言提供了其他支持库的方式实现异步，或者通过多线程的方式支持异步。</p><p>JavaScript 默认是同步和单线程模式，也就是说它不可以新建线程和平行运行。代码是按照编程顺序逐行执行的，如下示例：</p><pre><code>const a = 1
const b = 2
const c = a * b
console.log(c)</code></pre><p>但是 JavaScript 是诞生于浏览器的，它的主要工作就是响应用户的交互操作，如：onClick, onMouseOver, onChange, onSubmit 等。那么它如何在同步模式下实现上面的功能呢？</p><p>答案就在他的运行环境中，浏览器提供了一系列的 APIs 来处理这些功能。node.js 引入了 non-blocking I/O 无阻塞 IO 的环境使得在此基础上扩展了文件访问，网络访问等的异步处理能力。</p><p>你无法预知用户何时会点击了浏览器的一个按钮，所以我们就会提前定义一个 <strong>click event</strong> 的 <strong>event handler</strong> 事件处理器，这个 <strong>event handler</strong> 内需要定义一个 function，当事件被触发时会自动被调用。</p><p>如下示例定义了一个 button 的 <strong>click event handler</strong>：</p><pre><code>document.getElementById('button').addEventListener('click', () =&gt; {});
</code></pre><p>这个响应过程叫做 callback。</p><p>一个 callback 就是一个作为某个 function 的传入参数的 function，且只会在 event 被触发时才被执行。</p><p>JavaScript 可以定义 first-class functions，能够以参数的形式传入其他 function，也叫 higher-order functions。</p><p>通常情况，我们可以将客户端代码放在 <strong>window</strong> object 的 <strong>load</strong> event 中作为 callback function，这样就可以在页面加载完成后执行这部分代码：</p><pre><code>window.addEventListener('load', () =&gt; {
    //...
})</code></pre><p>callback 不止在浏览器的 DOM 结构下应用，一个常用的情景就是定时器：</p><pre><code>setTimeout(() =&gt; {
  // runs after 2 seconds
}, 2000)</code></pre><p>XHR 请求也会接受 callback，下面的示例中将一个 function 赋值给 XMLHttpRequest 的一个 property，当特定的 event 发生时会调用定义的 function：</p><pre><code>const XMLHttpRequest = require('xmlhttprequest').XMLHttpRequest;
const xhr = new XMLHttpRequest();
xhr.onreadystatechange = () =&gt; {
    if (xhr.readyState == 4) {
        xhr.status == 200 ? console.log(xhr.responseText) : console.log('error');
    };
};
xhr.open('GET', 'https://niekun.net');
xhr.send();</code></pre><p>以上示例执行后，如果网址访问成功则会输出网页内容，否则输出 error。</p><p>那么如何处理 callback 的 errors？通常情况下 node.js 接受的的策略是：将 <strong>callback</strong> function 的第一个参数作为 <strong>error</strong> object，叫做 <strong>error-first callbacks</strong>。当没有 error 时 object 为 null，当有 error 发生时，object 中会包含相关信息。</p><p>下面是一个读取文件的示例：</p><pre><code>const fs = require('fs')
fs.readFile('./fs.json', (err, data) =&gt; {
    if (err !== null) {
        console.log('read error');
        return;
    }
    console.log(data.toString());
})</code></pre><p>在读取中有错误时 err 会包含错误信息。</p><p>callback 在一般情况下使用很方便，但是每个 callback 相当于增加了一层嵌套层级，当你有很多个 callback 时就会产生多级嵌套，代码结构会越来越复杂。例如一下示例：</p><pre><code>window.addEventListener('load', () =&gt; {
  document.getElementById('button').addEventListener('click', () =&gt; {
    setTimeout(() =&gt; {
      items.forEach(item =&gt; {
        //your code here
      })
    }, 2000)
  })
})</code></pre><p>以上是一个四级嵌套，看起来已经比较复杂了，如果有更多的 callback 发生代码的结构会变得更加难以理解。</p><h3>Promise 异步</h3><p>从 ES6 开始 JavaScript 引入了多个处理异步代码的功能代替 callback 模式，包括：Promises (ES6) 和 Async/Await (ES2017)。</p><p><strong>promise</strong> 在我之前的 JavaScript 教程中做了介绍，参考：<a href="https://blog.niekun.net/archives/2011.html">https://blog.niekun.net/archives/2011.html</a></p><p>下面是一个 promise 的应用示例：</p><pre><code>let done = true;

const isItDoneYet = new Promise((resolve, reject) =&gt; {
    if (done) {
        const workDone = &quot;working done&quot;;
        resolve(workDone);
    } else {
        const why = 'still working on';
        reject(why);
    }
});

const checkIfDone = () =&gt; {
    isItDoneYet
    .then((ok =&gt; console.log(ok)), (err =&gt; console.log(err)))
}

checkIfDone();

//output:
//working done</code></pre><p><strong>resolve</strong> 和 <strong>reject</strong> function 也可以分别在 then 和 catch 中定义：</p><pre><code>const checkIfDone = () =&gt; {
    isItDoneYet
    .then(ok =&gt; console.log(ok))
    .catch(err =&gt; console.log(err))
}</code></pre><p>一个 promise 就是定义一个数据的 proxy 代理，这个数据会在后续中产生。promise 可以用来执行异步任务而不需要使用 callback。它在最近的 ES2017 更新中被进一步的整合为 async 和 await。理解 promise 的运行机制对于理解 async 和 await 很有必要。</p><p>当调用一个 promise 时，它将保持在 pending 挂起状态，程序会继续执行下面的指令。在 promise pending 状态直到它有了 resolve 解决指令期间，可以提供其调用 function 需要的数据。</p><p>创建的 promise 最终会在一个 <strong>resolved</strong> state 或 <strong>rejected</strong> state 状态下结束，并分别调用其 callback function：<strong>then</strong> 和 <strong>catch</strong>。</p><p>promise API 提供了一个 constructor 构建器，通过 <code>new Promise()</code> 初始化。在上面的示例中，promise 判断参数 done 的值，如果为 true 则进入 <strong>resolved</strong> 状态(当 then 的 resolve 调用时)，如果为 false 则进入 <strong>rejected</strong> 状态(当 catch 调用时)。在没有调用 then 或 catch 时，promise 保持 pending 状态。</p><p>通过 resolve 和 reject，我们可以和向前交流获取 promise 的状态结果，以及根据结果执行什么指令。这里我们只是简单的输出了一行字符串信息，也可以是一个 object 或 null 也可以。由于在此之前我们已经创建了 promise，所以它已经开始了执行，这对于理解 resuming a promise 继续执行 promise 很重要。</p><p>一个常用的 promise 使用的技巧：<strong>Promisifying</strong>，定义一个包含 callback 的常规 function，callback 返回一个 promise，下面是一个示例：</p><pre><code>const fs = require('fs');

const getFile = (fileName) =&gt; {
    return new Promise((resolve, rejects) =&gt; {
        fs.readFile('./fs.json', (err, data) =&gt; {
            if (err) {
                rejects(err)
                return
            }
            resolve(data)
        })
    })
}

getFile(&quot;fs.json&quot;)
    .then(data =&gt; console.log(data.toString()))
    .catch(err =&gt; console.log(err))</code></pre><p>通过上面的介绍，我们知道了通过 <code>new Promise()</code> 命令可以创建一个 promise，然后根据实际条件执行 promise 的 <strong>resolve</strong>(then) 或 <strong>reject</strong>(catch) function。</p><h4>promises chain 链</h4><p>一个 promise 可以作为另一个 promise 的返回，可以组成一个 promises 链条。</p><p>Fetch API 是介绍 promises 链很好的示例。它可以 fetch 获取一个资源，然后顺序执行一个 promises chain。fetch API 是基于 promise 的结构，调用 <code>fetch()</code> 就等同于通过 <code>new Promise()</code> 定义 promise。</p><p>下面的是一个 promises 链示例，使用了 Fetch API：</p><pre><code>const fetch = require('node-fetch');

const status = response =&gt; {
    if (response.status &gt;= 200 &amp;&amp; response.status &lt; 300) {
        return Promise.resolve(response)
    }
    return Promise.reject(new Error(response.statusText))
}

const json = response =&gt; response.json() // return a promise

fetch('https://api.github.com/users/github') // return a promise, resolve is a response type
    .then(status) // use response as data and reture a promise
    .then(json) // use response as data convert to json and reture a promise
    .then(data =&gt; console.log('Request succeeded with JSON response', data)) // resolve call
    .catch(err =&gt; console.log('Request failed', err)) // if status promise call reject function, would call here</code></pre><p><strong>以上程序的执行过程如下：</strong></p><ul><li>使用 fetch 获取一个 url 的数据，然后返回一个 promise，resolve 时返回数据为一个 <strong>response</strong>，其中包含很多 properties，这里需要用到 status 和 statusText</li><li>当 fetch 数据完成后我们调用 resolve 也就是 <strong>status</strong> function，status 使用 response 数据来判断并返回一个 promise，resolve 数据为 response 本身</li><li>下一步当 <strong>status</strong> promise 调用 resolve 时会调用 <strong>json</strong> function，将 response 数据转换为 json 格式并返回一个 promise resolve 数据为 json 数据，如果 <strong>status</strong> 进入 reject 也就是 response 不正常，则会直接执行最后的 <strong>catch</strong> function 跳过前面的环节</li><li>然后是数据的输出，当 <strong>json</strong> promise 调用 resolve 时会执行输出 data 数据</li></ul><p>在上面的示例中，我们在 promise 链的最后定义了一个 catch，当 promise 链中的任何一个 promise 失败然后 raise 一个 error 或者 reject，控制器会执行链中定义的最近的一个 catch。</p><p><strong>reject</strong> 或 raise <strong>error</strong> 都会触发 catch 部分，下面两种定义的 promise 语法都会进入 catch：</p><pre><code>new Promise((resolve, reject) =&gt; {
    throw new Error('error')
}).catch(err =&gt; console.log(err))

new Promise((resolve, reject) =&gt; {
    reject('error')
}).catch(err =&gt; console.log(err))</code></pre><p>也可以将 errors 级联，如果在 catch 中再次 throw 一个 error，可以再次附加一个 catch 来处理它：</p><pre><code>new Promise((resolve, reject) =&gt; {
    throw new Error('error')
})
.catch(err =&gt; {throw new Error('error')})
.catch(err =&gt; console.log(err))</code></pre><h4>promises 顺序</h4><p>多个 promises 可以控制他们的响应顺序，使用 <code>Promise.all()</code> 可以定义一个 promise list 表，当 promises 都 resolve 时设置执行动作。</p><p>请看下面的测试：</p><pre><code>const fetch = require('node-fetch');

const f1 = fetch('http://localhost/fs.json');
const f2 = fetch('http://localhost/fs2.json');

Promise.all([f1, f2])
.then(response =&gt; console.log(&quot;array of results&quot;, response))
.catch(err =&gt; console.log(err))</code></pre><p>返回的结果：</p><pre><code>array of results [
  Response {
    size: 0,
    timeout: 0,
    [Symbol(Body internals)]: { body: [PassThrough], disturbed: false, error: null },
    [Symbol(Response internals)]: {
      url: 'http://localhost/fs.json',
      status: 404,
      statusText: 'Not Found',
      headers: [Headers],
      counter: 0
    }
  },
  Response {
    size: 0,
    timeout: 0,
    [Symbol(Body internals)]: { body: [PassThrough], disturbed: false, error: null },
    [Symbol(Response internals)]: {
      url: 'http://localhost/fs2.json',
      status: 404,
      statusText: 'Not Found',
      headers: [Headers],
      counter: 0
    }
  }
]</code></pre><p>可以看到 response 是一个数组，包含了两个 promise 返回的数据且按数组定义的顺序排列。</p><p>使用 ES6 的 object 拆解语法，上面示例也可以这样写：</p><pre><code>Promise.all([f1, f2])
.then(([response1, response2]) =&gt; console.log(&quot;array of results&quot;, response1, response2))
.catch(err =&gt; console.log(err))</code></pre><h4>Promise.race()</h4><p>当 <code>Promise.race()</code> 中定义的 promises 数组中有第一个 resolve 的 promise 时，这个 promise 会运行 then 且只运行这一次，最终的状态就是那个 promise resolved 状态。</p><p>下面是一个示例：</p><pre><code>const first = new Promise((resolve, reject) =&gt; {
    setTimeout(resolve, 500, 'first');
})
const second = new Promise((resolve, reject) =&gt; {
    setTimeout(resolve, 100, 'second');
})
Promise.race([first, second]).then(res =&gt; console.log(res))

//output:
//second</code></pre><p>上面的示例中，首先定义了两个 promise，当 resolve 时都是执行了一个定时器。先到达定时时间的 promise 将会执行 resolve 动作。</p><h3>async 和 await</h3><p>JavaScript 从 ES2015 才引入 promise 代替 callback，从 ES2017 开始 JavaScript 处理异步有了更加简化的语法：<strong>async/await</strong>。</p><p><strong>async</strong> functions 是 promise 和 generator 的结合。也即是说 async/await 是基于 promise 的。关于 promise 和 generator 的 JavaScript 语法可以参考：<a href="https://blog.niekun.net/archives/2011.html">https://blog.niekun.net/archives/2011.html</a></p><p>promise 是为了处理异步而创造的，但随着使用场景的复杂化，它的劣势被凸显出来：语法臃肿，promise 链不能打断需要联系书写。于是便诞生了 <strong>async</strong> function。它可以让代码看起来像是同步代码，但在底层它是异步的且无 IO 阻塞问题。</p><p>首先我们定义一个异步 promise：</p><pre><code>const doSomethingAsync = () =&gt; {
    return new Promise(resolve =&gt; {
        setTimeout(resolve, 2000, 'i did something')
    })
}</code></pre><p><strong>setTimeout</strong> 第三个参数是 resolve 的传入数据。</p><p>当我们要调用这个 <strong>promise</strong> function 时使用关键词 <strong>await</strong>，然后 call 动作将会 pending 挂起状态直到 promise 被 resolved 或 rejected，注意在客户端代码中，需要使用 <strong>async</strong> 定义相关 function：</p><pre><code>const doSomething = async () =&gt; {
    console.log(await doSomethingAsync());
}
console.log('before')
doSomething()
console.log('after')

//output:
//before
//after
//i did something</code></pre><p>以上是一个简单的示例说明 async 的用法，await 后的 promise function 返回值是 resolve 或 reject 的数据。</p><p>在 function 定义中使用 async 关键词意味着这个 function 返回值为 promise 类型，即使定义中没有明确定义返回类型，它依然会返回 promise。所以以下代码是有效的：</p><pre><code>const test = async () =&gt; {
    return 'test';
}
test().then(res =&gt; console.log(res))

//output:
//test</code></pre><p>以上的代码和下面的写法是一样的效果：</p><pre><code>const test = async () =&gt; {
    return Promise.resolve('test');
}
test().then(res =&gt; console.log(res))</code></pre><p>可以看到使用 async 后语法得到了简化易读，当代码很复杂时这一优势会更加明显，下面是使用 promise 语法读取 json 数据并拆解它的示例：</p><pre><code>const getFirstUserData = () =&gt; {
    return fetch('/js.json') // return a promise, resolve response data
        .then(response =&gt; response.json()) // reture a promise, resolve translate response data to json type
        .then(users =&gt; users[0]) // return a promise, resolve is first element in response array data
        .then(user =&gt; fetch(`/users/${user.name}`)) // use first element data to fetch new data and return response data when resolve
        .then(userResponse =&gt; userResponse.json()) // translate to json type and return it if resolve
}
getFirstUserData()</code></pre><p>下面使用 <strong>async/await</strong> 来实现上面的功能：</p><pre><code>const { default: fetch } = require(&quot;node-fetch&quot;)

const getFirstUserData = async () =&gt; {
    const response = await fetch('/js.json')
    const users = await response.json()
    const user = users[0]
    const userResponse = await fetch(`/users/${user.name}`)
    const userData = await userResponse.json()

    return userData;
}
getFirstUserData()</code></pre><h4>多个 async function 组合使用</h4><p><strong>async</strong> function 可以很方便的组成 chain 链，且语法相比较 promise 更加易读。</p><p>下面是一个多个 async function 组合使用的示例：</p><pre><code>const promiseToDoSomething = () =&gt; {
    return new Promise(resolve =&gt; {
        setTimeout(resolve, 2000, 'i did something')
    })
}

const watchSomeoneDoingSomething = async () =&gt; {
    const something = await promiseToDoSomething()
    return something + '\nand i watched'
}

const watchSomeoneWatchingSomeoneDoingSomething = async () =&gt; {
    const something = await watchSomeoneDoingSomething()
    return something + '\nand i watched as well'
}

watchSomeoneWatchingSomeoneDoingSomething().then(res =&gt; console.log(res))

//output:
//i did something
//and i watched
//and i watched as well</code></pre><p><strong>async/await</strong> function 看起来就像是同步代码，这样调试起来非常方便。</p><h3>Event emitter 事件触发器</h3><p>如果在浏览器端开发过 JavaScript，你肯定了解用户通过 events 事件来实现交互，如：鼠标点击，键盘按键，鼠标移动等。</p><p>在后端，node.js 通过 <strong>events</strong> module 可以建立一个小型系统来处理 events 事件。通常使用 <strong>EventEmitter</strong> class，下面是初始化 <strong>events</strong> 的方法：</p><pre><code>const EventEmitter = require('events')
const eventEmitter = new EventEmitter()</code></pre><p>此时 <strong>eventEmitter</strong> object 有很多 properties，其中最常用的就是 <strong>on</strong> 和 <strong>emit</strong> method：</p><ul><li><strong>on</strong> 用来定义一个 event 事件，同时定义一个 callback function，当 event 触发后被执行</li><li><strong>emit</strong> 用来触发某个 event 事件</li></ul><p>下面我们创建一个 <strong>start</strong> event：</p><pre><code>eventEmitter.on('start', () =&gt; console.log('started'))</code></pre><p>然后触发 <strong>start</strong>：</p><pre><code>eventEmitter.emit('start')

//output:
//start</code></pre><p>可以给 event 传递参数，在 callback 时使用：</p><pre><code>eventEmitter.on('test1', par =&gt; console.log('started', par))
eventEmitter.emit('test1', 'wow')

//output:
//started wow</code></pre><p>当然也可以给 event 传递多个数据：</p><pre><code>eventEmitter.on('test2', (a, b) =&gt; console.log(`started from ${a} to ${b}`))
eventEmitter.emit('test2', 1, 200)

//output:
//started from 1 to 200</code></pre><p><strong>EventEmitter</strong> object 同样有很多其他实用 method 来实现交互，例如：</p><ul><li><strong>once()</strong>: 添加一个一次性的 event 事件监听器，只会被触发一次</li><li><strong>removeListener() / off()</strong>: 删除某个已定义的 event 监听器</li><li><strong>removeAllListeners()</strong>: 删除所有的 event 监听器</li></ul><p>更多关于 events module 的用法参考：<a href="https://nodejs.org/api/events.html">https://nodejs.org/api/events.html</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2100.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/2100.html</wfw:commentRss>
</item>
<item>
<title>node.js 入门教程之三 -- npm</title>
<link>https://blog.niekun.net/archives/2085.html</link>
<guid>https://blog.niekun.net/archives/2085.html</guid>
<pubDate>Tue, 26 Jan 2021 15:45:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[调用 node.js 文件node.js 有内建的 module system 模块系统，一个node.js 文件可以导入其他 node.js 文件内定义的功能。语法如下：const libra...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<h3>调用 node.js 文件</h3><p>node.js 有内建的 module system 模块系统，一个node.js 文件可以导入其他 node.js 文件内定义的功能。</p><p>语法如下：</p><pre><code>const library = require('./libs')</code></pre><p>和导入其他第三方模块类似使用 <strong>require</strong> 指令，需要指定 node.js 文件路径。以上示例表示导入当前目录下的 <strong>libs.js</strong> 文件。</p><p>js 文件中默认定义的 objects 等元素是私有的，不能够被外部使用。在被导入的文件中，需要在引用前 expose 暴漏出需要被外部使用的功能。需要使用到 module system 的 <strong>module.exports</strong> API 来实现。</p><!--more--><p>当给一个 <strong>object</strong> 或 <strong>function</strong> 赋予 <strong>exports</strong> 属性时，就表明这些元素可以暴漏给外部。<strong>有两种方法来实现</strong>。</p><p><strong>第一种方法</strong>是将某个 object 直接赋值给 <strong>module.exports</strong>，<strong>module.exports</strong> 是 module system 的一个 object 用来将某个 object 暴漏出来，且只能在一个文件中赋值给某一个元素，下面是一个示例：</p><p><strong>libs.js</strong> 文件：</p><pre><code>const person = {
    name: 'marco',
    age: 20
}

module.exports = person;</code></pre><p><strong>main.js</strong> 文件：</p><pre><code>const libs = require('./libs');

console.log(libs.age);

//OUTPUT:
//20</code></pre><p>上面示例中，我们将 <strong>libs.js</strong> 文件的 <strong>person</strong> object 赋值给了 <strong>module.exports</strong>，在 <strong>main.js</strong> 中调用 <strong>libs.js</strong> 文件后，<strong>main.js</strong> 中的 <strong>libs</strong> object 就相当于 <strong>person</strong> object。</p><p>我们可以发现，这种定义方法可以将某个 node.js 文件中的一个 object 暴漏给外部使用。</p><p><strong>第二种方法</strong>是将需要暴漏的元素定义为 <strong>exports</strong> 的 properties，这种方式可以将多个 objects 或 function 暴漏给外部。</p><p>libs.js 文件：</p><pre><code>const person = {
    name: 'marco',
    age: 20
}
exports.person = person;

exports.car = {
    brand: 'bmw',
    color: 'red'
}</code></pre><p>main.js 文件：</p><pre><code>const libs = require('./libs');

console.log(libs.person.age);
console.log(libs.car.brand);

//OUTPUT:
//20
//bmw</code></pre><p>以上示例中，我们先在 <strong>libs.js</strong> 中定义了两个 object，并都作为 <strong>exports</strong> 的一个 property，可以看到有两种方式定义。在 <strong>main.js</strong> 中调用后，通过调用 <strong>libs</strong> object 对应的 properties 名称即可调用对应暴露的元素。</p><h3>npm 包管理器</h3><p><strong>npm</strong> 是 <strong>node.js</strong> 的标准包管理器。</p><p>一开始，npm 作为下载和管理 node.js 包的依赖的工具，现在也成为了 JavaScript 前端开发工具。</p><h4>下载包</h4><p>如果项目中有 <strong>package.json</strong> 文件，可以通过下面指令自动安装所有在文件中定义的模块，安装路径为 <strong>node_modules</strong> 文件夹内：</p><pre><code>npm install
</code></pre><p>安装某一个模块包：</p><pre><code>npm install &lt;package-name&gt;
</code></pre><p>在项目中安装的包会自动添加条目到 <strong>package.json</strong> 文件中。也可以在安装时使用 <code>--save</code> 选项来添加到文件。</p><h4>更新包</h4><p>更新项目中所有包：</p><pre><code>npm update
</code></pre><p>更新某一个包：</p><pre><code>npm update &lt;package-name&gt;
</code></pre><h4>执行任务</h4><p><strong>package.json</strong> 文件内支持定义指定的命令行指令，通过下面的语法来执行：</p><pre><code>npm run &lt;task-name&gt;
</code></pre><p>指令定义在 <strong>scripts</strong> 块内，例如：</p><pre><code>{
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;uname -r&quot;
  }
}</code></pre><p>此时我们在终端执行下面命令：</p><pre><code>$ npm run start
Debugger attached.

&gt; start
&gt; uname -r

5.8.0-38-generic
Waiting for the debugger to disconnect...</code></pre><p>可以看到通过 run 定义命令的名称就可以执行对应的命令。</p><h4>包安装路径</h4><p>当使用 npm 安装包时，可以定义两种安装模式：</p><ul><li>local install 逻辑安装</li><li>global install 全局安装</li></ul><p>默认情况下当我们使用下面指令安装包：</p><pre><code>npm install chalk
</code></pre><p>包会安装到当前项目路径下的 node_modules 文件夹内。此时 npm 会将对应包的信息写入 <strong>package.json</strong> 文件内的 <strong>dependencies</strong> 块内，如：</p><pre><code>{
  &quot;dependencies&quot;: {
    &quot;chalk&quot;: &quot;^4.1.0&quot;,
    &quot;inquirer&quot;: &quot;^7.3.3&quot;,
    &quot;minimist&quot;: &quot;^1.2.5&quot;,
    &quot;progress&quot;: &quot;^2.0.3&quot;
  }
}</code></pre><p>全局安装通过 <code>-g</code> 标记实现：</p><pre><code>npm install -g chalk
</code></pre><p>使用全局安装模式时，npm 不会将包安装到项目路径下，而是 <strong>global</strong> location 路径下。通过 <code>npm root -g</code> 命令可以返回 golbal 路径的地址，Linux 默认地址为：<code>/usr/local/lib/node_modules</code>，Windows 默认地址为：<code>C:\Users\YOU\AppData\Roaming\npm\node_modules</code>。</p><h4>可执行程序</h4><p>当安装一个包后，我们通过 <strong>require</strong> 关键词来调用模块：</p><pre><code>const inquirer = require('inquirer')
</code></pre><p>当安装的包是可执行程序的时候呢？当安装的包含有可执行程序时，程序会放在 <code>node_modules/.bin/</code> 文件夹内，关于如何运行这些可执行程序，我们通过 <strong>cowsay</strong> 包来演示。</p><p>首先安装 <strong>cowsay</strong>，这里安装到 global 路径下：</p><pre><code>npm install -g cowsay
</code></pre><p>我的 global 路径地址为：<code>/opt/node-v15.5.1-linux-x64/lib/node_modules</code>，可执行文件被安装在 <code>/opt/node-v15.5.1-linux-x64/bin/</code> 目录下：</p><pre><code>cowsay -&gt; ../lib/node_modules/cowsay/cli.js</code></pre><p>查看属性可以看到此可执行文件是指向 cli.js 的一个链接。</p><p>通过 <strong>npx</strong> 命令可以方便的执行此程序，不需要提供程序所在路径：</p><pre><code>$ npx cowsay wow
 _____
&lt; wow &gt;
 -----
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||</code></pre><h3>package.json 文件</h3><p>package.json 文件是其项目的一个声明，它可以用来做一些完全没有关联的事情。例如，它是配置工具的仓库，也存储着 npm 安装的包的版本信息。</p><p>下面是最简单的文件形式：</p><pre><code>{}
</code></pre><p>文件需要遵守 json 格式，否则无法被程序读取其定义的内容。没有什么内容是必须的，所以可以是一个简单的大括号。如果你要做一个通过 npm 分享的 node.js 包，那么 package.json 文件需要定义一些必须的属性以供了解这个包的信息，后面会做详细介绍。</p><p>下面是另一个示例：</p><pre><code>{
  &quot;name&quot;: &quot;test-node&quot;
}</code></pre><p>以上定义了一个 <strong>name</strong> property，定义了这个 app 或 package 的名称。文件和项目文件在同一文件夹下。</p><p>下面是一个更加复杂的示例：</p><pre><code>{
  &quot;name&quot;: &quot;test-project&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;A Vue.js project&quot;,
  &quot;main&quot;: &quot;src/main.js&quot;,
  &quot;private&quot;: true,
  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;,
    &quot;start&quot;: &quot;npm run dev&quot;,
    &quot;unit&quot;: &quot;jest --config test/unit/jest.conf.js --coverage&quot;,
    &quot;test&quot;: &quot;npm run unit&quot;,
    &quot;lint&quot;: &quot;eslint --ext .js,.vue src test/unit&quot;,
    &quot;build&quot;: &quot;node build/build.js&quot;
  },
  &quot;dependencies&quot;: {
    &quot;vue&quot;: &quot;^2.5.2&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;autoprefixer&quot;: &quot;^7.1.2&quot;,
    &quot;babel-core&quot;: &quot;^6.22.1&quot;,
    &quot;babel-eslint&quot;: &quot;^8.2.1&quot;,
    &quot;babel-helper-vue-jsx-merge-props&quot;: &quot;^2.0.3&quot;,
    &quot;babel-jest&quot;: &quot;^21.0.2&quot;,
    &quot;babel-loader&quot;: &quot;^7.1.1&quot;,
    &quot;babel-plugin-dynamic-import-node&quot;: &quot;^1.2.0&quot;,
    &quot;babel-plugin-syntax-jsx&quot;: &quot;^6.18.0&quot;,
    &quot;babel-plugin-transform-es2015-modules-commonjs&quot;: &quot;^6.26.0&quot;,
    &quot;babel-plugin-transform-runtime&quot;: &quot;^6.22.0&quot;,
    &quot;babel-plugin-transform-vue-jsx&quot;: &quot;^3.5.0&quot;,
    &quot;babel-preset-env&quot;: &quot;^1.3.2&quot;,
    &quot;babel-preset-stage-2&quot;: &quot;^6.22.0&quot;,
    &quot;chalk&quot;: &quot;^2.0.1&quot;,
    &quot;copy-webpack-plugin&quot;: &quot;^4.0.1&quot;,
    &quot;css-loader&quot;: &quot;^0.28.0&quot;,
    &quot;eslint&quot;: &quot;^4.15.0&quot;,
    &quot;eslint-config-airbnb-base&quot;: &quot;^11.3.0&quot;,
    &quot;eslint-friendly-formatter&quot;: &quot;^3.0.0&quot;,
    &quot;eslint-import-resolver-webpack&quot;: &quot;^0.8.3&quot;,
    &quot;eslint-loader&quot;: &quot;^1.7.1&quot;,
    &quot;eslint-plugin-import&quot;: &quot;^2.7.0&quot;,
    &quot;eslint-plugin-vue&quot;: &quot;^4.0.0&quot;,
    &quot;extract-text-webpack-plugin&quot;: &quot;^3.0.0&quot;,
    &quot;file-loader&quot;: &quot;^1.1.4&quot;,
    &quot;friendly-errors-webpack-plugin&quot;: &quot;^1.6.1&quot;,
    &quot;html-webpack-plugin&quot;: &quot;^2.30.1&quot;,
    &quot;jest&quot;: &quot;^22.0.4&quot;,
    &quot;jest-serializer-vue&quot;: &quot;^0.3.0&quot;,
    &quot;node-notifier&quot;: &quot;^5.1.2&quot;,
    &quot;optimize-css-assets-webpack-plugin&quot;: &quot;^3.2.0&quot;,
    &quot;ora&quot;: &quot;^1.2.0&quot;,
    &quot;portfinder&quot;: &quot;^1.0.13&quot;,
    &quot;postcss-import&quot;: &quot;^11.0.0&quot;,
    &quot;postcss-loader&quot;: &quot;^2.0.8&quot;,
    &quot;postcss-url&quot;: &quot;^7.2.1&quot;,
    &quot;rimraf&quot;: &quot;^2.6.0&quot;,
    &quot;semver&quot;: &quot;^5.3.0&quot;,
    &quot;shelljs&quot;: &quot;^0.7.6&quot;,
    &quot;uglifyjs-webpack-plugin&quot;: &quot;^1.1.1&quot;,
    &quot;url-loader&quot;: &quot;^0.5.8&quot;,
    &quot;vue-jest&quot;: &quot;^1.0.2&quot;,
    &quot;vue-loader&quot;: &quot;^13.3.0&quot;,
    &quot;vue-style-loader&quot;: &quot;^3.0.1&quot;,
    &quot;vue-template-compiler&quot;: &quot;^2.5.2&quot;,
    &quot;webpack&quot;: &quot;^3.6.0&quot;,
    &quot;webpack-bundle-analyzer&quot;: &quot;^2.9.0&quot;,
    &quot;webpack-dev-server&quot;: &quot;^2.9.1&quot;,
    &quot;webpack-merge&quot;: &quot;^4.1.0&quot;
  },
  &quot;engines&quot;: {
    &quot;node&quot;: &quot;&gt;= 6.0.0&quot;,
    &quot;npm&quot;: &quot;&gt;= 3.0.0&quot;
  },
  &quot;browserslist&quot;: [&quot;&gt; 1%&quot;, &quot;last 2 versions&quot;, &quot;not ie &lt;= 8&quot;]
}</code></pre><p>包含了很多的属性设置：</p><ul><li><strong>version</strong> 表示当前版本号</li><li><strong>name</strong> 设置包名称</li><li><strong>description</strong> 对 app 简要的描述</li><li><strong>main</strong> 设置 app 的入口文件</li><li><strong>private</strong> 如果设置为 true 可以防止包被无意的发布到 npm</li><li><strong>scripts</strong> 定义可以运行的脚本命令</li><li><strong>dependencies</strong> npm 依赖包列表</li><li><strong>devDependencies</strong> 定义开发使用的 npm 包列表</li><li><strong>engines</strong> 设置 app 运行的 node 版本</li><li><strong>browserslist</strong> 指定支持的浏览器版本</li></ul><p>以上所有的属性都可以被 npm 或其他工具使用。</p><h4>常用属性</h4><p>下面介绍一些常规使用的属性，包括你在本地开发的项目也可以使用。</p><p><strong>name</strong> 定义app 名称：</p><pre><code>&quot;name&quot;: &quot;test-project&quot;
</code></pre><p>name 必须小于 214 个字符，不能含有空格，只能包含<strong>小写字母，横杠<code>-</code> 或下划线<code>_</code></strong>。如果将包发布到 npm，会生成一个独有的链接。</p><p><strong>author</strong> 定义作者信息：</p><pre><code>&quot;author&quot;: &quot;marco &lt;me@niekun.net&gt; (https://niekun.net)&quot;
</code></pre><p>或者：</p><pre><code>  &quot;author&quot;: {
    &quot;name&quot;: &quot;marco&quot;,
    &quot;email&quot;: &quot;me@niekun.net&quot;,
    &quot;url&quot;: &quot;https://niekun.net&quot;
  }</code></pre><p><strong>contributors</strong> 定义代码贡献者信息，可以包含多人：</p><pre><code>  &quot;contributors&quot;: [
    {
      &quot;name&quot;: &quot;marco&quot;,
      &quot;email&quot;: &quot;me@niekun.net&quot;,
      &quot;url&quot;: &quot;https://niekun.net&quot;
    }
  ]</code></pre><p><strong>bugs</strong> 定义反馈 bug 的链接，一般是 GitHub issue 页面：</p><pre><code>&quot;bugs&quot;: &quot;https://github.com/whatever/package/issues&quot;
</code></pre><p><strong>homepage</strong> 定义包的主页链接：</p><pre><code>&quot;homepage&quot;: &quot;https://whatever.com/package&quot;
</code></pre><p><strong>version</strong> 定义当前包的版本：</p><pre><code>&quot;version&quot;: &quot;1.0.0&quot;
</code></pre><p>此属性遵守 semantic versioning (semver) notation 语义版本标记语法。也就是由三个数字表示：x.x.x</p><p><strong>license</strong> 定义包的授权信息：</p><pre><code>&quot;license&quot;: &quot;MIT&quot;
</code></pre><p><strong>keywords</strong> 定义关于这个包实现功能的关键词，是一个数组：</p><pre><code>  &quot;keywords&quot;: [
    &quot;learning&quot;,
    &quot;nodejs&quot;
  ]</code></pre><p>使用 keywords 可以帮助别人找到你的包，或者在 <a href="https://www.npmjs.com/">https://www.npmjs.com/</a> 网站上搜索关键词。</p><p><strong>description</strong> 定义一个对此 app 的简短描述：</p><pre><code>&quot;description&quot;: &quot;a node.js beginner guide&quot;
</code></pre><p><strong>repository</strong> 定义项目仓库地址：</p><pre><code>&quot;repository&quot;: &quot;github:whatever/node-project&quot;
</code></pre><p>注意如果不是使用的 GitHub 也可以定义其他工具：</p><pre><code>&quot;repository&quot;: &quot;gitlab:whatever/node-project&quot;
</code></pre><p>也可以明确的定义版本控制系统信息：</p><pre><code>  &quot;repository&quot;: {
    &quot;type&quot;: &quot;git&quot;,
    &quot;url&quot;: &quot;https://github.com/whatever/testing.git&quot;
  }</code></pre><p><strong>main</strong> 设置包的入口：</p><pre><code>&quot;main&quot;: &quot;./main.js&quot;
</code></pre><p><strong>private</strong> 如果设置为 true，可以防止包被无意的发布到 npm：</p><pre><code>&quot;private&quot;: &quot;true&quot;
</code></pre><p><strong>scripts</strong> 定义可执行的 node 脚本：</p><pre><code>  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;uname -r&quot;,
    &quot;test&quot;: &quot;echo abcd&quot;
  }</code></pre><p>定义的脚本是命令行程序，通过 npm run xxx 执行，如：</p><pre><code>npm run start
</code></pre><p><strong>dependencies</strong> 定义 app 需要安装的 npm 依赖包：</p><pre><code>  &quot;dependencies&quot;: {
    &quot;chalk&quot;: &quot;^4.1.0&quot;,
    &quot;inquirer&quot;: &quot;^7.3.3&quot;,
    &quot;minimist&quot;: &quot;^1.2.5&quot;,
    &quot;progress&quot;: &quot;^2.0.3&quot;
  }</code></pre><p>当通过 <code>npm install &lt;PACKAGENAME&gt;</code> 安装包，会自动将包写入 package.json 文件的 dependencies 块。</p><p><strong>devDependencies</strong> 定义 app 开发需要的 npm 依赖包：</p><pre><code>&quot;devDependencies&quot;: {
  &quot;autoprefixer&quot;: &quot;^7.1.2&quot;,
  &quot;babel-core&quot;: &quot;^6.22.1&quot;
}</code></pre><p>和 <strong>dependencies</strong> 的区别是这里定义的包只是在开发设备上安装，而不需要在执行设备上安装。开发包通过以下命令安装：</p><pre><code>npm install --save-dev &lt;PACKAGENAME&gt;
</code></pre><p><strong>engines</strong> 设置此包运行的 node 版本和其他命令版本：</p><pre><code>  &quot;engines&quot;: {
    &quot;node&quot;: &quot;&gt;= 6.0.0&quot;,
    &quot;npm&quot;: &quot;&gt;=3.0.0&quot;
  }</code></pre><p><strong>browserslist</strong> 定义 app 支持的浏览器版本：</p><pre><code>&quot;browserslist&quot;: [
  &quot;&gt; 1%&quot;,
  &quot;last 2 versions&quot;,
  &quot;not ie &lt;= 8&quot;
]</code></pre><p>以上定义的意义是：支持所有类型浏览器的最近两个版本且需要至少有 1% 的占有率，不包括小于等于 IE8 版本的浏览器。浏览器占有率信息来自于 <a href="https://caniuse.com/">https://caniuse.com/</a> 统计。</p><h4>依赖包版本信息</h4><p>在 <strong>dependencies</strong> 和 <strong>devDependencies</strong> 中定义了依赖包列表，每个包都定义了版本信息，如：<strong>^0.13.0</strong> 或 <strong>~3.0.0</strong>，通过版本号前的符号可以们定义接受那些版本的升级，下面介绍版本标记的用法：</p><ul><li>无标记，如 1.0.0 定义只安装此版本的包</li><li><strong>latest</strong> 定义安装最新版本的包</li><li><strong>^</strong> 只能升级到不改变最左边第一个非零数字的版本，如定义 <strong>^0.13.0</strong>，通过 npm update 可以升级到 0.13.1 或 0.13.2，但不能升级到 0.14.0，定义 <strong>^1.13.0</strong>，能够升级到 1.13.1 或 1.14.0，不能升级到 2.0.0</li><li><strong>~</strong> 只能升级最后一位数字变化的版本，如 定义 <strong>~1.13.0</strong>，能够升级到 1.13.1，但不能升级到 1.14.0</li><li><strong>&gt;</strong> 接受大于定义的版本号的更新</li><li><strong>&gt;=</strong> 接受大于等于定义的版本号的更新</li><li><strong>&lt;</strong> 接受小于定义的版本号的更新</li><li><strong>&lt;=</strong> 接受小于等于定义的版本号的更新</li><li><strong>-</strong> 设置一个版本范围，如：1.0.0 - 2.0.0</li><li><strong>||</strong> 组合设置，如：&lt; 2.0.0 || &gt; 3.0.0</li></ul><p>更加详细的定义方法参考：<a href="https://nodejs.dev/learn/semantic-versioning-using-npm">https://nodejs.dev/learn/semantic-versioning-using-npm</a></p><h3>package-lock.json 文件</h3><p>在 npm 5 版本中 npm 引入了 package-lock.json 文件。</p><p>前面介绍了 package.json 文件，它是一个通用的被广泛使用的配置文件。package-lock.json 文件的目的是更加确切的追踪安装的依赖包的版本，以用来 100% 复制开发者的安装环境到其他安装者设备上，即使某些包已经够了更新版本。</p><p>这解决了一个 package.json 遗留的问题，在 package.json 中你可以定义某个包可接受的版本升级范围，版本格式遵守 semantic versioning (semver) notation 语义版本标记语法，例如：</p><ul><li><strong>~1.13.1</strong> 可以升级到 1.13.2，但不可以升级到 1.14.0</li><li><strong>^1.13.1</strong> 可以升级到 1.14.0，但不能升级到 2.0.0</li><li><strong>1.13.1</strong> 只能安装 1.13.1 版本，不能升级到其他任何版本</li></ul><p>你发布的包中并不包含开发环境中的  node_modules 文件夹因为它占用空间很大。当在其他设备中通过 <code>npm install</code>  命令安装依赖包时，竟会遵循上面定义的版本范围安装支持的最新版本到设备中，这就会导致用户安装的版本和你开发环境的版本不一致，可能导致 bug 的出现。</p><p>package-lock.json 中定义了你当前开发环境安装的各种依赖包的准确版本，这样通过 <code>npm install</code> 命令安装的就是其中定义的准确版本。</p><p>这一概念并不是 npm 独创的，其他编程语言也在使用类似的模式，如 php 的 Composer。</p><p>package-lock.json 文件需要打包在仓库中，以供其他人使用。当使用 <code>npm update</code> 更新包时，package-lock.json 中的定义也会同步更新。</p><p>下面是一个 package-lock.json 文件的示例，当我们执行 <code>npm install cowsay</code> 时，会创建以下内容：</p><pre><code>{
  &quot;requires&quot;: true,
  &quot;lockfileVersion&quot;: 1,
  &quot;dependencies&quot;: {
    &quot;ansi-regex&quot;: {
      &quot;version&quot;: &quot;3.0.0&quot;,
      &quot;resolved&quot;: &quot;https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz&quot;,
      &quot;integrity&quot;: &quot;sha1-7QMXwyIGT3lGbAKWa922Bas32Zg=&quot;
    },
    &quot;cowsay&quot;: {
      &quot;version&quot;: &quot;1.3.1&quot;,
      &quot;resolved&quot;: &quot;https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz&quot;
,
      &quot;integrity&quot;: &quot;sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==&quot;,
      &quot;requires&quot;: {
        &quot;get-stdin&quot;: &quot;^5.0.1&quot;,
        &quot;optimist&quot;: &quot;~0.6.1&quot;,
        &quot;string-width&quot;: &quot;~2.1.1&quot;,
        &quot;strip-eof&quot;: &quot;^1.0.0&quot;
      }
    },
    &quot;get-stdin&quot;: {
      &quot;version&quot;: &quot;5.0.1&quot;,
      &quot;resolved&quot;: &quot;https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz&quot;,
      &quot;integrity&quot;: &quot;sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g=&quot;
    },
    &quot;is-fullwidth-code-point&quot;: {
      &quot;version&quot;: &quot;2.0.0&quot;,
      &quot;resolved&quot;: &quot;https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz&quot;,
      &quot;integrity&quot;: &quot;sha1-o7MKXE8ZkYMWeqq5O+764937ZU8=&quot;
    },
    &quot;minimist&quot;: {
      &quot;version&quot;: &quot;0.0.10&quot;,
      &quot;resolved&quot;: &quot;https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz&quot;,
      &quot;integrity&quot;: &quot;sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8=&quot;
    },
    &quot;optimist&quot;: {
      &quot;version&quot;: &quot;0.6.1&quot;,
      &quot;resolved&quot;: &quot;https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz&quot;,
      &quot;integrity&quot;: &quot;sha1-2j6nRob6IaGaERwybpDrFaAZZoY=&quot;,

      &quot;requires&quot;: {
        &quot;minimist&quot;: &quot;~0.0.1&quot;,
        &quot;wordwrap&quot;: &quot;~0.0.2&quot;
      }
    },
    &quot;string-width&quot;: {
      &quot;version&quot;: &quot;2.1.1&quot;,
      &quot;resolved&quot;: &quot;https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz&quot;,
      &quot;integrity&quot;: &quot;sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==&quot;,
      &quot;requires&quot;: {
        &quot;is-fullwidth-code-point&quot;: &quot;^2.0.0&quot;,
        &quot;strip-ansi&quot;: &quot;^4.0.0&quot;
      }
    },
    &quot;strip-ansi&quot;: {
      &quot;version&quot;: &quot;4.0.0&quot;,
      &quot;resolved&quot;: &quot;https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz&quot;,
      &quot;integrity&quot;: &quot;sha1-qEeQIusaw2iocTibY1JixQXuNo8=&quot;,
      &quot;requires&quot;: {
        &quot;ansi-regex&quot;: &quot;^3.0.0&quot;
      }
    },
    &quot;strip-eof&quot;: {
      &quot;version&quot;: &quot;1.0.0&quot;,
      &quot;resolved&quot;: &quot;https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz&quot;,
      &quot;integrity&quot;: &quot;sha1-u0P/VZim6wXYm1n80SnJgzE2Br8=&quot;
    },
    &quot;wordwrap&quot;: {
      &quot;version&quot;: &quot;0.0.3&quot;,
      &quot;resolved&quot;: &quot;https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz&quot;,
      &quot;integrity&quot;: &quot;sha1-o9XabNXAvAAI03I0u68b7WMFkQc=&quot;
    }
  }
}</code></pre><p>我们安装的 cowsay 有如下依赖，它们会被自动安装：</p><ul><li>get-stdin</li><li>optimist</li><li>string-width</li><li>strip-eof</li></ul><p>以上的依赖包可能也会有它们各自的其他依赖包，会自动安装相关其他包，每个包的依赖包在 <strong>requires</strong> 属性中定义。</p><p>所有的包以字母排序顺序在文件中。每个包都有 <strong>version</strong> 属性定义了各自当前安装的版本，<strong>resolved</strong> 定义了包地址，<strong>integrity</strong> 字符串用来验证包。</p><h3>包版本管理及安装</h3><p>下面的指令查询当前安装的所有包及其依赖包：</p><pre><code>npm list
</code></pre><p>输出信息示例：</p><pre><code>❯ npm list
/Users/joe/dev/node/cowsay
└─┬ cowsay@1.3.1
  ├── get-stdin@5.0.1
  ├─┬ optimist@0.6.1
  │ ├── minimist@0.0.10
  │ └── wordwrap@0.0.3
  ├─┬ string-width@2.1.1
  │ ├── is-fullwidth-code-point@2.0.0
  │ └─┬ strip-ansi@4.0.0
  │   └── ansi-regex@3.0.0
  └── strip-eof@1.0.0</code></pre><p>当然也可以直接打开 package-lock.json 文件查看，但这样不太方便观察结构。</p><p><code>npm list -g</code> 用来查看 global 安装的包。</p><p>如果只想查询顶层的包，也就是你主动通过 <code>npm install</code> 安装的那些包，可通过 <code>npm list --depth=0</code> 查询：</p><pre><code>❯ npm list --depth=0
/Users/joe/dev/node/cowsay
└── cowsay@1.3.1</code></pre><p>也可以单独查询某个包：</p><pre><code>❯ npm list cowsay
/Users/joe/dev/node/cowsay
└── cowsay@1.3.1</code></pre><p>使用下面命令查询某个包当前发布的最新版本：</p><pre><code>❯ npm view cowsay version
1.4.0</code></pre><p>要安装某个包的特定版本需要加上 <code>@</code> 标记：</p><pre><code>npm install cowsay@1.2.0
</code></pre><p>查看某个包的所有历史版本列表：</p><pre><code>$ npm view cowsay versions
[
  '1.0.0', '1.0.1', '1.0.2',
  '1.0.3', '1.1.0', '1.1.1',
  '1.1.2', '1.1.3', '1.1.4',
  '1.1.5', '1.1.6', '1.1.7',
  '1.1.8', '1.1.9', '1.2.0',
  '1.2.1', '1.3.0', '1.3.1',
  '1.4.0'
]</code></pre><p>通过 <code>npm update</code> 可以更新所有已安装的包，更新版本规则遵循 package.json 定义的版本升级范围，同时会更新 package-lock.json 文件内的当前包版本信息。</p><p>想要查询当前有哪些包有更新版本时，可以执行 <code>npm outdated</code> 命令：<br><img src="https://blog.niekun.net/usr/uploads/2021/01/1402612766.png" alt="2021-01-29T01:29:02.png" title="2021-01-29T01:29:02.png"></p><p>其中有些更新是大版本更新， <code>npm update</code> 并不会更新到这些大版本，因为这些更新可能包含有重大的变化。如果要强制更新到最新的版本包括大版本更新，可以按顺序执行下面的命令：</p><pre><code>npm install -g npm-check-updates
ncu -u
npm update</code></pre><p>使用下面命令卸载某个包：</p><pre><code>npm uninstall &lt;package-name&gt;
</code></pre><p>添加 <code>-S</code> 或 <code>--save</code> 标记删除 package.json 中的相关信息。如果要删除的包是一个开发包，在 devDependencies 中定义过，则需要添加 <code>-D</code> 或 <code>--save-dev</code> 标记来删除相关信息：</p><pre><code>npm uninstall -S &lt;package-name&gt;
npm uninstall -D &lt;package-name&gt;</code></pre><p>如果包是 global 安装的，则卸载需要添加 <code>-g</code> 标记：</p><pre><code>npm uninstall -g &lt;package-name&gt;
</code></pre><h3>npm local 和 global 安装</h3><p>本地包和全局包的区别是本地包通过 <code>npm install</code> 安装到当前项目下的 node_modules 文件夹内，全局包通过 <code>npm install -g</code> 安装到系统路径下，路径地址可通过 <code>npm root -g</code> 查询。</p><p>在程序中，只能 require 本地包：</p><pre><code>require('package-name')
</code></pre><p>通常情况下推荐所有的包都以本地模式安装。这可以让不同的程序使用各自不同版本的包。更新一个全局包会同时影响所有使用这个包的 app。</p><p>当一个包含有可执行程序时，应该安装为 global 全局包。这样所有的项目都可以调用执行。</p><h3>npm dependencies 和 devDependencies</h3><p>当通过 npm intall 安装包时，表示将包作为 dependency。包信息会自动写入 package.json 文件的 dependencies 块内。当安装时添加 <code>-D</code> 标记，表示将包作为 devdependency 安装。包信息会自动写入 devDependencies 块内。</p><p>开发包的目的是用来开发程序时使用，作为产品运行时是不需要的。</p><p>执行 npm install 会默认安装这些开发包。如果不需要安装开发包需要加上 <code>--production</code> 标记：</p><pre><code>npm install --production xxx
</code></pre><h3>npx 包运行器</h3><p>npx 可以用来运行 node.js 程序。node.js 开发者通常将大部分含有可执行程序的包作为 global 包发布，这样就使得可执行程序在系统 PATH 路径下可以被直接执行。但这样的弊端就是不能安装不同版本的包。</p><p>使用 npx 命令可以自动寻找 node_modules 文件夹内的对应的名称的可执行程序，而不需要知道程序具体的路径，也不需要以 global 方式安装包。</p><p>npx 另一个很好的功能是可以直接运行某些命令而不需要提前安装它们，还可以通过 <code>@</code> 标记来执行不同版本的同一命令。</p><p>cowsay 是一个很好的示例来说明 npx 的使用，如果我们以 global 模式安装 cowsay，可以通过下面方式执行：</p><pre><code>cowsay &quot;wow&quot;
</code></pre><p>以上命令只有通过 global 方式安装才能够正常执行，否则会报错提示命令不存在。</p><p>如果以 local 方式安装 cowsay，可以通过 npx 执行：</p><pre><code>npx cowsay &quot;Hello&quot;
</code></pre><p>通过 <code>@</code> 标记来执行不同版本的命令：</p><pre><code>npx node@10 -v #v10.18.1
npx node@12 -v #v12.14.1</code></pre><p>npm 也可以直接执行来自 url 的任意代码片段，而不仅限于 npm 官方渠道发布的包。下面示例是执行部署在 glist 的包：</p><pre><code>npx https://gist.github.com/zkat/4bc19503fe9e9309e2bfaa2c58074d32
</code></pre><p>可执行程序路径定义在 package.json 文件的 bin 属性内。</p><p>glist 包含内容如下：<br><img src="https://blog.niekun.net/usr/uploads/2021/01/1152197546.jpg" alt="1.jpg" title="1.jpg"></p><p>当然执行不受控制网络的代码需要多加注意。</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2085.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/2085.html</wfw:commentRss>
</item>
<item>
<title>node.js 入门教程之二 -- Getting Started</title>
<link>https://blog.niekun.net/archives/2051.html</link>
<guid>https://blog.niekun.net/archives/2051.html</guid>
<pubDate>Sat, 09 Jan 2021 15:48:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[V8 JavaScript EngineV8 是 chrome 浏览器的 JavaScript Engine 名称，它是用来在 chrome 中获取和执行 JavaScript 代码的工具。V8...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<h3>V8 JavaScript Engine</h3><p>V8 是 chrome 浏览器的 JavaScript Engine 名称，它是用来在 chrome 中获取和执行 JavaScript 代码的工具。V8 提供了一个 JavaScript 的运行环境，DOM 及其他 web API 是由 browser 提供的。</p><p>JavaScript Engine 是独立于其所寄生的浏览器的，这一特性才使 node.js 得以诞生。node.js 选择了 V8 Engine 且随着 node.js 的不断成长，大量服务端通过 JavaScript 编写的程序使用 v8 Engine。</p><p>基于 V8 同样可以创造桌面应用，例如 Electron 项目。</p><p>不同的浏览器有着各自的 Engine：</p><ul><li><strong>Firefox</strong> has SpiderMonkey</li><li><strong>Safari</strong> has JavaScriptCore (also called Nitro)</li><li><strong>Edge</strong> was originally based on Chakra but has more recently been rebuilt using Chromium and the V8 engine.</li></ul><p>所有的 Engine 都遵守 ECMAScript 标准。</p><!--more--><p>在最初时候 JavaScript 被作为一种  interpreted language 解释型语言。但是现代 JavaScript Engine 不在单单 interpret 解释代码，而是要 compile 编译代码。</p><p>从 2009 年起，Firefox 将 SpiderMonkey 编译器集成到浏览器中，从此大家都开始引入这一方案。</p><p>JavaScript 代码被 V8 通过内部的 just-in-time (JIT) 编译器编译来提高执行效率。</p><h3>命令行运行 node.js 代码</h3><p>一般情况下在安装好 node.js 后，可以通过 node 命令执行 node.js 代码，需要传递被执行文件的路径：</p><pre><code>node app.js
</code></pre><h3>触发信号的使用</h3><p>当在终端中执行 node.js 程序时，可以通过快捷键 <code>ctrl C</code> 退出程序。当我们下面介绍如果通过更加<strong>程序化的方式</strong>实现退出动作。</p><p><strong>首先介绍第一种比较直接粗暴的方式</strong>：</p><pre><code>process.exit()
</code></pre><p>通过调用 <strong>precess</strong> 模块的 <strong>exit</strong> function ，进程会立即被强行终止。这意味着任何它当前挂起的任务，正在传输的数据，对文件的访问和读写等都会被以一种不友好的方式终止掉。</p><p><strong>process</strong> 不需要通过 <strong>require</strong> 的方式引入，他是默认被包含的。</p><p>你可以传递一个整型数字作为 exit code 退出码，不写的话默认为 <code>0</code>：</p><pre><code>process.exit(1)
</code></pre><p>不同的退出码有不同的意义，你可以使用不同的退出码来和其他程序响应。各种退出码的意义：<a href="https://nodejs.org/api/process.html#process_exit_codes">https://nodejs.org/api/process.html#process_exit_codes</a></p><p>你也可以提前设置退出码：</p><pre><code>process.exitCode = 1
</code></pre><p>在后续执行到 <code>process.exit</code> 时会返回此处设置的值。</p><p><strong>下面介绍更加友好的退出方式</strong>。</p><p>在上一节中，我们介绍了通过 http 模块搭建一个简单的 web 服务器，使用 express 模块也可以搭建 web 服务器，默认没有安装此模块，首先需要通过 npm 进行安装，模块会安装到当前路径下：</p><pre><code>npm install express
</code></pre><p>新建 js 文件，内容如下：</p><pre><code>const express = require('express')
const app = express()

app.get('/', (req, res) =&gt; {
  res.send('Hi!')
})

const server = app.listen(3000, () =&gt; console.log('Server ready'))</code></pre><p>打开浏览器访问本地 3000 端口即可看到输出。</p><p>这个 web 服务会一直进行下去，如果调用了 <code>process.exit()</code>，当前的响应会立刻被终止，这是显然不太好的。</p><p>我们可以通过发送一个 <strong>SIGTERM</strong> 信号，然后处理对这个信号的响应。响应的动作可以是关闭这个 web 服务，上面的示例增加如下代码：</p><pre><code>process.on('SIGTERM', () =&gt; {
    server.close(() =&gt; console.log('process termimated'));
});</code></pre><p>这里我们监控一个 <strong>SIGTERM</strong> signal 作为一个 event 事件，然后响应关闭服务器的动作。</p><p><code>process.on</code> 叫做 <strong>signal handler</strong> 信号响应器，用来定义接受的信号及对应的响应动作。这里定义当 <strong>SIGTERM</strong> 信号被触发后，执行关闭 server 动作及输出 log。</p><p><strong>SIGTERM</strong> 是告诉系统将进程友好终止的信号。此信号被触发后，首先会执行 <strong>signal handler</strong> 信号响应器所定义的响应动作，也就是关闭 web 服务器，最后再终止对应进程。</p><p><strong>SIGTERM</strong> 信号一般是由进程管理器，如：<strong>upstart</strong>，<strong>supervisord</strong> 发出。这里我们在程序内部触发此信号：</p><pre><code>setTimeout(() =&gt; {
    process.kill(process.pid, 'SIGTERM')
}, 3000);</code></pre><p><code>process.kill()</code> method 用来将 <strong>signal</strong> 信号发送给对应 <strong>pid</strong> 进程。语法如下：</p><pre><code>process.kill(pid, signal)
</code></pre><ul><li><strong>pid</strong> <number> 进程 ID</li><li><strong>signal</strong> <string> | <number> 要发送的信号, 大写字母的字符串或数字. 默认为: 'SIGTERM'</li></ul><p>当 pid 对应进程不存在时将会 throw 一个 error。<code>process.pid</code> 返回值为当前程序的进程 ID。</p><p>虽然 <code>process.kill</code> 名称看起来是要终止一个进程，但是他的确仅仅是一个 <strong>signal sender</strong> 信号发送器。具体会有什么样的结果完全取决于发送的是什么信号，以及对应信号的响应。<strong>kill</strong> method 的文档：<a href="https://nodejs.org/api/process.html#process_process_kill_pid_signal">https://nodejs.org/api/process.html#process_process_kill_pid_signal</a></p><p>以上示例中，加入对 <strong>SIGTERM</strong> 信号的触发和响应后，效果为：首先开启一个 web 服务器，3 秒后会尝试关闭此服务器并输出 log，此处会等待服务器完全结束当前 request 才会结束，最后终止进程：</p><pre><code>$ node express.js 
Server ready
process termimated</code></pre><p>注意 Windows 下 <strong>signal handler</strong> 信号响应器会无效，以上示例如果在 Windows 下执行不会输出最后一行 log 信息。</p><p><strong>常见的信号：</strong></p><ul><li><strong>SIGTERM</strong> 告诉系统需要友好的终止某个进程</li><li><strong>SIGKILL</strong> 立即结束对应进程，类似于 <code>process.exit()</code> 的效果</li><li><strong>beforeExit</strong> 进程退出前会触发此信号</li><li><strong>exit</strong> 进程退出时会触发此信号</li></ul><p>下面是一个对部分信号触发时间的测试：</p><pre><code>process.on(&quot;beforeExit&quot;, () =&gt;
    console.log(&quot;before exit&quot;));

process.on(&quot;exit&quot;, () =&gt;
    console.log(&quot;exit&quot;));

console.log(&quot;running&quot;);</code></pre><p>以上程序执行后输出信息如下：</p><pre><code>$ node process.js 
running
before exit
exit</code></pre><p>更多信号的意义参考：<a href="https://man7.org/linux/man-pages/man7/signal.7.html">signal(7) — Linux manual page</a><br>更多使用方法参考：<a href="https://nodejs.org/api/process.html#process_signal_events">Signal events</a></p><h3>环境变量的读取</h3><p>node.js 的核心模块 <strong>process</strong> 提供了 <strong>env</strong> properties 寄存了当前程序开始时的所有 environment variables 环境变量。执行以下命令可以输出所有变量：</p><pre><code>console.log(process.env);
</code></pre><p>查看某一个变量：</p><pre><code>console.log(process.env.HOME);

//-&gt; /home/marco</code></pre><p>也可以设置自定义的环境变量并给其赋值：</p><pre><code>console.log(process.env.TEST);
process.env.TEST = &quot;dev&quot;;
console.log(process.env.TEST);

// output:
// undefined
// dev</code></pre><h3>node.js REPL</h3><p>通常情况下我们将代码写在 js 文件中，然后通过 node 命令执行：</p><pre><code>node app.js
</code></pre><p>如果不指定需要执行的 js 文件，则会进入 REPL (Read Evaluate Print Loop) 编程环境，可以通过直接输入指令，逐行执行代码。</p><p>进入 REPL：</p><pre><code>$ node
Welcome to Node.js v15.5.1.
Type &quot;.help&quot; for more information.
&gt; </code></pre><p>尝试输出 log 信息：</p><pre><code>&gt; console.log('test')
test
undefined
&gt; </code></pre><p>可以发现首先会输出指定的字符串内容，然后输出 <strong>undefined</strong>，它是 <code>console.log</code> function 的返回值。</p><p>同样在 REPL 中也可以使用 tab 键来自动补全指令名称。</p><p>输入 JavaScript object 名称和符号点<code>.</code>，然后点击 tab 键会输出指定 object 的所有 properties。例如 Array：</p><pre><code>&gt; Array.
Array.__defineGetter__      Array.__defineSetter__      Array.__lookupGetter__      Array.__lookupSetter__
Array.__proto__             Array.hasOwnProperty        Array.isPrototypeOf         Array.propertyIsEnumerable
Array.toLocaleString        Array.valueOf

Array.apply                 Array.arguments             Array.bind                  Array.call
Array.caller                Array.constructor           Array.toString

Array.from                  Array.isArray               Array.length                Array.name
Array.of                    Array.prototype

&gt; Array.</code></pre><p>使用这种方式输出  global objects 全局可用的所有 objects：</p><pre><code>&gt; global.
global.__defineGetter__      global.__defineSetter__      global.__lookupGetter__      global.__lookupSetter__
global.__proto__             global.hasOwnProperty        global.isPrototypeOf         global.propertyIsEnumerable
global.toLocaleString        global.toString              global.valueOf

global.constructor

global.AbortController       global.AbortSignal           global.AggregateError        global.Array
global.ArrayBuffer           global.Atomics               global.BigInt                global.BigInt64Array
global.BigUint64Array        global.Boolean               global.Buffer                global.DataView
global.Date                  global.Error                 global.EvalError             global.Event
global.EventTarget           global.FinalizationRegistry  global.Float32Array          global.Float64Array
global.Function              global.Infinity              global.Int16Array            global.Int32Array
global.Int8Array             global.Intl                  global.JSON                  global.Map
global.Math                  global.MessageChannel        global.MessageEvent          global.MessagePort
global.NaN                   global.Number                global.Object                global.Promise
global.Proxy                 global.RangeError            global.ReferenceError        global.Reflect
global.RegExp                global.Set                   global.SharedArrayBuffer     global.String
global.Symbol                global.SyntaxError           global.TextDecoder           global.TextEncoder
global.TypeError             global.URIError              global.URL                   global.URLSearchParams
global.Uint16Array           global.Uint32Array           global.Uint8Array            global.Uint8ClampedArray
global.WeakMap               global.WeakRef               global.WeakSet               global.WebAssembly
global._                     global._error                global.assert                global.async_hooks
global.buffer                global.child_process         global.clearImmediate        global.clearInterval
global.clearTimeout          global.cluster               global.console               global.constants
global.crypto                global.decodeURI             global.decodeURIComponent    global.dgram
global.diagnostics_channel   global.dns                   global.domain                global.encodeURI
global.encodeURIComponent    global.escape                global.eval                  global.events
global.fs                    global.global                global.globalThis            global.http
global.http2                 global.https                 global.inspector             global.isFinite
global.isNaN                 global.module                global.net                   global.os
global.parseFloat            global.parseInt              global.path                  global.perf_hooks
global.process               global.punycode              global.querystring           global.queueMicrotask
global.readline              global.repl                  global.require               global.setImmediate
global.setInterval           global.setTimeout            global.stream                global.string_decoder
global.sys                   global.timers                global.tls                   global.trace_events
global.tty                   global.undefined             global.unescape              global.url
global.util                  global.v8                    global.vm                    global.wasi
global.worker_threads        global.zlib

&gt; global.</code></pre><p>REPL 有一些特殊指令，以 <code>.</code> 开始：</p><ul><li><code>.help</code>: shows the dot commands help</li><li><code>.editor</code>: enables editor mode, to write multiline JavaScript code with ease. Once you are in this mode, enter ctrl-D to run the code you wrote.</li><li><code>.break</code>: when inputting a multi-line expression, entering the .break command will abort further input. Same as pressing ctrl-C.</li><li><code>.clear</code>: resets the REPL context to an empty object and clears any multi-line expression currently being input.</li><li><code>.load</code>: loads a JavaScript file, relative to the current working directory</li><li><code>.save</code>: saves all you entered in the REPL session to a file (specify the filename)</li><li><code>.exit</code>: exits the repl (same as pressing ctrl-C two times)</li></ul><h3>来自命令行的传递参数</h3><p>在执行某个 js 文件时，你可以传入任意个数的数据作为传入参数供程序内使用。参数可以是独立的，也可以是以 key/value 形式：</p><pre><code>node app.js jon
node appljs name=jon age=20</code></pre><p>如果使用第二种方式，则需要对其进行解析，后面会介绍。</p><p>通过访问 <strong>process</strong> 模块的 <strong>argv</strong> property 可以 retrieve 这些传入参数，<strong>argv</strong> 是一个数组，它的首个元素是 node 可执行文件路径，第二个元素是当前执行的 js 文件路径，其他元素就是传入参数数据。</p><p>我们新建 argv.js 文件内容如下：</p><pre><code>process.argv.forEach((val, index) =&gt; {
    console.log(`${index}: ${val}`);
});</code></pre><p>执行以下指令：</p><pre><code>$ node argv.js ABC
0: /opt/node-v15.5.1-linux-x64/bin/node
1: /mnt/hgfs/Development/node.js/argv.js
2: ABC</code></pre><p>可以看到第三个元素是我们传入的数据。</p><p>可以通过 array 的 <strong>slice</strong> method 将所有传入参数单独提取出来：</p><pre><code>const val = process.argv.slice(2);
</code></pre><p><strong>slice</strong> 语法如下：</p><pre><code>array.slice(start, end)
</code></pre><p>将指定的数组范围内的元素生成一个新数组并返回，<strong>start</strong> 参数为起始元素索引，<strong>end</strong> 为终止元素索引，<strong>end</strong> 默认值为原数组最后一个元素。</p><p><strong>如果传入参数没有定义索引 key：</strong></p><pre><code>node app.js jon
</code></pre><p>使用以下方法调用：</p><pre><code>const val = process.argv.slice(2);
console.log(val[0]);</code></pre><p><strong>如果传入参数定义了索引 key：</strong></p><pre><code>node app.js name=jon
</code></pre><p>此时 <strong>args[0]</strong> 的值为 <strong>name=joe</strong>，需要对其进行解析操作，最简单的是使用 minimist 库实现(先通过 <strong>npm</strong> 安装)：</p><pre><code>const args = require('minimist')(process.argv.slice(2));
console.log(args['name']);
console.log(args['age']);</code></pre><p>此时我们需要在传入参数的索引 key 前加双横杠<code>--</code>:</p><pre><code>$ node argv.js --name=jon --age=20
jon
20</code></pre><h3>命令行输出</h3><p>node.js 提供了一个 <strong>console</strong> 模块提供了很多有用的方法来在命令行下交互信息。它同浏览器下的 <strong>console</strong> object 类似。</p><p>最基础的就是 <code>console.log</code> method，可以将传入数据输出为字符串到终端。如果传入一个 object，会将其渲染为 string。</p><p>你可以输出多个数据，例如：</p><pre><code>let a = 1;
let b = 2;
console.log(a, b);

//output:
//1 2</code></pre><p>可以使用连接符来组合字符串和变量：</p><pre><code>console.log('num1 is ' + a + ', num2 is ' + b)
</code></pre><p>通过传入变量和一个对应的 format specifier 格式占位符来使格式解析更加明晰：</p><pre><code>console.log('num1 is %s, num2 is %s', a, b)
</code></pre><ul><li><strong>%s</strong> 格式化一个变量成字符串</li><li><strong>%d</strong> 格式化一个变量成数字</li><li><strong>%i</strong> 格式化一个变量成整数</li><li><strong>%o</strong> 格式化一个变量为 object</li></ul><p>调用 <strong>clear</strong> method 可以清空当前终端的信息:</p><pre><code>console.clear();
</code></pre><p><strong>count</strong> method 可以实现对一个输出字符串的累计计数，输出字符串的同时会显示此字符串已经输出的次数，执行以下代码：</p><pre><code>console.count('count1')
console.count('count2')
console.count('count1')
console.count('count1')</code></pre><p>输出结果为：</p><pre><code>count1: 1
count2: 1
count1: 2
count1: 3</code></pre><p>结合 <strong>time</strong> 和 <strong>timeEnd</strong> method 可以计算执行一段代码花费的时间：</p><pre><code>const doSomeThing = () =&gt; console.log('test');
const measureTime = () =&gt; {
    console.time();
    doSomeThing();
    console.timeEnd();
}
measureTime()

//output:
//test
//default: 5.937ms</code></pre><p>以上示例中，调用 <code>console.time()</code> 开始计时，调用 <code>console.timeEnd()</code> 终止计时并返回总时间。</p><p>通过 <code>console.log</code> 等输出到终端的信息称之为 standard 标准输出：<strong>stdout</strong>，通过 <code>console.error</code> 会输出到 <strong>stderr</strong> stream 流，不会显示到终端而是输出到了 error log。</p><p>可以通过  <code>escape sequences</code> 转义序列来给输出信息添加颜色，执行下面示例：</p><pre><code>console.log('\x1b[31m%s, \x1b[33m%s', 'hello', 'world')
</code></pre><p>输出如下：<br><img src="https://blog.niekun.net/usr/uploads/2021/01/4134573984.png" alt="2021-01-12T07:41:15.png" title="2021-01-12T07:41:15.png"></p><p><code>\x1b[</code> 后跟对应颜色的数字编号即可：</p><ul><li>30m    Black</li><li>31m    Red</li><li>32m    Green</li><li>33m    Yellow</li><li>34m    Blue</li><li>35m    Purple</li><li>36m    Cyan</li><li>37m    White</li></ul><p>但这种方法比较麻烦，输入也不太友好。</p><p>最好的方式是通过 Chalk 库来实现这个功能，它不仅可以修改颜色，还可以设置粗体，下划线，斜体等效果。需要通过 <code>npm install chalk</code> 安装库。</p><p>使用方法如下：</p><pre><code>const chalk = require('chalk')
console.log(chalk.yellow('hello world'))</code></pre><p>这种方法使代码更加清晰可读。更多 chalk 使用方法参考：<a href="https://github.com/chalk/chalk">https://github.com/chalk/chalk</a></p><p><strong>创建进度条</strong></p><p>Progress 模块可以用来在终端创建进度条效果，通过 <code>npm install progress</code> 安装。</p><p>下面示例创建一个 10 级的进度条，每 100 ms 进一格，完成后取消定时器：</p><pre><code>const ProgressBar = require('progress')

const bar = new ProgressBar(':bar', { total: 10 })
const timer = setInterval(() =&gt; {
    bar.tick();
    if (bar.complete) {
        clearInterval(timer);
    }
}, 100);</code></pre><p>每调用一次 <code>bar.tick()</code> 就会前进一格，可以在程序中添加进度条来提示进度。</p><h3>命令行输入</h3><p>下面介绍如何在命令行下进行输入输出交互。</p><p>node.js 从 version 7 开始提供了 <strong>readline</strong> module 可以在程序运行期间获取一个可读取的 stream 流的数据，如 <strong>process.stdin</strong> stream，一次读取一行数据。</p><p>请看下面示例：</p><pre><code>const readline = require('readline').createInterface({
    input: process.stdin,
    output: process.stdout
});

readline.question(&quot;what is your name\n&quot;, name =&gt; {
    console.log(`Hi, ${name}`);
    readline.close();
});

//output:
//what is your name
//marco
//Hi, marco</code></pre><p><strong>question()</strong> method 显示第一个参数数据到命令行，然后等待用户输入数据，当用户输入数据并敲回车后会自动调用定义的 function，并将输入数据作为传入数据。</p><p>readline 的更多用法参考：<a href="https://nodejs.org/api/readline.html">https://nodejs.org/api/readline.html</a></p><p>但需要输入一个密码时，我们希望在输入时可以隐藏输入的信息，我们可以通过 <strong>Inquirer.js</strong> 模块来实现需求。</p><p><strong>Inquirer.js</strong> 项目地址：<a href="https://github.com/SBoudrias/Inquirer.js">https://github.com/SBoudrias/Inquirer.js</a></p><p>通过 npm 安装：</p><pre><code>npm install inquirer
</code></pre><p><strong>inquirer</strong> 可以实现很多输入交互方式，如：常规输入，密码，列表，选项框等，下面举例说明：</p><pre><code>const inquirer = require('inquirer')

var questions = [
    {
        type: 'input',
        name: 'name',
        message: 'what is your name\n',
        default: function () {
            return 'Doe';
        }
    },
    {
        type: 'input',
        name: 'age',
        message: 'how old are you?\n'
    },
    {
        type: 'input',
        name: 'phone number',
        message: 'please input your phone number\n',
        validate: function (value) {
            var pass = value.match(
              /^1[3|4|5|6|7|8|9][0-9]{9}$/
            );
            if (pass)
              return true;
            else
                return 'Please enter a valid phone number';
        }
    },
    {
        type: 'password',
        name: 'password',
        message: 'your password\n'
    }
];

inquirer.prompt(questions)
.then(answers =&gt; {
    console.log(`Hi, ${answers['name']}, you age is ${answers['age']}, your phone number is ${answers['phone number']}`);
});</code></pre><p><strong>questions</strong> 数组定义了需要输入的内容，可以定义多项输入信息，每个输入内容都是一个独立的 question object 用来定义这个 question 具体的模式，下面介绍最常用的几个 properties：</p><ul><li>type 提示框的类型，默认为 input，可选项有: input, number, confirm, list, rawlist, expand, checkbox, password, editor</li><li>name 定义了此 question 的名称，用来在 answers 中读取数据时使用</li><li>message 定义一个打印输出的字符串提示信息</li><li>default 如果没有输入内容，则使用此处定义的默认值，可以是变量或 function</li><li>validate 用来判断输入信息是否满足一定条件，如果满足则返回 true，不满足返回预定一个提示信息并停留在当前 question 等待用户修改输入内容</li></ul><p>更多使用 question object 的属性参考：<a href="https://github.com/SBoudrias/Inquirer.js#question">https://github.com/SBoudrias/Inquirer.js#question</a></p><p>在上面的示例中，通过 <strong>validate</strong> function 判断电话号码是否有效，通过 <strong>string</strong> 的 <strong>match</strong> method 使用正则表达式来匹配信息。<strong>match</strong> method 语法如下：</p><pre><code>string.match(regexp)
</code></pre><p>注意 regexp 是一个字符串，需要使用斜杠<code>/</code>来包围，如：</p><pre><code>var str = &quot;abcdefab&quot;;
if (str.match(/ab/))
    console.log(true);
else
    console.log(false);

//output:
//true</code></pre><p>还可以使用修饰符来设置正则匹配限制，可用的修饰符有 <code>g</code> 和 <code>i</code>，放在正则表达式结尾斜杠<code>/</code>后面。</p><p><code>g</code> 修饰符表示 global 全局查找，当使用 g 时，所有匹配结果将会返回，当不使用 g 时，只有第一个匹配的结果会返回，且包含其 groups，index 等信息：</p><pre><code>var str = &quot;abcdefab&quot;;
console.log(str.match(/ab/));
console.log(str.match(/ab/g));

//OUTPUT:
//[ 'ab', index: 0, input: 'abcdefab', groups: undefined ]
//[ 'ab', 'ab' ]</code></pre><p><code>i</code> 修饰符用来设置忽略大小写：</p><pre><code>var str = &quot;abcdefabAB&quot;;
console.log(str.match(/ab/g));
console.log(str.match(/ab/gi));

//OUTPUT:
//[ 'ab', 'ab' ]
//[ 'ab', 'ab', 'AB' ]</code></pre><p>当 <strong>question</strong> object 的 <strong>type</strong> 定义为 <strong>password</strong> 类型时，输入时信息会被隐藏。</p><p><strong>prompt</strong> method 用来显示提示框，传入参数就是预定义的 question 数组，其返回值为 <strong>promise</strong> 类型，所以可以通过 <strong>then</strong> method 来实现异步响应。promise 的用法参考：<a href="https://blog.niekun.net/archives/2011.html">https://blog.niekun.net/archives/2011.html</a></p><p>这里通过 <strong>then</strong> method 定义了 success 的 function，传入参数就是用户输入的数据构成的 object，通过 <strong>question</strong> object 中 <strong>name</strong> property 定义的名称来索引到具体的某个输入数据。</p><p>更多 inquirer 示例：<a href="https://github.com/SBoudrias/Inquirer.js/tree/master/packages/inquirer/examples">https://github.com/SBoudrias/Inquirer.js/tree/master/packages/inquirer/examples</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2051.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/2051.html</wfw:commentRss>
</item>
<item>
<title>node.js 入门教程之一 -- 介绍</title>
<link>https://blog.niekun.net/archives/2043.html</link>
<guid>https://blog.niekun.net/archives/2043.html</guid>
<pubDate>Fri, 08 Jan 2021 09:28:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[Node.js 是一个开源跨平台的 JavaScript 运行环境，它是时下最流行的工具，能够应用于几乎所有的项目。Node.js 运行 V8 JavaScript engine。它是 chro...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>Node.js 是一个开源跨平台的 JavaScript 运行环境，它是时下最流行的工具，能够应用于几乎所有的项目。Node.js 运行 V8 JavaScript engine。它是 chrome 的核心，这让 Node.js 可以脱离浏览器运行 JavaScript 代码。</p><p>一个 Node.js app 运行在一个线程中，不会给每个 request 建立一个进程。Node.js 在其标准库中提供了一个 asynchronous I/O primitives 异步 IO 原生语法库来防止阻塞，同时 Node.js 中的库使用一种 non-blocking paradigms 无阻塞范式，将阻塞作为一种 exception 来处理。</p><p>当 Node.js 执行 IO 动作，例如读取文件，访问数据库等，不同于等待进程，占用 CPU 资源，Node.js 会在收到 request 响应后再去处理后续操作。这将使 Node.js 可以在一个 server 上同时处理上千条链接而不会引入大量的进程而导致 bug 出现。</p><p>Node.js 的另一大优势是使用 JavaScript 的前端开发者可以同时编写 server 端的代码而不用学习新的语言。</p><p>最新的 ECMAScript 标准可以在 Node.js 中使用，你不需要等待用户去更新浏览器。通过使用不同版本的 Node.js 来切换不同的 ECMAScript 标准。</p><!--more--><p>Node.js 使用 JavaScript 语言，如果你还不太了解 js 可以参考我之前的 8 篇 JavaScript 教程：<a href="https://blog.niekun.net/archives/1979.html">JavaScript 入门教程之一 -- 总览</a></p><h3>海量的第三方库</h3><p>通过 <strong>npm</strong> 简单的结构帮助 Node.js 生态系统快速的增长。目前 <strong>npm</strong> 注册超过 1,000,000 个开源库可供免费使用。</p><h3>hello world</h3><p>web server 是最常见的 hello world 示例。</p><p>新建一个 js 文件，内容如下：</p><pre><code>const http = require('http')

const hostname = '127.0.0.1'
const port = 8080

const server = http.createServer((req, res) =&gt; {
  res.statusCode = 200
  res.setHeader('Content-Type', 'text/plain')
  res.end('Hello World!\n')
})

server.listen(port, hostname, () =&gt; {
  console.log(`Server running at http://${hostname}:${port}/`)
})</code></pre><p>以上代码首先引入 <strong>http</strong> 模块。Node.js 使用 CommonJS module 系统，使用内建的 <strong>require</strong> 关键词来引入其他文件写好的 module 模块。</p><p>Node.js 有一个很好的标准库：<a href="https://nodejs.org/api/">https://nodejs.org/api/</a>，包含有对 network 的直接支持。</p><p><strong>createServer</strong> method 创建一个新的 http server 并返回它。定义了一个 <strong>requestListener</strong> function，会被自动添加到 <strong>request</strong> event。</p><p><strong>listen</strong> method 定义特定的监听地址和端口。当 server 运行起来后， <strong>listen</strong> method 调用的 function 会被执行，这里我们显示 server 已启动的信息。</p><p>当收到一个 request，会自动调用 <strong>request</strong> event，并传入两个 object：一个 <strong>request</strong> (an http.IncomingMessage object) 和一个 <strong>response</strong> (an http.ServerResponse object)。</p><p>这两个 object 是处理 http 访问的核心。</p><p><strong>request</strong> object 提供了 request 请求的信息，在以上示例中没有使用到这个，但是我们可读取 request header 和 data 数据。</p><p><strong>response</strong> object 用来返回数据给发起请求者，在这里通过：</p><pre><code>res.statusCode = 200
</code></pre><p>返回一个 200 状态码，表示一次成功的响应。</p><p>然后我们设置一个 header：</p><pre><code>res.setHeader('Content-Type', 'text/plain')
</code></pre><p>最后我们关闭 response 响应，并将响应内容作为 <strong>end</strong> method 的参数传入：</p><pre><code>res.end('Hello World\n')
</code></pre><h3>Node.js Frameworks and Tools</h3><p>Node.js 是一个底层平台，为了让开发更加容易，海量的基于 Node.js 的第三方库通过社区建立。它们中的很多已经非常流行，以下是一些常见的第三方库：</p><ul><li><strong>AdonisJs</strong>: A full-stack framework highly focused on developer ergonomics, stability, and confidence. Adonis is one of the fastest Node.js web frameworks.</li><li><strong>Express</strong>: It provides one of the most simple yet powerful ways to create a web server. Its minimalist approach, unopinionated, focused on the core features of a server, is key to its success.</li><li><strong>Fastify</strong>: A web framework highly focused on providing the best developer experience with the least overhead and a powerful plugin architecture. Fastify is one of the fastest Node.js web frameworks.</li><li><strong>Gatsby</strong>: A React-based, GraphQL powered, static site generator with a very rich ecosystem of plugins and starters.</li><li><strong>hapi</strong>: A rich framework for building applications and services that enables developers to focus on writing reusable application logic instead of spending time building infrastructure.</li><li><strong>koa</strong>: It is built by the same team behind Express, aims to be even simpler and smaller, building on top of years of knowledge. The new project born out of the need to create incompatible changes without disrupting the existing community.</li><li><strong>Loopback.io</strong>: Makes it easy to build modern applications that require complex integrations.</li><li><strong>Meteor</strong>: An incredibly powerful full-stack framework, powering you with an isomorphic approach to building apps with JavaScript, sharing code on the client and the server. Once an off-the-shelf tool that provided everything, now integrates with frontend libs React, Vue, and Angular. Can be used to create mobile apps as well.</li><li><strong>Micro</strong>: It provides a very lightweight server to create asynchronous HTTP microservices.</li><li><strong>NestJS</strong>: A TypeScript based progressive Node.js framework for building enterprise-grade efficient, reliable and scalable server-side applications.</li><li><strong>Next.js</strong>: React framework that gives you the best developer experience with all the features you need for production: hybrid static & server rendering, TypeScript support, smart bundling, route pre-fetching, and more.</li><li><strong>Nx</strong>: A toolkit for full-stack monorepo development using NestJS, Express, React, Angular, and more! Nx helps scale your development from one team building one application to many teams collaborating on multiple applications!</li><li><strong>Sapper</strong>: Sapper is a framework for building web applications of all sizes, with a beautiful development experience and flexible filesystem-based routing. Offers SSR and more!</li><li><strong>Socket.io</strong>: A real-time communication engine to build network applications.</li><li><strong>Strapi</strong>: Strapi is a flexible, open-source Headless CMS that gives developers the freedom to choose their favorite tools and frameworks while also allowing editors to easily manage and distribute their content. By making the admin panel and API extensible through a plugin system, Strapi enables the world's largest companies to accelerate content delivery while building beautiful digital experiences.</li></ul><h3>安装</h3><p>在官方下载页面下载对应系统的安装包：<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a></p><p>macOS 可以通过 brew 来安装：</p><pre><code>brew install node
</code></pre><h3>node.js 和浏览器端的区别</h3><p>浏览器端和 node.js 都是使用 JavaScript 作为编程语言，但他们是完全不同的。</p><p>node.js 可以同时开发前端和后端 application，这样使用一种语言就可以完成所有的开发。</p><p>浏览器中使用 DOM 结构，或者其他 web 平台的 API 如：cookies，这些在 node.js 中都是没有的，<strong>document</strong> 或 <strong>window</strong> 等这些 object 是没有的。</p><p>使用 node.js 由你来控制 environment，你知道 application 所使用的 node.js 是哪个版本的，相比较于浏览器，你并不知道用户使用了什么浏览器。所以你可以使用更加现代的 ES 标准来编写程序。</p><p>另一个区别是 node.js 使用 <strong>CommonJS</strong> 模块系统，浏览器端我们已经可以使用 ES 的标准命令来导入模块了。也就是说 node.js 中使用 <strong>require()</strong> 而浏览器端使用 <strong>import</strong>。</p><h3>参考链接</h3><p><a href="https://nodejs.dev/learn/introduction-to-nodejs">https://nodejs.dev/learn/introduction-to-nodejs</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2043.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/2043.html</wfw:commentRss>
</item>
<item>
<title>JavaScript 入门教程之八 -- ES6</title>
<link>https://blog.niekun.net/archives/2011.html</link>
<guid>https://blog.niekun.net/archives/2011.html</guid>
<pubDate>Mon, 21 Dec 2020 22:13:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[ECMAScript (ES) 就是标准 JavaScript 的脚本语言规范。它的第 6 个版本，开始被叫做 ECMAScript 6 (ES6) 然后改名为 ECMAScript 2015，...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p><strong>ECMAScript</strong> (ES) 就是标准 JavaScript 的脚本语言规范。</p><p>它的第 6 个版本，开始被叫做 ECMAScript 6 (ES6) 然后改名为 ECMAScript 2015，为编写更加复杂的程序添加了很重要的新语法。包括了：classes and modules, iterators and for/of loops, generators, arrow functions, binary data, typed arrays, collections (maps, sets and weak maps), promises, number and math enhancements, reflection, and proxies。</p><p>ES6 是 ES5 的超集，ES6 现在非常流行，原因就是它引入了新的约定和 OOP 的概念，如：<strong>classes</strong>。下面我们介绍一些 ES6 中最核心的一些特性。</p><p>需要注意的是只有浏览器支持 ES6 的情况下才能够执行 ES6 指令，否则会报错。</p><!--more--><h3>var & let</h3><p>ES6 中有三种方式定义变量：</p><pre><code>var a = 10;
const b = &quot;test&quot;;
let c = true;</code></pre><p>使用那种类型来申明变量取决于变量需要使用的 <strong>scope</strong> 范围。<strong>scope</strong> 是所有编程语言的基本概念，它定义了变量的可见范围。</p><p><code>var</code> 关键词定义的变量是全局有效的，或者在整个 function 内有效，而与具体在那个代码块内定义它无关。</p><p><code>let</code> 可以定义一个变量在某个特定 scope 内有效，如一个代码块或一个表达式内。</p><p>例如：</p><pre><code>if (true) {
    let age = 5;
}
alert(age);</code></pre><p>以上代码会报错 <code>ES6.html:21 Uncaught ReferenceError: age is not defined</code>，可以打开浏览器调试窗口查看：<br><img src="https://blog.niekun.net/usr/uploads/2020/12/431690113.jpg" alt="1.jpg" title="1.jpg"></p><p>这种情况下，name 变量只能在 if 表达式内被使用，因为它使用 <code>let</code> 申明。</p><p>测试 <code>var</code> 和 <code>let</code> 的区别，我们做下面的示例：</p><pre><code>&lt;script&gt;
    function varTest() {
        var x = 1;
        if (true) {
            var x = 2;
            console.log(x); // 2
        }
        console.log(x); // 2
    }

    function letTest() {
        let x = 3;
        if (true) {
            let x = 4;
            console.log(x); // 4
        }
        console.log(x); // 3
    }
    varTest();
    letTest();
&lt;/script&gt;</code></pre><p>输出结果为：</p><pre><code>2
2
4
3</code></pre><p><code>varTest()</code> 中定义的两个 x 实际上是同一个变量。<code>letTest()</code> 中 if 表达式中的 x 和外围的 x 不是一个变量。</p><p><code>let</code> 最常使用的地方就是 for 循环中：</p><pre><code>for (let index = 0; index &lt; 3; index++) {
}</code></pre><p>index 只在 for 循环内可以被使用。</p><p><code>const</code> 变量和 <code>let</code> 变量一样都在 scope 内有效。不同点是 <code>const</code> 变量的值是不可变的，不能够被重新分配数据。</p><p>以下指令会报错：</p><pre><code>const a = 1;
a = 2;</code></pre><h3>Template Literals</h3><p><strong>Template literals</strong> 文字模板是将变量输出到字符串的一种方式，ES6 之前需要打断字符串：</p><pre><code>var name = &quot;marco&quot;;
var msg = &quot;hello&quot; + name + &quot;!&quot;;
console.log(msg);</code></pre><p>ES6 引入了一种新的方式来处理：</p><pre><code>var name = &quot;marco&quot;;
var msg = `hello ${name}!`;
console.log(msg);</code></pre><p><strong>template literals</strong> 文字模板使用 <code>`</code> 符号来代替引号 <code>&quot;</code> 或 <code>'</code>。</p><p><code>${expression}</code> 是一个占位符，可以包含任何表达式，将评估的结果返回后嵌入 <strong>template literals</strong> 文字模板中。</p><p>例如：</p><pre><code>var a = 1;
var b = 2;
var msg = `sum is ${a + b}`;
console.log(msg);</code></pre><h3>Loops and Functions in ES6</h3><p>在 JavaScript 中常用 <strong>for</strong> 循环来 iterate list 中的元素：</p><pre><code>let array = [1, 2, 3];
for (let index = 0; index &lt; array.length; index++) {
    const element = array[index];
}</code></pre><p><strong>for...in</strong> 循环可以用来 iterating 一个含有一定数量的 properties 的 object：</p><pre><code>let obj = {
    a: 1,
    b: 2,
    c: 3
};
for (let key in obj) {
    console.log(obj[key]);
}</code></pre><p>log 输出为：</p><pre><code>1
2
3</code></pre><p>注意 <code>for...in</code> loop 不能 iterate 一个 <strong>array</strong> 数组。虽然数组也是一个 object，但他的 index 索引是基于 number 数字的。基于 JavaScript engine，<code>for...in</code> 循环 iterate 某个 list 的元素的顺序是随机的，而且 iterating 索引是一个 string 字符串的，而不是 number 数字，所以当你测试对这个索引进行某些 math 数学加法运算，会发现执行的是对字符串的串联而不是数字运算。</p><p>ES6 中引入了一个 <code>for...of</code> loop 能够创建一个对 <strong>iterable object</strong> 进行 iterating 的循环，数组就是一种 iterable object，而含有 <code>name: value</code> 结构属性的 object 不属于。后面我们会介绍实际上是通过 <strong>Symbol.iterator</strong> 来索引数组类型的 object 的。</p><p>例如：</p><pre><code>let array = [1, 2, 3];
for (const iterator of array) {
    console.log(iterator);
}</code></pre><p>在每个循环中，iterator 变量都会赋值为 object 内的坐标元素。</p><p><code>for...of</code> loop 适用于其他 <code>iterable objects</code> 例如 string 字符串：</p><pre><code>for (const iterator of &quot;object&quot;) {
    console.log(iterator);
}</code></pre><p>输出结果为：</p><pre><code>o
b
j
e
c
t</code></pre><p><code>for...of</code> 同样适用于 ES6 新引入的一些集合：<strong>Map</strong>, <strong>Set</strong>, <strong>WeakMap</strong>, and <strong>WeakSet</strong>，后面我们会做介绍。</p><h3>Functions in ECMAScript 6</h3><p>ES6 之前定一个 function 的方法如下：</p><pre><code>function add(a, b) {
    let sum = a + b;
    console.log(sum);
}</code></pre><p>ES6 介绍了一种新的语法，效果和上面的示例完全一样：</p><pre><code>const add = (a, b) =&gt; {
    let sum = a + b;
    console.log(sum);
}</code></pre><p>这种写法叫做 <strong>arrow function</strong>，对于只有一个参数的简单 function 非常好用，可以省略关键词 <strong>function</strong> 和 <strong>return</strong> 甚至是大括号<code>{}</code>和小括号<code>()</code>：</p><pre><code>const greet = x =&gt; &quot;welcome&quot; + x;</code></pre><p>以上代码定义了一个 <strong>greet</strong> function，有一个参数和一个 string 返回值。</p><p>如果 function 没有参数，需要加一个小括号<code>()</code>：</p><pre><code>const x = () =&gt; alert(&quot;hi&quot;);</code></pre><p>这种语法对于 <strong>inline function</strong> 很有用。</p><p>假如有一个数组，需要对其每一个元素都执行某个 function，使用 array 的 <code>forEach</code> method 来为每个元素调用 function，传统写法如下：</p><pre><code>var arr = [1, 2 ,3 ];
arr.forEach(function(el) {
    console.log(el * 2);
});</code></pre><p>在 ES6 中，以上功能可以重写为：</p><pre><code>arr.forEach(el =&gt; {
    console.log(el * 2);
});</code></pre><p>代码是不是简化很多呢？</p><h4>Default Parameters in ES6</h4><p>之前的 function 中定义参数的默认值可以这样：</p><pre><code>function test(a, b = 2, c = 3) {
    console.log(a + b + c);
}</code></pre><p>使用 <strong>arrow function</strong> 可以这样定义：</p><pre><code>const test = (a, b = 2, c = 3) =&gt; {
    console.log(a + b + c);
}</code></pre><h3>ES6 objects</h3><p>JavaScript 中 <strong>object</strong> 内可以定义多个 variable 变量，叫做 <strong>properties</strong>。properties 定义了 function 的叫做 <strong>method</strong>，例如：</p><pre><code>var person = {
    name: &quot;marco&quot;, age: 20,
    like: &quot;basketball&quot;, height: 62,
    test: function() {
        alert(&quot;method&quot;);
    }
};</code></pre><p><strong>test</strong> 就是一个 method，ES6 引入了一种简化的语法和 properties 名称来使定义更加方便和易懂。</p><p>新的语法定义 method 不需要冒号<code>:</code> 和 <code>functon</code> 关键词：</p><pre><code>let person = {
    test() {
        alert(&quot;hi&quot;);
    }
};
person.test();</code></pre><p>当使用已知变量定义 properties 且定义名称和变量名称一样时，可以简写语法如下：</p><pre><code>let height = 160;
let weight = 60;

let man = {
    height,
    weight
};</code></pre><p>以上定义中 <strong>man</strong> object 就定义了两个 properties：<strong>height</strong>，<strong>weight</strong>，且赋值为外部调用变量的值。</p><p>当在 object 中定义了相同名称的 properties，最后一个定义的 property 将会覆盖前面的：</p><pre><code>let x = {a: 2, a: 3, a: 4};
console.log(x.a);</code></pre><p>输出结果为：4</p><p>在 ES5 中如果使用了 restrict 限制模式，定义重复名称的 properties 将会报语法错误，ES6 中<strong>取消了这个限制</strong>。</p><h4>Computed Property Names 预定义属性名</h4><p>ES6 中，可以使用 <strong>computed property name 预定义属性名</strong>。通过方括号<code>[]</code> 我们可以在 properties name 中使用一个表达式，可以进行包括串联字符串或数学运算等指令。当需要创建一个基于实际用户数据(id, email等)的特定 object 时非常有用。</p><p>示例 1：</p><pre><code>let name = &quot;marco&quot;;
let id = &quot;123&quot;;
let tel = &quot;1300000&quot;;

let user = {
    [name]: &quot;tom&quot;,
    [`user_${id}`]: `${tel}`
};
console.log(user.user_123);

//output:
//1300000</code></pre><p>示例 2：</p><pre><code>let i = 0;

let x = {
    ['foo' + ++i]: i,
    ['foo' + ++i]: i
}
console.log(x.foo1);
console.log(x.foo2);

//output:
//1
//2</code></pre><p>示例 3：</p><pre><code>var par = 'size';

var config = {
    [par]: 1,
    ['mobile' + par.charAt(0).toUpperCase() + par.slice(1)]: 2
}
console.log(config.mobileSize);

//output:
//2</code></pre><p>当需要创建基于变量的自定义 object 时，这种方法很有效。</p><p>ES6 object 新增了一个新的 method：<code>assign()</code> 可以用来将多个 source 源结合起来创建一个新 object。<code>assign()</code> 也可以用来创建一个已知 object 的副本。</p><p>请看下面示例：</p><pre><code>let user1 = {
    name: 'marco',
    age: 20,
    sex: 'male'
}

let user2 = {
    name: 'jim',
    age: 18,
    tel: '12345'
}

let newUser = Object.assign({}, user1, user2);
console.log(newUser.name);
console.log(newUser.tel);

//output:
//jim
//12345</code></pre><p><code>Object.assign()</code> 的第一个参数表示需要添加新 properties 的目标 object，第一个参数后的所有参数都会被作为 source 源，源参数的数量没有限制，可以任意多个。</p><p>但是源参数的顺序很重要，因为前面的源 properties 将会被后面的有着同样属性 name 的源 properties 覆盖。例如上面示例中，user1 的 name 和 age properties 会被 user2 的同样名称的 properties 覆盖。</p><p>以上示例，我们使用<code>{}</code> 作为目标 object，使用两个 object 作为源。</p><p>下面我们介绍如何使用 <code>assign()</code> 创建一个 object 复制，新 object 不和原 object 产生关联。</p><p>在下面的示例中，我们使用简单的 assignment <code>=</code> 来创建新 object，但是这种方式会在 object 和原 object 间产生 reference 关联。对新 object 的修改会影响到原 object：</p><pre><code>let person = {
    name: 'marco',
    age: 20
};

let newPerson = person;
newPerson.name = &quot;tom&quot;;
console.log(newPerson.name);
console.log(person.name);

//output:
//tom
//tom</code></pre><p>可以看到 修改 <strong>newPerson</strong> 的 <strong>name</strong> 属性也会同时影响到 <strong>person</strong> 的 <strong>name</strong> 属性。</p><p>为了避免这种情况，可以使用 <code>Object.assign()</code> 来新建 object：</p><pre><code>let person = {
    name: 'marco',
    age: 20
};

let newPerson = Object.assign({}, person);
newPerson.name = 'tom';
console.log(newPerson.name);
console.log(person.name);

//output:
//tom
//marco</code></pre><p>我们也可以在 <code>assign()</code> 中直接给 properties 赋值：</p><pre><code>let person = {
    name: 'marco',
    age: 20
};

let newPerson = Object.assign({}, person, {name: 'john'});
console.log(newPerson.name);
console.log(person.name);

//output:
//john
//marco</code></pre><p>以上就是 ES6 中 object 的新语法介绍。</p><h3>Array Destructuring in ES6 数组拆解</h3><p><strong>destructuring assignment</strong> 拆解赋值语法能够实现将一个 array 的 values 拆分，或者将一个 object 的 properties 拆解为独立的个体。</p><h4>Destructuring array</h4><p>ES6中引入的快捷语法来拆解 <strong>array</strong> 数组，下面的示例介绍如何将数组元素拆解为独立个体：</p><pre><code>let arr = [1, 2, 3];
let [a, b, c] = arr;

console.log(a);
console.log(b);
console.log(c);</code></pre><p>也可以拆分一个 function 返回的数组：</p><pre><code>let a = () =&gt; {
    return [1, 2, 3]
};

let [a, , c] = a();</code></pre><p>注意上面示例中，第二个参数留空了，表示 a 赋值数组第一个元素，c 赋值数组第三个元素。</p><p>以上 function 使用了 ES6 的简写语法，参考上一节的介绍。</p><p><strong>destructuring</strong> 拆分语法同样能够简化赋值和交换数据：</p><pre><code>let a, b, c = 3, d = 4;

[a, b = 2] = [1]; //a=1, b=2
[c, d] = [d, c]; //c=d, d=c

console.log(a);
console.log(b);
console.log(c);
console.log(d);

//output:
//1
//2
//4
//3</code></pre><p>以上的语法再一些使用场景中能够很大简化代码量，使程序更加简洁。</p><h4>Destructuring object</h4><p>类似于拆解数组，也可以拆解 object 的 properties 为单独个体：</p><pre><code>let obj = {h: 1, s: 2};
let {h, s} = obj;

console.log(h);
console.log(s);</code></pre><p>注意定义的新变量名需要和 object property 名称一致，否则新变量的值为：<strong>undefined</strong>。</p><p>也可以不声明新变量而直接赋值，但有语法要求。需要加小括号<code>()</code>：</p><pre><code>let obj = {h: 1, s: 2};
let h, s;
({h, s} = obj);</code></pre><p>拆解时可以给 <strong>object</strong> 的 properties 定义新的名称，使用: <strong>name: newname</strong> 形式：</p><pre><code>let obj = {h: 1, s: 2};
let {h: a, s: b} = obj;

console.log(a);
console.log(b);</code></pre><p>这时候如果执行：<code>console.log(h);</code> 会报错。</p><p>最后，我们可以给新变量设置初值，如果 object 中没有定义这个属性，新变量就会使用初值：</p><pre><code>let user = {name: &quot;marco&quot;, id: 123};
let {name = &quot;tom&quot;, age = 20} = user;
console.log(name);
console.log(age);

//output:
//marco
//20</code></pre><p>以上示例中，<strong>user</strong> object 含有 name 属性，则赋值为对应数据，没有 age 属性则会使用默认值作为新变量的数据。</p><h3>ES6 Rest Parameters</h3><p>在 ES6 之前，如果调用 function 时传入的参数数量是变化的，我们可以使用 arguments array object 来访问这些传入数据。下面示例中，我们创建一个 function 来检查传入参数值是否都在一个给定数组内：</p><pre><code>function containsAll(arr) {
    for (let index = 1; index &lt; arguments.length; index++) {
        let num = arguments[index];
        if (arr.indexOf(num) == -1) {
            return false;
        }
    }
    return true;
}

let x = [2, 4, 6, 8];
console.log(containsAll(x, 2, 4));
console.log(containsAll(x, 3, 4, 6));

//output:
//true
//false</code></pre><p>可以看到 function 预定义的参数只有一个，我们在调用时传入了大于 1 个的参数，这时候在 function 内就需要使用 <strong>arguments</strong> 数组来索引传入数据。arguments[0] 代表第一个参数，也就是预定义的 arr 参数，其他数据在 <strong>arguments</strong> 数组中往后依次排列。</p><p>我们使用了 <strong>array</strong> 的 <strong>indexOf</strong> method 来获取某个数据在数组中的 position 位置，如果数组中不存在这个数据，则返回 <code>-1</code>，这里我们使用了 <code>===</code> identity operator 来确保数据类型和数值都要匹配上。</p><p>我们可以给 <strong>function</strong> 传入任意数量的数据，然后使用 <strong>arguments</strong> 数组来访问它们。</p><p>ES6 中通过使用 <strong>rest parameter</strong> <strong>剩余参数</strong>创建了一种更加简洁的语法，来访问变化的传入参数数据：</p><pre><code>function containsAll(arr, ...nums) {
    for (const iterator of nums) {
        if (arr.indexOf(iterator) == -1) {
            return false;
        }
    }
    return true;
}</code></pre><p><strong>...nums</strong> 叫做 <strong>rest parameter</strong> <strong>剩余参数</strong>，它包含了所有 <strong>extra</strong> 附加的传入参数，<code>...</code> 叫做 <strong>Spread operator</strong> 延伸符。</p><p>只有后面的传入参数才可能被标记为 <strong>rest parameter</strong>，如果调用时没有 extra 附加的传入参数，则 <strong>rest parameter</strong> 的值将会是一个空数组<code>[]</code>，而不是 <strong>undefined</strong>。</p><h3>Spread Operator 延伸符</h3><p><strong>Spread Operator</strong> 延伸符类似于 <strong>Rest Parameter</strong>，但它在应用于 <strong>object</strong>，<strong>array</strong> 或 <strong>function</strong> 时有其他功能。</p><p><strong>function</strong></p><p>在 ES6之前，我们可以通过 <code>apply()</code> method 来实现调用 function 时使用数组作为传入参数：</p><pre><code>function test(a, b, c) {
    console.log(a + b + c);
}
var arr = [1, 2, 3];
test.apply(null, arr);

//output:
//6</code></pre><p>通过 function 的 <code>apply()</code> method，可以将 <strong>method</strong> 应用于其他外部 object 上，同时用一个数组传入 function 参数。具体参考：<a href="https://blog.niekun.net/archives/1992.html">JavaScript 入门教程之四 -- Functions</a></p><p>ES6 使用 <strong>Spread Operator</strong> 实现更加简单的语法来实现上面的功能：</p><pre><code>const test = (a, b, c, d) =&gt; {
    console.log(a + b + c + d);
}
var arr = [1, 2, 3];
test(...arr, 4);

//output:
//10</code></pre><p>以上示例中，我们使用了 <code>...</code> 延伸符来将数组数据作为传入参数。因为数组只有 3 个数据，所以我们后面又附加了一个传入参数。</p><p>也可以应用于 constructor function：</p><pre><code>let date = [2020, 11, 1];
let x = new Date(...date);
console.log(x.getFullYear());</code></pre><p><strong>array</strong></p><p>ES6 之前，我们使用下面方法给数组中插入元素：</p><pre><code>var arr = [&quot;one&quot;, &quot;two&quot;, &quot;five&quot;];
arr.splice(2, 0, &quot;three&quot;, &quot;four&quot;);
console.log(arr[3]);</code></pre><p><code>splice</code> method 用来给数组中某个位置插入数据，第一个参数是行号，第二个参数是列号，后面的参数是要插入的元素，可以是任意多个。</p><p>ES6 中，可以这样写：</p><pre><code>let newArr = [&quot;three&quot;, &quot;four&quot;];
let arr = [&quot;one&quot;, &quot;two&quot;, ...newArr, &quot;five&quot;];</code></pre><p>因为数组的标准创建方法是：</p><pre><code>let arr = new Array(a, b, c);
</code></pre><p>所以为了将传递参数放在数组中，我们就可以使用 <code>...</code><strong>延伸符</strong>来处理：</p><pre><code>let arr = new Array(...newArr);
//or
let arr = [...newArr];</code></pre><p><strong>object literals</strong></p><p>在 object 中使用 <strong>Spread Operator</strong> 可以复制所有的 properties 到新的 object：</p><pre><code>const obj1 = {
    a: 1,
    b: 2
}
const obj2 = {
    c: 3,
    d: 4
}

const obj3 = {...obj1, ...obj2};
console.log(obj3.a);
console.log(obj3.d);

//output:
//1
//4</code></pre><p>使用前面提到的 <code>Object.assign()</code> method 也可以实现复制 object。</p><p><strong>注意</strong>，如果通过下面的方法想要合并两个 object 会得到不一样的结果：</p><pre><code>const merge = (...objs) =&gt; ({...objs});

let newObj = merge(obj1, obj2);
console.log(newOb);

//output:
//{0: {a: 1, b: 2}
   1: {c: 3, d: 4}}</code></pre><p>它会将每个 object 作为一个 property 的值。</p><h3>Classes in ES6</h3><p>这一节我们将介绍如何创建 <strong>class</strong> 来创建同样结构的不同 object。</p><p>使用关键词 <strong>class</strong> 来创建 class，包含一个 <strong>constructor</strong> method 来初始化参数。这个结构和 c++ 的 class 定义方法很类似。</p><p>下面是一个示例：</p><pre><code>class Test {
    constructor(a, b) {
        this.a = a;
        this.b = b;
    }
}</code></pre><p><strong>class</strong> 名称的首字母习惯用大写字符。声明好的 <strong>class</strong> 可以使用 <strong>new</strong> 关键词来创建 <strong>object</strong>：</p><pre><code>const x = new Test(1, 2);
const y = new Test(3, 4);
console.log(x.a);

//output:
//1</code></pre><p>在使用 class 前<strong>必须先定义它</strong>，如果把定义放在调用后面，则会报错：ReferenceError。</p><p>也可以在表达式中直接定义 class，可以有 class 名称，也可以不写：</p><pre><code>const x = class Test {
    constructor(a, b) {
        this.a = a;
        this.b = b;
    }
};

const y = class {
    constructor(a, b) {
        this.a = a;
        this.b = b;
    }
};</code></pre><p><strong>constructor</strong> 是 class 来初始化 object 时的特殊 method，每个 class 只能够一个 <strong>constructor</strong>。</p><p>ES6 引入了一种简写语法，可以在定义 method 时省略 <strong>function</strong> 关键词。class 中定义的 method 叫做 <strong>prototype method</strong>，object 中可以调用对应 class 中的 method。</p><p>请看下面示例：</p><pre><code>class Test {
    constructor(a, b) {
        this.a = a;
        this.b = b;
    }
    get sum() {
        return this.calcSum();
    }
    calcSum() {
        return this.a + this.b;
    }
}

const x = new Test(1, 2);
console.log(x.sum);
console.log(x.calcSum());

//output:
//3
//3</code></pre><p>以上代码中，<code>sum</code> 叫做 getter 获取器，<code>calcSum</code> 是 method。getter function 使用关键词 <strong>get</strong> 定义，必须有 return 返回值，调用时不需要写小括号<code>()</code>，类似于 property 的调用。</p><p><strong>static method</strong> 是另一种特殊 method，这种 method 不能在实例化的 object 中调用，只能被 class 本身调用，使用关键词 <strong>static</strong> 定义：</p><pre><code>class Test {
    constructor(a, b) {
        this.a = a;
        this.b = b;
    }
    static distance(x, y) {
        const dx = x.a - y.a;
        const dy = x.b - y.b;
        return Math.hypot(dx, dy);
    }
}

const x = new Test(1, 2);
const y = new Test(3, 4);
let z = Test.distance(y, x);
console.log(z);</code></pre><p>以上示例中可以看到，<strong>distance</strong> method 直接使用 <strong>Test</strong> class 调用，而不是 object。<strong>Static methods</strong> 常用于在一个 application 中创建功能性 function。</p><p><strong>extends</strong> 关键词用来创建一个 class 的 child class。child class 继承了 parent class 的所有 properties 和 methods。</p><p>示例：</p><pre><code>class Animal {
    constructor(name) {
        this.name = name;
    }
    speak() {
        console.log(`${this.name} makes a noise.`);
    }
}

class Dog extends Animal {
    speak() {
        console.log(`${this.name} barks.`)
    }
}

let dog = new Dog('tom');
dog.speak();

//output:
//tom barks.</code></pre><p>上面示例中，<strong>Dog</strong> class 是 <strong>Animal</strong> class 的 child class，继承了 Animal 的所有 properties 和 method。child class 也可以 overwrite 重写 parent class 的 method。</p><p>当 child class 也有 constructor 时，需要首先调用 <code>super()</code> 来初始化 parent class，然后才能使用 <strong>this</strong> 关键词。初始化参数要考虑 parent class 需要的参数：</p><pre><code>class Dog extends Animal {
    constructor(name, age) {
        super(name);
        this.age = age;
    }
    speak() {
        console.log(`${this.name} barks.`)
    }
}</code></pre><p>同样的，使用 <strong>super</strong> 关键词可以调用 <strong>parent</strong> 的 method，这在 <strong>child</strong> class 重写了某个 method 时可以使用这个方法调用 <strong>parent</strong> 原始的 method，下面是修改后的完整示例：</p><pre><code>class Animal {
    constructor(name) {
        this.name = name;
    }
    speak() {
        console.log(`${this.name} makes a noise.`);
    }
}

class Dog extends Animal {
    constructor(name, age) {
        super(name);
        this.age = age;
    }
    speak() {
        super.speak();
        console.log(`${this.name} barks.`)
    }
}

let dog = new Dog('tom', 10);
dog.speak();
console.log(dog.age);

//output:
//tom makes a noise.
//tom barks.
//10</code></pre><p><code>super.speak()</code> 调用了 <strong>parent</strong> class 的 method。</p><h3>ES6 Map</h3><p><strong>Map</strong> object 可以存储 <strong>key/value</strong> pairs 配对数据组。一个 key 或 value 可以是任何数据类型，例如 string，number，object，源数据等任何数据。</p><p>使用 <code>new Map([iterable])</code> 来创建 Map object，<strong>iterable</strong> 可以是任何可以 iterable 的数据，但每个元素都需要是由 key/value 两个构成的 pairs 数组。可以看到 Map 和 object 和相似，Map 的单个元素和 object 的 property 结构类似。但使用 Map 由如下优点：</p><ul><li>key 可以是任何数据类型，包括：function，object或其他</li><li>可以获取 Map 的 size，也就是包含的元素个数</li><li>可以直接在 Map 中 iterate</li><li>添加和删除 key/value 组合时性能更强</li></ul><pre><code>let map = new Map([
    ['a', 1],
    ['b', 2]
]);
console.log(map.size);

//output:
//2</code></pre><p>以上示例定义了一个 Map object。包含两个 pairs 配对，每个配对都是一个含有 2 个元素的数组。<strong>Map</strong> 的 <strong>size</strong> property 返回包含的配对个数。</p><p><strong>Map</strong> object 可用的 method：</p><ul><li><code>set(key, value)</code> 添加一个 pairs 配对，如果指定的 key 已经存在，则会替换对应的 value。</li><li><code>get(key)</code> 获取包含指定 key 的配对的 value，如果不存在指定 key 的 pairs 配对，则返回 undefined</li><li><code>has(key)</code> 查询是否存在包含指定 key 的配对，如果存在返回 true</li><li><code>delete(key)</code> 删除包含指定 key 的配对，然后返回 true，如果不存在这个配对，则返回 false</li><li><code>clear()</code> 删除所有 Map 中的 pairs 配对</li><li><code>keys()</code> 返回一个 iterator 包含所有 pairs 配对中的 key</li><li><code>values()</code> 返回一个 iterator 包含所有 pairs 配对中的 value</li><li><code>entries()</code> 返回一个 iterator 包含所有 pairs 配对数组：[key, value]</li></ul><p>示例：</p><pre><code>let map = new Map();
map.set('a', 1).set('b', 2);

console.log(map.get('a'));
console.log(map.has('b'));

for (const iterator of map.entries()) {
    console.log(iterator[0] + &quot; : &quot; + iterator[1]);
}

//output:
//1
//true
//a : 1
//b : 2</code></pre><p>以上示例演示了部分 Map method。</p><h3>ES6 Set</h3><p><strong>Set</strong> object 可以用来存储 unique 唯一的 values，不允许有重复数据。</p><p>使用 <code>new Set([iterable])</code> 语法来创建一个 Set object，iterable 是一个数组或任何其他可以 iterate 的数据：</p><pre><code>let set = new Set([1, 3, 5, 1, 7, 5]);
console.log(set.size);

//output:
//4</code></pre><p><strong>size</strong> property 返回这个 <strong>Set</strong> object 包含数据个数。可以看到返回值为 4，这是因为重复的数据会被忽略。</p><p>可供使用的 method 如下：</p><ul><li><code>add(value)</code> 添加一个新数据到 Set</li><li><code>delete(value)</code> 删除某个数据</li><li><code>has(value)</code> 检查是否存在某个数据，如果存在则返回 true</li><li><code>clear()</code> 清空 Set</li><li><code>values()</code> 返回一个 iterator 包含所有 Set object 中的数据。</li></ul><p>示例：</p><pre><code>let set = new Set();
set.add(1).add(3).add(9).add(1);

console.log(set.has(3));
for (const iterator of set) {
    console.log(iterator);
}

//output:
//true
//1
//3
//9</code></pre><p>以上示例介绍了 Set 部分 method 的用法。</p><p><strong>Set</strong> 支持不同的数据类型，例如 <code>1</code> 和 <code>'1'</code> 是不同的数据。甚至是 <strong>NaN</strong> 和 <strong>undefined</strong> 也可以存储在 <strong>Set</strong> 中。</p><h3>ES6 Promises</h3><p><code>Promise</code> 相比较于 <code>setTimeout()</code> method 是一种更好的<strong>异步编程</strong>方法。</p><p>通常想要延时执行某个 function，可以通过 <code>setTimeout()</code> 实现：</p><pre><code>setTimeout(() =&gt; {
    console.log('second');
    setTimeout(() =&gt; {
        console.log('third');
    }, 3000);
}, 3000);
console.log('first');

//OUTPUT:
//frist
//second
//third</code></pre><p>以上示例实现：先输出 first，延时 3 秒输出 second，然后再过 3 秒后输出 third。每个 function 只执行一次，如果要循环执行，可以使用  <code>setInterval()</code> 实现。</p><p><strong>setTimeout</strong> method 可以实现异步执行动作，但是如果需要处理的任务很多，使用这种方法就会导致嵌套很复杂。</p><p>ES6 引入的 <strong>promise</strong> 可以解决这个问题，使用下面语法结构创建 <strong>promise</strong>：</p><pre><code>new Promise(function(resolve, reject) {
    if (success)
        resolve(result);
    else
        reject(Error('failure'));
});</code></pre><p>创建 <strong>Promise</strong> 需要定义一个 function 包含有两个参数，这两个参数是 method 类型的。可以在 function 中根据需要使用这两个 method。示例中 <strong>resolve</strong> 在 <strong>success</strong> 为 true 时被调用，<strong>reject</strong> 在 else 情况被调用。</p><p>那么 <strong>Promise</strong> 中需要的这两个 method 在哪里定义的呢？如果我们在程序中一个 method 返回类型为 <strong>Promise</strong> 类型，则可以调用 <code>then</code> method，有两个传入参数就是 2 个 method 的定义。</p><p>下面的示例中，定义一个返回值为 <strong>Promise</strong> 类型的 function，然后调用这个 function：</p><pre><code>const asyncTest = (work) =&gt; {
    return new Promise((resolve, reject) =&gt; {
        if (work === &quot;&quot;)
            reject(Error('nothing'));
        setTimeout(() =&gt; {
            resolve(work);
        }, 3000);
    });
};

asyncTest('second')
.then((result) =&gt; {
    console.log(result);
    return asyncTest('third');
},
(error) =&gt; console.log(error))
.then((result) =&gt; console.log(result),
(error) =&gt; console.log(error));

console.log('frist');

//OUTPUT:
//frist
//second
//third</code></pre><p>以上示例和第一个示例效果一样，首先输出 frist，3 秒后输出 second，在经过 3 秒输出 third。同样的都是三个输出都是异步进行的。</p><p>以上语法相比之前的代码使逻辑关系更加清晰，<strong>Promise</strong> object 定义了调用两个 <strong>method</strong> 的原则，通过调用 <strong>then</strong> method 定义 2 个 method 的指令，只有 <strong>Promise</strong> 类型的 object 才有 <strong>then</strong> method。所以如果要继续扩充异步动作，只需要在某个 method 中返回 <strong>promise</strong> 类型的数据，就可以继续通过 <strong>then</strong> method 定义其他动作。</p><p>以上示例中，我们通过第一个 <strong>then</strong> 定义 1 个延时触发指令，然后返回一个新的 <strong>Promise</strong> 类型 object，这样可以继续调用第二个 <strong>then</strong> 来实现其他异步动作。以此类推可以继续扩展下去。</p><h3>Iterators & Generators</h3><p><strong>Symbol.iterator</strong> 是 object 内置默认的 iterator，for...of loop 就是基于这种类型的 iterator 来处理数组 object 的。</p><p>下面的示例介绍 <strong>Symbol.iterator</strong> 和 <strong>generator functions</strong> 如何使用：</p><pre><code>let myIterableObj = {
    [Symbol.iterator]: function* () {
        yield 1;
        yield 2;
        yield 3;
    }
};
console.log([...myIterableObj])</code></pre><p>以上示例中，我们创建了一个 object 通过 <strong>Symbol.iterator</strong> 和 <strong>generator function</strong> 来定义一些 properties。</p><p>使用关键词 <strong>function</strong> 后加一个星号<code>*</code> 叫做 <strong>generator function</strong> (or gen function)。</p><p>通过下面示例介绍如何使用 <strong>generator function</strong>：</p><pre><code>function* id() {
    let index = 0;
    while (index &lt; 5) {
        yield index++;
    }
}
let x = id();
console.log(x.next().value);
console.log(x.next().value);
console.log(x.next().value);

//output:
//0
//1
//2</code></pre><p>可以看到当 <strong>generator function</strong> 返回数据后，如果条件依然满足，它就不会直接跳出 function 而是会继续执行指令直到内部指令完全执行完毕，这一过程中可以使用关键词 <strong>yield</strong> 多次返回数据。这在实现异步程序中很有用，尤其是结合 <strong>Promise</strong> 来使用。</p><p><strong>generator function</strong> 可以进行多级嵌套使用，实现更加复杂的循环逻辑。</p><p>下面的示例依然结合 <strong>Symbol.iterator</strong> 和 <strong>generator functions</strong> 使用：</p><pre><code>const arr = ['a', '1', '3', '5b', '9', 'f'];
const myObj = {
    [Symbol.iterator]: function*() {
        for (const iterator of arr) {
            yield `${iterator}`;
        }
    }
};

const all = [...myObj]
.map(i =&gt; parseInt(i, 10))
.map(Math.sqrt)
.filter(i =&gt; i &lt; 5)
.reduce((i, d) =&gt; i + d);

console.log(all);

//output:
//7.9681187850686666</code></pre><p>以上示例的过程如下：</p><ul><li>首先我们创建一个数组 arr，数组元素都是字符或字符串类型。</li><li>然后使用 <strong>Symbol.iterator</strong> 和 <strong>generator functions</strong> 的语法来创建一个 <strong>iterable object</strong>：myObj，数据使用前面定义的数组 arr。</li><li>然后创建一个新的 all 数组，数据使用第二部创建的 myObj，由于 myObj 也是 <strong>iterable objet</strong> 所以这里通过 <code>...</code> 延伸符来将 myObj 作为传入参数来创建数组 object。</li><li>然后使用数组的 <strong>map</strong> method 来将字符元素转换成 int 数字，这里会过滤掉一些不能转换的元素。</li><li>然后使用数组的 <strong>filter</strong> method 来进一步过滤元素</li><li>最后使用数字的 <strong>reduce</strong> method 来将所有元素进行计算，返回为一个数字。</li></ul><p><code>parseInt()</code> Function 可以将字符解析返回为一个数字。语法如下：</p><pre><code>parseInt(string, radix)
</code></pre><p><strong>string</strong> 是需要解析的字符，<strong>radix</strong> 定义所使用的进制系统，可定义范围为：2-36，这是一个可选项，默认为 10。如果字符的首字符不是数字，则会返回 <strong>NaN</strong>。</p><p>map，filter 和 reduce method 的用法在 <a href="https://blog.niekun.net/archives/1997.html">JavaScript 入门教程之六 -- JS内置 Objects</a> 做过介绍。</p><p>更多 array 的 method 用法参考：<a href="https://www.w3schools.com/jsref/jsref_obj_array.asp">JavaScript Array Reference</a></p><h3>Modules 模组</h3><p>将相关的代码放在一个模块里有利于代码整洁度和可操作性，ES6 之前使用一些第三方库可以实现这一功能如：RequireJS, CommonJS，ES6 现在原生支持这一特性。</p><p><strong>使用 modules 模组需要考虑的：</strong></p><ul><li>可操作性，一个模组应该是完全独立的，不依赖于其他模组</li><li>命名空间 namespacing，前面介绍了变量申明的 scope，使用 var 会在代码中全局申明，可能引起命名污染，使用模组可以创建一个私有空间来完美解决这个问题</li><li>代码复用性，我们希望一个代码段能够被不同的项目引用，使用模组可以方便了在不同项目中调用</li></ul><p>下面介绍如何创建和使用 modules，我们在项目 lib 目录下创建 math.js 文件：</p><pre><code>export const sum = (x, y) =&gt; x + y;
export let pi = 3.14;</code></pre><p>调用这个模块：</p><pre><code>&lt;script type=&quot;module&quot;&gt;
    import * as math from './lib/math.js'
    console.log(math.sum(math.pi, math.pi));
&lt;/script&gt;

//output:
//6.28</code></pre><p>我们首先创建了一个 js 文件作为 module 模组，使用 <strong>export</strong> 关键词定义的 function 和 variable 变量可以被调用这个模组的文件访问到。</p><p>然后在我们的 script 中使用 import 关键词来调用模组。注意如果 script 中调用了其他模组，需要设置是script <strong>type</strong> 类型为 <strong>module</strong>，否则浏览器会报错。</p><p>import 时我们设置了这个 module 的名称为 <strong>math</strong>，module 中的 function 或 variable 时就可以通过 math 来调用，就像 object 一样。</p><p><strong>需要注意的是</strong>，如果你是在本地开发，直接打开包含调用了 module 的 html 文件或 js 文件会报错，提示：<em>Access to Script at ' from origin 'null' has been blocked by CORS policy</em>，需要通过真实的搭建一个 web 服务器来访问这个 html 文件才能正常执行。</p><p>如果使用 chrome 可以通过插件来建立一个简单的本地 web 服务器：<a href="https://chrome.google.com/webstore/detail/web-server-for-chrome/ofhbbkphhbklhfoeikjpcbhemlocgigb/related?hl=en">Web Server for Chrome</a></p><h3>Built-in Methods 内建 methods</h3><p>ES6 引入了一些新的内建 method 使有些任务可以更轻松地执行，下面介绍最常用的几种。</p><h4>Array Element Finding 数组元素查询</h4><p>ES6 之前我们想要得到一个数组经过某个规则过滤后的第一个元素，可以通过 <strong>filter</strong> method 实现：</p><pre><code>var x = [1, 4, 6, 3, 8].filter(function(i) {
    return i &gt; 5;
})[0];

console.log(x);

//output:
//6</code></pre><p>现在我们可以使用 <strong>find</strong> method 更加简洁的语法实现相同的功能：</p><pre><code>var x = [1, 4, 6, 3, 8].find(i =&gt; i &gt; 5);
console.log(x);

//output:
//6</code></pre><p>也可以使用 <strong>findIndex</strong> method 来得到符合条件的第一个元素的索引地址：</p><pre><code>var index = [1, 4, 6, 3, 8].findIndex(i =&gt; i &gt; 5);
console.log(index);

//output:
//2</code></pre><h4>Repeating Strings 重复字符串</h4><p>ES6 之前，想要将一个字符串重复多次可以使用一下方法：</p><pre><code>console.log(Array(4).join('foo'));

//output:
//foofoofoo</code></pre><p>以上示例中，首先声明一个有 4 个元素 array 数组但没有赋初值，当前元素为 empty，然后通过 <strong>join</strong> method 给将所有元素合并为字符串，分隔符为 <strong>foo</strong>，这样我们就变相返回了一个将源字符串重复三次的新字符串。</p><p>使用 ES6 的新语法实现这个功能更加简单：</p><pre><code>console.log('foo'.repeat(3));

//output:
//foofoofoo</code></pre><p>字符串的 <strong>repeat</strong> method 的参数定义重复次数并返回新字符串。</p><h3>Searching Strings 查询字符串</h3><p>ES6 之前我们只能通过 <strong>indexOf</strong> method 来查询一个 string 中 text 的位置，如：</p><pre><code>var x = 'helloworld'.indexOf('llo') === 2;
var y = 'helloworld'.indexOf('llo', 3) === -1;
console.log(x);
console.log(y);

//output:
//true
//true</code></pre><p>关于 indexOf 的用法参考：<a href="https://blog.niekun.net/archives/1997.html">JavaScript 入门教程之六 -- JS内置 Objects</a></p><p>ES6 使用更加简洁明了的语法代替以上语法：</p><pre><code>var x = 'helloworld'.startsWith('hel', 0);
var y = 'helloworld'.endsWith('hello', 5);
var z = 'helloworld'.includes('llo');
var i = 'helloworld'.includes('llo', 3);

console.log(x);
console.log(y);
console.log(z);
console.log(i);

//output:
//true
//true
//true
//false</code></pre><p><strong>startsWith</strong> method 返回所查询的 text 的起始字符所在位置。<br><strong>endsWith</strong> method 返回所查询的 text 结束后紧跟的元素的所在位置。<br><strong>includes</strong> mehod 返回所查询的 text 的所在位置，默认从第 0 位开始，可自定义起始查询位置。</p><p>如果不存在所查询的元素，将返回 <code>-1</code>。</p><p>以上就是 ES6 中较常用的新语法，这里我推荐在实现同一功能的情况下，优先使用 ES6 新引入的语法来处理。这样可以使我们的代码更加简洁易读。</p><p><strong>经过 8 个章节的教程，我们基本涵盖了 JavaScript 的基本编程方法。后续的学习中需要继续补充完善，在实际应用中才能对 JavaScript 有进一步的认识。</strong></p>
]]></content:encoded>
<slash:comments>1</slash:comments>
<comments>https://blog.niekun.net/archives/2011.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/2011.html</wfw:commentRss>
</item>
<item>
<title>JavaScript 入门教程之七 -- DOM</title>
<link>https://blog.niekun.net/archives/2002.html</link>
<guid>https://blog.niekun.net/archives/2002.html</guid>
<pubDate>Sat, 19 Dec 2020 14:10:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[当你打开一个网页，html 页面会被加载和渲染到屏幕上。为了完成这个过程，浏览器会建立这个页面的 Document Object Model 模型。也就是一个指向页面逻辑架构的 object。一...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>当你打开一个网页，html 页面会被加载和渲染到屏幕上。为了完成这个过程，浏览器会建立这个页面的 <strong>Document Object Model</strong> 模型。也就是一个指向页面逻辑架构的 object。</p><p>一个页面的 <strong>DOM</strong> 可以被表示为一些嵌套的 boxes：<br><img src="https://blog.niekun.net/usr/uploads/2020/12/4242689357.png" alt="1.png" title="1.png"></p><p>JavaScript 能够用来操作 <strong>DOM</strong>，动态的添加、删除、修改其中的元素。</p><!--more--><h3>DOM tree</h3><p>DOM 将一个 document 表达为一个 tree structure 树形结构， html 元素称为这个 tree 上的相关联的 nodes 节点。</p><p>整个 tree 上的 nodes 之间都是互相有关联的。nodes 可以有 child node 子节点。在同一个 tree level 层级的 nodes 叫做 siblings 兄弟关系。想象下面的一个 document structure：<br><img src="https://blog.niekun.net/usr/uploads/2020/12/4196340561.png" alt="2.png" title="2.png"></p><p><strong>以上示例中的关系结构是：</strong></p><ul><li><code>&lt;html&gt;</code> 有两个 children：<code>&lt;head&gt;</code>, <code>&lt;body&gt;</code>;</li><li><code>&lt;head&gt;</code> 有一个 child：<code>&lt;title&gt;</code>，有一个 parent：<code>&lt;html&gt;</code>;</li><li><code>&lt;title&gt;</code> 有一个 parent：<code>&lt;head&gt;</code>， 没有 children;</li><li><code>&lt;body&gt;</code> 有两个 children：<code>&lt;h1&gt;</code> and <code>&lt;a&gt;</code>，有一个 parent：<code>&lt;html&gt;</code>;</li></ul><p>理解 HTML document 的元素间的关系很重要，这样我们就可以使用 JavaScript 来操纵这些元素了。</p><p><code>document</code> object 在 JavaScript 中被预定义，可以用来访问 DOM 中的所有元素。换句话说，<code>document</code> object 是页面中所有元素的拥有者。所以想要访问 html 页面中的元素，首先需要访问 <code>document</code> object。</p><p>看下面的示例：</p><pre><code>document.body.innerHTML = &quot;Some text&quot;;
</code></pre><p><code>body</code> 是 DOM 中的元素，通过 <code>document</code> 来访问到它，然后通过其 <code>innerHTML</code> property 修改其内容。</p><h3>Selecting Elements</h3><p>所有的元素都是 object，都有 properties 和 method。<code>document</code> 有能够让我们选择其内部元素的 method，常用的有三种方法：</p><pre><code>//finds element by id
document.getElementById(id) 

//finds elements by class name
document.getElementsByClassName(name) 

//finds elements by tag name
document.getElementsByTagName(name)</code></pre><p>下面的示例，我们使用 <code>getElementById</code> method 来选中一个元素，并修改其内容：</p><pre><code>var elem = document.getElementById(&quot;demo&quot;);
elem.innerHTML = &quot;hello world&quot;;</code></pre><p>注意以上示例中我们需要 html 有一个元素设置 <code>id=&quot;demo&quot;</code>，如：</p><pre><code>&lt;body&gt;
    &lt;div id=&quot;demo&quot;&gt;&lt;/div&gt;
&lt;/body&gt;</code></pre><p><code>getElementsByClassName()</code> method 会返回一个特定 calss name 的集合。例如，我们有三个含有 <code>class=&quot;demo&quot;</code> 的元素：</p><pre><code>&lt;body&gt;
    &lt;div class=&quot;demo&quot;&gt;test1&lt;/div&gt;
    &lt;div class=&quot;demo&quot;&gt;test2&lt;/div&gt;
    &lt;div class=&quot;demo&quot;&gt;test3&lt;/div&gt;
&lt;/body&gt;</code></pre><p>首先选中全部 3 个元素为一个数组，然后修改第一个元素内容：</p><pre><code>&lt;script&gt;
    var arr = document.getElementsByClassName(&quot;demo&quot;);
    arr[0].innerHTML = &quot;hi&quot;;
&lt;/script&gt;</code></pre><p>类似的方式， <code>getElementsByTagName</code> method 返回一个特定 tag 的集合。下面的示例中，将选中所有 paragraph 元素然后修改他们的内容：</p><pre><code>&lt;body&gt;
    &lt;p&gt;1&lt;/p&gt;
    &lt;p&gt;2&lt;/p&gt;
    &lt;p&gt;3&lt;/p&gt;
&lt;/body&gt;

&lt;script&gt;
    var arr = document.getElementsByTagName(&quot;p&quot;);
    for (var i = 0; i &lt; arr.length; i++) {
        arr[i].innerHTML = &quot;hi there&quot;;
    }
&lt;/script&gt;</code></pre><p>每个 DOM 中的元素都有 properties 和 method 来提供给我们关于其在 DOM 中的相互关系的信息：</p><ul><li><code>element.childNodes</code> 返回其子元素的数组</li><li><code>element.firstChild</code> 返回其第一个子元素</li><li><code>element.lastChild</code> 返回其最后一个子元素</li><li><code>element.hasChildNodes</code> 当其有子元素时返回 true，否则返回 false</li><li><code>element.nextSibling</code> 返回下一个处于同一 tree level 节点的元素</li><li><code>element.previousSibling</code> 返回上一个处于同一 tree level 节点的元素</li><li><code>element.parentNode</code> 返回其 parent 节点的元素</li></ul><h3>Changing Attributes</h3><p>当选中了想要的元素后，就可以修改其相关属性了。</p><p>我们前面使用过通过 <code>innerHTML</code> property 修改了元素的 text 内容。同样的方法，我们可以修改它的属性值，例如修改一个 image 的 <code>src</code> 属性：</p><pre><code>&lt;/body&gt;
    &lt;img id=&quot;img1&quot; src=&quot;1.jpg&quot; alt=&quot;&quot; srcset=&quot;&quot;&gt;
&lt;/body&gt;

&lt;script&gt;
    var el = document.getElementById(&quot;img1&quot;);
    el.src = &quot;2.jpg&quot;;
&lt;/script&gt;</code></pre><p>通常情况下，元素中所有的属性都可以通过 JavaScript 修改。</p><p>html 元素的 style 也可以通过 JavaScript 修改，所有的 style 属性可以通过 <code>style</code> object 来访问，例如：</p><pre><code>&lt;body&gt;
    &lt;div id=&quot;demo2&quot; style=&quot;width: 200px;&quot;&gt;some text&lt;/div&gt;
&lt;/body&gt;

&lt;script&gt;
    var x = document.getElementById(&quot;demo2&quot;);
    x.style.color = '#6600FF';
    x.style.width = '100px';
&lt;/script&gt;</code></pre><p>所有的 css properties 都可以通过 JavaScript 修改。但是要注意，JavaScript 中相关 property 时，<strong>名称中不能够使用 dash<code>-</code> 横杠</strong>，如果 css 属性名称有横杠，需要转换成 camelCase versions，也就是相关首字母转换成大写。例如：js 在调用 <code>background-color</code> property 时需要写成 <code>backgroundColor</code>。</p><h3>Adding & Removing Elements 创建和删除元素</h3><p><strong>Adding Elements</strong></p><p>使用下面的 method 来创建节点 node：</p><ul><li><code>element.cloneNode()</code> clone 一个节点并将其返回</li><li><code>document.createElement(element)</code> 创建一个新元素的节点</li><li><code>document.createTextNode(text)</code> 创建一个新的 text 节点</li></ul><p>下面简单说下元素和节点：</p><pre><code>&lt;div&gt;
    test1
    &lt;p&gt;&lt;/p&gt;
&lt;/div&gt;</code></pre><p>以上示例中，<code>div</code> 就是一个 element 元素，<code>test1</code> 就是这个元素下的 text node 节点，<code>p</code> 就是 <code>div</code> 元素下的另一个子元素节点。</p><p>例如：</p><pre><code>var node = document.createTextNode(&quot;Some new text&quot;);
</code></pre><p>将会创建一个 text 节点，但是当前它并不会出现在页面上，因为还没有定义它属于那个元素。</p><p><code>element.appendChild(newNode)</code> method 来给元素添加一个新的子节点，并放在最后。</p><p><code>element.insertBefore(node1, node2)</code> method 将添加的新直接点 node1 放在已有的子节点 node2 之前。</p><p>下面做一个示例：</p><pre><code>&lt;body&gt;
    &lt;div id=&quot;demo3&quot;&gt;test&lt;/div&gt;
&lt;/body&gt;

&lt;script&gt;
    var p = document.createElement(&quot;p&quot;);
    var node = document.createTextNode(&quot;some text&quot;);
    p.appendChild(node);

    var el = document.getElementById(&quot;demo3&quot;);
    el.appendChild(p);
&lt;/script&gt;</code></pre><p>以上出现的执行过程为：创建一个元素 <code>p</code> 和 text node <code>node</code>，然后将 node 作为 p 的子元素，最后将 p 添加到 el 中。</p><p><strong>Removing Elements</strong></p><p>想要<strong>删除一个元素</strong>，首先需要选中其 parent 元素，然后使用 <code>removeChild(node)</code> method 来删除相关子元素，例如：</p><pre><code>&lt;body&gt;
    &lt;div id=&quot;div1&quot;&gt;
        &lt;p id=&quot;p1&quot;&gt;some text one&lt;/p&gt;
        &lt;p id=&quot;p2&quot;&gt;some text two&lt;/p&gt;
    &lt;/div&gt;
&lt;/body&gt;

&lt;script&gt;
    var parent = document.getElementById(&quot;div1&quot;);
    var child = document.getElementById(&quot;p1&quot;);
    parent.removeChild(child);
&lt;/script&gt;</code></pre><p>也可以使用 <code>parentNode</code> property 来获取某个子元素的 parent 元素，然后执行相关操作：</p><pre><code>child.parentElement.removeChild(child);</code></pre><p><strong>Replacing Elements</strong></p><p>使用 <code>element.replaceChild(newNode, oldNode)</code> method 来替换一个元素。例如：</p><pre><code>&lt;script&gt;
    var newEl = document.createElement(&quot;p&quot;);
    var node = document.createTextNode(&quot;this is a new node&quot;);
    newEl.appendChild(node);

    var parent = document.getElementById(&quot;div1&quot;);
    var child = document.getElementById(&quot;p1&quot;);
    parent.replaceChild(newEl, child);
&lt;/script&gt;</code></pre><h3>Animations 动态效果</h3><p>现在我们已经知道如何选择和修改元素，下面我们可以创建一个简单的动画效果。</p><p>首先建立一个 html 页面，包含一个 box 元素，后期通过 js 来让它动起来：</p><pre><code>&lt;style&gt;
    #container {
        width: 200px;
        height: 200px;
        background: green;
        position: relative;
    }
    #box {
        width: 50px;
        height: 50px;
        background: red;
        position: absolute;
    }
&lt;/style&gt;
&lt;body&gt;
    &lt;div id=&quot;container&quot;&gt;
        &lt;div id=&quot;box&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;</code></pre><p><strong>box</strong> 元素是 <strong>container</strong> 的子元素，注意两个的 <code>position</code> attribute，container 是 <strong>relative</strong>，box 是 <strong>absolute</strong>，我们将创建一个让 box 从左移动到右的动画。</p><p>为了实现动态效果，我们需要在一个很小的时间间隔下修改元素的相关 properties，可以使用 <code>setInterval()</code> method：</p><pre><code>&lt;script&gt;
    var pos = 0;
    var box = document.getElementById(&quot;box&quot;);

    function move() {
        pos++;
        box.style.left = pos + &quot;px&quot;;
    }

    setInterval(move, 10);
&lt;/script&gt;</code></pre><p>以上指令控制 <strong>box</strong> 的 <strong>left</strong> property 每 10 毫秒移动 1 位。</p><p>但是以上的代码会让 box 元素一直向右移动，我们可以加一个简单的判断来检测 box 到达 container 边沿，然后使用  <code>clearInterval()</code> method 停止定时器：</p><pre><code>function move() {
    if (pos &gt;= 150) {
        clearInterval();
    } else {
        pos++;
        box.style.left = pos + &quot;px&quot;;
    }
}</code></pre><p>当 <strong>left</strong> 属性达到 150 时，由于 <strong>box</strong> 宽度为 50，<strong>container</strong> 宽度为 200，这时候 <strong>box</strong> 已经达到边沿。</p><h3>Handling Events 事件处理</h3><p>我们可以实现当一个 event 事件发生时执行特定 JavaScript 代码，如点击某个元素，移动鼠标，提交一个表格等。</p><p>当一个 event 发生在目标元素上时，一个 handling function 会被执行。常用的 html events 包括：<br><img src="https://blog.niekun.net/usr/uploads/2020/12/171918129.png" alt="3.png" title="3.png"></p><p>event 事件可以作为一个属性添加在元素内，如：</p><pre><code> &lt;p onclick=&quot;someFunc()&quot;&gt;some text&lt;/p&gt;
</code></pre><p>下面我们创建一个事件，当用户点击元素时弹出一个窗口：</p><pre><code>&lt;body&gt;
    &lt;button onclick=&quot;show()&quot;&gt;click me&lt;/button&gt;
&lt;/body&gt;

&lt;script&gt;
    function show() {
        alert(&quot;hello&quot;);
    }
&lt;/script&gt;</code></pre><p>event handling 事件响应也可以在 js 中直接分配给 elements：</p><pre><code>&lt;body&gt;
    &lt;div id=&quot;demo&quot;&gt;demo&lt;/div&gt;
&lt;/body&gt;

&lt;script&gt;
    var el = document.getElementById(&quot;demo&quot;);
    el.onclick = function () {
        el.innerHTML = &quot;clicked&quot;;
    }
&lt;/script&gt;</code></pre><p><strong>onload</strong> 和 <strong>onunload</strong> events 会在用户进入和离开页面时被触发。可以用来实现当页面加载完成后执行的动作：</p><pre><code>&lt;body onload=&quot;doSomething()&quot;&gt;
</code></pre><p>类似的 <code>window.onload</code> event 可以在整个页面加载后执行动作：</p><pre><code>window.onload = function () {
    //do someting
}</code></pre><p><code>onchange</code> event 在文本框中很有用，当文本框的 text 内容被修改同时元素不在 focus 状态时 <code>onchange</code> event 响应。</p><p>例如：</p><pre><code>&lt;body&gt;
    &lt;input type=&quot;text&quot; id=&quot;name&quot; onchange=&quot;changed()&quot;&gt;
&lt;/body&gt;

&lt;script&gt;
    function changed() {
        var el = document.getElementById(&quot;name&quot;);
        el.value = el.value.toUpperCase();
    }
&lt;/script&gt;</code></pre><p>以上示例中，当我们在文本框输入字符，然后将光标移动到其他地方或者敲回车键后，文本框字符会自动转换为大写。</p><p>理解 events 很重要，因为它是实现动态页面的核心。</p><p><strong>Event Listeners</strong></p><p><code>addEventListener()</code> method 可以给一个元素添加 event handler 而不会覆盖其已有的 event handlers。可以给一个元素添加多个 event handler 甚至是统一类型的 handler，比如可以添加两个 <code>click</code> handler。</p><p>语法如下：</p><pre><code>element.addEventListener(event, function, useCapture);
</code></pre><ul><li>第一个参数是 event 类型，如："click" 或 "mousedown"，需要用引号包围</li><li>第二个参数是事件发生时调用的 function 名称，不需要写小括号<code>()</code></li><li>第三个参数时一个 Boolean 数值，定义是使用 event bubbling 还是 event capturing，这个参数是可选项，后续会介绍</li></ul><p><strong>注意这里 event 名称不需要 <code>on</code> 前缀</strong>，使用 <code>click</code> 代替 <code>onclick</code>。</p><pre><code>element.addEventListener(&quot;click&quot;, myFunction);
element.addEventListener(&quot;mouseover&quot;, myFunction);

function myFunction() {
  alert(&quot;Hello World!&quot;);
}</code></pre><p>以上代码给元素添加了两个 event handler，我们可以删除其中一个：</p><pre><code>element.removeEventListener(&quot;mouseover&quot;, myFunction);
</code></pre><p>下面的示例中，我们给 button 创建一个 event handler，然后再触发事件后删除这个 event handler：</p><pre><code>&lt;body&gt;
    &lt;button id=&quot;btn&quot;&gt;click me&lt;/button&gt;
&lt;/body&gt;

&lt;script&gt;
    var btn = document.getElementById(&quot;btn&quot;);
    btn.addEventListener(&quot;click&quot;, myFunction);

    function myFunction() {
        alert(Math.random());
        btn.removeEventListener(&quot;click&quot;, myFunction);
    }
&lt;/script&gt;</code></pre><p>当第一次点击 button 后会弹出窗口，然后删除 <code>click</code> event，后面点击会没有反应。</p><p>IE8 及以下版本的浏览器不支持 <code>addEventListener()</code> 和 <code>removeEventListener()</code> methods，可以使用 <code>document.attachEvent()</code> 来添加 event handler。</p><p><strong>Event Propagation 事件传播</strong></p><p>在 DOM 中有两种方式进行 event propagation 事件传播：<strong>bubbling</strong> 和 <strong>capturing</strong>。</p><p>当事件触发时，可以定义元素顺序。例如有一个 <code>&lt;p&gt;</code> 元素在 <code>&lt;div&gt;</code> 元素内部，当用户点击 <code>&lt;p&gt;</code> 元素时，哪个元素的 <code>click</code> event handler 首先被触发？</p><ul><li>在 <strong>bubbling</strong> 模式下，最内部元素的 event 最先响应，逐级触发外层元素；</li><li>在 <strong>capturing</strong> 模式下，最外部元素的 event 最先响应，逐级触发内层元素。</li></ul><p><code>addEventListener()</code> method 支持设置事件传播类型，定义下面的 <strong>useCapture</strong> 参数：</p><pre><code>addEventListener(event, function, useCapture)
</code></pre><p><strong>useCapture</strong> 默认值为 <strong>false</strong>，也就是 <strong>bubbling</strong> 模式，当设置为 <strong>true</strong> 时 event 使用 <strong>capturing</strong> 模式。例如：</p><pre><code>//Capturing propagation
elem1.addEventListener(&quot;click&quot;, myFunction, true); 

//Bubbling propagation
elem2.addEventListener(&quot;click&quot;, myFunction, false);</code></pre><p>当同一个 event 存在于多个 DOM 层级中的元素时，设置 event propagation 事件传播模式很有用。</p><h3>Image Slider 幻灯片</h3><p>下面我们制作一个幻灯片程序，通过 <strong>Next</strong> 和 <strong>Prev</strong> button 来切换图片。</p><p>首先创建 html，包含两个 button 和一个 image：</p><pre><code>&lt;html&gt;
&lt;body&gt;
    &lt;button&gt; Prev &lt;/button&gt;
    &lt;img id=&quot;slider&quot; src=&quot;https://blog.niekun.net/usr/uploads/2020/12/2749019084.jpg&quot;&gt;
    &lt;button&gt; Next &lt;/button&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><p>然后再 JavaScript 中定义我们的图片数组：</p><pre><code>&lt;script&gt;
    var images = [
    &quot;https://blog.niekun.net/usr/uploads/2020/12/2749019084.jpg&quot;,
    &quot;https://blog.niekun.net/usr/uploads/2020/12/1648461111.jpg&quot;,
    &quot;https://blog.niekun.net/usr/uploads/2020/12/3914156262.jpg&quot;];
&lt;/script&gt;</code></pre><p>下面需要添加响应 <strong>Next</strong> 和 <strong>Prev</strong> button 的 event handler 来切换不同图片：</p><pre><code>&lt;body&gt;
    &lt;button onclick=&quot;prev()&quot;&gt; Prev &lt;/button&gt;
    &lt;img id=&quot;slider&quot; src=&quot;https://blog.niekun.net/usr/uploads/2020/12/2749019084.jpg&quot;&gt;
    &lt;button onclick=&quot;next()&quot;&gt; Next &lt;/button&gt;
&lt;/body&gt;
&lt;script&gt;
    var images = [
    &quot;https://blog.niekun.net/usr/uploads/2020/12/2749019084.jpg&quot;,
    &quot;https://blog.niekun.net/usr/uploads/2020/12/1648461111.jpg&quot;,
    &quot;https://blog.niekun.net/usr/uploads/2020/12/3914156262.jpg&quot;];

    var num = 0;
    function next() {
        var slider = document.getElementById(&quot;slider&quot;);
        num++;
        if (num &gt;= images.length)
            num = 0;
        slider.src = images[num];
    }

    function prev() {
        var slider = document.getElementById(&quot;slider&quot;);
        num--;
        if (num &lt; 0)
            num = images.length - 1;
        slider.src = images[num];
    }
&lt;/script&gt;</code></pre><p>效果如下：<br><img src="https://blog.niekun.net/usr/uploads/2020/12/3936392311.jpg" alt="4.jpg" title="4.jpg"></p><p><strong>num</strong> 变量存储当前图片的 index 索引。</p><h3>Form Validation 表格验证</h3><p>html5 添加了一些用来验证的属性，例如 <strong>required</strong> attribute 能够添加给 <strong>input</strong> 元素来强制必须输入内容。</p><p>更加复杂的验证机制可以通过 JavaScript 完成。</p><p><strong>form</strong> 元素有一个 <strong>onsubmit</strong> event 能够用来进行验证。我们创建一个 form 表格，有两个 input 和一个 button，需要两个 input 输入一样的内容且不为空才通过验证：</p><pre><code>&lt;form onsubmit=&quot;return validate()&quot; method=&quot;post&quot;&gt;
    number: &lt;input type=&quot;text&quot; name=&quot;num1&quot; id=&quot;num1&quot;&gt;
    &lt;br&gt;
    repeat: &lt;input type=&quot;text&quot; name=&quot;num2&quot; id=&quot;num2&quot;&gt;
    &lt;br&gt;
    &lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt;
&lt;/form&gt;</code></pre><p>然后定义 <code>validate()</code> function：</p><pre><code>&lt;script&gt;
    function validate() {
        var n1 = document.getElementById(&quot;num1&quot;);
        var n2 = document.getElementById(&quot;num2&quot;);

        if (n1.value != &quot;&quot; &amp;&amp; n2.value != &quot;&quot;) {
            if (n1.value == n2.value)
                return true;
        }
        alert(&quot;the values shoud be equal and not blank&quot;);
        return false;
    }
&lt;/script&gt;</code></pre><p>只有当 <strong>onsubmit</strong> event 的返回值为 <strong>true</strong> 时，form 才会被提交。</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2002.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/2002.html</wfw:commentRss>
</item>
<item>
<title>JavaScript 入门教程之六 -- JS内置 Objects</title>
<link>https://blog.niekun.net/archives/1997.html</link>
<guid>https://blog.niekun.net/archives/1997.html</guid>
<pubDate>Fri, 18 Dec 2020 18:53:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[下面介绍一些 JavaScript 内部定义好的 obect，可以直接使用。JavaScript Arrays 数组当你需要定义三个课程名称时，需要分别定义：var course1 =&quot...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>下面介绍一些 JavaScript 内部定义好的 obect，可以直接使用。</p><h3>JavaScript Arrays 数组</h3><p>当你需要定义三个课程名称时，需要分别定义：</p><pre><code>var course1 =&quot;HTML&quot;; 
var course2 =&quot;CSS&quot;; 
var course3 =&quot;JS&quot;; </code></pre><p>当你有 100 个课程名称呢？这时候可以使用 Array：</p><pre><code>var courses = new Array(&quot;HTML&quot;, &quot;CSS&quot;, &quot;JS&quot;);</code></pre><!--more--><p>以上定义了一个数组 courses，存储了 3 个元素。</p><p>可以使用 index 索引号内访问数组元素，索引号 0 表示第一个元素：</p><pre><code>var courses = new Array(&quot;HTML&quot;, &quot;CSS&quot;, &quot;JS&quot;);
var course = courses[0];
courses[1] = &quot;c++&quot;;</code></pre><p>以上示例表示：给变量 course 赋值数组第一个元素，给第二个元素赋值 <code>c++</code>。</p><p><strong>如果尝试访问超出数组元素的索引，会返回 <code>undefined</code></strong>。</p><p>在定义数组时也可以只申明数组元素个数，后续再给元素赋值：</p><pre><code>var courses = new Array(3);
courses[0] = &quot;HTML&quot;;
courses[1] = &quot;CSS&quot;;
courses[2] = &quot;JS&quot;;</code></pre><p>array 数组是一种特殊的 object，它使用 index number 来访问元素，而标准 object 使用 property name 来访问元素，name 是字符形式。</p><p>如下是 array 和 object 的元素定义区别：</p><pre><code>var arr = {
    0: 0,
    1: 1,
    2: 2,
    3: 3
}

var obj = {
    '0': 0,
    '1': 1,
    '2': 2,
    '3': 3
}</code></pre><p>在 array 的 index 数字索引永远是按顺序排列的。所以我们访问以上示例中 arr 和 obj 元素的方式为：<code>arr[0]</code>, <code>obj['0']</code>。</p><p>JavaScript array 是动态的，也就是你可以在创建时不传入任何参数给构造器：</p><pre><code>var courses = new Array();
courses[0] = &quot;HTML&quot;;
courses[1] = &quot;CSS&quot;;
courses[2] = &quot;JS&quot;;
courses[3] = &quot;C++&quot;;</code></pre><p>你可以添加任意多个元素给数组。</p><p>为了定义更加方便，可以使用 array literal 语法来创建数组：</p><pre><code>var courses = [&quot;HTML&quot;, &quot;CSS&quot;, &quot;JS&quot;];</code></pre><p>以上语法和使用 <code>new</code> 关键词创建的数组是一样的。<strong>推荐使用这种语法</strong>。</p><p><strong>JavaScript array 内建了很多实用的 properties 和 method。</strong></p><p><strong>length</strong> property 返回数组的元素个数：</p><pre><code>var courses = [&quot;HTML&quot;, &quot;CSS&quot;, &quot;JS&quot;];
document.write(courses.length);</code></pre><p><code>length</code> 的返回值比最后一个元素的索引号大 1，如果数组为空，则返回值为 0。</p><p><strong>concat</strong> method 可以叠加两个数组并返回为一个新的数组：</p><pre><code>var c1 = [&quot;HTML&quot;, &quot;CSS&quot;, &quot;JS&quot;];
var c2 = [&quot;C++&quot;];
var newC = c1.concat(c2);</code></pre><p>newC 数组拥有四个元素："HTML", "CSS", "JS", "C++"。注意使用 <code>concat()</code> method 并不会影响 c1 和 c2。</p><p><code>map</code> method 可以给数组每个元素调用一个 function 然后返回修改后的数据为一个新数组：</p><pre><code>var arr = [1, 2, 3, 4];
var newArr = arr.map(function(i) {
    return i * 2;
})
console.log(newArr);

//output:
//0: 2
//1: 4
//2: 6
//3: 8
//length: 4</code></pre><p><code>reduce</code> Method 可以将数组元素合并为一个 value。语法为：</p><pre><code>array.reduce(function(total, currentValue))
</code></pre><p>total 为元素合并的累积值，currentValue 为当前循环处理到的元素。调用 reduce 时，第一次传入 total 为 第一个元素数据，currentValue 为数组第二个元素，function 会返回一个结果作为第二次循环 total 的数据，currentValue 指向第三个元素，然后进行循环调用 function 累积 total 的值，最后返回 total。</p><p>下面举例说明：</p><pre><code>var arr = [1, 3 ,5];
var sum = arr.reduce(function(total, curr) {
    return total + curr;
});
console.log(sum);

//output:
//9</code></pre><p><code>filter</code> method 可以逐个过滤数组的元素，返回符合条件元素创建一个新数组。语法如下：</p><pre><code>array.filter(function(currentValue))
</code></pre><p>filter 将数组元素逐个作为传入参数调用 function，function 返回值为 Boolean 类型，如果为 true 则返回当前数组元素，反之则丢弃当前数组元素。</p><p>示例如下：</p><pre><code>var arr = [1, 4, 6, 3, 8];
var newArr = arr.filter(function(i) {
    return i &lt; 5;
});

console.log(newArr);

//OUTPUT:
//0: 1
//1: 4
//2: 3
//length: 3</code></pre><p><code>join</code> method 将数组所有元素转换为一个字符串并返回这个字符串。下面是一个示例：</p><pre><code>var arr = ['a', 'b', 'c'];
var x = arr.join();
console.log(x);

//output:
//a,b,c</code></pre><p>元素间会通过一个分隔符隔开，默认是一个逗号<code>,</code>，可以通过 join 的参数自定义分隔符：</p><pre><code>var arr = ['a', 'b', 'c'];
var x = arr.join('/');
console.log(x);

//output:
//a/b/c</code></pre><p><code>indexOf</code> method 搜索一个数组中特定的元素，并返回这个元素所在 index 索引。语法如下：</p><pre><code>array.indexOf(item, start)
</code></pre><p><strong>item</strong> 是搜索的元素，<strong>start</strong> 定义开始搜索的位置，默认为 0。</p><p>示例如下：</p><pre><code>var arr = ['a', 'b', 'c', 'a', 'e', 'b'];
var x = arr.indexOf('b');
var y = arr.indexOf('b', 2);
var z = arr.indexOf('f');
console.log(x);
console.log(y);
console.log(z);

//output:
//1
//5
//-1</code></pre><p>当搜索的元素不存在时，返回值为 <code>-1</code>。</p><p><strong>Associative Arrays</strong> 关联型数组</p><p>很多编程语言支持给数组添加命名化的 index 索引，也就是给每个元素定义一个名称，<strong>但是 JavaScript 不支持这种操作</strong>，因为它只能使用内部默认的 index 数字型索引。</p><p>但是我们依然可以定义命名化的 index 索引数组，JavaScript 会将其作为一个 object 处理：</p><pre><code>var a = [];
a[&quot;name&quot;] = &quot;marco&quot;;
a[&quot;age&quot;] = 20;
document.write(a[&quot;age&quot;]);</code></pre><p>JavaScript 会将 a 作为 object 处理，这样 name 和 age 就是其 properties。可以使用以上写法来读取 property 数据。</p><p>由于 a 数组被作为 object 处理，所以标准 array 的一些 method 和 properties 将无法正确执行，例如：<code>a.length</code> 返回值将是 0 而不是 2。</p><p>JavaScript 原生并不支持命名化的元素索引，所以<strong>推荐</strong>当你想要使用 number 数字型 index 时使用 array，当你想要使用命名化的索引时使用 object。</p><h3>the Math Object 数学对象</h3><p>the Math Object 可以用来处理数学运算任务，它包含多个 properties：<br><img src="https://blog.niekun.net/usr/uploads/2020/12/2493943028.png" alt="1.png" title="1.png"></p><p><strong>Math 没有 constructor 构造器</strong>，所以使用时并不需要单独创建 object。例如：</p><pre><code>document.write(Math.PI);
</code></pre><p>以上将输出：3.141592653589793</p><p>Math object 包含多个 method 用来计算：<br><img src="https://blog.niekun.net/usr/uploads/2020/12/2808938315.png" alt="2.png" title="2.png"></p><p>下面示例计算 4 的平方根：</p><pre><code>var a = Math.sqrt(4);</code></pre><p>如果想要得到一个 0- 10 的随机数，可以使用下面方法：</p><pre><code>Math.ceil(Math.random() * 10);
</code></pre><p>下面编写一个小程序，让用户输入一个数字然后将这个数字的平方根放在弹窗通知中：</p><pre><code>var n = prompt(&quot;please input a number: &quot;, &quot;&quot;);
var m = Math.sqrt(n);
alert(m);</code></pre><h3>The Date Object 时间对象</h3><p><code>setInterval()</code> method 用来在指定的间隔时间(毫秒)下调用 function 或评估一个表达式。它将会持续调用直到执行 <code> clearInterval()</code> 或关闭窗口。</p><p>下面的示例将会每三秒钟弹出窗口：</p><pre><code>function myAlert() {
    alert(&quot;hello&quot;);
}
setInterval(myAlert, 3000);</code></pre><p>注意传递 function 时只需要写 function 名称即可，不需要小括号<code>()</code>。</p><p><code>Data</code> object 可以让我们使用时间元素，一个 <code>Date</code> object 由：a year, a month, a day, an hour, a minute, a second, and milliseconds 构成。</p><p>使用 <code>new</code> 关键词来创建一个 Date obect，包含有当前的<strong>日期和时间</strong>：</p><pre><code>var d = new Date();
//d stores the current date and time</code></pre><p>也可以使用指定的日期和时间来创建 Date object：</p><pre><code>new Date(milliseconds)
new Date(dateString)
new Date(year, month, day, hours, minutes, seconds, milliseconds)</code></pre><p>JavaScript 日期计算使用毫秒为单位，起始日期为：01 January, 1970 00:00:00 (UTC)。一天包含 86,400,000 毫秒。</p><p>以下示例使用不同方式定义指定日期：</p><pre><code>//Fri Jan 02 1970 00:00:00
var d1 = new Date(86400000); 

//Fri Jan 02 2015 10:42:00
var d2 = new Date(&quot;January 2, 2015 10:42:00&quot;);

//Sat Jun 11 1988 11:42:00
var d3 = new Date(88,5,11,11,42,0,0);</code></pre><p>JavaScript 的月份从 0 到 11，1 月就是 0，12 月就是 11。Date object 是 static 类型的，创建后就不会改变。</p><p>Date object 有如下 method 可供使用：<br><img src="https://blog.niekun.net/usr/uploads/2020/12/986046713.png" alt="3.png" title="3.png"></p><p>例如读取当前小时数值：</p><pre><code>var d = new Date();
document.write(d.getHours());</code></pre><p>下面示例在窗口显示当前时间，且每秒刷新一次：</p><pre><code>function printTime() {
    var d = new Date();
    var hour = d.getHours();
    var min = d.getMinutes();
    var sec = d.getSeconds();
    document.body.innerHTML = hour + &quot;:&quot; + min + &quot;:&quot; + sec;
}

setInterval(printTime, 1000);</code></pre><p><code>innerHTML</code> property 可以设置或返回一个 HTML 元素的内容，这里我们将 document 的 body 块的内容赋值为我们定义的时间数据，并且每秒覆盖更新一次。</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/1997.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/1997.html</wfw:commentRss>
</item>
</channel>
</rss>