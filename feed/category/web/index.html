<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
xmlns:content="http://purl.org/rss/1.0/modules/content/"
xmlns:dc="http://purl.org/dc/elements/1.1/"
xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
xmlns:atom="http://www.w3.org/2005/Atom"
xmlns:wfw="http://wellformedweb.org/CommentAPI/">
<channel>
<title>Marco Nie - web</title>
<link>https://blog.niekun.net/category/web/</link>
<atom:link href="https://blog.niekun.net/feed/category/web/" rel="self" type="application/rss+xml" />
<language>zh-CN</language>
<description></description>
<lastBuildDate>Tue, 24 Mar 2020 08:43:00 +0800</lastBuildDate>
<pubDate>Tue, 24 Mar 2020 08:43:00 +0800</pubDate>
<item>
<title>HTTP 协议结构</title>
<link>https://blog.niekun.net/archives/1432.html</link>
<guid>https://blog.niekun.net/archives/1432.html</guid>
<pubDate>Tue, 24 Mar 2020 08:43:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[The Hypertext Transfer Protocol (HTTP) is an application protocol for distributed, collaborative,...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<blockquote>The Hypertext Transfer Protocol (HTTP) is an application protocol for distributed, collaborative, hypermedia information systems.[1] HTTP is the foundation of data communication for the World Wide Web, where hypertext documents include hyperlinks to other resources that the user can easily access, for example by a mouse click or by tapping the screen in a web browser.</blockquote><p>以上说明摘录自 Wikipedia，HTTP 全称为<strong>超文本传输协议</strong>，设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。通过HTTP或者HTTPS协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。</p><h3>构成</h3><p>HTTP是一个客户端（用户）和服务端（网站）之间请求和应答的标准，通常使用TCP协议。有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS：<br><img src="https://blog.niekun.net/usr/uploads/2020/03/1755297292.png" alt="2020-03-24T00:48:01.png" title="2020-03-24T00:48:01.png"></p><p><strong>HTTP协议永远都是客户端发起请求，服务器回送响应。</strong><br><img src="https://blog.niekun.net/usr/uploads/2020/03/2181204214.png" alt="2020-03-24T00:50:21.png" title="2020-03-24T00:50:21.png"></p><p>HTTP是一个无状态的协议。协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。可以使用 <strong>connection: Keep-Alive</strong> 来保留 tcp 握手连接。</p><p><strong>一次HTTP操作称为一个事务，其工作过程可分为四步：</strong></p><ul><li>首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作开始。</li><li>建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URI）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。</li><li>服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。</li><li>客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。</li></ul><p>HTTP是基于传输层的TCP协议，而TCP是一个端到端的面向连接的协议。所谓的端到端可以理解为进程到进程之间的通信。所以HTTP在开始传输之前，首先需要建立TCP连接，而TCP连接的过程需要三次握手：<br><img src="https://blog.niekun.net/usr/uploads/2020/03/2093610890.png" alt="2020-03-24T00:54:05.png" title="2020-03-24T00:54:05.png"></p><p>可以使用 <strong>Wireshark</strong> 网络协议分析工具来查看一个握手过程：<a href="https://www.wireshark.org/">https://www.wireshark.org/</a></p><p>打开 Wireshark，点击 capture - options，上方选择当前连接外网的硬件，我选择 WiFi，在 capture filter 里设置监听地址：tcp port http:<br><img src="https://blog.niekun.net/usr/uploads/2020/03/2495975856.png" alt="2020-03-24T02:00:39.png" title="2020-03-24T02:00:39.png"></p><p>在浏览器访问：<a href="http://baidu.com">http://baidu.com</a>，记得如果使用了代理的话先关掉。</p><p>在 wireshark 里就会显示报文信息：<br><img src="https://blog.niekun.net/usr/uploads/2020/03/318072432.png" alt="2020-03-24T02:03:50.png" title="2020-03-24T02:03:50.png"></p><p>可以通过颜色区分报文种类，绿色是 tcp 报文，黑色是有问题的报文。如果报文过多可以使用上面的 filter 过滤有用信息。</p><p><strong>上面的报文显示了握手的过程：</strong></p><ul><li>前三个 tcp 连接分别是客户端发出连接请求，服务端回应客户端，客户端回应服务端确认</li><li><strong>然后客户端发起一个 http 页面 request 请求</strong></li><li>服务端发出 tcp 确认请求</li><li><strong>服务端发送 response http 数据 200 状态码</strong></li><li>客户端发出 tcp 确认</li></ul><p>下面主要分析 <strong>request</strong> 和 <strong>response</strong> 的 http 数据。</p><hr><h3>request 请求</h3><p>tcp 握手成功后，客户端就通过发送 request 开始请求 http 页面。</p><p><strong>发出的请求信息（message request）结构如下:</strong></p><ul><li>请求行（例如GET /images/logo.gif HTTP/1.1，表示从/images目录下请求logo.gif这个文件）</li><li>请求头（例如Accept-Language: en）</li><li>空行</li><li>其他消息体</li></ul><p>请求行和标题必须以<code>&lt;CR&gt;&lt;LF&gt;</code>作为结尾。空行内必须只有<code>&lt;CR&gt;&lt;LF&gt;</code>而无其他空格。在HTTP/1.1协议中，所有的请求头，除Host外，都是可选的。</p><p>一个最简单的 request：</p><pre><code>GET / HTTP/1.1
Host: www.bing.com</code></pre><p>末尾有一个空行。第一行指定方法、资源路径、协议版本；第二行是在1.1版里必带的一个header作用于指定主机。</p><p>上面访问 <a href="http://baidu.com">http://baidu.com</a> 的request 全部内容如下：(在 wireshark 点击 request http 报文可查看)</p><pre><code>    GET / HTTP/1.1\r\n
    Host: news.baidu.com\r\n
    Connection: keep-alive\r\n
    Upgrade-Insecure-Requests: 1\r\n
    DNT: 1\r\n
    User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36\r\n
    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\r\n
    Referer: https://www.baidu.com/\r\n
    Accept-Encoding: gzip, deflate\r\n
    Accept-Language: en,en-US;q=0.9,zh-CN;q=0.8,zh;q=0.7,zh-TW;q=0.6\r\n
    Cookie: BIDUPSID=DFBCEB19126518FE5B14DE02435939DF; PSTM=1585012306; BAIDUID=DFBCEB19126518FEC81AB23A0B7A652F:FG=1; H_PS_PSSID=30971_1426_31118_21108_30824_26350\r\n
    \r\n
    [Full request URI: http://news.baidu.com/]
    [HTTP request 1/3]
    [Response in frame: 23]
    [Next request in frame: 599]</code></pre><h4>请求方法</h4><p>HTTP/1.1协议中共定义了八种方法（也叫“动作”）来以不同方式操作指定的资源：</p><ul><li><strong>GET</strong> 向指定的资源发出“显示”请求。使用GET方法应该只用在读取数据，GET上要在url之外带一些参数就只能依靠url上附带querystring。</li><li><strong>HEAD</strong> 与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。</li><li><strong>POST</strong> 向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。</li><li><strong>PUT</strong> 向指定资源位置上传其最新内容。</li><li><strong>DELETE</strong> 请求服务器删除Request-URI所标识的资源。</li><li><strong>TRACE</strong> 回显服务器收到的请求，主要用于测试或诊断。</li><li><strong>OPTIONS</strong> 这个方法可使服务器传回该资源所支持的所有HTTP请求方法。</li><li><strong>CONNECT</strong> HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接。</li></ul><p>当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Method Not Allowed），当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501（Not Implemented）。</p><p><strong>最常用的就是 GET 和 POST 方法。</strong></p><p><strong>GET和POST的区别：</strong></p><ul><li>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&相连，如EditPosts.aspx?name=test1&id=123456. POST方法是把提交的数据放在HTTP包的Body中。</li><li>GET提交的数据大小有限制，最多只能有1024字节（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制。</li><li>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。</li><li>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。</li></ul><h4>版本</h4><ul><li><strong>HTTP/0.9</strong> 已过时。只接受GET一种请求方法，没有在通讯中指定版本号，且不支持请求头。不支持 POST</li><li><strong>HTTP/1.0</strong> 这是第一个在通讯中指定版本号的HTTP协议版本，至今仍被广泛采用，特别是在代理服务器中。</li><li><strong>HTTP/1.1</strong> 持久连接被默认采用，并能很好地配合代理服务器工作。还支持以管道方式在同时发送多个请求，降低线路负载提高传输速度。</li><li><strong>HTTP/2</strong> 当前版本，于2015年5月作为互联网标准正式发布。</li></ul><h4>请求头</h4><p>HTTP 头字段根据实际用途被分为以下 4 种类型：</p><ul><li>通用头字段(英语：General Header Fields)</li><li>请求头字段(英语：Request Header Fields)</li><li>响应头字段(英语：Response Header Fields)</li><li>实体头字段(英语：Entity Header Fields)</li></ul><p>常见的请求头字段：</p><ul><li>Accept 能够接受的回应内容类型：Accept: text/plain</li><li>Connection 该浏览器想要优先使用的连接类型：Connection: keep-alive</li><li>Content-Type 请求体的多媒体类型：Content-Type: application/x-www-form-urlencoded</li><li>Host 服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号：Host: en.wikipedia.org:80</li><li>User-Agent - 浏览器的浏览器身份标识字符串：ser-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/21.0</li><li>If-Modified-Since 把浏览器端缓存页面的最后修改时间发送到服务器，如果和服务器文件时间一致，那么返回304：If-Modified-Since: Thu, 09 Feb 2012 09:07:57 GMT</li><li>pragma 指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝，在HTTP/1.1版本中，它和Cache-Control: no-cache作用一模一样：pragma: no-cache</li><li>Cache-Control 指定请求和响应遵循的缓存机制：Cache-Control: no-cache</li><li>Cookie 之前由服务器通过 Set- Cookie （下文详述）发送的一个 超文本传输协议Cookie</li></ul><p>常见的非标准请求头字段：</p><ul><li>DNT 请求某个网页应用程序停止跟踪某个用户：DNT: 1 (DNT启用)</li><li>X-Forwarded-For 一个事实标准 ，用于标识某个通过超文本传输协议代理或负载均衡连接到某个网页服务器的客户端的原始互联网地址：X-Forwarded-For: 129.78.138.66, 129.78.64.103</li><li>X-Forwarded-Host 一个事实标准 ，用于识别客户端原本发出的 Host 请求头部：X-Forwarded-Host: en.wikipedia.org</li><li>X-Forwarded-Proto 一个事实标准，用于标识某个超文本传输协议请求最初所使用的协议：X-Forwarded-Proto: https</li></ul><p>更多请求头字段参考：<a href="https://zh.wikipedia.org/wiki/HTTP%E5%A4%B4%E5%AD%97%E6%AE%B5#%E8%AF%B7%E6%B1%82%E5%AD%97%E6%AE%B5">wikepedia</a></p><h3>response 响应</h3><p>服务端发出 tcp 确认后，发出 response 响应 http 页面。</p><p><strong>发出的响应信息（message request）结构如下:</strong></p><ul><li>状态行（例如HTTP/1.1 200 OK，表示从信息传递成功）</li><li>响应头（例如Content-Length: 3059）</li><li>空行</li><li>传递实体内容(可以为空)</li></ul><p>下面是一个 http 页面的响应实例：</p><pre><code>    HTTP/1.1 200 OK\r\n
    Content-Type: text/html; charset=utf-8\r\n
    Server: GitHub.com\r\n
    Last-Modified: Fri, 22 Jan 2016 02:52:30 GMT\r\n
    ETag: W/&quot;56a1996e-2d27&quot;\r\n
    Access-Control-Allow-Origin: *\r\n
    Expires: Tue, 24 Mar 2020 06:32:29 GMT\r\n
    Cache-Control: max-age=600\r\n
    Content-Encoding: gzip\r\n
    X-Proxy-Cache: MISS\r\n
    X-GitHub-Request-Id: EAD6:198D:D9A2C:E5FDD:5E79A724\r\n
    Content-Length: 4509\r\n
    Accept-Ranges: bytes\r\n
    Date: Tue, 24 Mar 2020 06:22:29 GMT\r\n
    Via: 1.1 varnish\r\n
    Age: 0\r\n
    Connection: keep-alive\r\n
    X-Served-By: cache-hnd18730-HND\r\n
    X-Cache: MISS\r\n
    X-Cache-Hits: 0\r\n
    X-Timer: S1585030950.603621,VS0,VE171\r\n
    Vary: Accept-Encoding\r\n
    X-Fastly-Request-ID: 806211821134676c48d8c7c6ed9cee2a6bad952d\r\n
    \r\n
    [HTTP response 1/5]
    [Time since request: 0.405424000 seconds]
    [Request in frame: 2595]
    [Next request in frame: 2604]
    [Next response in frame: 2623]
    [Request URI: http://zq210wl.github.io/imgs/noise.png]
    Content-encoded entity body (gzip): 4509 bytes -&gt; 11559 bytes
    File Data: 11559 bytes
    &lt;!DOCTYPE HTML&gt;
    &lt;html&gt;
    &lt;head&gt;
      &lt;meta charset=&quot;utf-8&quot;&gt;
      ...
    &lt;/head&gt;
    &lt;body&gt;
      ...
    &lt;/body&gt;</code></pre><h4>状态行</h4><p>响应行结构为：当前HTTP版本号，3位数字组成的状态代码，以及描述状态的短语，彼此由空格分隔。</p><h4>状态码</h4><p>状态代码的第一个数字代表当前响应的类型：</p><ul><li>1xx消息——请求已被服务器接收，继续处理</li><li>2xx成功——请求已成功被服务器接收、理解、并接受</li><li>3xx重定向——需要后续操作才能完成这一请求</li><li>4xx请求错误——请求含有词法错误或者无法被执行</li><li>5xx服务器错误——服务器在处理某个正确请求时发生错误</li></ul><p>详细的状态码介绍参考：<a href="https://blog.niekun.net/archives/192.html">https://blog.niekun.net/archives/192.html</a></p><h4>响应头</h4><p>HTTP 头字段根据实际用途被分为以下 4 种类型：</p><ul><li>通用头字段(英语：General Header Fields)</li><li>请求头字段(英语：Request Header Fields)</li><li>响应头字段(英语：Response Header Fields)</li><li>实体头字段(英语：Entity Header Fields)</li></ul><p>常见的响应头字段：</p><ul><li>Allow 对于特定资源有效的动作：Allow: GET, HEAD</li><li>Age 这个对象在代理缓存中存在的时间，以秒为单位：Age: 12</li><li>Connection 针对该连接所预期的选项：Connection: keep-alive</li><li>Content-Language 内容所使用的语言：Content-Language: da</li><li>Expires 指定一个日期/时间，超过该时间则认为此回应已经过期：Expires: Thu, 01 Dec 1994 16:00:00 GMT</li><li>Location 用来进行重定向，或者在创建了某个新资源时使用：Location: <a href="http://www.w3.org/pub/WWW/People.html">http://www.w3.org/pub/WWW/People.html</a></li><li>Refresh 用于设定可定时的重定向跳转。右边例子设定了5秒后跳转至：Refresh: 5; url=<a href="http://www.w3.org/pub">http://www.w3.org/pub</a></li><li>Server服务器的名字：Server: Apache/2.4.1 (Unix)</li><li>Upgrade 要求客户端升级到另一个协议：Upgrade: HTTP/2.0</li><li>Set-Cookie 设置 HTTP cookie记录客户端身份：Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1</li></ul><p>常见的非标准回应字段：</p><ul><li>X-Powered-By 表明用于支持当前网页应用程序的技术：X-Powered-By: PHP/5.4.0</li><li>X-Content-Duration 指出音视频的长度，单位为秒：X-Content-Duration: 42.666</li></ul><p>详细的响应头字段参考：<a href="https://zh.wikipedia.org/wiki/HTTP%E5%A4%B4%E5%AD%97%E6%AE%B5#%E8%AF%B7%E6%B1%82%E5%AD%97%E6%AE%B5">Wikipedia</a></p><h4>响应头的 location 段</h4><p>HTTP Location 是在两种情况使用在响应头中：</p><ul><li>要求网页浏览器加载其他网页(域名转址)。在这种情况下，应该使用HTTP状态码3xx发送Location头。</li><li>提供有关新创建资源位置的信息。在这种情况下，应该使用HTTP状态码201或202发送Location头。</li></ul><p>示例：</p><pre><code>HTTP/1.1 302 Found
Location: http://www.example.org/index.php</code></pre><p>客户端请求的 URL 被服务端重定向到 <a href="http://www.example.org/index.php.">http://www.example.org/index.php.</a></p><p>客户端请求：</p><pre><code>GET /blog HTTP/1.1
Host: www.example.com</code></pre><p>服务端响应：</p><pre><code>HTTP/1.1 302 Found
Location: /articles/</code></pre><p>该位置 /blog 被客户端定向到 <a href="http://www.example.com/articles/.">http://www.example.com/articles/.</a></p><h4>解决HTTP无状态的问题</h4><p>使用Cookie来实现：</p><ul><li>服务器给每个Session分配一个唯一的JSESSIONID，并通过Cookie发送给客户端。</li><li>当客户端发起新的请求的时候，将在Cookie头中携带这个JSESSIONID。这样服务器能够找到这个客户端对应的Session。</li></ul><p><img src="https://blog.niekun.net/usr/uploads/2020/03/2798926810.png" alt="2020-03-24T07:45:16.png" title="2020-03-24T07:45:16.png"></p><p>使用URL回写来实现：<br>URL回写是指服务器在发送给浏览器页面的所有链接中都携带JSESSIONID的参数，这样客户端点击任何一个链接都会把JSESSIONID带会服务器。如果直接在浏览器输入服务端资源的url来请求该资源，那么Session是匹配不到的。</p><h3>URI 统一资源标志符</h3><p>统一资源标识符（英语：Uniform Resource Identifier，缩写：URI）在电脑术语中是一个用于标识某一互联网资源名称的字符串。</p><p>该种标识允许用户对网络中（一般指万维网）的资源通过特定的协议进行交互操作。URI的最常见的形式是统一资源定位符（URL），经常指定为非正式的网址。更罕见的用法是统一资源名称（URN），其目的是通过提供一种途径。用于在特定的名字空间资源的标识，以补充网址。</p><p>通用URI的格式如下：</p><pre><code>[协议名]://[用户名]:[密码]@[主机名]:[端口]/[路径]?[查询参数]#[片段ID]</code></pre><p><strong>下面是两个常见的 URI 构成：</strong></p><pre><code>
                   hierarchical part
        ┌───────────────────┴─────────────────────┐
                    authority               path
        ┌───────────────┴───────────────┐┌───┴────┐
  abc://username:password@example.com:123/path/data?key=value&amp;key2=value2#fragid1
  └┬┘   └───────┬───────┘ └────┬────┘ └┬┘           └─────────┬─────────┘ └──┬──┘
scheme  user information     host     port                  query         fragment


  urn:example:mammal:monotreme:echidna
  └┬┘ └──────────────┬───────────────┘
scheme              path</code></pre><p>以 <code>https://zh.wikipedia.org:80/w/index.php?title=Special:随机页面#ABC</code> 为例, 其中：</p><ul><li>https，是协议；</li><li>zh.wikipedia.org，是服务器；</li><li>80，是服务器上的网络端口号；</li><li>/w/index.php，是路径；</li><li>?title=Special:随机页面，是询问。</li><li><h1>ABC，是片段</h1></li></ul><h3>　参考连接</h3><p>[超文本传输协议]　(<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE)">https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE)</a><br><a href="https://zh.wikipedia.org/wiki/HTTP%E5%A4%B4%E5%AD%97%E6%AE%B5">HTTP头字段</a><br><a href="https://zh.wikipedia.org/wiki/HTTP_Location">HTTP_Location</a><br><a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E6%A0%87%E5%BF%97%E7%AC%A6">统一资源标志符</a><br><a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6">一资源定位符</a><br><a href="https://www.jianshu.com/p/7275aa3e4a13">HTTP协议详解</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/1432.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/1432.html</wfw:commentRss>
</item>
<item>
<title>wkhtmltopdf 将 html为 pdf</title>
<link>https://blog.niekun.net/archives/1375.html</link>
<guid>https://blog.niekun.net/archives/1375.html</guid>
<pubDate>Wed, 18 Mar 2020 12:58:56 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[一般浏览器都可以将当前页面输出为 pdf，但当有很多个 html 文件时一个一个转换就很麻烦了，可以使用 wkhtmltopdf 命令行工具来实现自动化批量转换。wkhtmltopdf and ...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>一般浏览器都可以将当前页面输出为 pdf，但当有很多个 html 文件时一个一个转换就很麻烦了，可以使用 wkhtmltopdf 命令行工具来实现自动化批量转换。</p><blockquote>wkhtmltopdf and wkhtmltoimage are open source (LGPLv3) command line tools to render HTML into PDF and various image formats using the Qt WebKit rendering engine. These run entirely "headless" and do not require a display or display service.</blockquote><p>wkhtmltopdf 官网：<a href="https://wkhtmltopdf.org/">https://wkhtmltopdf.org/</a><br>GitHub 主页：<a href="https://github.com/wkhtmltopdf/wkhtmltopdf">https://github.com/wkhtmltopdf/wkhtmltopdf</a></p><p class="more"><a href="https://blog.niekun.net/archives/1375.html" title="wkhtmltopdf 将 html为 pdf">[...]</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/1375.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/1375.html</wfw:commentRss>
</item>
<item>
<title>网站压力测试 loader.io</title>
<link>https://blog.niekun.net/archives/1300.html</link>
<guid>https://blog.niekun.net/archives/1300.html</guid>
<pubDate>Tue, 10 Mar 2020 15:51:50 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[免费的网站压力测试平台 loader.io官网：https://loader.io/]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>免费的网站压力测试平台 loader.io<br>官网：<a href="https://loader.io/">https://loader.io/</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/1300.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/1300.html</wfw:commentRss>
</item>
<item>
<title>关于手机端无法使用 typecho 的搜索框解决</title>
<link>https://blog.niekun.net/archives/1249.html</link>
<guid>https://blog.niekun.net/archives/1249.html</guid>
<pubDate>Tue, 03 Mar 2020 22:34:48 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[最近自己做了一个 typecho 的主题，主要是手机端的页面优化和字体优化，使用了 bootstrap 来渲染，主题在 GitHub 上开源：https://github.com/nie11ku...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>最近自己做了一个 typecho 的主题，主要是手机端的页面优化和字体优化，使用了 bootstrap 来渲染，主题在 GitHub 上开源：<a href="https://github.com/nie11kun/TypechoAwesome">https://github.com/nie11kun/TypechoAwesome</a></p><p>但是测试发现搜索框无法正确搜索，总是返回主页。</p><p>今天终于发现问题所在了，由于我的网站使用的 NS 服务是 cloudflare 的，在当时设置的时候，把移动端 Mobile Redirect 优化选择上了，每次访问网站都会重定向到 <strong>m.niekun.net</strong>，估计是 cf 做了什么精简，导致功能丢失，把 Mobile Redirect 关闭就正常了。</p><p>具体修改路径是 speed - optimisation：<br><img src="https://niekun.net/usr/uploads/2020/03/448267460.png" alt="2020-03-03T14:33:02.png" title="2020-03-03T14:33:02.png"></p><p>页面拉到最下方，将 Mobile Redirect 关掉：<br><img src="https://niekun.net/usr/uploads/2020/03/412183147.png" alt="2020-03-03T14:33:36.png" title="2020-03-03T14:33:36.png"></p><p>再次访问主页，就不会重定向到 <strong>m.niekun.net</strong> 而是 <strong>niekun.net</strong> 了。</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/1249.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/1249.html</wfw:commentRss>
</item>
<item>
<title>aria2 使用指南</title>
<link>https://blog.niekun.net/archives/1199.html</link>
<guid>https://blog.niekun.net/archives/1199.html</guid>
<pubDate>Fri, 28 Feb 2020 17:10:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[aria2 是一款轻量级的下载器，支持 HTTP/HTTPS, FTP, SFTP, BitTorrent and Metalink 等多种协议。它有如下特点：多节点链接：下载一个文件可以同时链...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p><img src="https://niekun.net/usr/uploads/2020/02/722287411.png" alt="2020-02-28T08:41:44.png" title="2020-02-28T08:41:44.png"></p><p>aria2 是一款轻量级的下载器，支持 HTTP/HTTPS, FTP, SFTP, BitTorrent and Metalink 等多种协议。</p><p>它有如下特点：</p><ul><li>多节点链接：下载一个文件可以同时链接多个源来提速</li><li>轻量级：占用系统资源极少，一般下载任务内存占用 10mb 内</li><li>全功能的 BitTorrent 客户端：支持 DHT, PEX, Encryption, Magnet URI, Web-Seeding, Selective Downloads, Local Peer Discovery and UDP tracker</li><li>支持 metalink 链接</li><li>支持远程控制：支持 RPC 界面控制 aria2 进程</li></ul><p>官网：<a href="https://aria2.github.io/">https://aria2.github.io/</a><br>GitHub 主页：<a href="https://github.com/aria2/aria2">https://github.com/aria2/aria2</a><br>webui-aria2：<a href="https://github.com/ziahamza/webui-aria2">https://github.com/ziahamza/webui-aria2</a></p><p class="more"><a href="https://blog.niekun.net/archives/1199.html" title="aria2 使用指南">[...]</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/1199.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/1199.html</wfw:commentRss>
</item>
<item>
<title>TypechoAwesome theme for Typecho</title>
<link>https://blog.niekun.net/archives/820.html</link>
<guid>https://blog.niekun.net/archives/820.html</guid>
<pubDate>Thu, 19 Dec 2019 09:55:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[此主题是我在 typecho 原版默认主题基础上做了移动端的优化处理，适合喜欢简洁风格的人使用。typecho 是一款轻量的博客系统，风格很简洁，相比较 wordpress 占用资源很少，所以我...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p><img src="https://niekun.net/usr/uploads/2019/12/725033772.jpg" alt="TypechoAwesome-logo.jpg" title="TypechoAwesome-logo.jpg"></p><p>此主题是我在 typecho 原版默认主题基础上做了移动端的优化处理，适合喜欢简洁风格的人使用。</p><p>typecho 是一款轻量的博客系统，风格很简洁，相比较 wordpress 占用资源很少，所以我选择了 typecho。</p><p>官网：<a href="http://typecho.org/">http://typecho.org/</a><br>GitHub 主页：<a href="https://github.com/typecho/typecho">https://github.com/typecho/typecho</a></p><p>关于 typecho 的安装参考我的教程：<a href="https://niekun.net/index.php/archives/6.html">https://niekun.net/index.php/archives/6.html</a></p><p class="more"><a href="https://blog.niekun.net/archives/820.html" title="TypechoAwesome theme for Typecho">[...]</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/820.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/820.html</wfw:commentRss>
</item>
<item>
<title>HTML  特殊字符转义符号实体</title>
<link>https://blog.niekun.net/archives/798.html</link>
<guid>https://blog.niekun.net/archives/798.html</guid>
<pubDate>Tue, 17 Dec 2019 14:25:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[一些特殊符号需要显示在 HTML 上时，需要使用符号实体来表示：常用符号转义符号含义转义实体转义号 空格&amp;nbsp;&amp;#160;&lt;小于号&amp;lt;&amp;#60;&...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>一些特殊符号需要显示在 HTML 上时，需要使用符号实体来表示：</p><h2>常用符号转义</h2><table><tbody><tr><td align="center">符号</td><td align="center">含义</td><td>转义实体</td><td>转义号</td></tr><tr><td align="center"> </td><td align="center">空格</td><td><code>&amp;nbsp;</code></td><td><code>&amp;#160;</code></td></tr><tr><td align="center">&lt;</td><td align="center">小于号</td><td><code>&amp;lt;</code></td><td><code>&amp;#60;</code></td></tr><tr><td align="center">&gt;</td><td align="center">大于号</td><td><code>&amp;gt;</code></td><td><code>&amp;#62;</code></td></tr><tr><td align="center">&</td><td align="center">和</td><td><code>&amp;amp;</code></td><td><code>&amp;#38;</code></td></tr><tr><td align="center">"</td><td align="center">双引号</td><td><code>&amp;quot;</code></td><td><code>&amp;#34;</code></td></tr><tr><td align="center">'</td><td align="center">单引号</td><td><code>&amp;apos;</code></td><td><code>&amp;#39;</code></td></tr><tr><td align="center">¢</td><td align="center">分</td><td><code>&amp;cent;</code></td><td><code>&amp;#162;</code></td></tr><tr><td align="center">£</td><td align="center">磅</td><td><code>&amp;pound;</code></td><td><code>&amp;#163;</code></td></tr><tr><td align="center">¥</td><td align="center">元</td><td><code>&amp;yen;</code></td><td><code>&amp;#165;</code></td></tr><tr><td align="center">€</td><td align="center">欧元</td><td><code>&amp;euro;</code></td><td><code>&amp;#8364;</code></td></tr><tr><td align="center">©</td><td align="center">版权</td><td><code>&amp;copy;</code></td><td><code>&amp;#169;</code></td></tr><tr><td align="center">®</td><td align="center">注册商标</td><td><code>&amp;reg;</code></td><td><code>&amp;#174;</code></td></tr></tbody></table><h2>更多符号</h2><p>w3 教程：<a href="https://www.w3schools.com/HTML/html_entities.asp">https://www.w3schools.com/HTML/html_entities.asp</a><br>希腊字符：<a href="https://www.w3schools.com/charsets/ref_utf_greek.asp">https://www.w3schools.com/charsets/ref_utf_greek.asp</a><br>货币字符：<a href="https://www.w3schools.com/charsets/ref_utf_currency.asp">https://www.w3schools.com/charsets/ref_utf_currency.asp</a><br>箭头符号：<a href="https://www.w3schools.com/charsets/ref_utf_arrows.asp">https://www.w3schools.com/charsets/ref_utf_arrows.asp</a><br>数学符号：<a href="https://www.w3schools.com/charsets/ref_utf_math.asp">https://www.w3schools.com/charsets/ref_utf_math.asp</a><br>更多杂类：<a href="https://www.w3schools.com/charsets/ref_utf_symbols.asp">https://www.w3schools.com/charsets/ref_utf_symbols.asp</a></p>
]]></content:encoded>
<slash:comments>2</slash:comments>
<comments>https://blog.niekun.net/archives/798.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/798.html</wfw:commentRss>
</item>
<item>
<title>CSS element+element Selector 的使用</title>
<link>https://blog.niekun.net/archives/796.html</link>
<guid>https://blog.niekun.net/archives/796.html</guid>
<pubDate>Tue, 17 Dec 2019 09:37:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[选择特定元素内部的某个元素，需要使用加号 + 来进行选择。&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;div + p { ...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>选择特定元素内部的某个元素，需要使用加号 <code>+</code> 来进行选择。</p><p><img src="https://niekun.net/usr/uploads/2019/12/422125057.png" alt="2019-12-17T01:37:54.png" title="2019-12-17T01:37:54.png"></p><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;style&gt;
div + p {
  background-color: yellow;
}
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1&gt;Welcome to My Homepage&lt;/h1&gt;

&lt;div&gt;
  &lt;h2&gt;My name is Donald&lt;/h2&gt;
  &lt;p&gt;I live in Duckburg.&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;My best friend is Mickey.&lt;/p&gt;

&lt;p&gt;I will not be styled.&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/796.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/796.html</wfw:commentRss>
</item>
<item>
<title>javascript/css  强制更新</title>
<link>https://blog.niekun.net/archives/769.html</link>
<guid>https://blog.niekun.net/archives/769.html</guid>
<pubDate>Mon, 16 Dec 2019 17:14:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[当我们对网站做了修改，推送到远程服务器后，发现页面还是老样子。这是由于浏览器缓存的问题，html 页面一般会及时更新，但 JavaScript/css 脚本常常无法及时更新，这时候需要手动进行处...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>当我们对网站做了修改，推送到远程服务器后，发现页面还是老样子。这是由于浏览器缓存的问题，html 页面一般会及时更新，但 JavaScript/css 脚本常常无法及时更新，这时候需要手动进行处理。</p><p><strong>方法一：</strong><br>在多数浏览器中，可以使用 CTRL + F5 快捷键强制刷新。一般能看到最新的结果。</p><p><strong>方法二：</strong><br>如果你使用 Google chrome 浏览器，则可以使用 debugger 禁止缓存: 右键 - inspect - Network - Disable cache</p><p><strong>方法三：</strong><br>在源码的 link/script 中修改如下：</p><pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;my-css-file.css?v=1&quot;&gt;
&lt;script src=&quot;my-js-file.js?v=1&quot;&gt;&lt;/script&gt;
</code></pre><p>主要是在文件后加上 <code>?v=1</code> 类似的字符串。当然也可换成其他写法，如：<code>?time=2019126</code> 等。</p><p>下次更新文件时，将后缀修改成其他数字即可。这样的好处是你的用户们也可以同时收到最新更新。</p><p>参考链接：<br><a href="https://stackoverflow.com/questions/3951187/javascript-file-not-updating-no-matter-what-i-do">https://stackoverflow.com/questions/3951187/javascript-file-not-updating-no-matter-what-i-do</a><br><a href="https://stackoverflow.com/questions/3466989/what-does-appending-v-1-to-css-and-javascript-urls-in-link-and-script-tags-do">https://stackoverflow.com/questions/3466989/what-does-appending-v-1-to-css-and-javascript-urls-in-link-and-script-tags-do</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/769.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/769.html</wfw:commentRss>
</item>
<item>
<title>lightbox2 使用</title>
<link>https://blog.niekun.net/archives/768.html</link>
<guid>https://blog.niekun.net/archives/768.html</guid>
<pubDate>Thu, 12 Dec 2019 22:03:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[lightbox 是一个JavaScript 库，用来在前端显示图片。它的特点是轻量，容易部署，适用于现代的浏览器。官网：https://lokeshdhakar.com/projects/li...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p><img src="https://niekun.net/usr/uploads/2019/12/408731672.png" alt="2019-12-16T12:30:16.png" title="2019-12-16T12:30:16.png"><br>lightbox 是一个JavaScript 库，用来在前端显示图片。它的特点是轻量，容易部署，适用于现代的浏览器。</p><p>官网：<a href="https://lokeshdhakar.com/projects/lightbox2/">https://lokeshdhakar.com/projects/lightbox2/</a><br>GitHub 项目地址：<a href="https://github.com/lokesh/lightbox2">https://github.com/lokesh/lightbox2</a><br>release 下载：<a href="https://github.com/lokesh/lightbox2/releases">https://github.com/lokesh/lightbox2/releases</a></p><p class="more"><a href="https://blog.niekun.net/archives/768.html" title="lightbox2 使用">[...]</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/768.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/768.html</wfw:commentRss>
</item>
</channel>
</rss>