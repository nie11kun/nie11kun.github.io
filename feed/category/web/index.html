<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
xmlns:content="http://purl.org/rss/1.0/modules/content/"
xmlns:dc="http://purl.org/dc/elements/1.1/"
xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
xmlns:atom="http://www.w3.org/2005/Atom"
xmlns:wfw="http://wellformedweb.org/CommentAPI/">
<channel>
<title>Marco Nie - web</title>
<link>https://blog.niekun.net/category/web/</link>
<atom:link href="https://blog.niekun.net/feed/category/web/" rel="self" type="application/rss+xml" />
<language>zh-CN</language>
<description></description>
<lastBuildDate>Thu, 17 Dec 2020 16:33:00 +0800</lastBuildDate>
<pubDate>Thu, 17 Dec 2020 16:33:00 +0800</pubDate>
<item>
<title>JavaScript 入门教程之二 -- 基本概念</title>
<link>https://blog.niekun.net/archives/1985.html</link>
<guid>https://blog.niekun.net/archives/1985.html</guid>
<pubDate>Thu, 17 Dec 2020 16:33:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[数学运算符有以下运算符可以使用：加减运算使用方法很简单：var b = 10 + 2;var c = b - 3;document.write(c);]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<h3>数学运算符</h3><p>有以下运算符可以使用：<br><img src="https://blog.niekun.net/usr/uploads/2020/12/2072140588.png" alt="1.png" title="1.png"></p><p><strong>加减运算</strong>使用方法很简单：</p><pre><code>var b = 10 + 2;
var c = b - 3;
document.write(c);</code></pre><!--more--><p>可以使用 <code>eval()</code> 来将计算结果转换为字符串形式：</p><pre><code>var d = eval(&quot;10 + 2 + 1&quot;)
document.write(d);</code></pre><p>d 的结果就是 <code>&quot;13&quot;</code>。</p><p><strong>乘法使用星号<code>*</code> 来表示</strong>，以下三种写法都是正确的：</p><pre><code>var e = 2 * 3;
var f = 2 * '3';
var g = '2' * '3';
document.write(g);</code></pre><p>注意如果尝试对一个字符串进行乘法计算会返回：NaN (Not a Number)：</p><pre><code>var h = 'hello' * 2;
document.write(h);

//output：
//NaN</code></pre><p><strong>除法使用斜线<code>/</code> 表示</strong>：</p><pre><code>var i = 1 / 2;</code></pre><p>注意被除数不能为 0。</p><p>取模运算使用<code>%</code> 表示：</p><pre><code>var j = 10 % 3;
document.write(j);

//output:
//1</code></pre><p>可以对整数和浮点型数字进行取模运算。</p><p><strong>递增和递减</strong>：</p><p><img src="https://blog.niekun.net/usr/uploads/2020/12/1935080336.png" alt="2.png" title="2.png"></p><p>使用<code>++</code> 表示给对应变量进行加 1 运算，操作符写在变量前则返回加 1 后的值。写在后边返回加 1 前的值。<br>使用<code>--</code> 表示给对应变量进行减 1 运算，操作符写在变量前则返回减 1 后的值。写在后边返回减 1 前的值</p><pre><code>var k = 10;
var l = k++;
var m = ++l;
document.write(m);

//output:
//11</code></pre><h3>分配符 Assignment Operators</h3><p>可用的分配符有：<br><img src="https://blog.niekun.net/usr/uploads/2020/12/3717535399.png" alt="3.png" title="3.png"></p><p>除了常规用法外，也可以在一行命令中使用多个分配符，例如：</p><pre><code>var n = 4;
var o = 5;
o += n += 3;
document.write(o);

//output:
//12</code></pre><h3>比较符 Comparison Operators</h3><p>在逻辑判断中使用比较符来比较数据是否有区别。结果为 true 或 false。</p><p>例如可以使用 equal to (==) operator 来比较两个数据是否一样：</p><pre><code>var p = 2;
document.write(p == 1);

//output:
//false</code></pre><p>所有的数据类型都可以进行比较，返回值只有 true 和 false。但需要注意比较的两个数据需要是同一类型的。</p><p>以下是可用的比较符：<br><img src="https://blog.niekun.net/usr/uploads/2020/12/218772581.png" alt="4.png" title="4.png"></p><h3>逻辑判断符 Logical Operators</h3><p>逻辑判断符用来评估一个表达式，返回结果为 true 和 false。可用的逻辑判断符为：<strong>AND, OR, NOT</strong>：</p><ul><li><code>&amp;&amp;</code> - AND 如果判断块都为 true，则返回 true</li><li><code>||</code> - OR  如果任何一个判断块为 true，则返回 true</li><li><code>!</code> - NOT  如果判断块为 false，则返回 true</li></ul><p>下面的示例是对两个判断块进行 与<code>AND</code> 操作：</p><pre><code>(4 &gt; 2) &amp;&amp; (1 &lt; 3);</code></pre><p>以上两个判断块都为 true 则整个逻辑判断结果为 true。</p><h3>状况判断符 Conditional (Ternary) Operator</h3><p>状况判断符用来根据一些实际状态给某个变量赋值。语法如下：</p><pre><code>variable = (condition) ? value1: value2 
</code></pre><p>下面举例说明：</p><pre><code>var age = 20;
var isAdult = (age &lt; 18) ? &quot;too young&quot; : &quot;old enough&quot;;
document.write(isAdult);

//OUTPUT:
//old enough</code></pre><p>以上示例中，如果 age 小于 18 则 isAdult 赋值为 "too young"，如果 age 大于等于 18 则 isAdult 赋值为 "old enough"。</p><h3>字符串操作符 String Operators</h3><p>我们可以使用级联符<code>+</code> 来将多个字符串组合成一个新的字符串。例如：</p><pre><code>var str1 = &quot;this is a &quot;;
var str2 = &quot;test string&quot;;
document.write(str1 + str2);

//output:
// this is a test string</code></pre><p>注意一个数字使用引号括起来后就成了一个字符串，如：<code>&quot;42&quot;</code> 表示一个字符串。。</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/1985.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/1985.html</wfw:commentRss>
</item>
<item>
<title>JavaScript 入门教程之一 -- 总览</title>
<link>https://blog.niekun.net/archives/1979.html</link>
<guid>https://blog.niekun.net/archives/1979.html</guid>
<pubDate>Thu, 17 Dec 2020 10:31:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[JavaScript（通常缩写为JS）是一种高级的、解释型的编程语言。JavaScript是一门基于原型、函数先行的语言，是一门多范式的语言，它支持面向对象程序设计，命令式编程，以及函数式编程。...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<blockquote>JavaScript（通常缩写为JS）是一种高级的、解释型的编程语言。JavaScript是一门基于原型、函数先行的语言，是一门多范式的语言，它支持面向对象程序设计，命令式编程，以及函数式编程。最初命名为 Mocha，1995年9月在 Netscape Navigator 2.0 的 Beta 版中改名为 LiveScript，同年12月，Netscape Navigator 2.0 Beta 3 中部署时被重命名为 JavaScript，当时网景公司与昇阳电脑公司组成的开发联盟为了让这门语言搭上 Java 这个编程语言“热词”，因此将其临时改名为 JavaScript，日后这成为大众对这门语言有诸多误解的原因之一。</blockquote><p>不同于服务器端脚本语言，例如 PHP 与 ASP，JavaScript 主要被作为客户端脚本语言在用户的浏览器上运行，不需要服务器的支持。所以在早期程序员比较青睐于 JavaScript 以减少对服务器的负担，而与此同时也带来另一个问题：安全性。而随着服务器变得强大，现在的程序员更喜欢运行于服务端的脚本以保证安全，但 JavaScript 仍然以其跨平台、容易上手等优势大行其道。同时，有些特殊功能（如AJAX）必须依赖 JavaScript 在客户端进行支持。随着引擎如 V8 和框架如 Node.js 的发展，及其事件驱动及异步 IO 等特性，JavaScript 逐渐被用来编写服务器端程序。且在近几年中，Node.js 的出世，让 JavaScript 也具有了一定的服务器功能。</p><!--more--><h3>我们的第一个 JavaScript</h3><p>我们首先来了解一些基本概念，给 web 网页加上 JavaScript。</p><p>在 web 上，JavaScript 位于 HTML document 内，可以在任意位置。js 内容使用 <code>&lt;script&gt;</code> 和 <code>&lt;/script&gt;</code> 包围起来：</p><pre><code>&lt;script&gt;
   ...
&lt;/script&gt;</code></pre><p>让我们使用 JavaScript 在网页上打印出一个 <strong>Hello World</strong>，新建一个 html 文件，内容如下：</p><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Page Title&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        
    &lt;/body&gt;
    &lt;script&gt;
        document.write(&quot;hello world&quot;);
    &lt;/script&gt;
&lt;/html&gt;</code></pre><p>使用 <code>document.write()</code> function 用来给 html document 写入内容。注意此 function 只用来测试，实际使用中会覆盖 document 中已有的内容。</p><p><strong>JavaScript 每条指令结尾使用分号<code>;</code> 来标记。</strong></p><p>文件保存后可以使用浏览器打开查看效果。</p><p>js 中还支持标准 html markup 标记语法，我们给 hello world 设置属性：</p><pre><code>    &lt;script&gt;
        document.write(&quot;&lt;h1&gt;hello world&lt;/h1&gt;&quot;);
    &lt;/script&gt;</code></pre><p>这时候文字会以标题模式显示。</p><p>也可以在浏览器终端 console 中输出信息，使用 <code>console.log()</code> function 实现：</p><pre><code>    &lt;script&gt;
        document.write(&quot;&lt;h1&gt;hello world&lt;/h1&gt;&quot;);
        console.log(&quot;this is a test log&quot;);
    &lt;/script&gt;</code></pre><p>打开浏览器的调试窗口即可看到输出信息，chrome 浏览器使用快捷键 <strong>ctrl+shift+I</strong> 或设置中打开调试：<br><img src="https://blog.niekun.net/usr/uploads/2020/12/3155874967.jpg" alt="1.jpg" title="1.jpg"></p><p>点击 console 栏查看：<br><img src="https://blog.niekun.net/usr/uploads/2020/12/2655756535.jpg" alt="2.jpg" title="2.jpg"></p><h3>注释</h3><p>对于不需要被执行的语句可以使用符号来忽略，使用双斜杠 <code>//</code> 注释单行内容，使用 <code>/*</code> 和 <code>*/</code> 注释一个块。</p><p>修改我们上面的 html 文件的 js 块：</p><pre><code>    &lt;script&gt;
        // this is a commit
        document.write(&quot;&lt;h1&gt;hello world&lt;/h1&gt;&quot;);
        console.log(&quot;this is a test log&quot;);
        /* this code create
            a alert box
        */
        alert(&quot;this is a alert box&quot;);
    &lt;/script&gt;</code></pre><p><code>alert()</code> function 用来弹出一个提示窗口。</p><h3>变量</h3><p>variables 变量是存储数据的容器。变量的值可以再程序中被修改。</p><p>使用关键词 <code>var</code> 申明一个变量：</p><pre><code>var x = 10;
</code></pre><p>以上指令给变量 x <strong>分配</strong>数据 10。注意我们在此使用 <strong>assign 分配</strong>来描述这个过程，因为在 JavaScript 中等于号<code>=</code> 会调用 <code>assignment</code> operator 操作符，而不是 <code>equal to</code> operator 操作符。</p><p>变量名是大小写敏感的，也就是说 <code>name</code> 和 <code>Name</code> 是两个变量。</p><p>让我们输出一个变量值到浏览器：</p><pre><code>var x = 10;
document.write(x);</code></pre><p><strong>变量定义的基本原则：</strong></p><ul><li>首字符必须是这三者之一：字母，下划线<code>_</code>，<code>$</code> 符。后续字符可以是字母、数字，下划线或者 <code>&amp;</code></li><li>名称不能包含数学运算符或操作符</li><li>不能包含空格</li><li>不能使用特殊字符，如：# & % 等</li><li>不能使用连字符<code>-</code>，这是减法保留符</li></ul><h3>数据类型</h3><p>JavaScript 支持多种类型的数据：numbers, strings, arrays 等。</p><h4>number</h4><p>number 可以是整数或小数：</p><pre><code>var a = 10;
var b = 1.1;</code></pre><p>变量分配的数据类型可以任意修改，例如重新分配 a 的数据为 string 字符串：</p><pre><code>a = &quot;this is a strings&quot;;
</code></pre><h4>string</h4><p>使用 string 可以来存储及操作文本信息。使用引号来包裹内容，单引号<code>'</code> 或双引号<code>&quot;</code> 都可以：</p><pre><code>var a = 'marco';
var b = &quot;john&quot;;</code></pre><p>如果要在 string 内部使用也引号，可以通过内外使用不同的单双引号来实现，js 会自动区分：</p><pre><code>var a = &quot;this is a 'test'&quot;;
</code></pre><p>如果内外想要使用同一个引号形式可以在内部使用转义符 <code>\</code> 来实现：</p><pre><code>a = &quot;this \&quot;is\&quot; a \&quot;other\&quot; test&quot;;
</code></pre><p>转义符可以将特殊字符作为普通字符使用，也可以实现特殊功能，一些列表是常用的转码：<br><img src="https://blog.niekun.net/usr/uploads/2020/12/3151408178.png" alt="3.png" title="3.png"></p><p><strong>注意字符串的包裹分号需要前后统一，起始用了单引号结尾也必须使用单引号，否则会报错。</strong></p><h3>Boolean</h3><p>Boolean 只有两种结果：true 和 false。</p><p>如果你需要一种只有两种可能的结果的数据类型，就可以使用 Boolean：</p><pre><code>var isActive = true;</code></pre><p>注意 Boolean 类型的值如果是：0 (zero), null, undefined, empty string 则都是 false，其他如果有一个真实数据的都为 true。</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/1979.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/1979.html</wfw:commentRss>
</item>
<item>
<title>nextcloud 安装教程</title>
<link>https://blog.niekun.net/archives/1904.html</link>
<guid>https://blog.niekun.net/archives/1904.html</guid>
<pubDate>Wed, 11 Nov 2020 10:42:14 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[安装包：https://nextcloud.com/changelog/#latest20系统需求：https://docs.nextcloud.com/server/20/admin_manu...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>安装包：<a href="https://nextcloud.com/changelog/#latest20">https://nextcloud.com/changelog/#latest20</a><br>系统需求：<a href="https://docs.nextcloud.com/server/20/admin_manual/installation/system_requirements.html">https://docs.nextcloud.com/server/20/admin_manual/installation/system_requirements.html</a><br>nginx 配置：<a href="https://docs.nextcloud.com/server/18/admin_manual/installation/nginx.html">https://docs.nextcloud.com/server/18/admin_manual/installation/nginx.html</a><br>php 配置相关：<a href="https://docs.nextcloud.com/server/20/admin_manual/installation/source_installation.html#php-fpm-tips-label">https://docs.nextcloud.com/server/20/admin_manual/installation/source_installation.html#php-fpm-tips-label</a><br>修改 php 内存限制：<a href="https://www.chinaz.com/program/2011/1010/213048.shtml">https://www.chinaz.com/program/2011/1010/213048.shtml</a><br>安装 php 内存缓存：<a href="https://docs.nextcloud.com/server/15/admin_manual/configuration_server/caching_configuration.html">https://docs.nextcloud.com/server/15/admin_manual/configuration_server/caching_configuration.html</a><br>命令行安装：<a href="https://docs.nextcloud.com/server/stable/admin_manual/installation/command_line_installation.html">https://docs.nextcloud.com/server/stable/admin_manual/installation/command_line_installation.html</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/1904.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/1904.html</wfw:commentRss>
</item>
<item>
<title>子网-子网掩码-子网地址的含义解析</title>
<link>https://blog.niekun.net/archives/1885.html</link>
<guid>https://blog.niekun.net/archives/1885.html</guid>
<pubDate>Tue, 27 Oct 2020 22:32:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[互联网设备之间是通过分配给每台主机的 IP 地址实现访问的，当前是以 32 位 IPv4 地址作为标准。为了便于使用，每 8 位用点.来隔开，习惯使用十进制形式表示，如：192.168.88.3...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>互联网设备之间是通过分配给每台主机的 IP 地址实现访问的，当前是以 32 位 IPv4 地址作为标准。为了便于使用，每 8 位用点<code>.</code>来隔开，习惯使用十进制形式表示，如：192.168.88.3</p><pre><code>Decimal  192         168         88           3
Binary   11000000    10101000    01011000     00000011</code></pre><p>理论上可以分配 2 的 32 次方个 IP 地址。</p><!--more--><h3>子网</h3><p>IP 地址可以划分为多个子集，也就是子网。比如一个路由器上连接的设备就在一个子网系统下，每个设备分配的 IP 地址就是子网网段内的地址。</p><p>子网的优势是设备间的访问更加直接，内部设备不需要连接子网以外的网络就可以实现内部互通。管理员对子网内的维护也更加方便，不会影响子网外的网络。</p><p>子网的 IP 段是一个连续的区间，如：192.168.1.0～192.168.1.255，在这个子网内的主机分配的 IP 地址最后一段就在 0～255 之间，其中第一个 192.168.0.0 是子网地址，最后一个 192.168.1.255 是广播地址，这两个地址是默认占用的，不能分配给主机使用。</p><h3>子网掩码</h3><p>子网掩码是为了能更加方便清晰的表达子网网段范围而被使用的。</p><p>一个典型的子网掩码格式：<code>255.255.255.128</code>，写成二进制如下：<code>11111111.11111111.11111111.10000000</code></p><p>如果子网内的一个主机 IP 地址为：192.168.88.3，我们和子网掩码按位进行<code>与</code>操作：</p><pre><code>192.168.88.3     11000000    10101000    01011000    00000011
255.255.255.128  11111111    11111111    11111111    10000000
192.168.88.0     11000000    10101000    01011000    00000000</code></pre><p>最后一行是结果写成十进制为：192.168.88.0，这就是子网的第一个 IP 地址，也就是子网地址。</p><p>子网掩码内为<code>1</code>的位对应的 IP 位是子网的固定位，这些位在网段内是固定不变的，也就是以上示例中前 25 位 IP 地址都是子网固定位，后 7 位就是子网可分配的地址位，可分配的地址如下：</p><pre><code>192.168.88.0     1000000    10101000    01011000    00000000
192.168.88.127   1000000    10101000    01011000    01111111</code></pre><p>此子网网段 IP 就是：192.168.88.0～192.168.88.127，可分配给主机的地址为：192.168.88.1～192.168.88.126</p><p>子网完整的表述形式为：子网地址：192.168.88.0；子网掩码：225.225.225.128</p><p>也可以使用 CIDR 的形式描述：192.168.88.0/25，此方式更加简洁。关于 CIDR 的形式参考我的文章：<a href="https://blog.niekun.net/archives/399.html">https://blog.niekun.net/archives/399.html</a></p><p>子网掩码可分配位必须是连续的位，比如：必须是连续的32/31/30位为0，而不能是32/30位0，31位为1。所以子网掩码的可用编码就大大缩小的范围，比如固定位为前24位：255.255.255，后8位可用的编码方式只能在一下几种中选择：</p><pre><code>00000000    0
10000000    128
11000000    192
11100000    224
11110000    240
11111000    248
11111100    252
11111110    254
11111111    255</code></pre><p>以上就是子网系统的简单介绍。</p><h3>参考连接</h3><p><a href="https://www.ionos.com/digitalguide/server/know-how/subnetting-how-do-subnets-work/">Use subnetting to get the most out of your network</a><br><a href="https://www.ionos.com/digitalguide/server/know-how/broadcast-address/">What is a broadcast address and how does it work?</a><br><a href="https://blog.csdn.net/lihchweb/article/details/81226452">IP地址，子网掩码计算子网地址，广播地址，子网划分</a></p>
]]></content:encoded>
<slash:comments>1</slash:comments>
<comments>https://blog.niekun.net/archives/1885.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/1885.html</wfw:commentRss>
</item>
<item>
<title>Linux 下使用 OptiPNG 压缩图片</title>
<link>https://blog.niekun.net/archives/1666.html</link>
<guid>https://blog.niekun.net/archives/1666.html</guid>
<pubDate>Tue, 14 Jul 2020 17:25:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[最近越来也发现自己的博客加载图片变慢了，由于我很多教程是教 PS 的，会使用到很多图片和截图，所以影响尤其明显。每张图片小则 400Kb 大则 2-3Mb，对于网络浏览不太友好。可以直接在服务器...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>最近越来也发现自己的博客加载图片变慢了，由于我很多教程是教 PS 的，会使用到很多图片和截图，所以影响尤其明显。每张图片小则 400Kb 大则 2-3Mb，对于网络浏览不太友好。</p><p>可以直接在服务器上进行图片压缩，用到的工具是 OptiPNG。</p><p>OptiPNG home page：<a href="http://optipng.sourceforge.net/">http://optipng.sourceforge.net/</a></p><!--more--><h3>编译安装</h3><p>我选择从源码编译安装，这样可以直接使用最新版本。</p><p><strong>如何从源码编译程序可以参考我的文章</strong>：<a href="https://blog.niekun.net/archives/883.html">https://blog.niekun.net/archives/883.html</a></p><p>首先从官网下载源码到 vps 并解压：</p><pre><code>cd /tmp
wget http://prdownloads.sourceforge.net/optipng/optipng-0.7.7.tar.gz
tar xvf optipng-0.7.7.tar.gz
</code></pre><p>新建安装路径：</p><pre><code>mkdir /opt/optipng-0.7.7
ln -s /opt/optipng-0.7.7 /opt/optipng
</code></pre><p>configure & make：</p><pre><code>cd /tmp/optipng-0.7.7
./configure --prefix=/opt/optipng-0.7.7
make
make install
</code></pre><p>测试是否可以执行：</p><pre><code>/opt/optipng/bin/optipng
</code></pre><p>创建系统链接：</p><pre><code>ln -s /opt/optipng/bin/optipng /usr/local/bin/optipng
</code></pre><h3>使用</h3><p>可以使用命令查看处理前处理后的图片体积：</p><pre><code>ls -lh a.png
</code></pre><p>压缩一张 png 图片：</p><pre><code>optipng a.png
</code></pre><p>压缩目录下的所有 png 图片：</p><pre><code>optipng *.png
</code></pre><p>可以自定义压缩等级：</p><pre><code>Optimization levels:
    -o0         &lt;=&gt;     -o1 -nx -nz                             (0 or 1 trials)
    -o1         &lt;=&gt;     -zc9 -zm8 -zs0 -f0                      (1 trial)
                (or...) -zc9 -zm8 -zs1 -f5                      (1 trial)
    -o2         &lt;=&gt;     -zc9 -zm8 -zs0-3 -f0,5                  (8 trials)
    -o3         &lt;=&gt;     -zc9 -zm8-9 -zs0-3 -f0,5                (16 trials)
    -o4         &lt;=&gt;     -zc9 -zm8 -zs0-3 -f0-5                  (24 trials)
    -o5         &lt;=&gt;     -zc9 -zm8-9 -zs0-3 -f0-5                (48 trials)
    -o6         &lt;=&gt;     -zc1-9 -zm8 -zs0-3 -f0-5                (120 trials)
    -o7         &lt;=&gt;     -zc1-9 -zm8-9 -zs0-3 -f0-5              (240 trials)
    -o7 -zm1-9  &lt;=&gt;     -zc1-9 -zm1-9 -zs0-3 -f0-5              (1080 trials)
Notes:
    The combination for -o1 is chosen heuristically.
    Exhaustive combinations such as &quot;-o7 -zm1-9&quot; are not generally recommended.
Examples:
    optipng file.png                                            (default speed)
    optipng -o5 file.png                                        (slow)
    optipng -o7 file.png                                        (very slow)</code></pre>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/1666.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/1666.html</wfw:commentRss>
</item>
<item>
<title>使用 echo 模块输出 nginx 变量</title>
<link>https://blog.niekun.net/archives/1489.html</link>
<guid>https://blog.niekun.net/archives/1489.html</guid>
<pubDate>Mon, 30 Mar 2020 15:43:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[最近在学习 nginx 的反向代理，在处理请求和响应的时候，需要处理 header 头信息用到了很多 nignx 变量，但是在传递给代理服务器时，我不知道我设置的 proxy_set_heade...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>最近在学习 nginx 的反向代理，在处理请求和响应的时候，需要处理 header 头信息用到了很多 nignx 变量，但是在传递给代理服务器时，我不知道我设置的 proxy_set_header 等信息是否设置正确，以及其他用到的变量到底当前值是多少我也不知道。调试起来很费劲。</p><p>发现一个第三方 nginx 模块：<strong>echo</strong>，可以方便的输出信息，利用这一模块可以实现变量值读取到 html，调试方便了很多。</p><p>echo GitHub 主页：<a href="https://github.com/openresty/echo-nginx-module">https://github.com/openresty/echo-nginx-module</a></p><!--more--><h3>编译</h3><p>echo 模块需要从源码编译 nginx 时使用指令：<code>--add-module=</code> 加入，源码编译 nginx 及加入第三方模块参考我的教程：<a href="https://blog.niekun.net/archives/30.html">Nginx 安装/编译教程</a></p><h3>使用</h3><p>echo 使用命令很简单：</p><pre><code>server{
    listen 80;
    server_name 127.0.0.1;

    location /echo {
        default_type text/plain;
        echo 'remote address: $remote_addr';
        echo 'remote_port: $remote_port';
    }
}</code></pre><p>default_type text/plain 指令设置响应内容的格式，不设置的话浏览器访问会返回下载文件而不是网页。</p><p>执行 <code>curl 127.0.0.1/echo</code> 或浏览器访问 127.0.0.1/echo 路径就会看到 echo 定义的内容。</p><p>**注意如果在 echo 指令下面定义了其他 html 页面或者 proxy_pass 反向代理，则 echo 的内容会被覆盖，如果 echo 指令在 <br> location 段的最后，则会显示 echo 指令的内容。**</p>
]]></content:encoded>
<slash:comments>1</slash:comments>
<comments>https://blog.niekun.net/archives/1489.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/1489.html</wfw:commentRss>
</item>
<item>
<title>NGINX Reverse Proxy 反向代理的使用</title>
<link>https://blog.niekun.net/archives/1378.html</link>
<guid>https://blog.niekun.net/archives/1378.html</guid>
<pubDate>Mon, 30 Mar 2020 11:05:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[Proxying is typically used to distribute the load among several servers, seamlessly show content ...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<blockquote>Proxying is typically used to distribute the load among several servers, seamlessly show content from different websites, or pass requests for processing to application servers over protocols other than HTTP.</blockquote><p>nginx 可以将一个客户端的请求反向代理到其他地址/端口，从客户端上看不到代理过程。方向代理的常用来处理服务器上部署的多个网络服务，根据请求呈现不同网页内容，转发请求到其他应用程序等。支持转发的协议有： <strong> HTTP，FastCGI, uwsgi, SCGI, and memcached。</strong></p><p>不同于 nginx 的重定向 return/rewrite/try_fiels 功能，反向代理对于客户端是不可见的，关于重定向的语法参考：<a href="https://blog.niekun.net/archives/195.html">https://blog.niekun.net/archives/195.html</a></p><p>下面介绍 ngx_http_proxy_module 模块的使用方式。</p><!--more--><h3>语法</h3><p>proxy_pass 指令将请求转发到其他代理服务器。</p><p>转发一个 http 请求到另一个地址：</p><pre><code>location /some/path/ {
    proxy_pass http://www.example.com/link/;
}</code></pre><p>以上示例将访问 location 段的请求转发到特定地址，这里有几个规则需要注意：</p><p>1.代理地址如果不写明 location 段，则转发请求 location 到新的地址：</p><pre><code>location /some/path/ {
    proxy_pass http://www.example.com;
}</code></pre><p>以上规则下，访问 /some/path/.test.html 时，会转发到 <a href="http://www.example.com/some/path/.test.html">http://www.example.com/some/path/.test.html</a></p><pre><code>location ~ \.php {
    proxy_pass http://127.0.0.1:8000;
}</code></pre><p>以上规则下，访问 /some/path/test.php 时，会转发到 127.0.0.1:8000/some/path/test.php</p><p>2.代理地址包含新的 location 时会替换掉请求 location 部分：</p><pre><code>location /some/path/ {
    proxy_pass http://www.example.com/new/;
}</code></pre><p>以上规则下，访问 /some/path/test.html 时，会转发到 <a href="http://www.example.com/new/test.html">http://www.example.com/new/test.html</a>，注意 <a href="http://www.example.com/">http://www.example.com/</a> 和 <a href="http://www.example.com">http://www.example.com</a> 不同，也属于包含根路径 location 段的。</p><p>proxy_pass 语法用来转发给 http 服务，还支持转发给其他协议的服务：</p><ul><li>fastcgi_pass 转发给 FastCGI server 如 php 服务</li><li>uwsgi_pass 转发给 uwsgi server 如 python 服务</li><li>scgi_pass 转发给 SCGI server</li><li>memcached_pass 转发给 memcached server</li></ul><p>转发的服务地址可以用一个 <strong>upstream</strong> 组来实现负载均衡：</p><pre><code>http {
    upstream backend {
        server backend1.example.com;
        server backend2.example.com;
        server 192.0.0.1 backup;
    }
    
    server {
        ...
        location / {
            proxy_pass http://backend;
        }
    }
}</code></pre><p>以上是一个简单的负载均衡代理转发示例。关于 upstream 详细使用参考<a href="https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/">官方教程</a></p><h3>proxy_redirect 响应头 location/refresh 重定向</h3><p>当上游服务器返回的响应是重定向或刷新请求（如HTTP响应码是301或者302）时，proxy_redirect可以重设HTTP头部的location/Refresh 字段。</p><p>语法结构：</p><pre><code>proxy_redirect default;
proxy_redirect off;
proxy_redirect redirect replacement;
</code></pre><p>默认设置是：proxy_redirect default。</p><p>http 响应头的 location 段 HTTP Location 是在两种情况使用在响应头中：</p><ul><li>要求网页浏览器加载其他网页(域名转址)。在这种情况下，应该使用HTTP状态码3xx发送Location头。</li><li>提供有关新创建资源位置的信息。在这种情况下，应该使用HTTP状态码201或202发送Location头。</li></ul><p>通过修改 location 可以让客户端接收到响应后，访问重定向到新的 location。</p><p>更详细的关于重定向/刷新请求头概念，需要理解 http 协议的结构，查看我的教程：<a href="https://blog.niekun.net/archives/1432.html">HTTP 协议结构</a></p><p>如果设置：<br>server {</p><pre><code>listen 8080;
servername frontend;

proxy_redirect http://localhost:8000/two/ http://frontend:8080/one/;
...</code></pre><p>}</p><p>代理服务器返回的 http 头信息：</p><pre><code>HTTP/1.1 302 Found
Location: http://localhost:8000/two/some/uri/
</code></pre><p>则返回给客户端的 Location 段被重写为: <a href="http://frontend">http://frontend</a>:8080/one/some/uri/，客户端接收到后就会去重新访问这个新的地址。</p><p>server 名也可以被省略：</p><pre><code>proxy_redirect http://localhost:8000/two/ /
</code></pre><p>以上指令返回给客户端的 Location 段被重写为: <a href="http://frontend">http://frontend</a>:8080/some/uri/</p><p>proxy_redirect 默认设置值为：<strong>default</strong>，它会自动根据 server location 段和 proxy_pass 地址来修改头信息，以下两种写法效果一样：</p><pre><code>location /one/ {
    proxy_pass     http://localhost:8000/two/;
    proxy_redirect default;

location /one/ {
    proxy_pass     http://localhost:8000/two/;
    proxy_redirect http://localhost:8000/two/ /one/;</code></pre><p>以上两种写法都是将返回 location 头信息中 <a href="http://localhost">http://localhost</a>:8000/two/ 修改为 <a href="http://frontend">http://frontend</a>:8080/one/</p><p>redirect 和 replacement 都可以包含参数：</p><pre><code>proxy_redirect http://$proxy_host:8000/ $scheme$host:$server_port/;
</code></pre><p>rederect 可以使用正则匹配：</p><pre><code>proxy_redirect ~^(http://[^:]+):\d+(/.+)$ $1$2;
proxy_redirect ~*/user/([^/]+)/(.+)$      http://$1.example.com/$2;
</code></pre><p>可以同时写多个 proxy_redirect 指令来处理不同的重定向地址。<br>使用 proxy_redirect off 具有最高优先级，会取消当前同一级的所有 proxy_redirect 指令。</p><p>一个完整例子：</p><pre><code>server {
    listen           8080;
    server_name      127.0.0.1;

    location /return {
        return 301 https://niekun.net;
    }
    location /proxy {
        proxy_pass  $scheme://$http_host/return;
        proxy_redirect https://niekun.net /echo;
    }
    location /echo {
        default_type text/plain;
        echo 'remote address: $remote_addr';
    }
}</code></pre><p><strong>代理过程：</strong></p><ul><li>客户端访问：<a href="http://127.0.0.1">http://127.0.0.1</a>:8080/proxy</li><li>nginx 转发到：<a href="http://127.0.0.1">http://127.0.0.1</a>:8080/return</li><li>代理服务器响应 301 重定向到：<a href="https://niekun.net">https://niekun.net</a>，http 头的 location 值为：<a href="https://niekun.net">https://niekun.net</a></li><li>nginx 将 http 头的 location 修改为：<a href="http://127.0.0.1">http://127.0.0.1</a>:8080/echo</li><li>nginx 将修改后的响应内容发送给客户端</li><li>客户端根据响应再次访问：<a href="http://127.0.0.1">http://127.0.0.1</a>:8080/echo</li></ul><h3>转发请求头信息</h3><p>默认情况下，nginx 反向代理时会舍弃<strong>原始请求头中的空字符串项</strong>，并重新设定两个请求头内容：<strong>Host</strong> 和 <strong>Connection</strong>：</p><ul><li>Host -&gt; $proxy_host  也就是 proxy_pass 里的 host</li><li>Connection -&gt; close</li></ul><p>关于 http 请求头 header 的可定义的项目参考我的教程：<a href="https://blog.niekun.net/archives/1432.html">HTTP 协议结构</a></p><p>想要设置或修改传递给代理服务的请求头，使用 proxy_set_header 指令：</p><pre><code>location /some/path/ {
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header Accept-Encoding &quot;&quot;;
    proxy_pass http://localhost:8000;
}</code></pre><p>以上示例的处理结果是：</p><ul><li>设置 Host 为本 server 的host 地址而不是转发地址</li><li>设置 X-Real-IP 为客户端 IP 地址，用来识别访问服务的客户信息</li><li>清空 Accept-Encoding 的内容</li></ul><h3>mapping headers 动态请求头内容</h3><p>proxy_set_header 支持使用内部变量来定义，也可以使用 map 指令配合自定义参数来根据请求清空动态设置相关 header 内容，注意 map 指令要写在 http 段：</p><pre><code>map $http_cloudfront_forwarded_proto $cloudfront_proto {
    default &quot;http&quot;;
    https &quot;https&quot;;
}
server {
    ...
    location / {
        proxy_set_header X-Forwarded-Proto $cloudfront_proto;
        proxy_pass http://app;
        proxy_redirect off;
        ...
    }
}</code></pre><p>以上示例中 <code>$http_cloudfront_forwarded_proto</code> 是已知变量，<code>$cloudfront_proto</code> 是我自定义的变量，使用 map 指令来根据前者的值设置后者的值，然后在 proxy_set_header 设置。</p><p>map 指令支持以两个因变量来给终变量赋值,语法示例如下：</p><pre><code>map &quot;$http_cloudfront_forwarded_proto:$http_x_forwarded_proto&quot; $cloudfront_proto {
    default &quot;http&quot;;
    &quot;:https&quot; &quot;https&quot;;
    &quot;https:&quot; &quot;https&quot;;
    &quot;https:http&quot; &quot;https&quot;;
    &quot;http:https&quot; &quot;https&quot;;
    &quot;https:https&quot; &quot;https&quot;;
}</code></pre><p>如果用户访问时加了代理或者网站有 CDN，$remote_addr 的值就不是用户真实 IP 了。客户端也可以伪造 X-Forwarded-For 信息，使用 map 指令提取用户真实 IP，注意 map 指令要写在配置文件的 http 段：</p><pre><code>map $http_x_forwarded_for  $client_real_ip {
    default                         $remote_addr;
    ~^(([0-9\.]+),\s?)*([0-9\.]+)$  $3;
}

server {
    echo 'remote address: $client_real_ip';
}</code></pre><p>如果 $http_x_forwarded_for 没有匹配到则赋值为 $remote_addr，如果匹配到了则提取最后一个 IP。$client_real_ip 变量就是真是客户端的 IP 地址。</p><p>关于 $http_x_forwarded_for 和 $proxy_add_x_forwarded_for 参考我的文章：<a href="https://blog.niekun.net/archives/1296.html">获取用户真实 IP in Nginx</a></p><h3>buffers 缓存区</h3><p>默认情况下 nginx 缓存来自 proxy server 的响应内容。nginx 会一直在内部缓存来自代理服务器的响应内容直到内容接收完成，然后才发送给客户端。缓存能够帮助减轻客户端的压力，但会浪费服务器的资源和响应。但是打开缓存功能的另一个好处是当客户端再次进行一个缓存过的请求时，nginx 可以快速的返回已经在缓存区的内容。</p><p>使用 proxy_buffering 指令控制缓存打开/关闭。默认是 on 状态。proxy_buffers 指令控制缓存区数量和缓存大小。第一个来自代理服务器的响应会缓存到单独的区域，proxy_buffer_size 指令控制这一区域的大小：</p><pre><code>location /some/path/ {
    proxy_buffers 16 4k;
    proxy_buffer_size 2k;
    proxy_pass http://localhost:8000;
}</code></pre><p>以上示例会给 来自代理服务器：<a href="http://localhost">http://localhost</a>:8000 的响应建立 16 个缓存区，每个区域 4kb 空间，第一个响应缓存区 2kb 空间。</p><p>如果关闭缓存，来自代理服务器的响应会即时发送给客户端，对于想要快速响应的使用场景可以关闭缓存：</p><pre><code>location /some/path/ {
    proxy_buffering off;
    proxy_pass http://localhost:8000;
}</code></pre><h3>设置出口 IP 地址</h3><p>默认情况下 nginx 向 proxy 上游发起请求连接，代理服务器看到的请求 IP 地址来自 nignx 服务器地址。有时候 web 服务器会设置只允许特定 IP 地址的访问，可以通过 proxy_bind 指令来修改，<strong>nginx 用户必须是 root 才行</strong>：</p><pre><code>user root;
...
http{
    ...
    server {
        location /app1/ {
            proxy_bind proxy_bind $remote_addr transparent;
            proxy_pass http://example.com/app1/;
        }
    }
}</code></pre><p>以上示例中，代理服务器看到的请求来源就会是真正的访问客户端 IP 地址,也就是实现了<strong>透明代理</strong>。</p><p>nginx 配置后还需要配置 iptables 路由表来处理代理服务器响应内容：</p><ul><li>新建一个链，把过来的tcp包都打上标记。</li><li>新建一个路由表100，让有标记的包都走表100。</li><li>在路由表100加入一个默认路由，把所有包都扔到lo网卡上去。</li></ul><pre><code>      #### 新建一个 DIVERT 给包打标签
     sudo iptables -t mangle -N DIVERT;
     sudo iptables -t mangle -A DIVERT -j MARK --set-mark 1;
     sudo iptables -t mangle -A DIVERT -j ACCEPT;

     #### 把tcp的包给DIVERT处理
     sudo iptables -t mangle -A PREROUTING -p tcp -m socket -j DIVERT;

     #### 有标签的包去查名为 100 的路由表
     sudo ip rule add fwmark 1 lookup 100

     #### 100的路由表里就一条默认路由，把所有包都扔到lo网卡上去
     sudo ip route add local 0.0.0.0/0 dev lo table 100;</code></pre><p>具体实现我还不太懂，后期再研究下。</p><p>以上就是 http 代理服务器基本使用，下面简单介绍其他集中代理服务器的语法。</p><h3>fastcgi 代理服务器</h3><p>Nginx must rely on a separate PHP processor to handle PHP requests. Most often, this processing is handled with php-fpm, a PHP processor that has been extensively tested to work with Nginx.</p><p>简单说就是 FastCGI 实现了使用 Nginx 代理 php 请求的过程，将请求转发给 php-fpm：php 进程管理器。</p><pre><code>location / {
    fastcgi_pass  localhost:9000;
    # fastcgi_pass unix:/run/php/php7.3-fpm.sock;
    fastcgi_index index.php;
    
    fastcgi_split_path_info ^(.+?\.php)(.*)$;
    try_files $fastcgi_script_name =404;
    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
    include fastcgi_params;

    fastcgi_param HTTP_X-REAL-IP $remote_addr;
    fastcgi_param HTTP_X-FORWARED-FOR $proxy_add_x_forwarded_for;
    fastcgi_param HOST $http_host;
}</code></pre><ul><li>$fastcgi_split_path_info 用来将 请求 url 拆分成两部分：php 文件之前的 $fastcgi_script_name 和之后的部分：$fastcgi_path_info</li><li>fastcgi_pass 定义真正的用来处理 FastCGI 代理的服务，一般默认地址为：127.0.0.1:9000，可自定义指定为特定版本的php</li><li>fastcgi_param 定义 FastCGI 参数</li><li>fastcgi_params 一般在 nginx 配置目录下，包含了常用的 php 需要设定的参数。</li></ul><p>总结下和 http 语法区别：</p><ul><li>fastcgi_pass 类似于 proxy_pass</li><li>fastcgi_param  类似于 proxy_set_header，注意 fastcgi_param 添加 http 请求头信息要加上 <code>HTTP_</code> 前缀，如：<code>HTTP_X-FORWARED-FOR</code></li></ul><p>关于 FastCGI 的详细分析参考：<a href="https://www.digitalocean.com/community/tutorials/understanding-and-implementing-fastcgi-proxying-in-nginx">Understanding and Implementing FastCGI Proxying in Nginx</a></p><h3>uWSGI web 服务器</h3><p>uWSGI 是一个独立的 web 服务器，和 nginx 是一个类型的应用。一般 uWSGI 作为后端服务器使用，用 nginx 代理来访问。</p><p>uWSGI 可以用来部署 python 应用。之前我学习 django 的时候就使用过这个。</p><p>未完待续。。。</p><h3>参考链接</h3><p><a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html">ngx_http_proxy_module 模块所有指令</a><br><a href="https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/">NGINX Reverse Proxy</a><br><a href="https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/">HTTP Load Balancing</a><br><a href="https://docs.nginx.com/nginx/admin-guide/security-controls/securing-http-traffic-upstream/">Securing HTTP Traffic to Upstream Servers</a><br><a href="https://pengpengxp.github.io/archive/before-2018-11-10/2017-06-27-%E4%BD%BF%E7%94%A8nginx%E7%9A%84proxy_bind%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%E9%80%8F%E6%98%8E%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.html">使用nginx的proxy_bind选项配置透明的反向代理</a><br><a href="https://serversforhackers.com/c/nginx-mapping-headers">Mapping Headers in Nginx</a><br><a href="https://nginx.org/en/docs/http/ngx_http_fastcgi_module.html#fastcgi_pass">ngx_http_fastcgi_module 模块所有指令</a><br>[]()</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/1378.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/1378.html</wfw:commentRss>
</item>
<item>
<title>百度云网盘直链获取及下载</title>
<link>https://blog.niekun.net/archives/1443.html</link>
<guid>https://blog.niekun.net/archives/1443.html</guid>
<pubDate>Fri, 27 Mar 2020 11:46:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[众所周知，现在百度盘非会员下载速度十分慢，还要求必须使用他的客户端下载，我的资料现在也基本不会存在百度云了。但是在下载已经保存在上面的资源或者网络别人分享的资源，还是偶尔要用到，而我又对百度十分...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p><img src="https://blog.niekun.net/usr/uploads/2020/03/1366780471.png" alt="2020-03-27T01:40:28.png" title="2020-03-27T01:40:28.png"><br>众所周知，现在百度盘非会员下载速度十分慢，还要求必须使用他的客户端下载，我的资料现在也基本不会存在百度云了。但是在下载已经保存在上面的资源或者网络别人分享的资源，还是偶尔要用到，而我又对百度十分的讨厌，也不会去充值会员，所以研究了下如何解决非会员的限速问题。</p><!--more--><h3>BaiduPCS-Go</h3><p>BaiduPCS-Go 是我之前一直使用的工具，他是 GO 语言编写的命令行工具，需要登录你的账号使用，集成下载/上传等功能。就是一个第三方命令行客户端。</p><p>他可以设置<strong>缓存/并发数/user agent</strong>等，理论上可以加速下载。</p><p>GitHub 主页(作者已删除)：<a href="https://github.com/iikira/BaiduPCS-Go">https://github.com/iikira/BaiduPCS-Go</a><br>fork：<a href="https://github.com/Erope/BaiduPCS-Go">https://github.com/Erope/BaiduPCS-Go</a></p><p>可以下载 release 页面发布的版本，也可以使用源码自己编译，go 语言编译教程参考我的文章：<a href="https://blog.niekun.net/archives/468.html">https://blog.niekun.net/archives/468.html</a></p><p>打开 BaiduPCS-Go 客户端，进入命令行界面，登录完成后可以输入 <code>help</code> 指令查看支持的命令。</p><pre><code>----
  BaiduPCS-Go - 百度网盘客户端 for windows/amd64

USAGE:
  BaiduPCS-Go.exe [global options] command [command options] [arguments...]

VERSION:
  v3.6.1-devel

DESCRIPTION:
  BaiduPCS-Go 使用Go语言编写的百度网盘命令行客户端, 为操作百度网盘, 提供实用功能.
  具体功能, 参见 COMMANDS 列表

  特色:
    网盘内列出文件和目录, 支持通配符匹配路径;
    下载网盘内文件, 支持网盘内目录 (文件夹) 下载, 支持多个文件或目录下载, 支持断点续传和高并发高速下载.

  ---------------------------------------------------
  前往 https://github.com/iikira/BaiduPCS-Go 以获取更多帮助信息!
  前往 https://github.com/iikira/BaiduPCS-Go/releases 以获取程序更新信息!
  ---------------------------------------------------

  交流反馈:
    提交Issue: https://github.com/iikira/BaiduPCS-Go/issues
    邮箱: i@mail.iikira.com

AUTHOR:
  iikira/BaiduPCS-Go: https://github.com/iikira/BaiduPCS-Go

COMMANDS:
    tool           工具箱
    help, h, ?, ？  Shows a list of commands or help for one command
  其他:
    bg           管理后台任务
    clear, cls   清空控制台
    env          显示程序环境变量
    run          执行系统命令
    sumfile, sf  获取本地文件的秒传信息
    update       检测程序更新
  百度帐号:
    login    登录百度账号
    loglist  列出帐号列表
    logout   退出百度帐号
    su       切换百度帐号
    who      获取当前帐号
  百度网盘:
    cd                      切换工作目录
    cp                      拷贝文件/目录
    createsuperfile, csf    手动分片上传—合并分片文件
    download, d             下载文件/目录
    export, ep              导出文件/目录
    fixmd5                  修复文件MD5
    locate, lt              获取下载直链
    ls, l, ll               列出目录
    match                   测试通配符
    meta                    获取文件/目录的元信息
    mkdir                   创建目录
    mv                      移动/重命名文件/目录
    offlinedl, clouddl, od  离线下载
    pwd                     输出工作目录
    quota                   获取网盘配额
    rapidupload, ru         手动秒传文件
    recycle                 回收站
    rm                      删除文件/目录
    search, s               搜索文件
    share                   分享文件/目录
    tree, t                 列出目录的树形图
    upload, u               上传文件/目录
  配置:
    config  显示和修改程序配置项

GLOBAL OPTIONS:
  --verbose      启用调试 [%BAIDUPCS_GO_VERBOSE%]
  --help, -h     show help
  --version, -v  print the version

COPYRIGHT:
  (c) 2016-2019 iikira.</code></pre><p>执行 <code>login</code> 指令，登录百度账户，根据提示输入密码及验证码。</p><p>登录完成后可以使用 <code>ls</code> <code>cd</code> 等命令来访问目录及文件。</p><p>执行 <code>config</code> 命令查看当前配置信息：</p><pre><code>运行 BaiduPCS-Go config set 可进行设置配置

当前配置:
  名称                 值             描述                                             建议值                                                                                                                     
  appid             421937       百度 PCS 应用ID
  cache_size      256.00KB      下载缓存, 如果硬盘占用高或下载速度慢, 请尝试 调大此值     1KB ~ 256KB                                                                                                                
  max_parallel         64       下载最大并发量                                         50 ~ 500                                                                                                                   
  max_upload_parallel  64       上传最大并发量                                         1 ~ 100                                                                                                                    
  max_download_load    3         同时进行下载文件的最大数                               1 ~ 5                                                                                                                      
  max_download_rate    不限制    限制最大下载速度, 0代表不限制
  max_upload_rate      不限制    限制最大上传速度, 0代表不限制
  savedir      C:\Users\Marco Nie\Downloads          下载文件的储存目录
  enable_https         true      启用 https                                             true                                                                                                                       
  user_agent           Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36  Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36      浏览器标识
  pcs_ua                         PCS 浏览器标识
  pan_ua     netdisk;2.2.51.6;netdisk;10.0.63;PC;android-android    Pan 浏览器标识    netdisk;2.2.51.6;netdisk;10.0.63;PC;android-android                 
  proxy                         设置代理, 支持 http/socks5 代理
  local_addrs                   设置本地网卡地址, 多个地址用逗号隔开</code></pre><p>执行 <code>config set --名称=value</code> 可以修改设置值。</p><p>下载指令是 <code>d file_name</code>。</p><p>我当前使用 BaiduPCS-Go 速度非常慢，在下载时使用参数 --verbose 和 --status 查看详细信息，发现链接都是错误的，经过查询发现可能是 appid 的问题，我的账号可能上了黑名单了，需要修改 appid 来修复。</p><p>找了半天网上提供的 appid 都没法用，这个 python 小程序可以扫描可用的 appid：<a href="https://gist.github.com/pcmid/5818b1165bc3f5f2088e19299278a613">https://gist.github.com/pcmid/5818b1165bc3f5f2088e19299278a613</a></p><pre><code>from __future__ import print_function

import requests
import threading

import sys


def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)


class GetterTread(threading.Thread):
    def __init__(self, thread_id, app_id, times=1000):
        threading.Thread.__init__(self)

        self.__thread_id = thread_id

        self.__URL = &quot;http://pcs.baidu.com/rest/2.0/pcs/file?app_id={}&amp;method=list&amp;path=%2F&quot;

        with open(&quot;./BDUSS.txt&quot;) as f:
            BDUSS = f.readline()
            self.__COOKIES = {&quot;BDUSS&quot;: BDUSS}

        self.app_id = app_id
        self.times = times

    def run(self):
        current_id = self.app_id
        while current_id - self.app_id &lt; self.times:  # 250000:
            url = self.__URL.format(current_id)

            try:
                r = requests.get(url, cookies=self.__COOKIES)
                if r.status_code == 200:
                    print(current_id)
            except Exception:
                eprint(&quot;Exception: &quot; + str(current_id))

            current_id += 1
            # print(&quot;id &quot; + str(self.__thread_id) + &quot; over&quot;)


if __name__ == '__main__':

    start_app_id = 300000
    times = 1000

    threads_list = []

    while start_app_id &lt; 500000:
        thread = GetterTread(start_app_id, start_app_id, times)
        thread.start()
        threads_list.append(thread)
        start_app_id += times

    # print(&quot;size: &quot; + str(len(threads_list)))

    for thread in threads_list:
        thread.join()</code></pre><p>需要在目录下放一个 BDUSS.txt，里面填上你的账号的 BDUSS <a href="https://github.com/iikira/BaiduPCS-Go/wiki/%E5%85%B3%E4%BA%8E-%E8%8E%B7%E5%8F%96%E7%99%BE%E5%BA%A6-BDUSS">获取 BDUSS 的方法参考</a></p><h3>网盘直链下载助手</h3><p>BaiduPCS-Go 慢慢失效后，我开始找寻其他的有效方法，发现有一个网盘直链下载助手挺好用的。</p><p>官网：<a href="https://www.baiduyun.wiki/">https://www.baiduyun.wiki/</a><br>GitHub 主页：<a href="https://github.com/syhyz1990/baiduyun">https://github.com/syhyz1990/baiduyun</a></p><p>这是一个油猴脚本，需要在 chrome 安装 Tampermonkey 脚本管理器，在 chrome <a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo?hl=en-US">安装 tampermonkey</a></p><p>安装好管理器后，访问 <a href="https://github.com/syhyz1990/baiduyun/raw/master/baiduyun.user.js">GitHub脚本</a>，会自动跳转到 tampermonkey 安装界面，然后点击安装即可。</p><p>进入百度云盘，会出现一个下载助手按钮：<br><img src="https://blog.niekun.net/usr/uploads/2020/03/455780567.png" alt="2020-03-27T03:20:35.png" title="2020-03-27T03:20:35.png"></p><p>勾选想要下载的资源，点击下载助手，里面有几个选项：<br><img src="https://blog.niekun.net/usr/uploads/2020/03/1769818541.png" alt="2020-03-27T03:21:20.png" title="2020-03-27T03:21:20.png"></p><p>第一个是直接获取 api 下载链接，可以在浏览器或其他下载软件粘贴链接即可下载：<br><img src="https://blog.niekun.net/usr/uploads/2020/03/1015860586.png" alt="2020-03-27T03:22:18.png" title="2020-03-27T03:22:18.png"></p><p>第二个是 aria2 下载链接，可以导入 aria2 进行下载，关于 aria2 的安装参考我的教程：<a href="https://blog.niekun.net/archives/1199.html">https://blog.niekun.net/archives/1199.html</a></p><p>安装好 aria2 后还需要安装<strong>网盘万能助手</strong> chrome 插件才能使用这个功能。插件地址：<a href="https://www.baiduyun.wiki/download.html">https://www.baiduyun.wiki/download.html</a></p><p>插件安装步骤：</p><ul><li>下载好 zip 包后解压到文件夹</li><li>chrome 访问：chrome://extensions/ 右边打开 develop mode，点击 load unpacked 打开解压的文件夹就自动安装了</li><li>关闭 develop mode</li><li>重启浏览器</li></ul><p>第三个是远程 aria2 rpc 下载，也是需要安装 aria2 并启用 rpc，然后点击 rpc 配置，设置参数：<br><img src="https://blog.niekun.net/usr/uploads/2020/03/3217135409.png" alt="2020-03-27T03:24:48.png" title="2020-03-27T03:24:48.png"></p><p>点击显示链接可以直接发送到 aria2：<br><img src="https://blog.niekun.net/usr/uploads/2020/03/701382724.png" alt="2020-03-27T03:25:32.png" title="2020-03-27T03:25:32.png"></p><p>下载客户端推荐：<br>aria2：<a href="https://blog.niekun.net/archives/1199.html">https://blog.niekun.net/archives/1199.html</a><br>IDM：<a href="https://www.internetdownloadmanager.com/">https://www.internetdownloadmanager.com/</a> 可以设置最大链接数到 32 来提高下载速度 download - option - connection<br>xdown：<a href="https://xdown.org/">https://xdown.org/</a> 可以识别 aria2 的链接</p>
]]></content:encoded>
<slash:comments>1</slash:comments>
<comments>https://blog.niekun.net/archives/1443.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/1443.html</wfw:commentRss>
</item>
<item>
<title>HTTP 协议结构</title>
<link>https://blog.niekun.net/archives/1432.html</link>
<guid>https://blog.niekun.net/archives/1432.html</guid>
<pubDate>Tue, 24 Mar 2020 08:43:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[The Hypertext Transfer Protocol (HTTP) is an application protocol for distributed, collaborative,...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<blockquote>The Hypertext Transfer Protocol (HTTP) is an application protocol for distributed, collaborative, hypermedia information systems.[1] HTTP is the foundation of data communication for the World Wide Web, where hypertext documents include hyperlinks to other resources that the user can easily access, for example by a mouse click or by tapping the screen in a web browser.</blockquote><p>以上说明摘录自 Wikipedia，HTTP 全称为<strong>超文本传输协议</strong>，设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。通过HTTP或者HTTPS协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。</p><!--more--><h3>构成</h3><p>HTTP是一个客户端（用户）和服务端（网站）之间请求和应答的标准，通常使用TCP协议。有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS：<br><img src="https://blog.niekun.net/usr/uploads/2020/03/1755297292.png" alt="2020-03-24T00:48:01.png" title="2020-03-24T00:48:01.png"></p><p><strong>HTTP协议永远都是客户端发起请求，服务器回送响应。</strong><br><img src="https://blog.niekun.net/usr/uploads/2020/03/2181204214.png" alt="2020-03-24T00:50:21.png" title="2020-03-24T00:50:21.png"></p><p>HTTP是一个无状态的协议。协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。可以使用 <strong>connection: Keep-Alive</strong> 来保留 tcp 握手连接。</p><p><strong>一次HTTP操作称为一个事务，其工作过程可分为四步：</strong></p><ul><li>首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作开始。</li><li>建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URI）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。</li><li>服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。</li><li>客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。</li></ul><p>HTTP是基于传输层的TCP协议，而TCP是一个端到端的面向连接的协议。所谓的端到端可以理解为进程到进程之间的通信。所以HTTP在开始传输之前，首先需要建立TCP连接，而TCP连接的过程需要三次握手：<br><img src="https://blog.niekun.net/usr/uploads/2020/03/2093610890.png" alt="2020-03-24T00:54:05.png" title="2020-03-24T00:54:05.png"></p><p>可以使用 <strong>Wireshark</strong> 网络协议分析工具来查看一个握手过程：<a href="https://www.wireshark.org/">https://www.wireshark.org/</a></p><p>打开 Wireshark，点击 capture - options，上方选择当前连接外网的硬件，我选择 WiFi，在 capture filter 里设置监听地址：tcp port http:<br><img src="https://blog.niekun.net/usr/uploads/2020/03/2495975856.png" alt="2020-03-24T02:00:39.png" title="2020-03-24T02:00:39.png"></p><p>在浏览器访问：<a href="http://baidu.com">http://baidu.com</a>，记得如果使用了代理的话先关掉。</p><p>在 wireshark 里就会显示报文信息：<br><img src="https://blog.niekun.net/usr/uploads/2020/03/318072432.png" alt="2020-03-24T02:03:50.png" title="2020-03-24T02:03:50.png"></p><p>可以通过颜色区分报文种类，绿色是 tcp 报文，黑色是有问题的报文。如果报文过多可以使用上面的 filter 过滤有用信息。</p><p><strong>上面的报文显示了握手的过程：</strong></p><ul><li>前三个 tcp 连接分别是客户端发出连接请求，服务端回应客户端，客户端回应服务端确认</li><li><strong>然后客户端发起一个 http 页面 request 请求</strong></li><li>服务端发出 tcp 确认请求</li><li><strong>服务端发送 response http 数据 200 状态码</strong></li><li>客户端发出 tcp 确认</li></ul><p>下面主要分析 <strong>request</strong> 和 <strong>response</strong> 的 http 数据。</p><hr><h3>request 请求</h3><p>tcp 握手成功后，客户端就通过发送 request 开始请求 http 页面。</p><p><strong>发出的请求信息（message request）结构如下:</strong></p><ul><li>请求行（例如GET /images/logo.gif HTTP/1.1，表示从/images目录下请求logo.gif这个文件）</li><li>请求头（例如Accept-Language: en）</li><li>空行</li><li>其他消息体</li></ul><p>请求行和标题必须以<code>&lt;CR&gt;&lt;LF&gt;</code>作为结尾。空行内必须只有<code>&lt;CR&gt;&lt;LF&gt;</code>而无其他空格。在HTTP/1.1协议中，所有的请求头，除Host外，都是可选的。</p><p>一个最简单的 request：</p><pre><code>GET / HTTP/1.1
Host: www.bing.com</code></pre><p>末尾有一个空行。第一行指定方法、资源路径、协议版本；第二行是在1.1版里必带的一个header作用于指定主机。</p><p>上面访问 <a href="http://baidu.com">http://baidu.com</a> 的request 全部内容如下：(在 wireshark 点击 request http 报文可查看)</p><pre><code>    GET / HTTP/1.1\r\n
    Host: news.baidu.com\r\n
    Connection: keep-alive\r\n
    Upgrade-Insecure-Requests: 1\r\n
    DNT: 1\r\n
    User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36\r\n
    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\r\n
    Referer: https://www.baidu.com/\r\n
    Accept-Encoding: gzip, deflate\r\n
    Accept-Language: en,en-US;q=0.9,zh-CN;q=0.8,zh;q=0.7,zh-TW;q=0.6\r\n
    Cookie: BIDUPSID=DFBCEB19126518FE5B14DE02435939DF; PSTM=1585012306; BAIDUID=DFBCEB19126518FEC81AB23A0B7A652F:FG=1; H_PS_PSSID=30971_1426_31118_21108_30824_26350\r\n
    \r\n
    [Full request URI: http://news.baidu.com/]
    [HTTP request 1/3]
    [Response in frame: 23]
    [Next request in frame: 599]</code></pre><h4>请求方法</h4><p>HTTP/1.1协议中共定义了八种方法（也叫“动作”）来以不同方式操作指定的资源：</p><ul><li><strong>GET</strong> 向指定的资源发出“显示”请求。使用GET方法应该只用在读取数据，GET上要在url之外带一些参数就只能依靠url上附带querystring。</li><li><strong>HEAD</strong> 与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。</li><li><strong>POST</strong> 向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。</li><li><strong>PUT</strong> 向指定资源位置上传其最新内容。</li><li><strong>DELETE</strong> 请求服务器删除Request-URI所标识的资源。</li><li><strong>TRACE</strong> 回显服务器收到的请求，主要用于测试或诊断。</li><li><strong>OPTIONS</strong> 这个方法可使服务器传回该资源所支持的所有HTTP请求方法。</li><li><strong>CONNECT</strong> HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接。</li></ul><p>当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Method Not Allowed），当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501（Not Implemented）。</p><p><strong>最常用的就是 GET 和 POST 方法。</strong></p><p><strong>GET和POST的区别：</strong></p><ul><li>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&相连，如EditPosts.aspx?name=test1&id=123456. POST方法是把提交的数据放在HTTP包的Body中。</li><li>GET提交的数据大小有限制，最多只能有1024字节（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制。</li><li>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。</li><li>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。</li></ul><h4>版本</h4><ul><li><strong>HTTP/0.9</strong> 已过时。只接受GET一种请求方法，没有在通讯中指定版本号，且不支持请求头。不支持 POST</li><li><strong>HTTP/1.0</strong> 这是第一个在通讯中指定版本号的HTTP协议版本，至今仍被广泛采用，特别是在代理服务器中。</li><li><strong>HTTP/1.1</strong> 持久连接被默认采用，并能很好地配合代理服务器工作。还支持以管道方式在同时发送多个请求，降低线路负载提高传输速度。</li><li><strong>HTTP/2</strong> 当前版本，于2015年5月作为互联网标准正式发布。</li></ul><h4>请求头</h4><p>HTTP 头字段根据实际用途被分为以下 4 种类型：</p><ul><li>通用头字段(英语：General Header Fields)</li><li>请求头字段(英语：Request Header Fields)</li><li>响应头字段(英语：Response Header Fields)</li><li>实体头字段(英语：Entity Header Fields)</li></ul><p>常见的请求头字段：</p><ul><li>Accept 能够接受的回应内容类型：Accept: text/plain</li><li>Connection 该浏览器想要优先使用的连接类型：Connection: keep-alive</li><li>Content-Type 请求体的多媒体类型：Content-Type: application/x-www-form-urlencoded</li><li>Host 服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号：Host: en.wikipedia.org:80</li><li>User-Agent - 浏览器的浏览器身份标识字符串：ser-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/21.0</li><li>If-Modified-Since 把浏览器端缓存页面的最后修改时间发送到服务器，如果和服务器文件时间一致，那么返回304：If-Modified-Since: Thu, 09 Feb 2012 09:07:57 GMT</li><li>pragma 指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝，在HTTP/1.1版本中，它和Cache-Control: no-cache作用一模一样：pragma: no-cache</li><li>Cache-Control 指定请求和响应遵循的缓存机制：Cache-Control: no-cache</li><li>Cookie 之前由服务器通过 Set- Cookie （下文详述）发送的一个 超文本传输协议Cookie</li></ul><p>常见的非标准请求头字段：</p><ul><li>DNT 请求某个网页应用程序停止跟踪某个用户：DNT: 1 (DNT启用)</li><li>X-Forwarded-For 一个事实标准 ，用于标识某个通过超文本传输协议代理或负载均衡连接到某个网页服务器的客户端的原始互联网地址：X-Forwarded-For: 129.78.138.66, 129.78.64.103</li><li>X-Forwarded-Host 一个事实标准 ，用于识别客户端原本发出的 Host 请求头部：X-Forwarded-Host: en.wikipedia.org</li><li>X-Forwarded-Proto 一个事实标准，用于标识某个超文本传输协议请求最初所使用的协议：X-Forwarded-Proto: https</li></ul><p>更多请求头字段参考：<a href="https://zh.wikipedia.org/wiki/HTTP%E5%A4%B4%E5%AD%97%E6%AE%B5#%E8%AF%B7%E6%B1%82%E5%AD%97%E6%AE%B5">wikepedia</a></p><h3>response 响应</h3><p>服务端发出 tcp 确认后，发出 response 响应 http 页面。</p><p><strong>发出的响应信息（message request）结构如下:</strong></p><ul><li>状态行（例如HTTP/1.1 200 OK，表示从信息传递成功）</li><li>响应头（例如Content-Length: 3059）</li><li>空行</li><li>传递实体内容(可以为空)</li></ul><p>下面是一个 http 页面的响应实例：</p><pre><code>    HTTP/1.1 200 OK\r\n
    Content-Type: text/html; charset=utf-8\r\n
    Server: GitHub.com\r\n
    Last-Modified: Fri, 22 Jan 2016 02:52:30 GMT\r\n
    ETag: W/&quot;56a1996e-2d27&quot;\r\n
    Access-Control-Allow-Origin: *\r\n
    Expires: Tue, 24 Mar 2020 06:32:29 GMT\r\n
    Cache-Control: max-age=600\r\n
    Content-Encoding: gzip\r\n
    X-Proxy-Cache: MISS\r\n
    X-GitHub-Request-Id: EAD6:198D:D9A2C:E5FDD:5E79A724\r\n
    Content-Length: 4509\r\n
    Accept-Ranges: bytes\r\n
    Date: Tue, 24 Mar 2020 06:22:29 GMT\r\n
    Via: 1.1 varnish\r\n
    Age: 0\r\n
    Connection: keep-alive\r\n
    X-Served-By: cache-hnd18730-HND\r\n
    X-Cache: MISS\r\n
    X-Cache-Hits: 0\r\n
    X-Timer: S1585030950.603621,VS0,VE171\r\n
    Vary: Accept-Encoding\r\n
    X-Fastly-Request-ID: 806211821134676c48d8c7c6ed9cee2a6bad952d\r\n
    \r\n
    [HTTP response 1/5]
    [Time since request: 0.405424000 seconds]
    [Request in frame: 2595]
    [Next request in frame: 2604]
    [Next response in frame: 2623]
    [Request URI: http://zq210wl.github.io/imgs/noise.png]
    Content-encoded entity body (gzip): 4509 bytes -&gt; 11559 bytes
    File Data: 11559 bytes
    &lt;!DOCTYPE HTML&gt;
    &lt;html&gt;
    &lt;head&gt;
      &lt;meta charset=&quot;utf-8&quot;&gt;
      ...
    &lt;/head&gt;
    &lt;body&gt;
      ...
    &lt;/body&gt;</code></pre><h4>状态行</h4><p>响应行结构为：当前HTTP版本号，3位数字组成的状态代码，以及描述状态的短语，彼此由空格分隔。</p><h4>状态码</h4><p>状态代码的第一个数字代表当前响应的类型：</p><ul><li>1xx消息——请求已被服务器接收，继续处理</li><li>2xx成功——请求已成功被服务器接收、理解、并接受</li><li>3xx重定向——需要后续操作才能完成这一请求</li><li>4xx请求错误——请求含有词法错误或者无法被执行</li><li>5xx服务器错误——服务器在处理某个正确请求时发生错误</li></ul><p>详细的状态码介绍参考：<a href="https://blog.niekun.net/archives/192.html">https://blog.niekun.net/archives/192.html</a></p><h4>响应头</h4><p>HTTP 头字段根据实际用途被分为以下 4 种类型：</p><ul><li>通用头字段(英语：General Header Fields)</li><li>请求头字段(英语：Request Header Fields)</li><li>响应头字段(英语：Response Header Fields)</li><li>实体头字段(英语：Entity Header Fields)</li></ul><p>常见的响应头字段：</p><ul><li>Allow 对于特定资源有效的动作：Allow: GET, HEAD</li><li>Age 这个对象在代理缓存中存在的时间，以秒为单位：Age: 12</li><li>Connection 针对该连接所预期的选项：Connection: keep-alive</li><li>Content-Language 内容所使用的语言：Content-Language: da</li><li>Expires 指定一个日期/时间，超过该时间则认为此回应已经过期：Expires: Thu, 01 Dec 1994 16:00:00 GMT</li><li>Location 用来进行重定向，或者在创建了某个新资源时使用：Location: <a href="http://www.w3.org/pub/WWW/People.html">http://www.w3.org/pub/WWW/People.html</a></li><li>Refresh 用于设定可定时的重定向跳转。右边例子设定了5秒后跳转至：Refresh: 5; url=<a href="http://www.w3.org/pub">http://www.w3.org/pub</a></li><li>Server服务器的名字：Server: Apache/2.4.1 (Unix)</li><li>Upgrade 要求客户端升级到另一个协议：Upgrade: HTTP/2.0</li><li>Set-Cookie 设置 HTTP cookie记录客户端身份：Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1</li></ul><p>常见的非标准回应字段：</p><ul><li>X-Powered-By 表明用于支持当前网页应用程序的技术：X-Powered-By: PHP/5.4.0</li><li>X-Content-Duration 指出音视频的长度，单位为秒：X-Content-Duration: 42.666</li></ul><p>详细的响应头字段参考：<a href="https://zh.wikipedia.org/wiki/HTTP%E5%A4%B4%E5%AD%97%E6%AE%B5#%E8%AF%B7%E6%B1%82%E5%AD%97%E6%AE%B5">Wikipedia</a></p><h4>响应头的 location 段</h4><p>HTTP Location 是在两种情况使用在响应头中：</p><ul><li>要求网页浏览器加载其他网页(域名转址)。在这种情况下，应该使用HTTP状态码3xx发送Location头。</li><li>提供有关新创建资源位置的信息。在这种情况下，应该使用HTTP状态码201或202发送Location头。</li></ul><p>示例：</p><pre><code>HTTP/1.1 302 Found
Location: http://www.example.org/index.php</code></pre><p>客户端请求的 URL 被服务端重定向到 <a href="http://www.example.org/index.php.">http://www.example.org/index.php.</a></p><p>客户端请求：</p><pre><code>GET /blog HTTP/1.1
Host: www.example.com</code></pre><p>服务端响应：</p><pre><code>HTTP/1.1 302 Found
Location: /articles/</code></pre><p>该位置 /blog 被客户端定向到 <a href="http://www.example.com/articles/.">http://www.example.com/articles/.</a></p><h4>解决HTTP无状态的问题</h4><p>使用Cookie来实现：</p><ul><li>服务器给每个Session分配一个唯一的JSESSIONID，并通过Cookie发送给客户端。</li><li>当客户端发起新的请求的时候，将在Cookie头中携带这个JSESSIONID。这样服务器能够找到这个客户端对应的Session。</li></ul><p><img src="https://blog.niekun.net/usr/uploads/2020/03/2798926810.png" alt="2020-03-24T07:45:16.png" title="2020-03-24T07:45:16.png"></p><p>使用URL回写来实现：<br>URL回写是指服务器在发送给浏览器页面的所有链接中都携带JSESSIONID的参数，这样客户端点击任何一个链接都会把JSESSIONID带会服务器。如果直接在浏览器输入服务端资源的url来请求该资源，那么Session是匹配不到的。</p><h3>URI 统一资源标志符</h3><p>统一资源标识符（英语：Uniform Resource Identifier，缩写：URI）在电脑术语中是一个用于标识某一互联网资源名称的字符串。</p><p>该种标识允许用户对网络中（一般指万维网）的资源通过特定的协议进行交互操作。URI的最常见的形式是统一资源定位符（URL），经常指定为非正式的网址。更罕见的用法是统一资源名称（URN），其目的是通过提供一种途径。用于在特定的名字空间资源的标识，以补充网址。</p><p>通用URI的格式如下：</p><pre><code>[协议名]://[用户名]:[密码]@[主机名]:[端口]/[路径]?[查询参数]#[片段ID]</code></pre><p><strong>下面是两个常见的 URI 构成：</strong></p><pre><code>
                   hierarchical part
        ┌───────────────────┴─────────────────────┐
                    authority               path
        ┌───────────────┴───────────────┐┌───┴────┐
  abc://username:password@example.com:123/path/data?key=value&amp;key2=value2#fragid1
  └┬┘   └───────┬───────┘ └────┬────┘ └┬┘           └─────────┬─────────┘ └──┬──┘
scheme  user information     host     port                  query         fragment


  urn:example:mammal:monotreme:echidna
  └┬┘ └──────────────┬───────────────┘
scheme              path</code></pre><p>以 <code>https://zh.wikipedia.org:80/w/index.php?title=Special:随机页面#ABC</code> 为例, 其中：</p><ul><li>https，是协议；</li><li>zh.wikipedia.org，是服务器；</li><li>80，是服务器上的网络端口号；</li><li>/w/index.php，是路径；</li><li>?title=Special:随机页面，是询问。</li><li>\#ABC，是片段</li></ul><h3>　参考连接</h3><p><a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">超文本传输协议</a><br><a href="https://zh.wikipedia.org/wiki/HTTP%E5%A4%B4%E5%AD%97%E6%AE%B5">HTTP头字段</a><br><a href="https://zh.wikipedia.org/wiki/HTTP_Location">HTTP_Location</a><br><a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E6%A0%87%E5%BF%97%E7%AC%A6">统一资源标志符</a><br><a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6">一资源定位符</a><br><a href="https://www.jianshu.com/p/7275aa3e4a13">HTTP协议详解</a></p>
]]></content:encoded>
<slash:comments>1</slash:comments>
<comments>https://blog.niekun.net/archives/1432.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/1432.html</wfw:commentRss>
</item>
<item>
<title>wkhtmltopdf 将 html为 pdf</title>
<link>https://blog.niekun.net/archives/1375.html</link>
<guid>https://blog.niekun.net/archives/1375.html</guid>
<pubDate>Wed, 18 Mar 2020 12:58:56 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[一般浏览器都可以将当前页面输出为 pdf，但当有很多个 html 文件时一个一个转换就很麻烦了，可以使用 wkhtmltopdf 命令行工具来实现自动化批量转换。wkhtmltopdf and ...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>一般浏览器都可以将当前页面输出为 pdf，但当有很多个 html 文件时一个一个转换就很麻烦了，可以使用 wkhtmltopdf 命令行工具来实现自动化批量转换。</p><blockquote>wkhtmltopdf and wkhtmltoimage are open source (LGPLv3) command line tools to render HTML into PDF and various image formats using the Qt WebKit rendering engine. These run entirely "headless" and do not require a display or display service.</blockquote><p>wkhtmltopdf 官网：<a href="https://wkhtmltopdf.org/">https://wkhtmltopdf.org/</a><br>GitHub 主页：<a href="https://github.com/wkhtmltopdf/wkhtmltopdf">https://github.com/wkhtmltopdf/wkhtmltopdf</a></p><!--more--><h3>下载</h3><p>在 release 页面下载对应系统最新版：<a href="https://github.com/wkhtmltopdf/wkhtmltopdf/releases">https://github.com/wkhtmltopdf/wkhtmltopdf/releases</a></p><p>我要安装到 Ubuntu 18.04，所以下载：wkhtmltox_0.12.5-1.bionic_amd64.deb</p><p>查看 Ubuntu 系统代号可以使用命令：</p><pre><code>lsb_release -c
</code></pre><h3>安装</h3><p>下载的 deb 包，用以下命令进行安装：</p><pre><code>dpkg -i wkhtmltox_0.12.5-1.bionic_amd64.deb
</code></pre><h3>使用</h3><p>支持 url 或 本地 html 转换：</p><pre><code>wkhtmltopdf http://bing.com bing.pdf
wkhtmltopdf path/to/test.html index.pdf
</code></pre><p>配合 find 命令可以实现批量转换：</p><pre><code>find path/to/html -name '*.html' -exec wkhtmltopdf {} {}.pdf \;
mkdir pdf/
find path/to/html -name '*.pdf' -exec mv {} pdf/ \;</code></pre><p>find 命令详细用法参考：<a href="https://blog.niekun.net/archives/543.html">https://blog.niekun.net/archives/543.html</a></p><p>可以使用 wget 命令下载某个网站到本地，然后使用上面命令批量转换：</p><pre><code>wget -m -p -k URL
</code></pre><p>-m, –mirror 等价于 -r -N -l inf -nr<br>-p：下载所有html文件适合显示的元素<br>-k, –convert-links 转换非相对链接为相对链接,将文档链接都转换成本地的</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/1375.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/1375.html</wfw:commentRss>
</item>
</channel>
</rss>