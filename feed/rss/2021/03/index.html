<?xml version="1.0" encoding="UTF-8"?>
<rdf:RDF
xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
xmlns="http://purl.org/rss/1.0/"
xmlns:dc="http://purl.org/dc/elements/1.1/">
<channel rdf:about="https://blog.niekun.net/feed/rss/2021/03/">
<title>Marco Nie - 2021年3月</title>
<link>https://blog.niekun.net/2021/03/</link>
<description>you are the company you keep...</description>
<items>
<rdf:Seq>
<rdf:li resource="https://blog.niekun.net/archives/2208.html"/>
<rdf:li resource="https://blog.niekun.net/archives/2205.html"/>
<rdf:li resource="https://blog.niekun.net/archives/2204.html"/>
<rdf:li resource="https://blog.niekun.net/archives/2201.html"/>
<rdf:li resource="https://blog.niekun.net/archives/2198.html"/>
<rdf:li resource="https://blog.niekun.net/archives/2195.html"/>
</rdf:Seq>
</items>
</channel>
<item rdf:about="https://blog.niekun.net/archives/2208.html">
<title>QT 中通过 QCustomPlot widget 绘制可视化曲线表</title>
<link>https://blog.niekun.net/archives/2208.html</link>
<dc:date>2021-03-19T17:24:46+08:00</dc:date>
<description>今天在项目中需要添加一个柱状图，但由于我们的项目是 QT 4.8 的所以不支持 QtCharts。查询了下发现有 QCustomPlot 可以完美的实现需求，使用方法也很简单。官网：https://www.qcustomplot.com/下载：https://www.qcustomplot.com/index.php/downloadQCustomPlot 只有两个文件 qcustomplot.cpp 和 qcustomplot.h，将其复制到项目目录中并添加到项目中。然后引用头文件即可：#include &quot;qcustomplot.h&quot;
我们需要在 ui 中添加一个 widget 然后右键点击控件，选择提升：提升的 class 名称修改为 QCustomPlot：点击 add 然后点击 promote 即可。编译后可以看到图表样式：在使用中如果需要根据数据变化刷新渲染的图形，记得在修改数据后调用</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/2205.html">
<title>使用 instaloader 下载 Instagram 图片-视频</title>
<link>https://blog.niekun.net/archives/2205.html</link>
<dc:date>2021-03-16T11:55:00+08:00</dc:date>
<description>一直在使用 telegram bot 来下载 YouTube 或 twitter 视频，很方便快捷。关于配置自己的 bot 参考之前的文章：https://blog.niekun.net/archives/428.html我的应用于 telegram bot 的 YouTube 下载器源码地址：https://github.com/nie11kun/telegram-bot-youtube-downloader最近想给我的 telegram bot 添加 Instagram 图片的下载功能，但是 youtube-dl 并不支持 Instagram。查询了下发现了 instaloader 这个开源软件可以完美实现我想要的功能。instaloader 官网：https://instaloader.github.io/GitHub：https://github.com/instaloader/instaloader安装instaloader 需要 python 3.5 以上。推荐直接安装最新版 python。使用 pip3 安装：pip3 install instaloader --upgrade
注意必须通过 pip3 而不是 pip 安装，否则使用中会报错。使用安装完成后就可以使用 instaloader 命令来下载了。注意如果 python 安装到了自定义目录，如 /opt 则需要手动链接 instaloader 可执行程序到 /usr/local/bin 目录。下载 post如果要下载一个 post 中的图片，提取链接中的 shortcode 来下载，如下是一个 Instagram post 的链接：https://www.instagram.com/p/CMcMZycLpbS/?utm_source=ig_web_copy_link，其中的 CMcMZycLpbS 就是 shortcode 代码。需要通过 -shortcode 参数来下载对应的图片，且需要通过 -- 告诉 instaloader 不要将 -shortcode 作为 option 对待，如：instaloader -- -CMcMZycLpbS
关于命令中的特殊字符处理参考：https://blog.niekun.net/archives/2204.html默认会下载到当前目录下，并新建文件夹 -shortcode，媒体文件及相关文本文件就在其中，注意到文件夹是以特殊字符 - 开头的，所以访问目录需要加上 --，如：cd -- -CMcMZycLpbS
自定义下载目录通过 --dirname-pattern 参数可以指定下载目录，如：instaloader --dirname-pattern=/tmp/test -- -CMcMZycLpbS
就会将对应 post 的媒体下载到 /tmp/test 目录内。instaloader 的功能很强大，可以下载一个用户的所有发布内容，可以下载一个 #hashtag 标签的所有内容等。具体可以参考官方文档：https://instaloader.github.io/basic-usage.html#download-pictures-from-instagram我将 instaloader 加入了 telegram bot 中，可以很方便的下载一个 post 的媒体内容，有兴趣的可以查看：https://github.com/nie11kun/telegram-bot-youtube-downloader</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/2204.html">
<title>cd 到以 '-' dash 开头的目录的方法</title>
<link>https://blog.niekun.net/archives/2204.html</link>
<dc:date>2021-03-16T10:33:44+08:00</dc:date>
<description>Linux 下，当文件或文件夹包含空格或其他特殊符号如 $，在引用时需要将其放在单引号 '' 或 &quot;&quot; 中，如：cd '$abc'
cd &quot;abc de f&quot;
当文件以 - dash 开头时，命令会将其作为 option 处理，如：ls -lh
此时如果需要让命令将其识别为文件名称而不是 option 需要加入 -- 作为参数：cd -- '-abc'
这样命令就会将 - 开头的字符作为文件名称处理了。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/2201.html">
<title>React 入门教程之七 -- List 和 Form</title>
<link>https://blog.niekun.net/archives/2201.html</link>
<dc:date>2021-03-05T16:13:20+08:00</dc:date>
<description>list 列表和 key在 JavaScript 中我们通常使用 map method 来对一个 list 的每个元素进行操作：const numbers = [1, 2, 3, 4, 5];
const double = numbers.map((number) =&gt; { return number * 2});
console.log(double)

//output:
//[ 2, 4, 6, 8, 10 ]在 React 中对一个 list 的元素进行操作方法类似。我们可以在 JSX 中通过大括号{} 来建立一个 elements 的集合，下面示例中我们将 map 的返回定义为 &lt;li&gt; 元素并赋值给 listItems：const numbers = [1, 2, 3, 4, 5];
const listItems = numbers.map((number) =&gt; &lt;li&gt;{number}&lt;/li&gt;)

ReactDOM.render(
    &lt;ul&gt;{listItems}&lt;/ul&gt;,
    document.getElementById('root')
);注意在 render 中我们将 listItems 放在 &lt;ul&gt; 元素中。通常情况下我们将 lists 放在一个 component 中：const NumberList = (props) =&gt; {
    const numbers = props.numbers;
    const listItems = numbers.map((number) =&gt; &lt;li&gt;{number}&lt;/li&gt;)
    return (
        &lt;ul&gt;{listItems}&lt;/ul&gt;
    )
}

const numbers = [1, 2, 3, 4, 5];
ReactDOM.render(
    &lt;NumberList numbers={numbers}/&gt;,
    document.getElementById('root')
);当运行以上代码时，在浏览器终端会有一个 warning 警告信息：Each child in a list should have a unique "key" prop.：Key 是一个特殊的 string 字符串属性需要给创建的 list element 添加的。它可以用来定位 list 中的每个元素。下面我们给 list item 添加 Key 字符串属性：const NumberList = (props) =&gt; {
    const numbers = props.numbers;
    const listItems = numbers.map((number) =&gt;
        &lt;li key={number.toString()}&gt;
            {number}
        &lt;/li&gt;);
    return (
        &lt;ul&gt;{listItems}&lt;/ul&gt;
    );
}添加后报警就会消除。KeysKey 可以帮助 React 识别哪个 item 修改过，被删除，被添加。以上示例中，我们在 map 中创建 item 时给其 key 属性，这样每个 item 可以有确切的属性值。每个 list item 最好设置一个特殊的标识 key string 来区别于其他 items。最常用的就是使用数据中的 ID 作为 key：const TodoItems = (props) =&gt; {
    const todos = props.todos;
    const listItems = todos.map((todo) =&gt; 
        &lt;li key={todo.id}&gt;
            {todo.text}
        &lt;/li&gt;
    )
    return (
        &lt;ul&gt;{listItems}&lt;/ul&gt;
    );
}
const todos = [
    {id: 1, text: '123'},
    {id: 2, text: '456'}
];
ReactDOM.render(
    &lt;TodoItems todos={todos} /&gt;,
    document.getElementById('root')
);当没有特定的 ID 来作为标识时，作为最后的选择，可以使用 item 的 index 作为 key：const TodoItems = (props) =&gt; {
    const todos = props.todos;
    const listItems = todos.map((todo, index) =&gt; 
        &lt;li key={index}&gt;
            {todo.text}
        &lt;/li&gt;
    )
    return (
        &lt;ul&gt;{listItems}&lt;/ul&gt;
    );
}如果 items 的顺序可能会发生变化的话，不推荐使用 index 作为 key 使用，因为可能对性能产生影响并且对 component 的 state 造成问题。如果没有定义确切的 key 给 items，React 默认会使用 index 作为 keys。拆解 component 时 key 的处理keys 是对应与一个数组的内容而言的，它并不能单独存在。例如我们要拆解上面的 NumberList，提取出 ListItem，则需要将 key 定义在 &lt;ListItem /&gt; 元素中而不是 ListItem component 内部的 &lt;li&gt; 中：const ListItem = (props) =&gt; {
    return (
        &lt;li&gt;{props.value}&lt;/li&gt;
    );
}

const NumberList = (props) =&gt; {
    const numbers = props.numbers;
    const listItems = numbers.map((number) =&gt;
        &lt;ListItem key={number.toString()} value={number}/&gt;);
    return (
        &lt;ul&gt;{listItems}&lt;/ul&gt;
    );
}

const numbers = [1, 2, 3, 4, 5];
ReactDOM.render(
    &lt;NumberList numbers={numbers} /&gt;,
    document.getElementById('root')
);如果写成下面模式就是错误的：function ListItem(props) {
  const value = props.value;
  return (
    &lt;li key={value.toString()}&gt;
      {value}
    &lt;/li&gt;
  );
}每个 item 的 key 必须是特定的数组中每个 items 使用的 key 必须是互相独立且不相同的，但并不需要在全局下互相独立。在两个单独的数组中可以，其元素可以使用相同的 key：const React = require('react')
const ReactDOM = require('react-dom')

const Blog = (props) =&gt; {
    const sideBar = (
        &lt;ul&gt;
            {props.posts.map((post) =&gt;
                &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;
            )}
        &lt;/ul&gt;
    );
    const content = props.posts.map((post) =&gt;
        &lt;div key={post.id}&gt;
            &lt;h3&gt;{post.title}&lt;/h3&gt;
            &lt;p&gt;{post.content}&lt;/p&gt;
        &lt;/div&gt;
    );
    return (
        &lt;div&gt;
            {sideBar}
            &lt;hr/&gt;
            {content}
        &lt;/div&gt;
    );
}

const posts = [
    {id: 1, title: 'Hello World', content: 'Welcome to learning React!'},
    {id: 2, title: 'Installation', content: 'You can install React from npm.'}
];

ReactDOM.render(
    &lt;Blog posts={posts} /&gt;,
    document.getElementById('root')
);上面示例中，我们在 Blog component 中定义了两个 JSX，都创建了 list elements，每个元素的 key 使用了对应的 id 属性。在每个 list 内部 key 是互相独立的。可以看到不只是 &lt;li&gt; 元素可以加 key，只要通过 map 定义了一个 array 数组，就可以给每个元素加上 key 属性来互相独立识别。key 是为了给 React 识别用的。它本身并不作为一个普通 prop 传给 components，也就是在 component 内部并不能使用这个 key 数据，如果想要在 component 中使用这个数据则需要单独定义一个其他 prop 来传入 key 数据：const Post = (props) =&gt; {
    return (
        &lt;li&gt;
            {props.id}: {props.title}
        &lt;/li&gt;
    )
}
const Blog = (props) =&gt; {
    const sideBar = (
        &lt;ul&gt;
            {props.posts.map((post) =&gt;
                &lt;Post key={post.id} id={post.id} title={post.title} /&gt;
            )}
        &lt;/ul&gt;
    );
...
...
...
}上面示例中，Post component 无法直接访问 key 的数据，所以我们在调用 Post 时单独定义一个 id 属性并赋值为 key 相同的数据，这样就间接的可以在 Post component 中通过 id 来读取 key 的数据。在之前的 ListItem 示例中，我们声明了一个单独的 listItems 变量并在后续返回中将其放在 &lt;ul&gt; 中：const NumberList = (props) =&gt; {
    const numbers = props.numbers;
    const listItems = numbers.map((number) =&gt;
        &lt;ListItem key={number.toString()} value={number}/&gt;);
    return (
        &lt;ul&gt;{listItems}&lt;/ul&gt;
    );
}JSX 支持嵌入任何的 JavaScript 表达式，只需要使用大括号包围即可，所以上面的代码可以修改为以下模式：    return (
        &lt;ul&gt;
            {numbers.map((number) =&gt;
                &lt;ListItem key={number.toString()} value={number} /&gt;);}
        &lt;/ul&gt;
    );使用哪种方式来定义 JSX 取决于对应的使用场景，总的原则是要方便与代码阅读，逻辑清晰。需要注意的是如果 map() method 中层级太复杂，可以考虑将其拆分为多个 components。Forms 表格</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/2198.html">
<title>升级 command line tool 后 QT 编译 boost 库报错问题</title>
<link>https://blog.niekun.net/archives/2198.html</link>
<dc:date>2021-03-03T21:03:37+08:00</dc:date>
<description>今天打开一个 QT 项目后进行编译发现报错了，查看了下什么都没有修改就比较奇怪了。根据日志是 boost 库出了问题，报错为：Undefined symbols for architecture x86_64，但是 boost 库是以前编译好的从来没动过。回想起来前几天重新安装了下 command line tool 会不会有关系。看了下 QT kit 配置里面发现 clang 的设置居然有叹号。重新识别了下系统编译器：然后重建下项目配置：重新编译项目依然有报错。最后就是 boost 库的确有问题了。于是我重新编译了一次。居然问题就解决了。原来真的是由于系统的 Clang 更新后原来编译的 boost 库不兼容了，在此使用当前系统的 Clang 编译一次就行了。boost 库编译方法参考：https://blog.niekun.net/archives/1174.html</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/2195.html">
<title>React 入门教程之六 -- Conditional Rendering</title>
<link>https://blog.niekun.net/archives/2195.html</link>
<dc:date>2021-03-02T23:10:22+08:00</dc:date>
<description>在 React 中，我们可以创建独立的 component 来封装特定的功能。因此，可以根据不同的程序的 state 选择性的做部分渲染。和 JavaScript 的相同，React 中也可以使用 conditions 语法来选择性的渲染内容。如使用 if 或 conditional operator 来根据不同 state 状态创建不同 elements 然后让 React 更新 UI 来匹配 DOM。考虑下面两个 components：const UserGreeting = (props) =&gt; {
    return &lt;h1&gt;welcome back&lt;/h1&gt;
}

const GuestGreeting = (props) =&gt; {
    return &lt;h1&gt;please sign up&lt;/h1&gt;
}然后我们创建一个 Greeting component 来根据是否有用户登陆来显示以上两个中的一个：const Greeting = (props) =&gt; {
    let isLoggedIn = props.isLoggedIn;
    if (isLoggedIn)
        return &lt;UserGreeting /&gt;;
    else
        return &lt;GuestGreeting /&gt;;
}

ReactDOM.render(
    &lt;Greeting isLoggedIn={true} /&gt;,
    document.getElementById('root')
);以上示例会根据 isLoggedIn 属性的值来渲染不同的内容。elements 变量可以使用变量存储 elements，这样可以方便的根据情况 render 部分的 component 而不需要改变输出的指令内容。考虑下面两个 component 表示 login 和 logout：const LoginButton = (props) =&gt; {
    return (
        &lt;button onClick={props.onClick}&gt;
            login
        &lt;/button&gt;
    );
}

const LogoutButton = (props) =&gt; {
    return (
        &lt;button onClick={props.onClick}&gt;
            logout
        &lt;/button&gt;
    );
}然后我们创建 LoginControl component，它将根据当前情况渲染 login 或 logout button 以及之前创建的 Greeting element：class LoginControl extends React.Component {
    constructor(props) {
        super(props);
        this.handleLoginClick = this.handleLoginClick.bind(this);
        this.handleLogoutClick = this.handleLogoutClick.bind(this);
        this.state = {isLoggedIn: false};
    }

    handleLoginClick() {
        this.setState({isLoggedIn: true});
    }

    handleLogoutClick() {
        this.setState({isLoggedIn: false});
    }

    render() {
        let isLoggedIn = this.state.isLoggedIn;
        let button;
        if (isLoggedIn)
            button = &lt;LogoutButton onClick={this.handleLogoutClick} /&gt;
        else
            button = &lt;LoginButton onClick={this.handleLoginClick} /&gt;

        return (
            &lt;div&gt;
                &lt;Greeting isLoggedIn={isLoggedIn} /&gt;
                {button}
            &lt;/div&gt;
        );
    }

}

ReactDOM.render(
    &lt;LoginControl /&gt;,
    document.getElementById('root')
);inline condition 单语句判断使用 element 变量以及使用 if 语句根据条件渲染 component 是一种很好的方法。但是有时候可以使用简化语法。下面接收几种 inline condition 语法。inline if with && operator在 JSX 可以通过使用大括号{}来嵌入 JavaScript 表达式，包括逻辑符号：&amp;&amp;，在根据条件判断是否包含一个 element 时很有用。请看下面示例：const InlineCom = (props) =&gt; {
    return(
        &lt;div&gt;
            &lt;h1&gt;hello world&lt;/h1&gt;
            {props.count &gt; 10 &amp;&amp;
                &lt;h2&gt;count is: {props.count}&lt;/h2&gt;
            }
        &lt;/div&gt;
    );
}

ReactDOM.render(
    &lt;InlineCom count={20} /&gt;,
    document.getElementById('root')
);如果 props.count &gt; 10 满足条件则后面的 element 就会成为 component 一部分。在 JavaScript 中，true &amp;&amp; expression 将会评估为 expression，而 false &amp;&amp; expression 将会评估为 false。因此当 condition 为 true 时，&amp;&amp; 后的 element 将会输出，否则 React 将会忽略它。inline condition operator另一种根据情况通过 inline 单行判断来渲染 element 就是使用 JavaScript conditional operator：condition ? true : false。给 LoginControl 的返回添加如下：        return (
            &lt;div&gt;
                the user is &lt;b&gt;{isLoggedIn ? 'currenty' : 'not'}&lt;/b&gt; logged in.
                &lt;Greeting isLoggedIn={isLoggedIn} /&gt;
                {button}
            &lt;/div&gt;
        );通过 inline conditional operator 来输出不同的信息。也可以在较长的表达式中使用，例如可以将示例中 button 部分在 render 中这样处理：        return (
            &lt;div&gt;
                the user is &lt;b&gt;{isLoggedIn ? 'currenty' : 'not'}&lt;/b&gt; logged in.
                &lt;Greeting isLoggedIn={isLoggedIn} /&gt;
                {button}
                {isLoggedIn 
                    ? &lt;LogoutButton onClick={this.handleLogoutClick} /&gt;
                    : &lt;LoginButton onClick={this.handleLoginClick} /&gt;
                }
            &lt;/div&gt;
        );使用中根据实际情况选择最合适的方式处理 condition，最终目的是为了使结构更加清晰，代码易读。注意如果判断过复杂就需要考虑拆解 component 为多个个体了。阻止 component 渲染某些情况下我们可能需要将一个 component 隐藏起来，即使它在别的 component 中已经渲染了。可以通过 return null 来代替它的输出。下面示例中 WarningBanner 会根据 warn 属性的值来选择性渲染：const React = require('react')
const ReactDOM = require('react-dom')

const WarningBanner = (props) =&gt; {
    if (!props.warn) {
        return null;
    }
    return (
        &lt;div className='warning'&gt;
            warning!
        &lt;/div&gt;
    );
}

class Page extends React.Component {
    constructor(props) {
        super(props);
        this.state = {showWarning: true};
        this.handelToggleClick = this.handelToggleClick.bind(this);
    }
    handelToggleClick() {
        this.setState({showWarning: !this.state.showWarning});
    }

    render() {
        return (
            &lt;div&gt;
                &lt;WarningBanner warn={this.state.showWarning} /&gt;
                &lt;button onClick={this.handelToggleClick}&gt;
                    {this.state.showWarning ? 'hide' : 'show'}
                &lt;/button&gt;
            &lt;/div&gt;
        );
    }
}

ReactDOM.render(
    &lt;Page /&gt;,
    document.getElementById('root')
);在 render method 中 return null 不会影响到 component 的 lifecycle method。例如每次更新 componentDidUpdate 依然会被自动调用。</description>
</item>
</rdf:RDF>