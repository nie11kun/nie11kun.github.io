<?xml version="1.0" encoding="UTF-8"?>
<rdf:RDF
xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
xmlns="http://purl.org/rss/1.0/"
xmlns:dc="http://purl.org/dc/elements/1.1/">
<channel rdf:about="https://blog.niekun.net/feed/rss/">
<title>Marco Nie</title>
<link>https://blog.niekun.net/</link>
<description>you are the company you keep...</description>
<items>
<rdf:Seq>
<rdf:li resource="https://blog.niekun.net/archives/dnsmasq-nftset-nftables-1.html"/>
<rdf:li resource="https://blog.niekun.net/archives/intel-12-CPU-vmwre.html"/>
<rdf:li resource="https://blog.niekun.net/archives/openwrt-1.html"/>
<rdf:li resource="https://blog.niekun.net/archives/Linux.html"/>
<rdf:li resource="https://blog.niekun.net/archives/openwrt.html"/>
<rdf:li resource="https://blog.niekun.net/archives/Linux-ip.html"/>
<rdf:li resource="https://blog.niekun.net/archives/windows.html"/>
<rdf:li resource="https://blog.niekun.net/archives/codesys-enum.html"/>
<rdf:li resource="https://blog.niekun.net/archives/codesys.html"/>
<rdf:li resource="https://blog.niekun.net/archives/immich.html"/>
</rdf:Seq>
</items>
</channel>
<item rdf:about="https://blog.niekun.net/archives/dnsmasq-nftset-nftables-1.html">
<title>通过 dnsmasq nftset 和 nftables 对域名流量的控制</title>
<link>https://blog.niekun.net/archives/dnsmasq-nftset-nftables-1.html</link>
<dc:date>2024-05-07T10:31:00+08:00</dc:date>
<description>最近升级路由器系统到 openwrt 23，发现 dnsmasq-full 已经默认不支持 ipset 转而支持 nftset 了，所以之前的教程：通过 dnsmasq ipset 和 iptables 对域名流量的控制 已经不适用新版本系统。下面介绍如何通过 nfset 和 nftables 实现同样的功能。首先查看 dnsmasq 版本是否支持 nftset：root@OpenWrt:~# dnsmasq -v
Dnsmasq version 2.90  Copyright (c) 2000-2024 Simon Kelley
Compile time options: IPv6 GNU-getopt no-DBus UBus no-i18n no-IDN DHCP DHCPv6 no-Lua TFTP conntrack no-ipset nftset auth cryptohash DNSSEC no-ID loop-detect inotify dumpfile可以看到其中有 nftset 字样，如果没有就需要安装 dnsmasq-full，安装教程参考：dnsmasq 使用教程。nftables 提供 set 功能可以在一个路由表中建立特定名称一个 ip 库，并通过命令 ip daddr 索引库里的地址。先建立一个任意名称的路由表：nft add table tabletest
然后给这个路由表建立一个名称为 iplist 的 ip 库，并定义为 ipv4 地址：nft add set ip tabletest iplist { type ipv4_addr\; }
如果要添加一个 ip 网段，必须定义 ip 库属性：flags intervalnft add set ip tabletest iplist { type ipv4_addr \; flags interval \; }
现在就可以给这个 ip 库里添加 ip 地址了，命令如下：nft add element ip tabletest iplist { '111.22.33.4' };
nft add element ip tabletest iplist { '111.22.33.4/16' };
可以通过命令查看这个 ip 库里包含的所有地址：root@OpenWrt:~# nft list set ip tabletest iplist
table ip tabletest {
        set iplist {
                type ipv4_addr
                flags interval
                elements = { 111.22.33.4, 111.22.33.4/16 }
        }
}通过 dnsmasq 配置文件也可以添加指定域名解析出的 ip 地址到 nftset 对应 ip 库列表中，例如在 /etc/dnsmasq.conf 配置文件中添加以下指令：nftset=/qq.com/4#ip#tabletest#iplist
重启 dnsmasq 服务：service dnsmasq restart
查询一下 qq.com 的 ip 地址：root@OpenWrt:~# nslookup qq.com
Server:         127.0.0.1
Address:        127.0.0.1:53

Non-authoritative answer:
Name:   qq.com
Address: 157.255.219.143再次查看 iplist 表里包含的 ip 地址：root@OpenWrt:~# nft list set ip tabletest iplist
table ip tabletest {
        set iplist {
                type ipv4_addr
                flags interval
                elements = { 111.22.33.4, 111.22.33.4/16, 157.255.219.143 }
        }
}可以看到 qq.com 解析出来的 ip 地址已经放入了 iplist 表中。nftables 可以识别并处理 nftset 表中的 ip 地址，这样就可以做到对指定域名的流量控制。nftables 默认有 nat 和 filter 路由表，新建的自定义路由表需要首先指定某个路由链属于默认路由表的某个路由链类型。如：# 定义 tabletest 的 output 链，类型为 filter 路由表的 output 链
nft add chain tabletest output { type filter hook output priority 0 \; policy accept \; }

# 定义 tabletest 的 prerouting 链，类型为 nat 路由表的 prerouting 链
nft add chain tabletest prerouting { type nat hook prerouting priority 0 \; policy accept \; }nftables 规则处理 set 库里 ip 地址的流量：# 屏蔽本机对 iplist 库中 ip 地址的访问
nft add rule tabletest output ip daddr @iplist drop

# 目标地址为 set 库地址的prerouting tcp 流量转发到指定端口
nft add rule tabletest prerouting ip daddr @iplist ip protocol tcp redirect to :1081列出指定路由表定义的规则：root@OpenWrt:~# nft list table tabletest
table ip tabletest {
        set iplist {
                type ipv4_addr
                flags interval
                elements = { 111.22.33.4, 111.22.33.4/16, 157.255.219.143 }
        }

        chain output {
                type filter hook output priority filter; policy accept;
                ip daddr @iplist drop
        }

        chain prerouting {
                type nat hook prerouting priority filter; policy accept;
                ip daddr @iplist ip protocol tcp redirect to :1081
        }
}删除一个路由表：nft delete table tabletest
删除一个路由表中所有链和规则：nft flush table tabletest
删除指定路由表中某个路由链中的所有规则：nft flush chain tabletest output
参考链接fw4 Filtering traffic with IP sets by DNSnftablesSimple rule managementConfiguring tablesConfiguring Shadowsocks rules with nftset in OpenWRT 23</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/intel-12-CPU-vmwre.html">
<title>解决在 intel 12代以后的 CPU 上 vmwre 虚拟机性能低下问题</title>
<link>https://blog.niekun.net/archives/intel-12-CPU-vmwre.html</link>
<dc:date>2024-04-18T13:01:52+08:00</dc:date>
<description>最近更换了新的电脑，是 i7 12700H 的 CPU，按理说比以前的电脑性能好一些，但是导入之前的 vmware 虚拟机后发现运行起来优点卡顿，但是观察主机资源占用很低，cpu 占用也很低，研究了下才发现是由于新款 cpu 采用了大小核设计导致这个问题。我的这一款是 6 大核 8 小核 20 线程设计。默认情况下启动虚拟机资源分配是交给 windows 主机自己协调的，很可能会分配给小核运行虚拟机导致运行卡顿，资源管理器可以看到 cpu 负载都在后面的小核上：解决方法就是以管理员权限运行 vmware，这样 VMware 会自己调度资源使用，优先级大概是大核&gt;小核&gt;超线程。实际效果很明显，基本都运行在了大核上：</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/openwrt-1.html">
<title>openwrt 系统升级</title>
<link>https://blog.niekun.net/archives/openwrt-1.html</link>
<dc:date>2024-04-02T10:26:03+08:00</dc:date>
<description>小版本升级小版本升级，例如 19.05-&gt; 19.07。这种小版本的升级最方便的就是通过 Attended Sysupgrade 功能，可以保留已安装的包和系统设置。最大限度地无缝过渡。官方介绍：https://openwrt.org/docs/guide-user/installation/attended.sysupgrade需要先安装 Attended Sysupgrade luci 界面包：opkg install luci-app-attendedsysupgrade
建议使用此功能前依然做一次数据备份。然后重新登录 luci，在 system - Attended Sysupgrade 找到入口，点击 search for firmware upgrade 即可在线搜索可更新的系统。大版本升级最方便的就是通过 luci 界面升级系统，目前支持直接升级的大版本顺序是：19.07 &gt; 21.02 &gt; 22.03 &gt; 23.05。大版本升级改动openwrt 21：https://openwrt.org/releases/21.02/notes-21.02.0WPA3 support included by defaultTLS and HTTPS support included by defaultLuCI is now available over HTTPSInitial DSA support replaces the swconfig systemNew network configuration syntax and board.json changeKernel with container supportopenwrt 22：https://openwrt.org/releases/22.03/notes-22.03.0Firewall4 based on nftables，superseding the iptables-based firewall3Dark mode in LuCIopenwrt 23：https://openwrt.org/releases/23.05/notes-23.05.0Switch from wolfssl to mbedtls as default，TLS 1.3 SupportRust Package Support数据备份每个版本升级实际上就是重新刷入了一次固件，所以之前的配置文件什么的基本上都会被覆盖，所以系统内修改过的配置最好做一次备份。打开 luci 界面，选择 system - backup/flash firmware，在 configuration 菜单栏中将需要保存的文件或目录定义出来，然后在 action 菜单栏中选择 backup - generate archive 即可保存备份到本地。已安装包列表可以通过 awk 脚本识别出自己手动安装的包列表，方便更新系统后安装回去，下载脚本：https://github.com/richb-hanover/OpenWrtScripts/blob/main/opkgscript.sh执行以下命令会保存已安装的包列表到 /etc/config/opkg.installed：opkgscript.sh -v write
执行以下命令会识别并安装 /etc/config/opkg.installed 列表中的包：opkgscript.sh -v install
也可以执行以下 awk 脚本可以单独列出自己手动安装的包列表：#!/usr/bin/awk -f
BEGIN {
    ARGV[ARGC++] = &quot;/usr/lib/opkg/status&quot;
    cmd=&quot;opkg info busybox | grep '^Installed-Time: '&quot;
    cmd | getline FLASH_TIME
    close(cmd)
    FLASH_TIME=substr(FLASH_TIME,17)
}
/^Package:/{PKG= $2}
/^Installed-Time:/{
    INSTALLED_TIME= $2
    # Find all packages installed after FLASH_TIME
    if ( INSTALLED_TIME &gt; FLASH_TIME ) {
        cmd=&quot;opkg whatdepends &quot; PKG &quot; | wc -l&quot;
        cmd | getline WHATDEPENDS
        close(cmd)
        # If nothing depends on the package, it is installed by user
        if ( WHATDEPENDS == 3 ) print PKG
    }
}
EOF保存以上内容到 listuserpackages.awk 文件中并执行即可列出用户自行安装包列表。下载升级固件x86 版本的 openwrt 的升级固件就是全新安装时候用的固件，直接在官网下载需要版本的 gz 压缩包即可。下载地址：https://downloads.openwrt.org/releases/我下载的是：generic-ext4-combined.img.gz，注意不要解压出来，保留压缩包即可。进入 luci 的 system - backup/flash firmware 选择 Flash image ，然后选择刚才下载的压缩包即可上传更新，会提示是否保留设置和配置，跨大版本的升级必须取消选择保留数据，否则可能升级失败：如果升级后卡在 grub 界面说明可能是由于选择了保留配置导致升级失败了，可以参考官方教程通过 failsafe mode 恢复默认配置：Failsafe mode, factory reset, and recovery mode，或者直接重新安装系统。网络配置稍等几分钟安装好后你可能会发现 luci 无法在局域网中访问了，这是由于新安装的固件恢复了 network 配置，需要直接到 openwrt 设备上配置网络。配置教程参考：openwrt network 配置配置好网络后在局域网设备中可以用 ssh 登录了，此时会发现提示：@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the RSA key sent by the remote host is
SHA256:U9XODs/7A4k065pxSMyEtQ2m98v2P0bf/ML0MfzU.
Please contact your system administrator.
Add correct host key in C:\\Users\\Marco Nie/.ssh/known_hosts to get rid of this message.
Offending RSA key in C:\\Users\\Marco Nie/.ssh/known_hosts:6
Host key for 192.168.244.1 has changed and you have requested strict checking.
Host key verification failed.这是由于更新系统后 ssh 指纹发生了变化，需要删除本地缓存的 openwrt 设备的指纹在登陆，windows 系统 ssh 指纹保存地址为当前用户目录下的 .ssh 文件夹。升级后续升级后可以通过之前的脚本列出的已安装包的列表将自己需要的包安装回去，同时将备份数据按照新系统的格式恢复回去。从 openwrt 21 开始修改了 network 配置文件格式，参考：https://blog.niekun.net/archives/2291.html从 openwrt 22 开始替换 iptables 为 nftables，需要原始工具的话可以自行安装回去：opkg install iptables参考链接Opkg package managerOpenWRT 19.07 to 21.02.0 upgrade</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/Linux.html">
<title>Linux 查询及编辑用户及用户组</title>
<link>https://blog.niekun.net/archives/Linux.html</link>
<dc:date>2024-04-01T16:20:00+08:00</dc:date>
<description>查询当前所有用户compgen -u
查询当前所有用户组compgen -g
添加一个用户到某个组sudo usermod -a -G groupName userName
newgrp groupName
删除一个用户从某个组sudo usermod -G groupName userName
newgrp groupName
用户和组对文件的权限管理参考：chown 和 chmod 管理文件权限</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/openwrt.html">
<title>openwrt 添加新用户</title>
<link>https://blog.niekun.net/archives/openwrt.html</link>
<dc:date>2024-03-29T11:19:26+08:00</dc:date>
<description>安装好 openwrt 后默认有一个 root 用户，需要添加新用户也很简单，只需要在 /etc/passwd 文件最后按照格式增加一个用户即可，然后可以修改这个新用户的密码。下面使用一条命令快速添加新用户：grep -qw new_user /etc/passwd || echo &quot;new_user:x:0:23333:::&quot; &gt;&gt; /etc/passwd
命令先检查是否在文件中存在需要添加的用户名，如果不存在则在文件最后一行添加用户。其中 new_user 是用户名，0 是 uid，23333 是 gid。如果需要修改这个新用户的密码，执行命令即可：passwd new_user
以上就是创建新用户简单方法。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/Linux-ip.html">
<title>Linux 获取本地网关所有 ip 段地址</title>
<link>https://blog.niekun.net/archives/Linux-ip.html</link>
<dc:date>2024-03-28T15:35:07+08:00</dc:date>
<description>执行下面命令即可获取本地网关所有的 ip 段地址：$ ip address | grep -w inet | awk '{print $2}'
127.0.0.1/8
192.168.122.2/24
172.18.0.1/16
172.17.0.1/16
172.19.0.1/16</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/windows.html">
<title>windows 相对路径快捷方式</title>
<link>https://blog.niekun.net/archives/windows.html</link>
<dc:date>2024-03-18T10:09:15+08:00</dc:date>
<description>一般系统默认创建的都是指向某个文件绝对路径的快捷方式，如果移动原始文件位置后，快捷方式就失效了。可以自己修改快捷方式的属性来建立一个以快捷方式所在地址为准的指向一个相对路径的文件。这样适用于需要同时移动原始文件与快捷方式的情况。首先右键创建一个文件的快捷方式，然后右键选择快捷方式的属性，将目标位置地址改为：explorer.exe path/to/file.exe。注意 explorer.exe 后面的空格：后面的路径就是相对于快捷方式地址的相对路径。确认后默认快捷方式图标会变成资源管理器的图标，可以在属性里修改为其他图标。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/codesys-enum.html">
<title>codesys enum 枚举数据类型单元的使用</title>
<link>https://blog.niekun.net/archives/codesys-enum.html</link>
<dc:date>2024-03-07T08:21:07+08:00</dc:date>
<description>enum 类型的 dut 可以定义一组属性及其值，调用的时候可以方便的通过写其属性名称得到属性的值，也可以获取到属性本身的名称。下面举一个例子说明：{attribute 'qualified_only'}            // 必须先写类型名称再写属性名称 (例如 eColor.Red)
// {attribute 'strict'}                 //取消 'strict' 以允许转换 UDINT 数据类型
{attribute 'to_string'}                 // 运行字符串转换 (例如 TO_STRING(eColor.Red) = 'Red')
TYPE eColor :
(
    Red         := 16#FFFF0000,
    Green       := 16#FF00FF00,
    Blue        := 16#FF0000FF
    Yellow      := 16#FFFFFF00,
) UDINT;                                // 声明 UDINT 作为 int 整形类型
END_TYPE

// 定义一些变量
    ColorVar1   : eColor;
    ColorVar2   : eColor;
    ColorName   : STRING;
    ColorValue  : UDINT;

    ColorVar1 := eColor.Green;            // ColorVar1 = 16#FF00FF00
    ColorName := TO_STRING(ColorVar1);    // ColorName = 'Green';
    ColorValue := TO_UDINT(ColorVar1);    // ColorValue = 16#FF00FF00

    ColorVar2 := 16#FF00FF00;             // ColorVar2.Green
    ColorName := TO_STRING(ColorVar2);    // ColorName = 'Green';
    ColorValue := TO_UDINT(ColorVar2);    // ColorValue = 16#FF00FF00

    ColorVar1 := ColorVar2 OR eColor.Red; // 按位相与得到 Yellow=16#FFFFFF00
    ColorName := TO_STRING(ColorVar1);    // ColorName = 'Yellow';
    ColorValue := TO_UDINT(ColorVar1);    // ColorValue = 16#FFFFFF00以上示例列举了常用的 enum 类型可进行的数据交互方式。eColor.Green 可以获取enum类型属性的值，并可以赋值给其他对应 enum 实例TO_STRING(ColorVar1) 可以转换获取 enum 实例当前值对应属性名称字符串</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/codesys.html">
<title>codesys 常见编译及下载时报错解决方法</title>
<link>https://blog.niekun.net/archives/codesys.html</link>
<dc:date>2024-03-06T16:35:00+08:00</dc:date>
<description>No source code available for this object下载时出现此报警，原因是 task 任务中对 gou 的排序有问题，放在前面的 pou 中使用了后面 pou 才设定好的数据，需要重新排列 task 任务序列：SMC_FB_CALLED_FROM_WRONG_TASKmc_power mc_jog 等控制轴的功能块，一运行就报错 SMC_FB_CALLED_FROM_WRONG_TASK，可能是不同的 pou 放在了多个 task 任务中，循环中内部有了冲突，将所有的 pou 放在同一个 task 中就可以解决问题。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/immich.html">
<title>服务器部署 immich 照片备份工具</title>
<link>https://blog.niekun.net/archives/immich.html</link>
<dc:date>2024-03-04T09:30:00+08:00</dc:date>
<description>目前有很多的云备份服务可以使用，比如 icloud，google photos 等。immich 是一款实现类似功能的本地部署工具，将数据都存储在自己本地服务器上，拥有完善的手机端 app 可以方便的同步备份手机图片。GitHub 主页：https://github.com/immich-app/immich官网教程：https://immich.app/docs/overview/introduction/安装服务端使用 docker compose 安装，新建一个 immich 文件夹，下载 docker-compose.yml 和 .env 文件到文件夹：wget https://github.com/immich-app/immich/releases/latest/download/docker-compose.yml
wget -O .env https://github.com/immich-app/immich/releases/latest/download/example.env打开 .env 文件配置环境变量，主要就是配置备份路径和数据库密码，修改 UPLOAD_LOCATION 和 DB_PASSWORD。启动容器：docker compose up -d后续更新只需要进入 immich 文件夹执行下面命令即可：docker compose pull &amp;&amp; docker compose up -d
docker-compose.yml 文件中默认将 3001 端口映射到了本地 2283 端口，3001就是服务端访问端口号。下面是所有可用的端口，根据需要可以修改 docker-compose 文件映射到本地：PORTWeb Port3000webSERVER_PORTServer Port3001serverMICROSERVICES_PORTMicroservices Port3002microservicesMACHINE_LEARNING_HOSTMachine Learning Host0.0.0.0machine learningMACHINE_LEARNING_PORTMachine Learning Port3003machine learning配置账户网页端访问：http://you.machine.ip:2283 进入配置页面，根据提示建立一个管理员账户，后续可以在管理员账户中建立其他子账户供其他人使用。登录 app下载手机端 app，ios 直接在 app store 搜索 immich 下载，安卓在 github 发布页下载 apk：https://github.com/immich-app/immich/releases在手机端输入以下网址进入：http://you.machine.ip:2283/api然后就可以配置需要备份的手机端图片文件夹了。外网访问服务器在本地，如果要外网域名远程访问图库，需要一些额外的配置，我这里是通过 cloudflare 配置子域名，nginx 配置反向代理到 frps，最后本地服务器 frpc 配置本地 2283 端口绑定到远程域名访问即可。可以参考我之前的关于 frp 的教程：https://blog.niekun.net/archives/539.html</description>
</item>
</rdf:RDF>