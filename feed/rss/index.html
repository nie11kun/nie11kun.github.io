<?xml version="1.0" encoding="UTF-8"?>
<rdf:RDF
xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
xmlns="http://purl.org/rss/1.0/"
xmlns:dc="http://purl.org/dc/elements/1.1/">
<channel rdf:about="https://blog.niekun.net/feed/rss/">
<title>Marco Nie</title>
<link>https://blog.niekun.net/</link>
<description>you are the company you keep...</description>
<items>
<rdf:Seq>
<rdf:li resource="https://blog.niekun.net/archives/2757.html"/>
<rdf:li resource="https://blog.niekun.net/archives/2749.html"/>
<rdf:li resource="https://blog.niekun.net/archives/2744.html"/>
<rdf:li resource="https://blog.niekun.net/archives/2742.html"/>
<rdf:li resource="https://blog.niekun.net/archives/2731.html"/>
<rdf:li resource="https://blog.niekun.net/archives/2727.html"/>
<rdf:li resource="https://blog.niekun.net/archives/2705.html"/>
<rdf:li resource="https://blog.niekun.net/archives/2703.html"/>
<rdf:li resource="https://blog.niekun.net/archives/2672.html"/>
<rdf:li resource="https://blog.niekun.net/archives/2642.html"/>
</rdf:Seq>
</items>
</channel>
<item rdf:about="https://blog.niekun.net/archives/2757.html">
<title>Windows 配置 FTP 服务器</title>
<link>https://blog.niekun.net/archives/2757.html</link>
<dc:date>2022-09-15T15:04:00+08:00</dc:date>
<description>Windows 10 以上系统自带 FTP server，可以简单的搭建一个局域网内应用的 FTP 服务器。下面介绍具体操作流程。搜索 windows feature 打开功能开关配置界面：开启如下 ftp 相关选项，确认后等待安装完成：搜索 Administrative Tools：双击 Internet Information Services (IIS) Manager:sites 上右键点击 add ftp site：设置名称及共享路径：选择无 ssl：选择 basic 验证以及指定可登录 FTP 的用户，设置读写权限：可以单独建立一个用户用来登录 ftp，建立账户可以参考我的教程：https://blog.niekun.net/archives/2103.html#title-4设置完成后，点击完成即可。然后配置防火墙例外，搜索 allow an app through windows firewall:在列表中找到 ftp server 并打勾即可：以上就完成了 Windows 端 ftp 服务器的搭建，可以使用 ftp 客户端登录此 ftp 服务器了。参考链接：How to set up and manage an FTP server on Windows 10</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/2749.html">
<title>Miniflux 搭建自己的 RSS 服务系统</title>
<link>https://blog.niekun.net/archives/2749.html</link>
<dc:date>2022-08-12T14:50:00+08:00</dc:date>
<description>一直在使用 feedly 作为 rss 订阅器阅读文章，基本可以满足我的需求，但是部分站点只能预览摘要，想要阅读全文还打开文章链接。最近发现一个开源免费的 rss 系统，他的特点就是轻量无多于内容，致力于阅读体验。同时我发现他的一些独有功能，可以在文章只显示摘要时，有一个下载全文的选项，这样就实现了大部分文章在 rss 阅读器中就可以阅读全文的需求了。Miniflux 需要自己部署在服务器上，它提供了多种安装方法，最简单的就是 docker 方式，避免手动配置环境及数据库等步骤。我的系统环境：Ubuntu server 20.04Miniflux 官网：https://miniflux.app/GitHub 主页：https://github.com/miniflux/v2安装这里介绍通过 docker compose 安装的方法，关于 docker 环境的部署参考我的教程：https://blog.niekun.net/archives/2742.html#title-1新建 miniflux 文件夹用来放置相关配置：mkdir miniflux
cd miniflux
然后建立 docker-compose.yml 配置文件，内容如下：version: '3.4'
services:
  miniflux:
    image: ${MINIFLUX_IMAGE:-miniflux/miniflux:latest}
    container_name: miniflux
    restart: always
    ports:
      - &quot;18080:8080&quot;
    depends_on:
      - db
    environment:
      - DATABASE_URL=postgres://miniflux:secret@db/miniflux?sslmode=disable
      - BASE_URL=https://miniflux.your.domain
      - RUN_MIGRATIONS=1
      - CREATE_ADMIN=1
      - ADMIN_USERNAME=admin
      - ADMIN_PASSWORD=test123
      - DEBUG=1
    # Optional health check:
    # healthcheck:
    #  test: [&quot;CMD&quot;, &quot;/usr/bin/miniflux&quot;, &quot;-healthcheck&quot;, &quot;auto&quot;]
  db:
    image: postgres:latest
    container_name: postgres
    restart: always
    environment:
      - POSTGRES_USER=miniflux
      - POSTGRES_PASSWORD=secret
    volumes:
      - miniflux-db:/var/lib/postgresql/data
    healthcheck:
      test: [&quot;CMD&quot;, &quot;pg_isready&quot;, &quot;-U&quot;, &quot;miniflux&quot;]
      interval: 10s
      start_period: 30s
volumes:
  miniflux-db:其中需要自行根据实际情况修改一些内容：port 端口的主机映射，这里我使用了 18080 映射容器内的 8080 端口BASE_URL 设置需要访问 miniflux 服务的域名地址，后面需要配置反向代理ADMIN_USERNAME 设置管理员用户名ADMIN_PASSWORD  设置管理员用户密码敏感的环境变量值可以单独放在同配置文件路径下的 .env 文件中，上面的 docker 安装教程中有介绍。注意 DATABASE_URL 地址中的 postgres 用户名密码对应于 POSTGRES_USER 和 POSTGRES_PASSWORD 的值，需要保持一致。然后就可以启动容器：docker-compose up -d
反代配置首先如果需要解析到二级域名下，先要在 ns 服务端添加二级域名的 A 记录，然后才能正常解析 url。使用域名访问 miniflux 服务，需要通过主机使用的反代软件配置解析，我服务器使用的是 nginx，下面介绍配置方法。给 nginx 配置添加如下内容：server {
    listen        443 ssl http2;
    listen        [::]:443 ssl http2;
    server_name   miniflux.your.domain;
    include       my-server/ssl;

    location / {
        proxy_pass          http://127.0.0.1:18080;
        proxy_redirect      off;

        proxy_set_header    Host              $host;
        proxy_set_header    X-Forwarded-Host  $host;
        proxy_set_header    X-Real-IP         $remote_addr;
        proxy_set_header    X-Forwarded-For   $proxy_add_x_forwarded_for;
        proxy_set_header    X-Forwarded-Proto $scheme;
        proxy_set_header    Upgrade           $http_upgrade;
        proxy_set_header    Connection        &quot;upgrade&quot;;
        proxy_http_version  1.1;
    }
}以上配置需要根据实际情况修改监听端口及 domain，由于之前配置的 miniflux 的映射端口是 18080，所以反代到本地的对应端口即可。以上 miniflux 和 nginx 反代配置完成后应该就可以访问 https://miniflux.your.domain 了。用户名密码就是 docker 配置文件中定义的管理员账户及密码：使用如果某一篇文章不显示全文，只需要点击文章顶部的 download 按钮即可加载全文：miniflux 提供了丰富的 api 接口可供二次开发使用，通过简单的请求就可以获取到文章的各种信息，返回数据为 json 格式。官方 api 文档参考：https://miniflux.app/docs/api.html</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/2744.html">
<title>自建 RustDesk server</title>
<link>https://blog.niekun.net/archives/2744.html</link>
<dc:date>2022-08-07T14:08:23+08:00</dc:date>
<description>RustDesk 是一款开源的跨平台远程桌面软件，类似于 TeamViewer 的 UI 样式，但它是完全免费的。RustDesk 提供了 3 个免费的转发服务器，会根据你的地理位置自动选择最快的，一般使用足够了，如果对安全性有担忧，它们也提供了 server 端应用，可以自建转发服务器。下面就对搭建 server 端做一些介绍。RustDesk GitHub 主页：https://github.com/rustdesk/rustdeskRustDesk Server GitHub 主页：https://github.com/rustdesk/rustdesk-server服务器平台：ubuntu 20.04安装 server我是通过 docker 安装的 server 端，这样最快速简单。关于 docker 和 docker compose 的安装可以参考我之前的文章：https://blog.niekun.net/archives/2742.html#title-1docker-compose.yml 文件内容如下：version: '3'

networks:
  rustdesk-net:
    external: false

services:
  hbbs:
    container_name: hbbs
    ports:
      - 21115:21115
      - 21116:21116
      - 21116:21116/udp
      - 21118:21118
    image: rustdesk/rustdesk-server:latest
    command: hbbs -r 127.0.0.1:21117
    volumes:
      - ./data:/root
    networks:
      - rustdesk-net
    depends_on:
      - hbbr
    restart: unless-stopped

  hbbr:
    container_name: hbbr
    ports:
      - 21117:21117
      - 21119:21119
    image: rustdesk/rustdesk-server:latest
    command: hbbr
    volumes:
      - ./data:/root
    networks:
      - rustdesk-net
    restart: unless-stopped默认监听的是 21117 端口，客户端默认也是链接服务器的这个端口。这里配置监听本地 127.0.0.1。实际在通过域名或 IP 访问服务器时依然可以连接上服务。如果修改这里的默认端口，则在客户端设置的时候也需要指定此端口。启动服务：docker-compose up -d
此时在客户端设置 ID server：在第一行填入服务器 IP 地址即可：确认后，如果下方状态栏显示 ready 表示服务器链接正常：配置域名访问如果想要使用域名作为 server id，只需要在你的域名服务器里加上一条自定义的域名 NS 解析即可，如：rust.abc.com。注意如果你使用的是 cloudflare 服务，由于它在启用 CDN 后只支持少数端口的转发，而我们需要使用的是 21115 - 21119 这些端口，所以需要在 dns 配置时取消这个自定义域名的小黄云，只使用其 dns 服务：关于 cloudflare 的网络端口转发相关的信息参考官网内容：Network ports自定义域名配置好后，就可以在客户端的 ID server 中使用域名链接了。方法和上面介绍的用服务器 IP 设置的方法相同。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/2742.html">
<title>Joplin server 搭建</title>
<link>https://blog.niekun.net/archives/2742.html</link>
<dc:date>2022-07-14T08:19:00+08:00</dc:date>
<description>joplin 是一款开源笔记应用，全平台适用，支持多种云端同步方式。最近体验了下感觉不错，尤其是可以自行搭建 server 服务端保存数据，适合喜欢管理整个数据流程的人士。下面介绍如何在服务器通过 docker 搭建 joplin server 的方法。joplin 官网：https://joplinapp.org/GitHub 主页：https://github.com/laurent22/joplin各个平台客户端下载：https://joplinapp.org/download/我的服务器系统平台是 Ubuntu 20.04。docker 环境安装首先如果安装过老版的 docker 先卸载:sudo apt-get remove docker docker-engine docker.io containerd runc
安装基础环境： sudo apt-get update
 sudo apt-get install \
    ca-certificates \
    curl \
    gnupg \
    lsb-release添加 docker 官方 GPG key：sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
echo &quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null安装 docker 和 docker-compose： sudo apt-get update
 sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugindocker 配置为非 root 用户，解决执行命令需要 sudo：sudo groupadd docker
sudo usermod -aG docker $USER
su - ${USER}配置 docker-compose通过 docker-compose 可以方便的配置 docker 容器设置及多容器之间数据交互。新建 joplin 文件夹用来存放配置 docker-compose.yml 以及 .env 环境变量文件，我喜欢放在 opt 路径下：mkdir /opt/docker/joplin
cd /opt/docker/joplin
新建环境变量文件 .env 内容如下：APP_BASE_URL=https://joplin.your.site
APP_PORT=22300
# 
DB_CLIENT=postgres
POSTGRES_PASSWORD=PASSWORD
POSTGRES_DATABASE=joplin
POSTGRES_USER=USERNAME
POSTGRES_PORT=5432
POSTGRES_HOST=localhost上面的配置中需要自行修改几项：APP_BASE_URL 修改为你实际访问 joplin 服务的外网地址，需要提前配置好 dns 映射，我是通过 cloudflare 管理的POSTGRES_PASSWORD 修改数据库密码POSTGRES_USER 修改数据库用户名新建 docker-compose.yml 内容如下：version: '3'
services:
    db:
        image: postgres:13
        volumes:
            - ./data/postgres:/var/lib/postgresql/data
        ports:
            - &quot;5432:5432&quot;
        restart: unless-stopped
        environment:
            - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
            - POSTGRES_USER=${POSTGRES_USER}
            - POSTGRES_DB=${POSTGRES_DATABASE}
        network_mode: host
    app:
        image: joplin/server:latest
        depends_on:
            - db
        ports:
            - &quot;22300:22300&quot;
        restart: unless-stopped
        environment:
            - APP_PORT=${APP_PORT}
            - APP_BASE_URL=${APP_BASE_URL}
            - DB_CLIENT=${DB_CLIENT}
            - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
            - POSTGRES_DATABASE=${POSTGRES_DATABASE}
            - POSTGRES_USER=${POSTGRES_USER}
            - POSTGRES_PORT=${POSTGRES_PORT}
            - POSTGRES_HOST=${POSTGRES_HOST}
        network_mode: hostdocker-compose 会自动调用同一路径下的 .env 文件中定义的环境变量。完成配置后启动容器：docker-compose up -d
nginx 配置外网访问上面定义的 url 后，需要通过反向代理将数据流传给 joplin server 端口 22300，我使用的是 nginx 配置如下：server {
    listen        443 ssl http2;
    listen        [::]:443 ssl http2;
    server_name   joplin.your.site;
    include       my-server/ssl; 加入 ssl 相关配置

    location / {
        proxy_pass          http://127.0.0.1:22300;
        proxy_redirect      off;

        proxy_set_header    Host              $host;
        proxy_set_header    X-Real-IP         $remote_addr;
        proxy_set_header    X-Forwarded-For   $proxy_add_x_forwarded_for;
        proxy_set_header    X-Forwarded-Proto $scheme;
        proxy_set_header    Upgrade           $http_upgrade;
        proxy_set_header    Connection        &quot;upgrade&quot;;
        proxy_http_version  1.1;
    }
}完成后重启 nginx：systemctl restart nginx
访问配置好 docker 和 nginx 后就可以访问上面设置的 url 访问 joplin 了，默认会自动创建一个用户 admin@localhost，密码是 admin。第一次登录进去后最好修改下默认管理员密码，还可以创建多个账户。如果要适用账户的邮件服务，需要额外配置 SMTP 相关的内容，这里不做介绍，新建账户的激活邮件可以在管理菜单中找到，没有配置邮件服务的话无法发送成功，可以手动将邮件中的账户激活链接发送给别人。如果登录网址无法访问网页，可能是 docker 配置有问题，可以通过 log 查看是否有报错信息：docker container list # 查询到容器的 ID
docker logs ID # 通过 joplin 的容器 ID 查询其日志
插件joplin 桌面版支持安装插件，第三方插件有很多，可以在下面链接查找：Joplin Plugin Repository参考链接nstall Docker Engine on UbuntuHow To Install and Use Docker on Ubuntu 20.04docker logsjoplin server installdocker-compose.server.yml.env-sample</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/2731.html">
<title>Gradient 渐变色研究</title>
<link>https://blog.niekun.net/archives/2731.html</link>
<dc:date>2022-07-06T11:44:00+08:00</dc:date>
<description>图片中经常可以使用到渐变色，两个颜色形成自然过渡效果，在实际体验中可以发现，有时候渐变色看起来很舒服，有时候看起来比较别扭，下面分析一下其中原因。下图是两个颜色组成的渐变效果，它们两端的颜色都一样，但是效果相差很多：明显左边的看起来更加舒服，右边的比较生硬。我们知道每个颜色都是 RGB 的组合，通常 RGB 各自有 256 种变化范围，它们之间的组合产生了各种颜色：在 Photoshop 中选取一种颜色的方法有四种：RGB，HSB，LAB，CMYK。最常用的就是 RGB 和 HSB，下面主要围绕这两种方法介绍。不同于 RGB，HSB 或 HSV 拾取一种颜色是通过 H色相，S饱和度，B亮度确定的：当我们需要创建两个颜色的渐变图时，如果使用 RGB 模式，则它们的渐变过程是直接从两个颜色之间直线过渡。而使用 HSB 模式，它们的渐变过程是围绕 H色相环过渡到目标颜色：所以 RGB 模式就会穿过中间的灰色地带，效果就是过渡中颜色变淡变暗，这也就是看起开不舒服的原因。而 HSB 模式下饱和度和亮度都保持不变，只是色相发生变化，从而整体色彩持续保持鲜艳，呈现的效果就是看起来舒服。Photoshop 中创建渐变时，提供了 3 种模式可供选择，还原了 RGB 模式 和 HSB 模式的规则，分别是：perceptual，linear，classic：各种模式区别为：linear 最接近 HSB 模式，保证了过渡时候的饱和度和亮度，反映出颜色最鲜艳perceptual 在过渡中保证亮度稳定，但是降低了饱和度classic 在过渡中保证了饱和度稳定，但是降低了亮度三者对比图如下：实际使用中根据需要选择合适效果。参考链接：https://twitter.com/finmoorhouse/status/1543580508508065794</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/2727.html">
<title>安装内核插件修复第三方 SSD 导致 MacBook 待机耗电大问题</title>
<link>https://blog.niekun.net/archives/2727.html</link>
<dc:date>2022-06-26T13:05:33+08:00</dc:date>
<description>前几年给我的 MacBook Pro 2015 升级了 512G SSD 硬盘，什么都挺好就是合盖待机耗电量很大，一晚上基本就跑了 20% 电量，之前也研究过解决方法，还写过几篇博客：使用 OpenCore Legacy Patcher 为 2015 款 MacBook Pro 激活 AirPlay，macOS 电源管理修复 MacBook 休眠耗电大问题，但是最后都发现问题依旧。今天在国外苹果论坛上看到有人介绍通过安装一些内核插件降低待机时候 ssd 的功率从而解决耗电问题https://discussions.apple.com/thread/252167491：1) Get the newest firmware, where power management is already better and/or some sleep/wake issues are resolveda) Either by upgrading to Big Sur (or in Catalina, Mojave the latest security updates) with your original SSD insideORb) Upgrading Boot ROM Version without upgrading to Big Sur2) Install tools which significantly lower the idle wattage for 3rd party SSDsa) SsdPmEnablerb) NVMeFix plugin inside liluc) a+b combined reach an even lower wattage in most cases主要是第二条介绍的几个内核插件，SsdPmEnabler, lilu, NVMeFix都是在 GitHub 上的开源软件，三个都是提供 .kext 文件，需要将 .kext 文件复制到系统路径 /Library/Extensions，重启系统即可。后续我会测试是否有效。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/2705.html">
<title>esxi 配置 GPU 显卡直通给虚拟机使用</title>
<link>https://blog.niekun.net/archives/2705.html</link>
<dc:date>2022-05-25T08:56:00+08:00</dc:date>
<description>最近在我家里的 Ubuntu 上安装了 jellyfin 媒体中心，发现局域网内播放高码率视频卡顿严重，原因是默认设置的是软解码导致 cpu 负载很高，在设置里可以开启硬件解码，但是配置后发现播放视频会报错：客户端配置文件存在问题，服务器未发送兼容的媒体格式看后台 log 日志，发现在 ffmpeg 解码时有如下报错信息：[AVHWDeviceContext @ 0x558b80b15a80] libva: vaGetDriverNameByIndex() failed with unknown libva error, driver_name = (null)
[AVHWDeviceContext @ 0x558b80b15a80] Failed to initialise VAAPI connection: -1 (unknown libva error).
Device creation failed: -5.
Failed to set value 'vaapi=va:/dev/dri/renderD128' for option 'init_hw_device': Input/output error
Error parsing global options: Input/output error查找原因测试在 docker-compose.yml 中开启全部权限，配置 root PUID PGID，以及映射 GPU 设备给 docker：    environment:
      - PUID=0
      - PGID=0
    devices:
      - /dev/dri:/dev/dri
    privileged: true重启容器后依然会报错。报错信息显示无法读取 gpu 驱动名称，这应该不是 docker 的问题，在主机上测试 vainfo 也会报错：$ vainfo
error: can't connect to X server!
libva info: VA-API version 1.14.0
libva error: vaGetDriverNameByIndex() failed with unknown libva error, driver_name = (null)
vaInitialize failed with error code -1 (unknown libva error),exit报错内容和 jellyfin 的日志类似，测试添加环境变量强制指定驱动名称：export LIBVA_DRIVER_NAME=iHD再次 vainfo：$ vainfo
error: can't connect to X server!
libva info: VA-API version 1.14.0
libva info: User environment variable requested driver 'iHD'
libva info: Trying to open /usr/local/lib/dri/iHD_drv_video.so
libva info: Found init function __vaDriverInit_1_14
DRM_IOCTL_I915_GEM_APERTURE failed: Invalid argument
Assuming 131072kB available aperture size.
May lead to reduced performance or incorrect rendering.
get chip id failed: -1 [22]
param: 4, val: 0
libva error: /usr/local/lib/dri/iHD_drv_video.so init failed
libva info: va_openDriver() returns 18
vaInitialize failed with error code 18 (invalid parameter),exit现在看来应该是其他问题了，经过查询，esxi 默认是分配了虚拟显卡给虚拟机，导致虚拟机无法调用 gpu 底层的一些功能，从而导致 ffmpeg 等工具硬件解码失效。处理办法就是在 esxi 上配置显卡直通，然后添加给对应虚拟机直接调用硬件资源。经过下面的尝试，我还是设置显卡直通，导致最终无法实现硬件解码。可能是主板上有限制吧。显卡直通显卡直通应该就可以解决上面的问题，但是当我直接进入 esxi 控制台设备管理中却找不到 GPU 设备，需要进入 esxi ssh 查看是否有 GPU 设备类似于：UHD Graphics 630。ssh 登录 esxi 后台，首先查看是否有 GPU相关设备信息，终端命令行执行：lspci -v
找到显卡设备ID，如图所示：8086:9bc8 就是显卡设备 ID，其中 8086 是供应商 ID，也就是代表 Intel，9bc8 就是这块显卡的设备硬件 ID。然后关闭 esxi 对 GPU 的调用，然后手动添加 pci 设备信息，然后就可以在控制台配置直通了。通过 ssh 登录 esxi，输入如下命令取消显卡占用，注意取消后就不能连接显示器访问 esxi 后台图形界面了：esxcli system settings kernel set -s vga -v FALSE后期如果需要取消显卡直通或者登录图形后台需要重新开启显卡调用：esxcli system settings kernel set -s vga -v TRUE然后修改 passthru.map 添加 PCIE 设备 ID 信息。修改/etc/vmware/passthru.map 文件，根据上面找到的设备 ID 信息，在最底部增加以下信息：完成后保存并退出，然后重启 esxi。重启完成后就可以从控制台 pci 设备中找到显卡了：配置好直通后，给对应虚拟机配置显卡。虚拟机配置首先编辑虚拟机，CPU虚拟化这三个选项全部取消，未取消开启虚拟机会报错：由于硬件或软件支持不可用,因此无法为 0:2.0 注册设备 pciPassthru0：内存勾选预留所有客户机内存（全部锁定）选项，不勾选启动虚拟机会报错：最后添加显卡：然后配置虚拟机自定义参数：进入虚拟机选项 → 高级 → 配置参数 → 编辑配置添加以下参数：  键值hypervisor.cpuid.v0FALSE此参数的作用：不让操作系统识别是在虚拟机环境运行，一般直通独立显卡需要这样设置，核显可忽略，但设置也无妨。如下图所示：由于虚拟机默认有一个虚拟显卡，我们又添加了一个直通显卡，现在就有了两个显卡，但我们只想要直通的显卡工作，可以在配置参数里添加一行:  键值svga.presentFALSE这样操作后，我们开启虚拟机后再 /dev/dri 目录下就只会有一个 renderD128：ls -l /dev/dri/

total 0
crw-rw---- 1 root video 226,   0 Oct 23 20:41 card0
crw-rw---- 1 root video 226, 128 Oct 23 20:41 renderD128查看 pci 设备信息：&lt;&gt; sudo lspci -v -s  04:00.0
04:00.0 VGA compatible controller: Intel Corporation HD Graphics 530 (rev 06) (prog-if 00 [VGA controller])
    Subsystem: Hewlett-Packard Company Device 82bf
    Physical Slot: 161
    Flags: bus master, fast devsel, latency 64, IRQ 67
    Memory at fc000000 (64-bit, non-prefetchable) [size=16M]
    Memory at d0000000 (64-bit, prefetchable) [size=256M]
    I/O ports at 7000 [size=64]
    Expansion ROM at &lt;unassigned&gt; [disabled]
    Capabilities: [40] Vendor Specific Information: Len=0c &lt;?&gt;
    Capabilities: [70] Express Endpoint, MSI 00
    Capabilities: [ac] MSI: Enable+ Count=1/1 Maskable- 64bit-
    Capabilities: [d0] Power Management version 2
    Capabilities: [100] Process Address Space ID (PASID)
    Capabilities: [200] Address Translation Service (ATS)
    Capabilities: [300] Page Request Interface (PRI)
    Kernel driver in use: i915
    Kernel modules: i915这样显卡就直接直通给了虚拟机，注意这样配置后包括 esxi 本身和其他虚拟机就没有显卡可用了，导致没有图形界面。参考链接ESXI 7.02 Intel 核心显卡直通开启3D加速ESXi 6.5 Passthrough Video Card/GPU to Plex VMHW Transcoding - VAAPI - Intel not workingDeploying Hardware-Accelerated Graphics with VMware HorizonEsxi 6.7核显直通问题求教各位恩山大神Name: UHD Graphics 630</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/2703.html">
<title>Ubuntu 开启 RDP 远程连接</title>
<link>https://blog.niekun.net/archives/2703.html</link>
<dc:date>2022-05-23T10:18:00+08:00</dc:date>
<description>之前介绍过通过安装 TightVNC vnc server 远程连接 Ubuntu 桌面的教程，Windows 下常用的是 RDP 方式远程，使用体验非常流畅，不占用带宽。Linux 下也可以通过安装 Xrdp 的方式实现 rdp 连接。参考教程：Ubuntu desktop 配置 vnc serverxrdp 是对 Windows rdp 协议的开源实现。安装我的系统是 Ubuntu desktop 20.04，首先需要保证有一个已经安装的桌面环境，desktop 版默认是 genome，也可以安装其他的如 xfce：sudo apt install ubuntu-desktop安装 xrdp：sudo apt install xrdp安装完成后，xrdp 会自动启动，可以通过命令查看状态：$  sudo systemctl status xrdp
 
● xrdp.service - xrdp daemon
     Loaded: loaded (/lib/systemd/system/xrdp.service; enabled; vendor preset: enabled)
     Active: active (running) since Mon 2022-05-23 09:50:43 CST; 20min ago
       Docs: man:xrdp(8)
             man:xrdp.ini(5)
    Process: 83586 ExecStartPre=/bin/sh /usr/share/xrdp/socksetup (code=exited, status=0/SUCCESS)
    Process: 83594 ExecStart=/usr/sbin/xrdp $XRDP_OPTIONS (code=exited, status=0/SUCCESS)
   Main PID: 83595 (xrdp)
      Tasks: 2 (limit: 9459)
     Memory: 26.4M
     CGroup: /system.slice/xrdp.service
             ├─83595 /usr/sbin/xrdp
             └─83597 /usr/sbin/xrdp默认 rdp 端口为 3389.配置xrdp 安装后，会自动将一个 ssl key ssl-cert-snakeoil.key 放入 /etc/ssl/private/ 文件夹，需要将 xrdp 用户添加到 ssl-cert 用户组确保 xrdp 可以读取这个 ssl key：sudo adduser xrdp ssl-cert默认配置测试访问会有黑屏问题，显示不出来界面，需要修改 /etc/xrdp/startwm.sh 文件，在文件最后的 test -x /etc/X11/Xsession 前面加入如下内容：unset DBUS_SESSION_BUS_ADDRESS
unset XDG_RUNTIME_DIR重启 xrdp 服务：sudo systemctl restart xrdp现在就可以正常通过 rdp 连接到 Ubuntu了。在使用中，我出现了输入用户密码后停留在解锁界面无法登录进去的问题，经过查询 xdrp 目前不可以同时在多个设备上尝试登录。同时登录 xrdp 的用户如果和正常在主机上登录的是同一个用户，需要删除 dbus-user-session 包，用 dbus-x11 代替。第三点，需要保证 gdm3 运行，执行下面的命令：sudo apt remove dbus-user-session
sudo apt install dbus-x11

sudo systemctl set-default graphical
sudo systemctl isolate graphical重启 xrdp 服务：sudo systemctl restart xrdp此时应该就可以正常通过 rdp 客户端链接 ubuntu 界面了。但是我测试发现，第一次登录进去没问题，关闭后过一会儿再次尝试链接发现卡在登录界面没反应了，尝试执行如下命令：echo xfce4-session &gt; $HOME/.xsession
chmod +x .xsession发现问题似乎解决了，但是调用的事 xfce 桌面环境。远程登录在局域网下访问比较流畅，但是在外网下发现没法达到 Windows rdp 流畅的效果。解决方法可以是在外网通过 rdp 链接一个局域网下 Windows 设备，然后在 Windows 设备下通过 rdp 链接局域网内的 ubuntu 设备。参考链接How to Install Xrdp on Ubuntu 20.04Xrdp stuck on login, after password is entered, unblocked if I unlock from the ubuntu rdp serverUsing the console and XRDP together in Debian / Ubuntu / MintXRDP session immediately closes after loggin in</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/2672.html">
<title>使用曲线匹配颜色 in Photoshop</title>
<link>https://blog.niekun.net/archives/2672.html</link>
<dc:date>2022-05-12T10:36:00+08:00</dc:date>
<description>之前介绍过几种色彩匹配的方法，通过对亮度、颜色、饱和度的进行匹配，也可以通过设置曲线的黑、灰、白场来匹配颜色。下面介绍通过通过提取源图像和目标图像的黑白灰色彩，然后通过曲线将他们进行色彩匹配达到最终的效果。参考教程：精细匹配颜色 in Photoshop简易匹配颜色 in Photoshop用到的技术：曲线，拾色器原图如下：我们的目标是将左边的衣服颜色转换为右边衣服的色彩。首先在背景图层上新建两个空白图层，用来提取两人的衣服的黑白灰色彩信息：通过拾色工具分别拾取两个衣服的黑白灰部区域的色彩，并通过画笔工具记录在两个图层中，注意拾取颜色的时候设置为 3×3 或 5×5：新建曲线图层，放在最上方：首先提取右侧衣服色彩 rgb 信息，快捷键 I 选择拾色工具然后按 shift + alt 键分别在三条色彩上点击，注意操作的时候要选择到最上方的图层，否则拾取的颜色会不对：可以看到面板中保存了三个点位的rgb信息，我们后续需要将左侧的三条色条匹配为这里记录的颜色。下面在曲线图层中操作，我们需要在曲线中找到左侧三条颜色所在的位置，按 shift + ctrl 点击左侧第一条线，在曲线图层中会自动创建一个锚点就是拾取颜色所在的位置，在 rgb，red，green，blue 通道中都会有一个点：同样的方法将左侧三条颜色都在曲线中获取锚点：我们需要在 red green blue 通道的锚点中，将 output 信息修改为目标颜色的对应通道数值，比如右侧第一条亮部 rgb 为：216，92，59。我们就将刚才每个通道的 output 信息修改为这个值：以此类推将左侧三条颜色所在锚点的 output 修改为右侧记录的颜色 rgb 值：将 reference 图层放到曲线上方，可以看到记录的两个衣服色彩的 reference 和 target 图层颜色已经完全一致了：选中拾色器工具，同样的 shift + alt 点击三个之前创建的锚点可以删除它们。下面需要选出左侧衣服部分，临时关闭除背景外的其他图层，使用钢笔工具或其他你常用的工具提取出左侧衣服部分的选区，然后给曲线图层添加图层蒙版：根据实际情况，可以对曲线每个锚点的位置进行微调，以达到最佳效果。最终效果如下：以上就完成了简单的颜色匹配。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/2642.html">
<title>制作水坑效果 in Photoshop</title>
<link>https://blog.niekun.net/archives/2642.html</link>
<dc:date>2022-05-07T14:53:00+08:00</dc:date>
<description>今天介绍给晴朗路面添加雨天水坑效果，实际效果还不错。用到的技术：vanishing point，channel，puddle texture材质。原图如下：首先我们创建路面部分的立体平面，选择 filter - vanishing point：点击 create plant tool：根据路面形状，通过点击绘制出一个大致的梯形，注意如果轨迹不符合路面形状会显示为红色：拖拽线段扩展到整个路面：以上就完成了平面的构建，点击确认返回。首先复制背景图层。然后我们通过钢笔工具或者其他工具建立地面的选区：给复制的图层建立图层蒙版：然后解锁蒙版和图层的锁，否则后面颠倒图层蒙版也会动：然后选中图层而不是蒙版，点击 edit - transform - flip vertical：调整图层位置到合适：然后临时关闭路面倒影的图层，我们制作水坑的效果。首先需要一个水坑素材图片，如下图：导入 ps 后选中材质图层，按住 ctrl 点击图层全选材质图层，点击 ctrl c 复制图层，然后就可以关闭材质图层了：新建一个空白图层，再次打开 vanishing point，按 ctrl v 复制材质图层到界面：首先按ctrl T适当缩小图像，然后拖拽图层到下方创建的平面内：按住 ctrl 拖拽图层，复制多个图层铺满整个路面：完成后点击确认返回 ps，会将填充的平面内容在新图层上：我们需要利用涂层的黑白部分反差作为模拟水滩效果，所以首先提高图层反差，新建曲线图层并设置只影响材质图层，提高亮部：然后临时关闭其他图层，只保留材质图层：进入通道，选择一个通道按住 ctrl 点击通道获取选区：然后关闭材质图层，打开背景图层和路面反转图层，并将反转图层单独建立一个组：选中组，点击创建蒙版：这样我们就有了基本效果啦。下面微调效果，首先倒影是在路面上形成的，所以他的颜色分布也应该符合路面的色彩分布，所以我们在反转组内建立一个 gradient map 图层并锁定之影响下方图层：修改 map 颜色，亮部选区一个路面上较量区域的色彩，同样的暗部选取一个路面较暗的区域色彩，注意选择 3×3 拾取颜色：根据情况调节 gradient map 不透明度：水坑里的倒影一般会有一定的模糊，我们先将倒影图层转换为 smart object 然后选 filter - blur galley - path blur：根据情况可以适当加强一下饱和度，新建 vibrate 图层，调节饱和度：最终效果对比：</description>
</item>
</rdf:RDF>