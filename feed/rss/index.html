<?xml version="1.0" encoding="UTF-8"?>
<rdf:RDF
xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
xmlns="http://purl.org/rss/1.0/"
xmlns:dc="http://purl.org/dc/elements/1.1/">
<channel rdf:about="https://blog.niekun.net/feed/rss/">
<title>Marco Nie</title>
<link>https://blog.niekun.net/</link>
<description>you are the company you keep...</description>
<items>
<rdf:Seq>
<rdf:li resource="https://blog.niekun.net/archives/nftables.html"/>
<rdf:li resource="https://blog.niekun.net/archives/dnsmasq-nftset-nftables-1.html"/>
<rdf:li resource="https://blog.niekun.net/archives/intel-12-CPU-vmwre.html"/>
<rdf:li resource="https://blog.niekun.net/archives/openwrt-1.html"/>
<rdf:li resource="https://blog.niekun.net/archives/Linux.html"/>
<rdf:li resource="https://blog.niekun.net/archives/openwrt.html"/>
<rdf:li resource="https://blog.niekun.net/archives/Linux-ip.html"/>
<rdf:li resource="https://blog.niekun.net/archives/windows.html"/>
<rdf:li resource="https://blog.niekun.net/archives/codesys-enum.html"/>
<rdf:li resource="https://blog.niekun.net/archives/codesys.html"/>
</rdf:Seq>
</items>
</channel>
<item rdf:about="https://blog.niekun.net/archives/nftables.html">
<title>nftables 使用教程</title>
<link>https://blog.niekun.net/archives/nftables.html</link>
<dc:date>2024-05-08T10:14:00+08:00</dc:date>
<description>新版本的 openwrt 使用 fw4 防火墙，默认已经从 iptables 切换到了 nftables，语法有了很大的变化，下面介绍 nftables 的使用方法。路由表配置路由表是 nftables 中最顶层的容器，它管理着  chains, sets, maps, flowtables, 和 stateful objects.family 集合每个路由表都只能属于一个 family 集合，可用的 family 有：ip      监听 ipv4 的流量ip6     监听 ipv6 的流量inet    同时监听 ipv4 和 ipv6 的流量arp     监听 ARP-level 地址解析协议的流量bridge  监听 bridge 桥接流量 如交换机netdev  用于监听某个单独网卡的流量基本语法新建路由表：nft add table ip tabletest
以上命令在 ip 集合中新建一个名称为 tabletest 的路由表，可以处理 ipv4 流量路由表列表：# 列出所有路由表
nft list tables

# 列出所有 ip 集合的路由表
nft list tables ip删除一个路由表：nft delete table ip tabletest
路由链配置不同于 iptables，nftables 没有预定义的链，如 input output 等。想要在某个环节处理流量，需要定义一个自定义名称的基本链，然后将其挂载在一个特定的 netfilter hook 钩子上。下图是流量包在 linux 网络中的传输路径：流量传输到本机后开始监听 prerouting 和 input hooks，然后经过本机处理后流向 output -&gt; postrouting hooks。注意如果本机作为 router 路由使用，需要开启 ip 转发：echo 1 &gt; /proc/sys/net/ipv4/ip_forward
如果传入本机的流量目标地址不是本机，则受 forward hook 监听，这类流量的路径是 prerouting -&gt; forward -&gt; postrouting。以下是 netfilter 可用的 chains 和 hooks 列表：基本语法建立基本链，挂载在一个特定的 netfilter hook：nft add chain [&lt;family&gt;] &lt;table_name&gt; &lt;chain_name&gt; { type &lt;type&gt; hook &lt;hook&gt; priority &lt;value&gt; \; [policy &lt;policy&gt; \;] [comment \&quot;text comment\&quot; \;] }
注意，由于 nft 语法使用了特殊字符，如: ;，在命令行中执行需要加转义符 \。或者可以使用单引号 '` 将 nft 后的语句包起来，以下两种写法效果相同：nft add chain ip tabletest input { type filter hook input priority 0 \; }
nft 'add chain ip tabletest input { type filter hook input priority 0 ; }'
另一种方法是运行 nft 在交互模式，执行以下命令后就可以不加转义符: nft -i。上面的命令在 tebletest 路由表中新建一个 input 链，挂载在 filter 路由链的 input hook 上。这样就可以监听所有进入本地的流量。priority 决定了所有链的顺序，例如在 filter input hook 上挂载了多个自定义链，通过 priority 决定其执行顺序。数值越低执行优先级越高，例如 -12, -1, 0, 10。如果给多个挂载在同一个 hook 上的自定义基本链同样的 priority，它们的先后执行顺序就是不确定的。添加以下命令后就可以在 tabletest 基本链中监听本机输出的流量：nft 'add chain ip tabletest output { type filter hook output priority 0 ; }'
如果不定义大括号中的内容，也就是不挂载在特定 hook 上，则路由链不会监听任何流量。policy 定义了默认的策略，可用的默认策略为：accept 和 drop，如果路由链中的规则都没有匹配则会应用默认策略：accept 没有匹配到的流量继续在网络层传输drop   没有匹配到的流量被丢弃type 定义了挂载的基本 chain 类型，可用的基本链类型：filter, 用于过滤流量包route, 用于重路由，等同于 iptables 的 mangle 路由链的 output hook (其他 mangle hooks 可以使用 filter 代替)nat, 用于运行 Networking Address Translation (NAT). 只有第一个 nat 流量包会匹配到此链剩余的包会跳过此链，因此尽量不要使用此链过滤流量hook 定义了挂载的基本链 hook，可用的 hooks 如下：ingress 只能用于 netdev 和 inet family: 监听来自于 NIC driver 的流量, 早于 prerouting.prerouting: 监听所有在 routing 前的入口流量. 流量可能重定向到 local 或 remote systems.input: 监听所有被路由或重定向到 local system 的入口流量forward: 监听所有不被重定向到 local system 的入口流量output: 监听所有在 local machine 被管理的出口流量postrouting: 监听所有被路由后的即将离开 local system 的出口流量列出一个路由表的所有路由链：nft list ip table tabletest
列出一个路由表的指定路由链：nft list chain ip tabletest output
基本规则配置通过规则可以控制路由链上的流量。基本语法添加规则：nft add rule ip tabletest output ip daddr 8.8.8.8 counter
以上命令会在 tabletest 路由表的 output 链中添加一条规则，匹配出口流量中 ip 地址为 8.8.8.8 的流量并对匹配次数计数，nftables 中 counter 会默认启用即使不写。以上命令相当于 iptables 中的 -A 命令。列出某个链包含的规则：root@OpenWrt:~# nft list chain ip tabletest output
table ip tabletest {
        chain output {
                type filter hook output priority filter; policy accept;
                ip daddr 8.8.8.8 counter packets 0 bytes 0
        }
}下面测试以上规则是否生效，执行以下命令：ping -c 1 8.8.8.8再次查看此链的规则：root@OpenWrt:~# nft list chain ip tabletest output
table ip tabletest {
        chain output {
                type filter hook output priority filter; policy accept;
                ip daddr 8.8.8.8 counter packets 1 bytes 84
        }
}可以看到已经有一次计数了。指定位置添加规则：nftables 中必须通过 handle num 编号来在指定位置添加规则，需要通过 -a 查看链中已经存在的规则的编号：nft -n -a list table ip tabletest
-n 可以按数字顺序排号避免出现重复编号。再次查看链中的规则：root@OpenWrt:~# nft -n -a list table ip tabletest
table ip tabletest { # handle 4
        chain output { # handle 1
                type filter hook output priority 0; policy accept;
                ip daddr 8.8.8.8 counter packets 0 bytes 0 # handle 5
        }
}handle 5 就是这条规则的编号。下面我们通过 handle 索引在这条规则后添加一条新规则：nft add rule ip tabletest output position 5 ip daddr 127.0.0.8 drop
查看链中的规则：root@OpenWrt:~# nft -n -a list table ip tabletest
table ip tabletest { # handle 4
        chain output { # handle 1
                type filter hook output priority 0; policy accept;
                ip daddr 8.8.8.8 counter packets 0 bytes 0 # handle 5
                ip daddr 127.0.0.8 drop # handle 6
        }
}如果要在某条规则前插入一条规则需要使用 insert 指令：nft insert rule ip tabletest output position 5 ip daddr 127.1.1.8 drop
查看效果：root@OpenWrt:~# nft -n -a list table ip tabletest
table ip tabletest { # handle 4
        chain output { # handle 1
                type filter hook output priority 0; policy accept;
                ip daddr 127.1.1.8 drop # handle 7
                ip daddr 8.8.8.8 counter packets 0 bytes 0 # handle 5
                ip daddr 127.0.0.8 drop # handle 6
        }
}在某条链最前面添加一条规则：nft insert rule ip tabletest output ip daddr 192.168.2.1 counter
在最前面添加规则就不需要指定 handle 了。替换某条规则：替换一条规则也需要 handle 编号。下面示例会替换 handle 5 为新的规则：nft replace rule ip tabletest output handle 5 ip daddr 1.1.1.1
删除规则：同样的，删除某一条规则也需要获取这条规则的 handle 编号。删除 tabletest 链的 handle 7 规则： nft delete rule ip tabletest output handle 7
删除链中所有规则：nft flush chain ip tabletest output
删除路由表中所有链的所有规则：nft flush table ip tabletest
ruleset 层级的操作显示所有 family 的所有 rule 规则：nft list ruleset
显示某一个集合的所有 rule： % nft list ruleset arp
 % nft list ruleset ip
 % nft list ruleset ip6
 % nft list ruleset bridge
 % nft list ruleset inet清除所有集合的所有规则：nft flush ruleset
清除某一个集合的所有规则： % nft flush ruleset arp
 % nft flush ruleset ip
 % nft flush ruleset ip6
 % nft flush ruleset bridge
 % nft flush ruleset inet备份规则到文件：# 备份所有集合的所有规则
nft list ruleset &gt;&gt; backup.nft

# 备份 ip 集合的所有规则
nft list ruleset ip &gt;&gt; backup.nft从文件恢复规则：nft -f backup.nft
以 json 格式显示所有规则：nft --json list ruleset
流量元信息匹配通过 meta 选择器可以进行流量匹配或流量设置。下面简单介绍几个常用的匹配模式，更加详细的参考官方资料：https://wiki.nftables.org/wiki-nftables/index.php/Matching_packet_metainformationiifname 匹配网卡名称：# lo 网卡的入口流量会被接收
nft add rule tabletest input meta iifname lo acceptmark 匹配流量标记：# 流量标记为 123 的出口流量计数
nft add rule tabletest output meta mark 123 counterskgid 匹配流量由特定 gid 用户产生的数据：# 匹配来自 gid 用户 1000 的流量
nft add rule tabletest output meta skgid 1000 counter流量头信息匹配通过 ip {saddr | daddr}  可以匹配 ipv4 的 源流量或目标流量：# 匹配来自 192.168.1.100 且去往 192.168.1.1 的流量并计数
nft add rule tabletest input ip saddr 192.168.1.100 ip daddr 192.168.1.1 counter参考链接nftables HOWTO documentation pageNftables familiesNetfilter hooksOperations at ruleset level</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/dnsmasq-nftset-nftables-1.html">
<title>通过 dnsmasq nftset 和 nftables 对域名流量的控制</title>
<link>https://blog.niekun.net/archives/dnsmasq-nftset-nftables-1.html</link>
<dc:date>2024-05-07T10:31:00+08:00</dc:date>
<description>最近升级路由器系统到 openwrt 23，发现 dnsmasq-full 已经默认不支持 ipset 转而支持 nftset 了，所以之前的教程：通过 dnsmasq ipset 和 iptables 对域名流量的控制 已经不适用新版本系统。下面介绍如何通过 nfset 和 nftables 实现同样的功能。首先查看 dnsmasq 版本是否支持 nftset：root@OpenWrt:~# dnsmasq -v
Dnsmasq version 2.90  Copyright (c) 2000-2024 Simon Kelley
Compile time options: IPv6 GNU-getopt no-DBus UBus no-i18n no-IDN DHCP DHCPv6 no-Lua TFTP conntrack no-ipset nftset auth cryptohash DNSSEC no-ID loop-detect inotify dumpfile可以看到其中有 nftset 字样，如果没有就需要安装 dnsmasq-full，安装教程参考：dnsmasq 使用教程。nftables 提供 set 功能可以在一个路由表中建立特定名称一个 ip 库，并通过命令 ip daddr 索引库里的地址。关于 nftables 的使用教程参考：nftables 使用教程先建立一个任意名称的路由表：nft add table tabletest
然后给这个路由表建立一个名称为 iplist 的 ip 库，类型定义为 ipv4 地址：nft add set ip tabletest iplist { type ipv4_addr\; }
如果要添加一个 ip 网段，必须定义 ip 库属性：flags intervalnft add set ip tabletest iplist { type ipv4_addr \; flags interval \; }
现在就可以给这个 ip 库里添加 ip 地址了，命令如下：nft add element ip tabletest iplist { '111.22.33.4' };
nft add element ip tabletest iplist { '111.22.33.4/16' };
可以通过命令查看这个 ip 库里包含的所有地址：root@OpenWrt:~# nft list set ip tabletest iplist
table ip tabletest {
        set iplist {
                type ipv4_addr
                flags interval
                elements = { 111.22.33.4, 111.22.33.4/16 }
        }
}通过 dnsmasq 配置文件也可以添加指定域名解析出的 ip 地址到 nftset 对应 ip 库列表中，例如在 /etc/dnsmasq.conf 配置文件中添加以下指令：nftset=/qq.com/4#ip#tabletest#iplist
重启 dnsmasq 服务：service dnsmasq restart
查询一下 qq.com 的 ip 地址：root@OpenWrt:~# nslookup qq.com
Server:         127.0.0.1
Address:        127.0.0.1:53

Non-authoritative answer:
Name:   qq.com
Address: 157.255.219.143再次查看 iplist 表里包含的 ip 地址：root@OpenWrt:~# nft list set ip tabletest iplist
table ip tabletest {
        set iplist {
                type ipv4_addr
                flags interval
                elements = { 111.22.33.4, 111.22.33.4/16, 157.255.219.143 }
        }
}可以看到 qq.com 解析出来的 ip 地址已经放入了 iplist 表中。nftables 可以识别并处理 nftset 表中的 ip 地址，这样就可以做到对指定域名的流量控制。新建的自定义路由表需要首先指定某个动作链条属于什么动作链类型。如：# 定义 tabletest 的 output 链，类型为 filter 路由链的动作链 &quot;output&quot;
# 优先级 0 表示：(在任何路由决策前捕获传入数据包)
# 策略为 accept 表示没有匹配流量后继续传入后续路由表及规则进行匹配
nft add chain tabletest output { type filter hook output priority 0 \; policy accept \; }

# 定义 tabletest 的 prerouting 链，类型为 NAT 路由链的动作链 &quot;prerouting&quot;
nft add chain tabletest prerouting { type nat hook prerouting priority 0 \; policy accept \; }nftables 规则处理 set 库里 ip 地址的流量：# 屏蔽本机对 iplist 库中 ip 地址的访问
nft add rule tabletest output ip daddr @iplist drop

# 目标地址为 set 库地址的prerouting tcp 流量转发到指定端口
nft add rule tabletest prerouting ip daddr @iplist ip protocol tcp redirect to :1081列出指定路由表定义的规则：root@OpenWrt:~# nft list table tabletest
table ip tabletest {
        set iplist {
                type ipv4_addr
                flags interval
                elements = { 111.22.33.4, 111.22.33.4/16, 157.255.219.143 }
        }

        chain output {
                type filter hook output priority filter; policy accept;
                ip daddr @iplist drop
        }

        chain prerouting {
                type nat hook prerouting priority filter; policy accept;
                ip daddr @iplist ip protocol tcp redirect to :1081
        }
}删除一个路由表：nft delete table tabletest
删除一个路由表中所有规则，保留路由链定义：nft flush table tabletest
删除指定路由表中某个路由链中的所有规则：nft flush chain tabletest output
参考链接fw4 Filtering traffic with IP sets by DNSnftablesSimple rule managementConfiguring tablesConfiguring Shadowsocks rules with nftset in OpenWRT 23</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/intel-12-CPU-vmwre.html">
<title>解决在 intel 12代以后的 CPU 上 vmwre 虚拟机性能低下问题</title>
<link>https://blog.niekun.net/archives/intel-12-CPU-vmwre.html</link>
<dc:date>2024-04-18T13:01:52+08:00</dc:date>
<description>最近更换了新的电脑，是 i7 12700H 的 CPU，按理说比以前的电脑性能好一些，但是导入之前的 vmware 虚拟机后发现运行起来优点卡顿，但是观察主机资源占用很低，cpu 占用也很低，研究了下才发现是由于新款 cpu 采用了大小核设计导致这个问题。我的这一款是 6 大核 8 小核 20 线程设计。默认情况下启动虚拟机资源分配是交给 windows 主机自己协调的，很可能会分配给小核运行虚拟机导致运行卡顿，资源管理器可以看到 cpu 负载都在后面的小核上：解决方法就是以管理员权限运行 vmware，这样 VMware 会自己调度资源使用，优先级大概是大核&gt;小核&gt;超线程。实际效果很明显，基本都运行在了大核上：</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/openwrt-1.html">
<title>openwrt 系统升级</title>
<link>https://blog.niekun.net/archives/openwrt-1.html</link>
<dc:date>2024-04-02T10:26:03+08:00</dc:date>
<description>小版本升级小版本升级，例如 19.05-&gt; 19.07。这种小版本的升级最方便的就是通过 Attended Sysupgrade 功能，可以保留已安装的包和系统设置。最大限度地无缝过渡。官方介绍：https://openwrt.org/docs/guide-user/installation/attended.sysupgrade需要先安装 Attended Sysupgrade luci 界面包：opkg install luci-app-attendedsysupgrade
建议使用此功能前依然做一次数据备份。然后重新登录 luci，在 system - Attended Sysupgrade 找到入口，点击 search for firmware upgrade 即可在线搜索可更新的系统。大版本升级最方便的就是通过 luci 界面升级系统，目前支持直接升级的大版本顺序是：19.07 &gt; 21.02 &gt; 22.03 &gt; 23.05。大版本升级改动openwrt 21：https://openwrt.org/releases/21.02/notes-21.02.0WPA3 support included by defaultTLS and HTTPS support included by defaultLuCI is now available over HTTPSInitial DSA support replaces the swconfig systemNew network configuration syntax and board.json changeKernel with container supportopenwrt 22：https://openwrt.org/releases/22.03/notes-22.03.0Firewall4 based on nftables，superseding the iptables-based firewall3Dark mode in LuCIopenwrt 23：https://openwrt.org/releases/23.05/notes-23.05.0Switch from wolfssl to mbedtls as default，TLS 1.3 SupportRust Package Support数据备份每个版本升级实际上就是重新刷入了一次固件，所以之前的配置文件什么的基本上都会被覆盖，所以系统内修改过的配置最好做一次备份。打开 luci 界面，选择 system - backup/flash firmware，在 configuration 菜单栏中将需要保存的文件或目录定义出来，然后在 action 菜单栏中选择 backup - generate archive 即可保存备份到本地。已安装包列表可以通过 awk 脚本识别出自己手动安装的包列表，方便更新系统后安装回去，下载脚本：https://github.com/richb-hanover/OpenWrtScripts/blob/main/opkgscript.sh执行以下命令会保存已安装的包列表到 /etc/config/opkg.installed：opkgscript.sh -v write
执行以下命令会识别并安装 /etc/config/opkg.installed 列表中的包：opkgscript.sh -v install
也可以执行以下 awk 脚本可以单独列出自己手动安装的包列表：#!/usr/bin/awk -f
BEGIN {
    ARGV[ARGC++] = &quot;/usr/lib/opkg/status&quot;
    cmd=&quot;opkg info busybox | grep '^Installed-Time: '&quot;
    cmd | getline FLASH_TIME
    close(cmd)
    FLASH_TIME=substr(FLASH_TIME,17)
}
/^Package:/{PKG= $2}
/^Installed-Time:/{
    INSTALLED_TIME= $2
    # Find all packages installed after FLASH_TIME
    if ( INSTALLED_TIME &gt; FLASH_TIME ) {
        cmd=&quot;opkg whatdepends &quot; PKG &quot; | wc -l&quot;
        cmd | getline WHATDEPENDS
        close(cmd)
        # If nothing depends on the package, it is installed by user
        if ( WHATDEPENDS == 3 ) print PKG
    }
}
EOF保存以上内容到 listuserpackages.awk 文件中并执行即可列出用户自行安装包列表。下载升级固件x86 版本的 openwrt 的升级固件就是全新安装时候用的固件，直接在官网下载需要版本的 gz 压缩包即可。下载地址：https://downloads.openwrt.org/releases/我下载的是：generic-ext4-combined.img.gz，注意不要解压出来，保留压缩包即可。进入 luci 的 system - backup/flash firmware 选择 Flash image ，然后选择刚才下载的压缩包即可上传更新，会提示是否保留设置和配置，跨大版本的升级必须取消选择保留数据，否则可能升级失败：如果升级后卡在 grub 界面说明可能是由于选择了保留配置导致升级失败了，可以参考官方教程通过 failsafe mode 恢复默认配置：Failsafe mode, factory reset, and recovery mode，或者直接重新安装系统。网络配置稍等几分钟安装好后你可能会发现 luci 无法在局域网中访问了，这是由于新安装的固件恢复了 network 配置，需要直接到 openwrt 设备上配置网络。配置教程参考：openwrt network 配置配置好网络后在局域网设备中可以用 ssh 登录了，此时会发现提示：@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the RSA key sent by the remote host is
SHA256:U9XODs/7A4k065pxSMyEtQ2m98v2P0bf/ML0MfzU.
Please contact your system administrator.
Add correct host key in C:\\Users\\Marco Nie/.ssh/known_hosts to get rid of this message.
Offending RSA key in C:\\Users\\Marco Nie/.ssh/known_hosts:6
Host key for 192.168.244.1 has changed and you have requested strict checking.
Host key verification failed.这是由于更新系统后 ssh 指纹发生了变化，需要删除本地缓存的 openwrt 设备的指纹在登陆，windows 系统 ssh 指纹保存地址为当前用户目录下的 .ssh 文件夹。升级后续升级后可以通过之前的脚本列出的已安装包的列表将自己需要的包安装回去，同时将备份数据按照新系统的格式恢复回去。从 openwrt 21 开始修改了 network 配置文件格式，参考：https://blog.niekun.net/archives/2291.html从 openwrt 22 开始替换 iptables 为 nftables，需要原始工具的话可以自行安装回去：opkg install iptables参考链接Opkg package managerOpenWRT 19.07 to 21.02.0 upgrade</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/Linux.html">
<title>Linux 查询及编辑用户及用户组</title>
<link>https://blog.niekun.net/archives/Linux.html</link>
<dc:date>2024-04-01T16:20:00+08:00</dc:date>
<description>查询当前所有用户compgen -u
查询当前所有用户组compgen -g
添加一个用户到某个组sudo usermod -a -G groupName userName
newgrp groupName
删除一个用户从某个组sudo usermod -G groupName userName
newgrp groupName
用户和组对文件的权限管理参考：chown 和 chmod 管理文件权限</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/openwrt.html">
<title>openwrt 添加新用户</title>
<link>https://blog.niekun.net/archives/openwrt.html</link>
<dc:date>2024-03-29T11:19:26+08:00</dc:date>
<description>安装好 openwrt 后默认有一个 root 用户，需要添加新用户也很简单，只需要在 /etc/passwd 文件最后按照格式增加一个用户即可，然后可以修改这个新用户的密码。下面使用一条命令快速添加新用户：grep -qw new_user /etc/passwd || echo &quot;new_user:x:0:23333:::&quot; &gt;&gt; /etc/passwd
命令先检查是否在文件中存在需要添加的用户名，如果不存在则在文件最后一行添加用户。其中 new_user 是用户名，0 是 uid，23333 是 gid。如果需要修改这个新用户的密码，执行命令即可：passwd new_user
以上就是创建新用户简单方法。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/Linux-ip.html">
<title>Linux 获取本地网关所有 ip 段地址</title>
<link>https://blog.niekun.net/archives/Linux-ip.html</link>
<dc:date>2024-03-28T15:35:07+08:00</dc:date>
<description>执行下面命令即可获取本地网关所有的 ip 段地址：$ ip address | grep -w inet | awk '{print $2}'
127.0.0.1/8
192.168.122.2/24
172.18.0.1/16
172.17.0.1/16
172.19.0.1/16</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/windows.html">
<title>windows 相对路径快捷方式</title>
<link>https://blog.niekun.net/archives/windows.html</link>
<dc:date>2024-03-18T10:09:15+08:00</dc:date>
<description>一般系统默认创建的都是指向某个文件绝对路径的快捷方式，如果移动原始文件位置后，快捷方式就失效了。可以自己修改快捷方式的属性来建立一个以快捷方式所在地址为准的指向一个相对路径的文件。这样适用于需要同时移动原始文件与快捷方式的情况。首先右键创建一个文件的快捷方式，然后右键选择快捷方式的属性，将目标位置地址改为：explorer.exe path/to/file.exe。注意 explorer.exe 后面的空格：后面的路径就是相对于快捷方式地址的相对路径。确认后默认快捷方式图标会变成资源管理器的图标，可以在属性里修改为其他图标。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/codesys-enum.html">
<title>codesys enum 枚举数据类型单元的使用</title>
<link>https://blog.niekun.net/archives/codesys-enum.html</link>
<dc:date>2024-03-07T08:21:07+08:00</dc:date>
<description>enum 类型的 dut 可以定义一组属性及其值，调用的时候可以方便的通过写其属性名称得到属性的值，也可以获取到属性本身的名称。下面举一个例子说明：{attribute 'qualified_only'}            // 必须先写类型名称再写属性名称 (例如 eColor.Red)
// {attribute 'strict'}                 //取消 'strict' 以允许转换 UDINT 数据类型
{attribute 'to_string'}                 // 运行字符串转换 (例如 TO_STRING(eColor.Red) = 'Red')
TYPE eColor :
(
    Red         := 16#FFFF0000,
    Green       := 16#FF00FF00,
    Blue        := 16#FF0000FF
    Yellow      := 16#FFFFFF00,
) UDINT;                                // 声明 UDINT 作为 int 整形类型
END_TYPE

// 定义一些变量
    ColorVar1   : eColor;
    ColorVar2   : eColor;
    ColorName   : STRING;
    ColorValue  : UDINT;

    ColorVar1 := eColor.Green;            // ColorVar1 = 16#FF00FF00
    ColorName := TO_STRING(ColorVar1);    // ColorName = 'Green';
    ColorValue := TO_UDINT(ColorVar1);    // ColorValue = 16#FF00FF00

    ColorVar2 := 16#FF00FF00;             // ColorVar2.Green
    ColorName := TO_STRING(ColorVar2);    // ColorName = 'Green';
    ColorValue := TO_UDINT(ColorVar2);    // ColorValue = 16#FF00FF00

    ColorVar1 := ColorVar2 OR eColor.Red; // 按位相与得到 Yellow=16#FFFFFF00
    ColorName := TO_STRING(ColorVar1);    // ColorName = 'Yellow';
    ColorValue := TO_UDINT(ColorVar1);    // ColorValue = 16#FFFFFF00以上示例列举了常用的 enum 类型可进行的数据交互方式。eColor.Green 可以获取enum类型属性的值，并可以赋值给其他对应 enum 实例TO_STRING(ColorVar1) 可以转换获取 enum 实例当前值对应属性名称字符串</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/codesys.html">
<title>codesys 常见编译及下载时报错解决方法</title>
<link>https://blog.niekun.net/archives/codesys.html</link>
<dc:date>2024-03-06T16:35:00+08:00</dc:date>
<description>No source code available for this object下载时出现此报警，原因是 task 任务中对 gou 的排序有问题，放在前面的 pou 中使用了后面 pou 才设定好的数据，需要重新排列 task 任务序列：SMC_FB_CALLED_FROM_WRONG_TASKmc_power mc_jog 等控制轴的功能块，一运行就报错 SMC_FB_CALLED_FROM_WRONG_TASK，可能是不同的 pou 放在了多个 task 任务中，循环中内部有了冲突，将所有的 pou 放在同一个 task 中就可以解决问题。</description>
</item>
</rdf:RDF>