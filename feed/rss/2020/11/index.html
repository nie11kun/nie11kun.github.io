<?xml version="1.0" encoding="UTF-8"?>
<rdf:RDF
xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
xmlns="http://purl.org/rss/1.0/"
xmlns:dc="http://purl.org/dc/elements/1.1/">
<channel rdf:about="https://blog.niekun.net/feed/rss/2020/11/">
<title>Marco Nie - 2020年11月</title>
<link>https://blog.niekun.net/2020/11/</link>
<description>you are the company you keep...</description>
<items>
<rdf:Seq>
<rdf:li resource="https://blog.niekun.net/archives/1898.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1911.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1906.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1904.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1903.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1900.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1899.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1895.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1894.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1893.html"/>
</rdf:Seq>
</items>
</channel>
<item rdf:about="https://blog.niekun.net/archives/1898.html">
<title>C++ 入门教程 -- 数据类型，数组及指针</title>
<link>https://blog.niekun.net/archives/1898.html</link>
<dc:date>2020-11-19T15:54:00+08:00</dc:date>
<description>介绍数据类型操作系统根据数据类型分配内存空间，同一种数据类型才可以进行计算，如：合法的运算：55+15 //  legal C++ expression
非法的运算：55 + &quot;John&quot; // illegal

数字类型的有两种类型：整型，如：7，10。浮点型，如：3.14，5.67。字符串是一个数字、字符、符号的集合。使用双引号来标记，如：&quot;hello&quot;。字符使用单引号来标记，如：'A'。Boolean 类型只有两个可能的值：true 和 false。整型整型一般默认 4 个字节的存储空间。使用 int 来定义：int a = 42;
带符号型，可以定义正数和负数，一般不写默认 int 就是带符号型：signed int a;
无符号型，只能定义正数型：unsigned int a;
short 型，一般默认空间占用大小，就是 2 个字节：short int a;
long 型，2倍默认空间大小：long int a;
浮点型有三种浮点类型：float, double, 和 long double。浮点型都是 signed 带符号型的。一般情况下，float 型 4 个字节，double 型 8 个字节，long double 型 16 个字节。使用 float 来定义：float a = 3.14;
字符串string 字符串类型是一个字符、数字和符号的集合，使用双引号来标记。使用 string 定义变量，需要使用 &lt;string&gt; 库：#include &lt;string&gt;
using namespace std;

int main() {
    string test = &quot;hello&quot;;
    return 0;
}注意：&lt;string&gt; 库包含在 &lt;iostream&gt; 库中，所以如果已经引用来 &lt;iostream&gt; 就不需要再引用 &lt;string&gt; 了。char 类型char 类型包含了 1 个字节的整数，但是解释器会将这个整数解释为 ASCII 码对应字符。使用单引号来标记，如：char a = 'a';
变量定义规则所有变量的定义需要遵守以下规则：变量名首位必须是一个字母或下划线 _首字符之后的可以使用字母或数字，不能使用特殊字符或空格一般有两种常用的定义方法首字母及每个单词的首字符大写，如: BlankWord首字母小写后续的每个单词首字符大写，如：blankWord所有的变量名都是区分大小写的，如：helloword 和 HelloWord 是两个变量。数组数组是一个同一种数据类型变量的集合体，只需要一次就可以定义多个同一种变量类型的变量。如：int a[5] = {1, 2, 5, 7, 8};
变量名后方括号[]定义数组内变量个数，大括号{}内包含数组内元素实际值，使用逗号,分隔各个元素。注意大括号内的元素个数不能超过数组变量定义的个数。也可以在定义时不说明元素个数：int a[] = {1, 3, 7, 9};
会自动创建足够存储内部元素的数组。数组内每个元素都有一个 index 索引，从 0 开始，所以数组内第一个元素索引为 0，第二个为 1。使用索引号可以访问对应元素：int b[] = {11, 45, 62, 70, 88};

cout &lt;&lt; b[0] &lt;&lt; endl;
// Outputs 11

cout&lt;&lt; b[3] &lt;&lt; endl;
// Outputs 70如果需要逐个访问数组内元素，可以使用 loop 循环来实现：int myArr[5];

for(int x=0; x&lt;5; x++) {
  myArr[x] = 42;
}多维数组以上是单维数组的定义，也可以定义多维数组，如定义一个二位数组：int a[3][4];
想象这个数组为一个矩阵，有三行，每行 4 个元素：定义多维数组定义元素需要每行在一个大括号下单独定义：int x[2][3] = {
  {2, 3, 4}, // 1st row
  {8, 9, 10} // 2nd row
};也可以在一行内定义：int x[2][3] = {{2, 3, 4}, {8, 9, 10}};
使用行号和列号来定位一个元素：int x[2][3] = {{2, 3, 4}, {8, 9, 10}};
cout &lt;&lt; x[0][2] &lt;&lt; endl;

//Outputs 4指针每个变量都存储在内存单元内，每个内存空间都有地址。这个内存地址可以使用地址查询符&amp;来查询，如：int score = 5;
cout &lt;&lt; &amp;score &lt;&lt; endl;

//Outputs &quot;0x29fee8&quot;返回的地址就是存储变量 score 的值的地址空间。一个 pointer 指针就是一个存储某个变量所在内存地址的变量。指针类型可以使某些任务实现更加方便，某些任务，如动态内存分配则必须使用指针来实现。不同类型的指针变量的唯一区别就是其所在内存地址的数据类型的不同。和其他变量类型一样，定义指针变量需要申明类型。使用星号* 来表示是指针类型的变量。int *ip;  // pointer to an integer
double *dp;   // pointer to a double
float *fp;  // pointer to a float
char *ch;  // pointer to a character星号* 可以放在数据类型旁边或者变量旁边或者单独写在中间。我们可以将一个地址赋给指针变量：int score = 5;
int *scorePtr;
scorePtr = &amp;score;

cout &lt;&lt; scorePtr &lt;&lt; endl;

//Outputs &quot;0x29fee8&quot;scorePtr 的值就是 score 变量的内存地址。有两种指针的运算器：地址查询符&amp;，返回操作数所在内存地址 referencing数据查询符*，返回操作数的内存地址下的数据 dereferencing例如：int var = 50;
int  *p;
p = &amp;var;

cout &lt;&lt; var &lt;&lt; endl;
// Outputs 50 (the value of var)

cout &lt;&lt; p &lt;&lt; endl;
// Outputs 0x29fee8 (var's memory location)

cout &lt;&lt; *p &lt;&lt; endl;
/* Outputs 50 (the value of the variable
 stored in the pointer p) */定义指针类型变量时候的星号* 只是用来表明此变量为指针类型变量，不要和内存查询符混淆。数据查询符* 指针指向的变量的 alias，例如：int x = 5;
int *p = &amp;x;

x = x + 4;
x = *p + 4;
*p = *p + 4;P 是 x 的指针，以上示例的三种运算结果都是一样的，都是将变量 x 的值进行计算。我们可以通过定义变量的指针来操作变量值。静态内存和动态内存理解动态内存的工作机制对于开发有很大帮助。再 c++ 中内存被分为两种类型：the stack 静态内存空间：所有的本地变量占用静态内存空间the heap 动态内存空间：再程序运行时动态进行分配的空间，默认不占用很多情况下，提前并不知道一个定义的变量需要多少空间来存储信息需要在运行时动态请求内存空间。可以使用 new 操作符来定义一个变量使用 heap 方式再运行时动态分配内存空间，并返回分配的地址，例如：new int;
以上定义一个使用 heap 方式分配一个足够存储 int 类型的内存空间，并返回这个地址。分配的地址可以存储在一个指针中，可以在后续中使用：int *p = new int;
*p = 5;以上请求了一个动态内存来存储一个 int 类型数据，然后在这个地址存储值为 5。注意指针 p 变量存储在 stack 静态内存中，且其值为 heap 动态内存分配的 int 型数据的地址，结果 5 是存储在 heap 动态内存中的。本地静态内存 stack 下的变量，内存管理是自动进行的不需要手动干预，使用 heap 方式动态分配的内存空间需要手动干预操作，当不再需要动态内存空间的数据时使用 delete 操作符来释放空间。示例：int *p = new int; // request memory
*p = 5; // store value

cout &lt;&lt; *p &lt;&lt; endl; // use value

delete p; // free up the memory忘记释放使用 new 请求的动态内存空间会导致内存泄漏问题，因为在程序关闭时才会释放空间。注意 delete 操作的是指针类型。并且释放的只是 heap 动态内存，指针本身是存储在 stack 中的。当内存释放后，指针不指向某个内存地址，次时这个指针叫做：dangling pointers 悬浮指针。可以重新让这个指针指向内存地址：int *p = new int; // request memory
*p = 5; // store value

delete p; // free up the memory
// now p is a dangling pointer

p = new int; // reuse for a new address也可以定义一个 NULL 的空指针：int *ptr = NULL;
也可以指向一个数组：int *p = NULL; // Pointer initialized with null
p = new int[20]; // Request memory
delete [] p; // Delete array pointed to by p注意释放内存时要加上方括号[]。动态内存分配很有用，如当程序需要读取一张图片时，你提前并不知道图片的大小，需要多大的内存空间来存储。这时候使用动态内存来定义就很方便了。数据大小虽然不同类型数据的内存占用大小和不同架构的设备有关或使用的编译器，但 c++ 有一个最小的数据大小定义：可以使用 sizeof 指令来获取特定数据类型当前占用内存空间，如：sizeof(int)
返回值为此类型数据的内存大小，单位为字节：cout &lt;&lt; &quot;char: &quot; &lt;&lt; sizeof(char) &lt;&lt; endl;
cout &lt;&lt; &quot;int: &quot; &lt;&lt; sizeof(int) &lt;&lt; endl;
cout &lt;&lt; &quot;float: &quot; &lt;&lt; sizeof(float) &lt;&lt; endl;
cout &lt;&lt; &quot;double: &quot; &lt;&lt; sizeof(double) &lt;&lt; endl;
int var = 50;
cout &lt;&lt; &quot;var: &quot; &lt;&lt; sizeof(var) &lt;&lt; endl;

/* Outputs
char: 1
int: 4
float: 4
double: 8
var: 4
*/ 也可以获取数组的内存占用大小：double myArr[10];
cout &lt;&lt; sizeof(myArr) &lt;&lt; endl; 

//Outputs 80一个 double 占用 8 个字节，所以此数组共使用 80 个字节。可以使用 sizeof 分别读取整个数组和单个元素的内存空间来计算数组元素个数：int numbers[100];
cout &lt;&lt; sizeof(numbers) / sizeof(numbers[0]);

// Outputs 100以上就是 c++ 数据类型及指针的介绍。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1911.html">
<title>Speedtest CLI 命令行测速工具</title>
<link>https://blog.niekun.net/archives/1911.html</link>
<dc:date>2020-11-16T13:08:00+08:00</dc:date>
<description>speedtest 是国外很流行的测速平台，可以直接在其网站上测试本地上行下行带宽，最近看到其提供了本地命令行工具，使用起来更加方便了。官网：https://www.speedtest.net/安装首先需要到官网安装对应平台的 CLI 工具：https://www.speedtest.net/apps/cliLinux 类系统可以直接在使用 apt/brew 等包管理工具方便的安装，Windows 下需要手动下载 exe 可执行文件使用。macOS:brew tap teamookla/speedtest
brew update
brew install speedtest --forceubuntu:sudo apt-get install gnupg1 apt-transport-https dirmngr
export INSTALL_KEY=379CE192D401AB61
sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys $INSTALL_KEY
echo &quot;deb https://ookla.bintray.com/debian generic main&quot; | sudo tee  /etc/apt/sources.list.d/speedtest.list
sudo apt-get update
sudo apt-get install speedtestwindows:首先在网站上下载可执行文件，点击下载 1.0.0 版。可执行文件为 speedtest.exe，需要将其目录加入系统 PATH 路径才可以直接在 terminal 调用，加入 PATH 方法参考我的教程：https://blog.niekun.net/archives/413.html使用在终端下使用 speedtest -h 命令查看帮助：Speedtest by Ookla is the official command line client for testing the speed and performance of your internet connection.

Version: speedtest 1.0.0.2

Usage: speedtest [&lt;options&gt;]
  -h, --help                        Print usage information
  -V, --version                     Print version number
  -L, --servers                     List nearest servers
  -s, --server-id=#                 Specify a server from the server list using its id
  -I, --interface=ARG               Attempt to bind to the specified interface when connecting to servers
  -i, --ip=ARG                      Attempt to bind to the specified IP address when connecting to servers
  -o, --host=ARG                    Specify a server, from the server list, using its host's fully qualified domain name
  -p, --progress=yes|no             Enable or disable progress bar (Note: only available for 'human-readable'
                                    or 'json' and defaults to yes when interactive)
  -P, --precision=#                 Number of decimals to use (0-8, default=2)
  -f, --format=ARG                  Output format (see below for valid formats)
  -u, --unit[=ARG]                  Output unit for displaying speeds (Note: this is only applicable
                                    for ‘human-readable’ output format and the default unit is Mbps)
  -a                                Shortcut for [-u auto-decimal-bits]
  -A                                Shortcut for [-u auto-decimal-bytes]
  -b                                Shortcut for [-u auto-binary-bits]
  -B                                Shortcut for [-u auto-binary-bytes]
      --selection-details           Show server selection details
      --ca-certificate=ARG          CA Certificate bundle path
  -v                                Logging verbosity. Specify multiple times for higher verbosity
      --output-header               Show output header for CSV and TSV formats

 Valid output formats: human-readable (default), csv, tsv, json, jsonl, json-pretty

 Machine readable formats (csv, tsv, json, jsonl, json-pretty) use bytes as the unit of measure with max precision

 Valid units for [-u] flag:
   Decimal prefix, bits per second:  bps, kbps, Mbps, Gbps
   Decimal prefix, bytes per second: B/s, kB/s, MB/s, GB/s
   Binary prefix, bits per second:   kibps, Mibps, Gibps
   Binary prefix, bytes per second:  kiB/s, MiB/s, GiB/s
   Auto-scaled prefix: auto-binary-bits, auto-binary-bytes, auto-decimal-bits, auto-decimal-bytes首先使用测试最近的测速节点 testspeed -L:root@Marco-vostro-14-wsl:~# speedtest -L
Closest servers:

    ID  Name                           Location             Country
==============================================================================
 29105  陕西移动5G                 Xi'an                China
  2461  China Unicom                   Chengdu              China
  4575  China Mobile Group Sichuan     Chengdu              China
 24337  China Mobile Group Sichuan Co.,Ltd. Chengdu              China
 35527  sccn                           Chengdu              China
 31985  China Unicom                   Chongqing            China
 17584  Chongqing Mobile Company       Chongqing            CN
  5530  CCN                            Chongqing            China
 16145  Lanzhou,China Mobile,Gansu     Lanzhou              China执行 speedtest 命令进行测速，默认使用上面测试的最近的节点：root@Marco-vostro-14-wsl:~# speedtest

   Speedtest by Ookla

     Server: Chongqing Mobile Company - Chongqing (id = 17584)
        ISP: China Telecom
    Latency:    31.45 ms   (25.47 ms jitter)
   Download:    14.31 Mbps (data used: 17.5 MB)
     Upload:     8.23 Mbps (data used: 11.3 MB)
Packet Loss:     0.0%
 Result URL: https://www.speedtest.net/result/c/bee17d45-7b9c-44e6-8a6e-ef99d84ba441以上就是简单的用法，可以查看帮助了解更多的使用方法。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1906.html">
<title>两个子网间网络互访的原理</title>
<link>https://blog.niekun.net/archives/1906.html</link>
<dc:date>2020-11-13T11:29:00+08:00</dc:date>
<description>之前我介绍过子网，子网掩码，网关等基本概念解析，可以参考：https://blog.niekun.net/archives/1885.html在不同子网下的设备是不能直接访问的，因为他们在不同的网段内，比如：路由 A 下有子网 192.168.1.0/24路由 B 下有子网 192.168.3.0/24设备 james：192.168.1.10/24 网关：192.168.1.1设备 Johnny：192.168.3.10/24 网关：192.168.3.1两个路由的 wan 网口在同一网段：192.168.2.0/24 下正常情况下路由 A 下的设备无法访问路由 B 下的设备，因为他们在不同的子网网段下。路由 A 有两个网段：192.168.1.0 和 192.168.2.0，所以它可以同时看见这两个网段的设备，但是它并不知道 192.168.3.0 这一网段的存在。同样的道理，路由 B 并不知道 192.168.1.0 这一网段的存在。当你给一个设备添加一个路由表 route table，就可以告诉它有其他网段可以进行访问，同时需要告诉它一个可以访问到这个新网段的网关，这样就可以访问到其他网段了。例如让路由 A 访问到路由 B 的子网 192.168.3.0 可以通过给路由 A 添加新的路由表来实现，使用 ip route 命令：ip route add 192.168.3.0/24 via 192.168.2.2以上命令的意义是添加路由 B 子网的路由表 192.168.3.0/24，网关地址是路由 B 的 wan 地址 192.168.2.2。因为路由 B 可以访问到两个网络 192.168.2.0 和 192.168.3.0，而路由 A 和路由 B 通过 192.168.2.0 互访，所以通过给路由 A 添加以上路由表然后网关地址为路由 B 和外部通信的地址，这样路由 A 就可以访问到路由 B 的子网了。现在路由 A 可以访问到路由 B 的子网了，那么路由 A 下的设备如何访问路由 B 的子网设备呢？原理是相同的，可以通过给设备添加路由 B 子网的路由表，然后由于路由 A 已经可以访问 路由 B 子网了，所以将网关地址设置为路由 A 地址即可：ip route add 192.168.3.0/24 via 192.168.1.1在路由 A 下的 James 执行以上命令后，就可以访问到路由 B 下的 Johnny 了。同样的原理，在路由 B 上设置路由表及网关就可以实现子网互访了。参考链接：understand the 'ip route' command for cisco routers</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1904.html">
<title>nextcloud 安装教程</title>
<link>https://blog.niekun.net/archives/1904.html</link>
<dc:date>2020-11-11T10:42:14+08:00</dc:date>
<description>安装包：https://nextcloud.com/changelog/#latest20系统需求：https://docs.nextcloud.com/server/20/admin_manual/installation/system_requirements.htmlnginx 配置：https://docs.nextcloud.com/server/18/admin_manual/installation/nginx.htmlphp 配置相关：https://docs.nextcloud.com/server/20/admin_manual/installation/source_installation.html#php-fpm-tips-label修改 php 内存限制：https://www.chinaz.com/program/2011/1010/213048.shtml安装 php 内存缓存：https://docs.nextcloud.com/server/15/admin_manual/configuration_server/caching_configuration.html命令行安装：https://docs.nextcloud.com/server/stable/admin_manual/installation/command_line_installation.html</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1903.html">
<title>MySQL 用户密码规则配置</title>
<link>https://blog.niekun.net/archives/1903.html</link>
<dc:date>2020-11-11T10:37:00+08:00</dc:date>
<description>在创建 MySQL 用户时需要设置密码，有时候输入输入密码后会提示创建失败，密码设置 policy 错误。这是因为当前设置的密码和 MySQL 密码创建规则不符，可以查看当前规定的密码规则也可以进行修改。进入 MySQL 执行下面命令：SHOW VARIABLES LIKE 'validate_password%';
会列出密码创建相关参数：mysql&gt; SHOW VARIABLES LIKE 'validate_password%';
+--------------------------------------+--------+
| Variable_name                        | Value  |
+--------------------------------------+--------+
| validate_password_check_user_name    | ON     |
| validate_password_dictionary_file    |        |
| validate_password_length             | 8      |
| validate_password_mixed_case_count   | 1      |
| validate_password_number_count       | 1      |
| validate_password_policy             | MEDIUM |
| validate_password_special_char_count | 1      |
+--------------------------------------+--------+
7 rows in set (0.03 sec)其中 validate_password_length 是密码位数，validate_password_special_char_count 是密码包含特殊字符。可以通过命令修改参数值来改变密码规则，例如：取消特殊字符：SET GLOBAL validate_password_special_char_count= 0;
修改后可以测试再次建立用户设置密码。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1900.html">
<title>MySQL 8.0 修改用户密码加密方式</title>
<link>https://blog.niekun.net/archives/1900.html</link>
<dc:date>2020-11-11T09:41:00+08:00</dc:date>
<description>MySQL 8.0 默认创建的用户密码加密方式为：caching_sha2_password，有些应用在连接时由于不兼容会导致报错，可以修改为 MySQL 5 使用的加密方式：sha256_password。创建用户：create user &quot;newuser&quot;@&quot;localhost&quot; identified by &quot;PASSWORD&quot;;
授予全部数据库权限：grant all privileges on *.* to 'newuser'@'localhost';
修改成原来的加密方式：alter user &quot;newuser&quot;@&quot;localhost&quot; identified with mysql_native_password by 'PASSWORD';
刷新权限：    FLUSH PRIVILEGES;
查看已建立的用户及加密方式：SELECT user,authentication_string,plugin,host FROM mysql.user;
显示如下：+------------------+------------------------------------------------------------------------+---
| user             | authentication_string                         | plugin                | host      |
+------------------+------------------------------------------------------------------------+-----
| marco            | *D51541FCBC8DD8E                              | mysql_native_password | localhost |
| root             |                                               | auth_socket           | localhost |
+------------------+------------------------------------------------------------------------+---------以上就是修改用户密码加密方式的方法。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1899.html">
<title>MySQL 5.7 升级 8.0</title>
<link>https://blog.niekun.net/archives/1899.html</link>
<dc:date>2020-11-10T11:03:52+08:00</dc:date>
<description>首先备份本地数据库，以防升级错误：mysqldump -uUSER -pPASSWORD --all-databases &gt; /path/to/backup.sql
官网下载最新的 MySQL apt 库：https://dev.mysql.com/downloads/repo/apt/当前最新地址为：https://dev.mysql.com/get/mysql-apt-config_0.8.16-1_all.deb下载到本地后安装：dpkg -i mysql-apt-config_0.8.16-1_all.deb
期间会提示选择安装的 MySQL 版本，第一步选择当前安装的 MySQL 5.7，然后下一步选择 MySQL server 8.0，然后再下一步切换到 ok 选项确认。配置完成后更新 apt 库及安装新版 MySQL：apt update
apt install mysql-server
安装完成后验证当前安装版本：mysql -V
以上就是简单的 MySQL 升级教程。参考链接：https://dev.mysql.com/doc/mysql-apt-repo-quick-guide/en/#apt-repo-setuphttps://www.digitalocean.com/community/questions/upgrade-mysql-5-7-to-8-ubuntu-18-04</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1895.html">
<title>C++ 入门教程 -- 判断及循环</title>
<link>https://blog.niekun.net/archives/1895.html</link>
<dc:date>2020-11-07T15:53:00+08:00</dc:date>
<description>if 判断if 申明的使用场景：当一个判断条件达到是执行指令。语法结构：if (condition) {
    statements
}示例：if (7 &gt; 4) {
  cout &lt;&lt;  &quot;Yes&quot;; 
}

// Outputs &quot;Yes&quot;可以使用的相关性判断器：&lt;&gt;&gt;=&lt;===!=当条件不满足是，也可以执行命令：if (condition) {
  //statements
}
else {
 //statements
}if else 指令可以多次嵌套使用：int age = 18;
if (age &gt; 14) {
  if(age &gt;= 18) {
    cout &lt;&lt; &quot;Adult&quot;;
  }
  else {
    cout &lt;&lt; &quot;Teenager&quot;;
  }
}
else {
  if (age &gt; 0) {
    cout &lt;&lt; &quot;Child&quot;;
  }
  else {
    cout &lt;&lt; &quot;Something's wrong&quot;;
  }
}当命令只有一句时可以省略大括号：int a = 10;
if (a &gt; 4)
  cout &lt;&lt; &quot;Yes&quot;;
else
  cout &lt;&lt; &quot;No&quot;;while 循环一个 while 循环重复的执行设置的命令，直到设置的条件不满足为止。语法：while (condition) {
   statement(s);
}示例：int num = 1;
while (num &lt; 6) {
  cout &lt;&lt; &quot;Number: &quot; &lt;&lt; num &lt;&lt; endl;
  num = num + 1;
}当 num 变量小于 6 满足时，循环执行大括号内的指令，直到 num 的值大于等于 6 则跳出循环继续执行下面的指令。以上示例中当 num 第五次自加后结果为 6，则下一次循环开始时判断条件就为 false 了，就会跳出循环。for 循环for 循环指令可以实现指定循环次数，语法结构如下：for ( init; condition; increment ) {
  statement(s);
}init 用来设置变量初值，且只设置一次condition 用来给定执行循环的条件，满足则执行循环内指令increment 设置循环条件的变量值如何变化示例：for (int x = 1; x &lt; 10; x++) {
 // some code
 }定义并设置 x 变量初值 1，循环条件是 x 小于 10，每次循环后 x 自加 1。变量变化量可以自定：for (int a = 0; a &lt; 50; a+=10) {
  cout &lt;&lt; a &lt;&lt; endl;
}
/* Outputs
0
10
20
30
40
*/do while 循环不同于 while 循环，do while 循环首先执行一次循环内的指令，再判断条件是否满足。语法：do {
   statement(s);
} while (condition);示例：int a = 0;
do {
  cout &lt;&lt; a &lt;&lt; endl;
  a++;
} while(a &lt; 5);

/* Outputs
0
1
2
3
4
*/do while 即使条件不满足也至少会执行一次循环内的命令。switch 指令当需要根据一个变量值为不同的结果时执行不同的指令时可以使用 switch 指令。语法：switch (expression) {
  case value1:
    statement(s);
    break;
  case value2:
    statement(s);
    break;
    ...
  case valueN:
    statement(s);
    break;
    default:
    statement(s);
}当变量的值匹配到 switch 里定义的一个 value 值后，会执行此 case 下的指令。使用 break 来跳出 switch 指令，如果不写的话会顺序执行下面的case 指令，即使变量值并没有匹配到这个 case。default 用来定义当以上设置的 case 都没有匹配上时执行的指令。逻辑操作符有三个逻辑操作符：&& 与|| 或!  非与指令：当两个条件都满足时为 true：int age = 20;
if (age &gt; 16 &amp;&amp; age &lt; 60) {
  cout &lt;&lt; &quot;Accepted!&quot; &lt;&lt; endl;
}

// Outputs &quot;Accepted&quot;或指令：当任意一个条件满足时为 true：int age = 16;
int score = 90;
if (age &gt; 20 || score &gt; 50) {
    cout &lt;&lt; &quot;Accepted!&quot; &lt;&lt; endl;
}

// Outputs &quot;Accepted!&quot;非指令：当条件不满足时为 true：int age = 10;
if ( !(age &gt; 16) ) {
  cout &lt;&lt; &quot;Your age is less than 16&quot; &lt;&lt; endl;
}

// Outputs &quot;Your age is less than 16&quot;以上就是常用的判断及循环指令用法。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1894.html">
<title>C++ 入门教程 -- 基础概念</title>
<link>https://blog.niekun.net/archives/1894.html</link>
<dc:date>2020-11-07T15:13:00+08:00</dc:date>
<description>C++ 是一种跨平台的编程语言，用来创建高性能的应用程序，如操作系统，聊天软件，浏览器，游戏等。c++ 源自于 c 语言，并且很大程度上使用了 c 语言的设计理念。下面用几篇文章介绍 c++ 的基础用法。结构c++ 程序是一个集成很多命令和描述的集合，以下是一个模板程序：#include &lt;iostream&gt;
using namespace std;

// comment
int main()
{
    cout &lt;&lt; &quot;Hello world!&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;Hello world!&quot; &lt;&lt; &quot;WOW&quot; &lt;&lt; &quot;\n&quot;;
    return 0;
}
/*
comments
*/所有 c++ 程序的入口都是 main() function，使用大括号 {} 将 function 的内容包围起来，括号内的指令在 fuction 运行时执行。每句指令结尾使用分号; 结束。cout 是 iostream 的一个 object，功能是输出信息到标准的输出设备，一般是显示屏上。&lt;&lt; 是 insertion operator 用来将后面的字符串传入 cout 指令最后输出到显示屏。可以使用多个 &lt;&lt; 将信息连起来。iostream 是头文件，里面包含各种程序执行需要的功能模块，使用 #include 调用头文件。iostream 包含输入输出数据块的 stream object。每个 namespace 是一个申明区域，定义了程序调用 function 或 object 时的类型，using namespace std 告诉程序默认使用 std 类型的元素。在命令中可以直接写 std 中定义的元素：cout &lt;&lt; &quot;Hello world!&quot;;
std::cout &lt;&lt; &quot;Hello world!&quot;;以上两种写法效果是一样的，表示使用  std 类型的 cout 指令。也可以写自定义的申明如：namespace fs = boost::filesystem;
fs:path testpath;
以上申明意思是用 fs 表示 boost::filesystem 类型，然后定义一个 boost::filesystem::path 类型的变量。cout 执行后默认不添加行结束符号，添加一个 endl object 来实现换行操作。也可以添加字符串 \n 表示换行。反斜杠 \ 是转义符用来输入特殊意义的符号，如：\n 表示换行。// 双斜杠用来添加单行注释信息，斜杠所在的行不会被编译。/*....*/ 用来表示注释区域，这一段的内容都不被编译。变量定义一个变量会请求一个内存空间来存储变量值。编译器需要在定义变量时指定变量类型，类型可以是系统内置的也可以是自定义的。定义的个体可以是变量，function，class 等：int testVar = 10;
以上定义了一个 int 整数型的变量 testVar 并赋值为 10，注意变量名是区分大小写的，也就是 testVar 和 testvar 代表两个不同的变量。double testDouble1, testDouble2;
也可以同时定义两个变量。根据需求设置变量类型，可以优化内存占用空间。示例：#include &lt;iostream&gt;
using namespace std;

int main()
{
    int a = 30;
    int b = 12;
    int sum = a + b;
    cout &lt;&lt; sum;
    return 0;
}
//Outputs 42定义的变量可以在后续程序中赋值：int a;
int b = 1;

a = 2;
b = 3;输入参数使用 cin 来请求用户输入数据，用 extraction operator 来将输入数据提取到别处：int a;
cin &gt;&gt; a;以上程序定义一个 int 型变量，然后提示用户输入一个数据存储到变量 a 中。结合输入输出可以实现简单的交互操作：#include &lt;iostream&gt;
using namespace std;

int main() 
{
  int a, b;
  int sum;
  cout &lt;&lt; &quot;Enter a number \n&quot;;
  cin &gt;&gt; a;
  cout &lt;&lt; &quot;Enter another number \n&quot;;
  cin &gt;&gt; b;
  sum = a + b;
  cout &lt;&lt; &quot;Sum is: &quot; &lt;&lt; sum &lt;&lt; endl;

  return 0;
}运算符c++ 支持以下运算符：加减乘/ 除% 模(整除后的余数)int a = 1 + 1;
int b = 5 * 6;
int c = 5 % 2;
int d = 5 + 2 * 2;
int e = (5 + 2) * 2;

cout &lt;&lt; c &lt;&lt; endl;

//output: 1如果对变量本身的加减乘除操作可以简写：x *= 3; // equivalent to x = x * 3
x /= 2; // equivalent to x = x / 2
x %= 4; // equivalent to x = x % 4对本身自加或自减操作，有两种方式：后缀和前缀：x++; //后缀，相当于 x = x + 1
x--;
++x;
--x;
使用后缀方式是先执行表达式再自加，前缀方式是先自加再执行表达式：int a = 1;
int b = a++;
int c = ++a;

//b = 1
//c = 3以上是基础概念及指令。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1893.html">
<title>VMware 虚拟机磁盘文件合并</title>
<link>https://blog.niekun.net/archives/1893.html</link>
<dc:date>2020-11-05T16:39:01+08:00</dc:date>
<description>在创建 VMware workstation 虚拟机时，在磁盘选项上会提示选择创建单个虚拟磁盘文件或分割为多个文件。我喜欢使用单个文件，因为选择多个文件会在虚拟机目录下建立许多类似的 vmdk 文件，不太方便复制到其他地方。而且在导入 macOS 下的 VMware fusion 时会报错，所以推荐使用单个磁盘文件。当现有的虚拟机已经是使用多个文件形式的话，可以使用 VMware workstation 附带的 vmware-vdiskmanager.exe 工具来进行合并。vmware-vdiskmanager.exe 是一个命令行工具，工具的位置在 VMware 安装路径下，如：C:\Program Files (x86)\VMware\VMware Workstation\vmware-vdiskmanager.exe在 PS 命令行下调用此工具查看帮助：PS C:\Users\Marco Nie&gt; &amp;&quot;vmware-vdiskmanager.exe&quot;
VMware Virtual Disk Manager - build 16894299.
Usage: vmware-vdiskmanager.exe OPTIONS &lt;disk-name&gt; | &lt;mount-point&gt;
Offline disk manipulation utility
  Operations, only one may be specified at a time:
     -c                   : create disk.  Additional creation options must
                            be specified.  Only local virtual disks can be
                            created.
     -d                   : defragment the specified virtual disk. Only
                            local virtual disks may be defragmented.
     -k                   : shrink the specified virtual disk. Only local
                            virtual disks may be shrunk.
     -n &lt;source-disk&gt;     : rename the specified virtual disk; need to
                            specify destination disk-name. Only local virtual
                            disks may be renamed.
     -p                   : prepare the mounted virtual disk specified by
                            the mount point for shrinking.
     -r &lt;source-disk&gt;     : convert the specified disk; need to specify
                            destination disk-type.  For local destination disks
                            the disk type must be specified.
     -x &lt;new-capacity&gt;    : expand the disk to the specified capacity. Only
                            local virtual disks may be expanded.
     -R                   : check a sparse virtual disk for consistency and attempt
                            to repair any errors.
     -e                   : check for disk chain consistency.
     -D                   : make disk deletable.  This should only be used on disks
                            that have been copied from another product.
     -U                   : delete/unlink a single disk link.

  Other Options:
     -q                   : do not log messages

  Additional options for create and convert:
     -a &lt;adapter&gt;         : (for use with -c only) adapter type
                            (ide, buslogic, lsilogic). Pass lsilogic for other adapter types.
     -s &lt;size&gt;            : capacity of the virtual disk
     -t &lt;disk-type&gt;       : disk type id

  Disk types:
      0                   : single growable virtual disk
      1                   : growable virtual disk split into multiple files
      2                   : preallocated virtual disk
      3                   : preallocated virtual disk split into multiple files
      4                   : preallocated ESX-type virtual disk
      5                   : compressed disk optimized for streaming
      6                   : thin provisioned virtual disk - ESX 3.x and above

     The capacity can be specified in sectors, KB, MB or GB.
     The acceptable ranges:
                           ide/scsi adapter : [1MB, 8192.0GB]
                           buslogic adapter : [1MB, 2040.0GB]
        ex 1: vmware-vdiskmanager.exe -c -s 850MB -a ide -t 0 myIdeDisk.vmdk
        ex 2: vmware-vdiskmanager.exe -d myDisk.vmdk
        ex 3: vmware-vdiskmanager.exe -r sourceDisk.vmdk -t 0 destinationDisk.vmdk
        ex 4: vmware-vdiskmanager.exe -x 36GB myDisk.vmdk
        ex 5: vmware-vdiskmanager.exe -n sourceName.vmdk destinationName.vmdk
        ex 6: vmware-vdiskmanager.exe -k myDisk.vmdk
        ex 7: vmware-vdiskmanager.exe -p &lt;mount-point&gt;
              (A virtual disk first needs to be mounted at &lt;mount-point&gt;)VMware 生成的磁盘多个文件名称命名规则是如下：根磁盘文件 - 如：Windows7.vmdk分割磁盘文件 - 如：Windows7-s001.vmdk Windows7-s002.vmdk Windows7-s003.vmdk ...使用命令合并多文件时只需要指定跟磁盘文件名称即可。根据帮助文档，使用 -r 指令指定多文件，-t 0 指令指定输出为单文件。示例如下：&amp;&quot;vmware-vdiskmanager.exe&quot; -r Windows7.vmdk -t 0 merge.vmdk

Creating disk 'merge.vmdk'
  Convert: 100% done.
Virtual disk conversion successful.命令执行后，在对应目录下会生成 merge.vmdk 虚拟磁盘文件，可以使用此文件建立新的虚拟机。</description>
</item>
</rdf:RDF>