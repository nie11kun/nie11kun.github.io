<?xml version="1.0" encoding="UTF-8"?>
<rdf:RDF
xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
xmlns="http://purl.org/rss/1.0/"
xmlns:dc="http://purl.org/dc/elements/1.1/">
<channel rdf:about="https://blog.niekun.net/feed/rss/2020/11/">
<title>Marco Nie - 2020年11月</title>
<link>https://blog.niekun.net/2020/11/</link>
<description>you are the company you keep...</description>
<items>
<rdf:Seq>
<rdf:li resource="https://blog.niekun.net/archives/1918.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1915.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1898.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1911.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1906.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1904.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1903.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1900.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1899.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1895.html"/>
</rdf:Seq>
</items>
</channel>
<item rdf:about="https://blog.niekun.net/archives/1918.html">
<title>C++ 入门教程 -- Classes and Objects</title>
<link>https://blog.niekun.net/archives/1918.html</link>
<dc:date>2020-11-20T11:32:44+08:00</dc:date>
<description>object 对象Object Oriented Programming 面向对象编程是为了让编程更加接近于真实世界的理解方式。在程序中，每个 object 是一个独立的 unite 单元，拥有自己的 identify 标识，就像真实世界的某个独立物体一样。例如一个苹果就是一个 object，它的 identify 就是名称 苹果，每个苹果都有自己独立的 attributes 属性，如颜色，大小。一个属性就是这个 object 当前状态的描述。不同 object 的 attributes 属性是不一样的，例如一个苹果是绿色的，另一个是红色的。在正式世界中 object 都有其 behave 行为，例如汽车的 move 移动，手机的 ring 响铃。这种 object 的行为叫做 object 的 type 类型。描述一个 object需要的元素：identify 标识，attributes 属性，behavior 行为在程序中每个 object 是独立的，拥有独立的 identify 用来区分其他的 object：class我们通过创建 class 来表示 object，一个 class 描述了一个 object 的形象，但是它并不是一个真正的 object，他只是一个对某种 object 结构的定义。一个 class 可以用来建立多个 object。例如一套设计图纸可以用来作为蓝图修建多栋楼房。一个 class 包含：identify，attributes，behavior程序中，一个对象的 type 就是 class 的 name 名称；Attributes 属性可以是 properties 或 data 数据；behavior 行为通常是一个 function。例如我们建立一个银行系统程序：name: BankAccountattributes: accountNumber, balance, dateOpenedbehavior: open(), close(), deposit()一个 class 定义了某种 object 需要的属性和行为。但是它并不直接定义具体的属性值是多少，她只是一个框架的描述。当我们写好了一个 class，可以基于这个 class 来创建 objects，这个 object 就是 instance of class，就是 class 的实例。建立 class使用关键字 class 来建立 class，然后定义 class 名称，class 内容写在大括号{} 内。注意每个 class 结尾必须写分号;。例如：class BankAccount {

};一个 class 的 attributes 和 behaviors 可以设置 access 访问级别。定义时使用关键词 public 不仅可以在 class 内部使用，也可以在 class 外部访问这个属性。也可以是使用关键词 private 或 protected，下面做详细介绍。建立一个 class：class BankAccount {
  public:
    void sayHi() {
      cout &lt;&lt; &quot;Hi&quot; &lt;&lt; endl;
    }
};然后 instance 实例化这个 class：int main() 
{
  BankAccount test;
  test.sayHi();
}实例化的 object test 拥有其 class 所有的属性和行为。使用点分割符. 来访问 object 的各种属性和 function。抽象化数据抽象化的理念是给外部环境提供最核心的信息，而不用提供具体的细节。比如我们抽象化一本书，我们不用知道他具体有多少也，多少个字，什么颜色。我们只需要知道它是一本书就行了。抽象化的理念是面向对象编程最基础的模块。可以让我们建立一个 class 模型，然后基于这个模型创建具体的 objects 对象。封装encapsulation 封装意味着将一个整体包围起来，不仅仅是将其内容放在一起，也可以将其保护起来。它的设计原则就是让外部程序只能够访问其开放的元素，其他内容保持隐藏状态。例如我们上面的 BankAccount class，我们不想要外部直接访问修改 balance 余额属性，我们需要其使用 deposit() 或 withdraw() 方法来对其进行操作。所以我们需要将 balance 属性对外隐藏掉，只能通过内部 function 来访问。封装的优势有：控制内部数据的访问和修改代码更加灵活，方便后续根据情况修改修改一个地方，不影响其他地方下面举例说明如何使用封装来控制内部数据的可访问性，使用 public，private，protected 关键词。注意如果没有使用关键词，默认 class 内所有都是 private 类型的。访问 public 的数据：#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

class myClass {
  public:
    string name;
};

int main() {
  myClass myObj;
  myObj.name = &quot;SoloLearn&quot;;
  cout &lt;&lt; myObj.name;
  return 0;
}

//Outputs &quot;SoloLearn&quot;使用 public 关键词定义可被外部访问的属性，注意关键词后的冒号:。使用 private 保护内部数据：#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

class myClass {
  public:
    void setName(string x) {
      name = x;
    }
  private:
    string name;
};

int main() {
  myClass myObj;
  myObj.setName(&quot;John&quot;);

  return 0;
}name 不可以被外部直接访问修改，但是通过 setName() 就可以间接修改 name 的值。也可以通过 function 间接读取 private 的某些属性：class myClass {
  public:
    void setName(string x) {
      name = x;
    }
    string getName() {
      return name;
    }
  private:
    string name;
};以上示例，通过建立 public 里的 getName() 方法来读取 name 的值。constructor 构造器constructor 是 class 中特殊的 function，这个 function 的名称和 class 名称一样且没有返回类型，甚至没有 void，它会在 instance 实例化 object 时自动被执行，例如：class myClass {
  public:
    myClass() {
      cout &lt;&lt;&quot;Hey&quot;;
    }
    void setName(string x) {
      name = x;
    }
    string getName() {
      return name;
    }
  private:
    string name;
};

int main() {
  myClass myObj;

  return 0;
}

//Outputs &quot;Hey&quot;以上示例中，在实例化 myObj 时，会自动执行构造器 function。构造器 function 可以方便的让我们在实例化 class 时设置 initial 初始化参数。默认构造器没有参数，如果需要的话我们可以加入参数。例如：class myClass {
  public:
    myClass(string nm) {
      setName(nm);
    }
    void setName(string x) {
      name = x;
    }
    string getName() {
      return name;
    }
  private:
    string name;
};

int main() {
  myClass ob1(&quot;David&quot;);
  myClass ob2(&quot;Amy&quot;);
  cout &lt;&lt; ob1.getName();
}
//Outputs &quot;David&quot;以上示例中，构造器的作用是使用一个参数给 private name 赋值。当实例化这个 class 时，需要传入构造器需要的参数。注意我们可以在一个 class 中建立多个 constructor 构造器，来使用不同的参数。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1915.html">
<title>C++ 入门教程 -- Functions</title>
<link>https://blog.niekun.net/archives/1915.html</link>
<dc:date>2020-11-20T09:38:00+08:00</dc:date>
<description>一个 function 是为了完成某个任务的许多命令的一个集合。使用 function 的优势有：代码复用独立测试某功能修改一个 function 内部代码不影响程序整体结构同一个 function 可使用不同传入参数调用一个有效的 c++ 程序至少要有一个 function：main()。返回类型mian() function 通常结构如下：int main()
{
  // some code
  return 0;
}function 的返回值类型定义在它的名称前，以上示例中，返回类型为 int 型，表明此 function 会返回一个 int 型数据。有些 function 在执行后不需返回数据，则使用 void 来定义。void 是一个基本数据类型，用来定义无值 valueless 申明。结构function 定义结构如下：return_type function_name( parameter list )
{
   body of the function
}return-type: 返回值数据类型function name: function 名称parameters: 传递参数，当此function被调用时，传递数据给 function 内部使用。需要指定类型，名称及个数body of the function: 指令集合parameters 参数是可选的，当不需要传递参数时可以留空。使用我们定义一个无返回值类型的 function：void printSomething() 
{
  cout &lt;&lt; &quot;Hi there!&quot;;
}此 function 功能为输出一个字符串。我们在 main() 中调用此 function：int main() 
{
   printSomething();
   
   return 0;
}调用某个 function 只需要使用 function 名称及传入参数即可。注意 function 的申明和调用顺序，需要先申明然后调用，不然会报错：#include &lt;iostream&gt;
using namespace std;

void printSomething() {
  cout &lt;&lt; &quot;Hi there!&quot;;
}

int main() {
  printSomething();

  return 0;
}一个 function 的申明告诉编译器这个 function 的名称及调用方法，其内容可以在后续代码中定义：#include &lt;iostream&gt;
using namespace std;

//Function declaration
void printSomething();

int main() {
  printSomething();

  return 0;
}

//Function definition
void printSomething() {
  cout &lt;&lt; &quot;Hi there!&quot;;
}传递参数如果一个 function 需要传递数据，需要在申明定义正式的参数用来接收传递数据值。例如：void printSomething(int x) 
{
   cout &lt;&lt; x;
}以上定义一个 function 接收一个 int 整数然后输出这个整数。function 内的变量在调用此 function 时创建，在结束时清除。当一个带传递参数的 function 被定义后，在调用时需要传入对于数据类型的数据：#include &lt;iostream&gt;
using namespace std;

void printSomething(int x) {
  cout &lt;&lt; x;
}

int main() {
  printSomething(42);
}

// Outputs 42以上示例将 42 传入 printSometing() 然后输出数据。在 function 内对传入参数数据的改变不会对影响到外部的数据。可以在调用时使用不同的传入数据：int main() {
  printSomething(42);
  printSomething(22);
  printSomething(36);
}可以定义多个传递参数，使用逗号, 分隔，如：int addNumbers(int x, int y) {
  int result = x + y;
  return result;
}

int main() {
  cout &lt;&lt; addNumbers(50, 25);
  // Outputs 75
}以上示例定义了两个传递参数，返回值为两个参数的和。rand() function创建一个随机整数是程序内常用的使用场景，可以调用 rand() function 获取随机整数。需要用到 &lt;cstdlib&gt; 库：#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
using namespace std;

int main() {
  cout &lt;&lt; rand();
}输出 10 个 1 - 6 之间的随机数：int main () {
  for (int x = 1; x &lt;= 10; x++) {
  cout &lt;&lt; 1 + (rand() % 6) &lt;&lt; endl;
  }
}

/* Output: 
6
6
5
5
6
5
1
1
5
3
*/但是 rand() 其实生成的是伪随机数，因为每次执行以上程序生成的数都是一样的。使用 srand() 可以获得真正的随机数，它支持设置一个 seed 种子值来作为 rand() 的运行算法：int main () {
  srand(98);

  for (int x = 1; x &lt;= 10; x++) {
    cout &lt;&lt; 1 + (rand() % 6) &lt;&lt; endl;
  }
}改变 srand() 的 seed 传入值可以改变 rand() 算法来生成新的随机数。所以同一个 seed 值执行后生成的随机数是一样的。那么如何使用不同的 seed 值呢，一个方法是读取当前时间来作为 seed，这样就可以得到真正的随机数，读取系统时间需要使用 &lt;ctime&gt; 库：#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
using namespace std;

int main () {
  srand(time(0));

  for (int x = 1; x &lt;= 10; x++) {
    cout &lt;&lt; 1 + (rand() % 6) &lt;&lt; endl;
  }
}time(0) 返回当前时间的秒位。传递参数默认值当定义一个 function 时可以给参数项设置一个 default 默认值，这样在调用这个 function 时如果没有给参数赋值，就会使用默认值的数据，例如：int sum(int a, int b=42) {
  int result = a + b;
  return (result);
}以上示例中给变量 b 设置默认值 42，当调用这个 function 时如果没有给 b 传入数据，就会使用默认值：int main() {
  int x = 24;
  int y = 36;

  int result = sum(x, y);
  cout &lt;&lt; result &lt;&lt; endl;
  //Outputs 60

  result = sum(x);
  cout &lt;&lt;  result &lt;&lt; endl;
   //Outputs 66

  return 0;
}overload function 重写function overload 功能支持使用同样的名称建立多个 function，拥有不同的传递参数。例如创建一个 function，有一个 int 型的参数：void printNumber(int a) { 
  cout &lt;&lt; a;
}我们可以再次创建一个有同样名称的 function 有一个 float 类型的参数：void printNumber(float a) { 
  cout &lt;&lt; a;
}这两个 function 可以同时存在且互不影响，调用时根据传递参数类型或个数的不同来自动判断调用的具体是那个 function。注意不能仅仅建立有不同的返回值类型的同名 function 例如以下 function 不能同时建立：int printName(int a) { }
float printName(int b) { }
double printName(int c) { }递归 recursion递归操作在程序中很常见，可以在 function 中调用其自身。递归在数学中很常见，如计算阶乘：4! = 4 * 3 * 2 * 1 = 24
建立一个 function 实现上面的阶乘计算：int factorial(int n) {
  if (n==1) {
    return 1;
  }
  else {
    return n * factorial(n-1);
  }
}

int main() {
  cout &lt;&lt; factorial(4);
}如果我们调用此 function 传递参数为 4，则返回值计算过程为：返回 4 * factorial(3), 然后返回 4*3*factorial(2), 再次返回 4*3*2*factorial(1), 然后为 4*3*2*1，最后 n 为 1 结束递归调用 function。注意设计 recursion 时一定要有 base case 跳出递归的条件，要不然就会陷入死循环。数组类型传递参数数组也可以作为 function 的传递参数类型，例如：void printArray(int arr[], int size) {
  for(int x=0; x&lt;size; x++) {
    cout &lt;&lt; arr[x];
  }
}

int main() {
  int myArr[3]= {42, 33, 88};
  printArray(myArr, 3);
}printArray() 的参数为 int 型一个数组和单变量，在 main() 中调用时传入一个 3 个元素的数组和数组个数数据。会输出这个数组所有元素。当调用 function 时传入的数组只需要写数组名即可，不需要方括号[]。传入数据有两种方式给 function 传入数据：by value：复制传入参数的数据供 function 内部使用，内部对数据的修改操作不影响外部数据by reference：复制传入参数的相关性到 function 内部，这时候对传入数据的操作会直接影响到外部关联的数据c++ 默认使用 by value 传入数据。如：void myFunc(int x) {
  x = 100;
}

int main() {
  int var = 20;
  myFunc(var);
  cout &lt;&lt; var;
}
// Outputs 20以上示例中，将 var 的数据传入 myFunc()，传入数据给 function 内部变量 x，内部 x 变量的值修改为 100 后不会影响到外部的 var 的数据。by reference 方式会将传入数据的内存地址传入 function 中内部参数，这意味着 function 内对传入数据的修改会直接修改源传入数据内容。使用这种方式的 function，需要将传递数据定义为 pointer 指针类型。例如：void myFunc(int *x) {
  *x = 100;
}

int main() {
  int var = 20;
  myFunc(&amp;var);
  cout &lt;&lt; var;
}
// Outputs 100以上示例中定义一个 function 拥有指针类型的传递参数，在调用 myFunc() 时传入一个数据的地址，这样在 function 内对此地址数据的操作会直接改变外部对应地址的变量的数据。通常情况下，使用 by value 方式更加快速和高效，使用 by reference 方式会修改源相关联的数据会占用更多的内存。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1898.html">
<title>C++ 入门教程 -- 数据类型，数组及指针</title>
<link>https://blog.niekun.net/archives/1898.html</link>
<dc:date>2020-11-19T15:54:00+08:00</dc:date>
<description>介绍数据类型操作系统根据数据类型分配内存空间，同一种数据类型才可以进行计算，如：合法的运算：55+15 //  legal C++ expression
非法的运算：55 + &quot;John&quot; // illegal

数字类型的有两种类型：整型，如：7，10。浮点型，如：3.14，5.67。字符串是一个数字、字符、符号的集合。使用双引号来标记，如：&quot;hello&quot;。字符使用单引号来标记，如：'A'。Boolean 类型只有两个可能的值：true 和 false。整型整型一般默认 4 个字节的存储空间。使用 int 来定义：int a = 42;
带符号型，可以定义正数和负数，一般不写默认 int 就是带符号型：signed int a;
无符号型，只能定义正数型：unsigned int a;
short 型，一般默认空间占用大小，就是 2 个字节：short int a;
long 型，2倍默认空间大小：long int a;
浮点型有三种浮点类型：float, double, 和 long double。浮点型都是 signed 带符号型的。一般情况下，float 型 4 个字节，double 型 8 个字节，long double 型 16 个字节。使用 float 来定义：float a = 3.14;
字符串string 字符串类型是一个字符、数字和符号的集合，使用双引号来标记。使用 string 定义变量，需要使用 &lt;string&gt; 库：#include &lt;string&gt;
using namespace std;

int main() {
    string test = &quot;hello&quot;;
    return 0;
}注意：&lt;string&gt; 库包含在 &lt;iostream&gt; 库中，所以如果已经引用来 &lt;iostream&gt; 就不需要再引用 &lt;string&gt; 了。char 类型char 类型包含了 1 个字节的整数，但是解释器会将这个整数解释为 ASCII 码对应字符。使用单引号来标记，如：char a = 'a';
变量定义规则所有变量的定义需要遵守以下规则：变量名首位必须是一个字母或下划线 _首字符之后的可以使用字母或数字，不能使用特殊字符或空格一般有两种常用的定义方法首字母及每个单词的首字符大写，如: BlankWord首字母小写后续的每个单词首字符大写，如：blankWord所有的变量名都是区分大小写的，如：helloword 和 HelloWord 是两个变量。数组数组是一个同一种数据类型变量的集合体，只需要一次就可以定义多个同一种变量类型的变量。如：int a[5] = {1, 2, 5, 7, 8};
变量名后方括号[]定义数组内变量个数，大括号{}内包含数组内元素实际值，使用逗号,分隔各个元素。注意大括号内的元素个数不能超过数组变量定义的个数。也可以在定义时不说明元素个数：int a[] = {1, 3, 7, 9};
会自动创建足够存储内部元素的数组。数组内每个元素都有一个 index 索引，从 0 开始，所以数组内第一个元素索引为 0，第二个为 1。使用索引号可以访问对应元素：int b[] = {11, 45, 62, 70, 88};

cout &lt;&lt; b[0] &lt;&lt; endl;
// Outputs 11

cout&lt;&lt; b[3] &lt;&lt; endl;
// Outputs 70如果需要逐个访问数组内元素，可以使用 loop 循环来实现：int myArr[5];

for(int x=0; x&lt;5; x++) {
  myArr[x] = 42;
}多维数组以上是单维数组的定义，也可以定义多维数组，如定义一个二位数组：int a[3][4];
想象这个数组为一个矩阵，有三行，每行 4 个元素：定义多维数组定义元素需要每行在一个大括号下单独定义：int x[2][3] = {
  {2, 3, 4}, // 1st row
  {8, 9, 10} // 2nd row
};也可以在一行内定义：int x[2][3] = {{2, 3, 4}, {8, 9, 10}};
使用行号和列号来定位一个元素：int x[2][3] = {{2, 3, 4}, {8, 9, 10}};
cout &lt;&lt; x[0][2] &lt;&lt; endl;

//Outputs 4指针每个变量都存储在内存单元内，每个内存空间都有地址。这个内存地址可以使用地址查询符&amp;来查询，如：int score = 5;
cout &lt;&lt; &amp;score &lt;&lt; endl;

//Outputs &quot;0x29fee8&quot;返回的地址就是存储变量 score 的值的地址空间。一个 pointer 指针就是一个存储某个变量所在内存地址的变量。指针类型可以使某些任务实现更加方便，某些任务，如动态内存分配则必须使用指针来实现。不同类型的指针变量的唯一区别就是其所在内存地址的数据类型的不同。和其他变量类型一样，定义指针变量需要申明类型。使用星号* 来表示是指针类型的变量。int *ip;  // pointer to an integer
double *dp;   // pointer to a double
float *fp;  // pointer to a float
char *ch;  // pointer to a character星号* 可以放在数据类型旁边或者变量旁边或者单独写在中间。我们可以将一个地址赋给指针变量：int score = 5;
int *scorePtr;
scorePtr = &amp;score;

cout &lt;&lt; scorePtr &lt;&lt; endl;

//Outputs &quot;0x29fee8&quot;scorePtr 的值就是 score 变量的内存地址。有两种指针的运算器：地址查询符&amp;，返回操作数所在内存地址 referencing数据查询符*，返回操作数的内存地址下的数据 dereferencing例如：int var = 50;
int  *p;
p = &amp;var;

cout &lt;&lt; var &lt;&lt; endl;
// Outputs 50 (the value of var)

cout &lt;&lt; p &lt;&lt; endl;
// Outputs 0x29fee8 (var's memory location)

cout &lt;&lt; *p &lt;&lt; endl;
/* Outputs 50 (the value of the variable
 stored in the pointer p) */定义指针类型变量时候的星号* 只是用来表明此变量为指针类型变量，不要和内存查询符混淆。数据查询符* 指针指向的变量的 alias，例如：int x = 5;
int *p = &amp;x;

x = x + 4;
x = *p + 4;
*p = *p + 4;P 是 x 的指针，以上示例的三种运算结果都是一样的，都是将变量 x 的值进行计算。我们可以通过定义变量的指针来操作变量值。静态内存和动态内存理解动态内存的工作机制对于开发有很大帮助。再 c++ 中内存被分为两种类型：the stack 静态内存空间：所有的本地变量占用静态内存空间the heap 动态内存空间：再程序运行时动态进行分配的空间，默认不占用很多情况下，提前并不知道一个定义的变量需要多少空间来存储信息需要在运行时动态请求内存空间。可以使用 new 操作符来定义一个变量使用 heap 方式再运行时动态分配内存空间，并返回分配的地址，例如：new int;
以上定义一个使用 heap 方式分配一个足够存储 int 类型的内存空间，并返回这个地址。分配的地址可以存储在一个指针中，可以在后续中使用：int *p = new int;
*p = 5;以上请求了一个动态内存来存储一个 int 类型数据，然后在这个地址存储值为 5。注意指针 p 变量存储在 stack 静态内存中，且其值为 heap 动态内存分配的 int 型数据的地址，结果 5 是存储在 heap 动态内存中的。本地静态内存 stack 下的变量，内存管理是自动进行的不需要手动干预，使用 heap 方式动态分配的内存空间需要手动干预操作，当不再需要动态内存空间的数据时使用 delete 操作符来释放空间。示例：int *p = new int; // request memory
*p = 5; // store value

cout &lt;&lt; *p &lt;&lt; endl; // use value

delete p; // free up the memory忘记释放使用 new 请求的动态内存空间会导致内存泄漏问题，因为在程序关闭时才会释放空间。注意 delete 操作的是指针类型。并且释放的只是 heap 动态内存，指针本身是存储在 stack 中的。当内存释放后，指针不指向某个内存地址，次时这个指针叫做：dangling pointers 悬浮指针。可以重新让这个指针指向内存地址：int *p = new int; // request memory
*p = 5; // store value

delete p; // free up the memory
// now p is a dangling pointer

p = new int; // reuse for a new address也可以定义一个 NULL 的空指针：int *ptr = NULL;
也可以指向一个数组：int *p = NULL; // Pointer initialized with null
p = new int[20]; // Request memory
delete [] p; // Delete array pointed to by p注意释放内存时要加上方括号[]。动态内存分配很有用，如当程序需要读取一张图片时，你提前并不知道图片的大小，需要多大的内存空间来存储。这时候使用动态内存来定义就很方便了。数据大小虽然不同类型数据的内存占用大小和不同架构的设备有关或使用的编译器，但 c++ 有一个最小的数据大小定义：可以使用 sizeof 指令来获取特定数据类型当前占用内存空间，如：sizeof(int)
返回值为此类型数据的内存大小，单位为字节：cout &lt;&lt; &quot;char: &quot; &lt;&lt; sizeof(char) &lt;&lt; endl;
cout &lt;&lt; &quot;int: &quot; &lt;&lt; sizeof(int) &lt;&lt; endl;
cout &lt;&lt; &quot;float: &quot; &lt;&lt; sizeof(float) &lt;&lt; endl;
cout &lt;&lt; &quot;double: &quot; &lt;&lt; sizeof(double) &lt;&lt; endl;
int var = 50;
cout &lt;&lt; &quot;var: &quot; &lt;&lt; sizeof(var) &lt;&lt; endl;

/* Outputs
char: 1
int: 4
float: 4
double: 8
var: 4
*/ 也可以获取数组的内存占用大小：double myArr[10];
cout &lt;&lt; sizeof(myArr) &lt;&lt; endl; 

//Outputs 80一个 double 占用 8 个字节，所以此数组共使用 80 个字节。可以使用 sizeof 分别读取整个数组和单个元素的内存空间来计算数组元素个数：int numbers[100];
cout &lt;&lt; sizeof(numbers) / sizeof(numbers[0]);

// Outputs 100以上就是 c++ 数据类型及指针的介绍。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1911.html">
<title>Speedtest CLI 命令行测速工具</title>
<link>https://blog.niekun.net/archives/1911.html</link>
<dc:date>2020-11-16T13:08:00+08:00</dc:date>
<description>speedtest 是国外很流行的测速平台，可以直接在其网站上测试本地上行下行带宽，最近看到其提供了本地命令行工具，使用起来更加方便了。官网：https://www.speedtest.net/安装首先需要到官网安装对应平台的 CLI 工具：https://www.speedtest.net/apps/cliLinux 类系统可以直接在使用 apt/brew 等包管理工具方便的安装，Windows 下需要手动下载 exe 可执行文件使用。macOS:brew tap teamookla/speedtest
brew update
brew install speedtest --forceubuntu:sudo apt-get install gnupg1 apt-transport-https dirmngr
export INSTALL_KEY=379CE192D401AB61
sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys $INSTALL_KEY
echo &quot;deb https://ookla.bintray.com/debian generic main&quot; | sudo tee  /etc/apt/sources.list.d/speedtest.list
sudo apt-get update
sudo apt-get install speedtestwindows:首先在网站上下载可执行文件，点击下载 1.0.0 版。可执行文件为 speedtest.exe，需要将其目录加入系统 PATH 路径才可以直接在 terminal 调用，加入 PATH 方法参考我的教程：https://blog.niekun.net/archives/413.html使用在终端下使用 speedtest -h 命令查看帮助：Speedtest by Ookla is the official command line client for testing the speed and performance of your internet connection.

Version: speedtest 1.0.0.2

Usage: speedtest [&lt;options&gt;]
  -h, --help                        Print usage information
  -V, --version                     Print version number
  -L, --servers                     List nearest servers
  -s, --server-id=#                 Specify a server from the server list using its id
  -I, --interface=ARG               Attempt to bind to the specified interface when connecting to servers
  -i, --ip=ARG                      Attempt to bind to the specified IP address when connecting to servers
  -o, --host=ARG                    Specify a server, from the server list, using its host's fully qualified domain name
  -p, --progress=yes|no             Enable or disable progress bar (Note: only available for 'human-readable'
                                    or 'json' and defaults to yes when interactive)
  -P, --precision=#                 Number of decimals to use (0-8, default=2)
  -f, --format=ARG                  Output format (see below for valid formats)
  -u, --unit[=ARG]                  Output unit for displaying speeds (Note: this is only applicable
                                    for ‘human-readable’ output format and the default unit is Mbps)
  -a                                Shortcut for [-u auto-decimal-bits]
  -A                                Shortcut for [-u auto-decimal-bytes]
  -b                                Shortcut for [-u auto-binary-bits]
  -B                                Shortcut for [-u auto-binary-bytes]
      --selection-details           Show server selection details
      --ca-certificate=ARG          CA Certificate bundle path
  -v                                Logging verbosity. Specify multiple times for higher verbosity
      --output-header               Show output header for CSV and TSV formats

 Valid output formats: human-readable (default), csv, tsv, json, jsonl, json-pretty

 Machine readable formats (csv, tsv, json, jsonl, json-pretty) use bytes as the unit of measure with max precision

 Valid units for [-u] flag:
   Decimal prefix, bits per second:  bps, kbps, Mbps, Gbps
   Decimal prefix, bytes per second: B/s, kB/s, MB/s, GB/s
   Binary prefix, bits per second:   kibps, Mibps, Gibps
   Binary prefix, bytes per second:  kiB/s, MiB/s, GiB/s
   Auto-scaled prefix: auto-binary-bits, auto-binary-bytes, auto-decimal-bits, auto-decimal-bytes首先使用测试最近的测速节点 testspeed -L:root@Marco-vostro-14-wsl:~# speedtest -L
Closest servers:

    ID  Name                           Location             Country
==============================================================================
 29105  陕西移动5G                 Xi'an                China
  2461  China Unicom                   Chengdu              China
  4575  China Mobile Group Sichuan     Chengdu              China
 24337  China Mobile Group Sichuan Co.,Ltd. Chengdu              China
 35527  sccn                           Chengdu              China
 31985  China Unicom                   Chongqing            China
 17584  Chongqing Mobile Company       Chongqing            CN
  5530  CCN                            Chongqing            China
 16145  Lanzhou,China Mobile,Gansu     Lanzhou              China执行 speedtest 命令进行测速，默认使用上面测试的最近的节点：root@Marco-vostro-14-wsl:~# speedtest

   Speedtest by Ookla

     Server: Chongqing Mobile Company - Chongqing (id = 17584)
        ISP: China Telecom
    Latency:    31.45 ms   (25.47 ms jitter)
   Download:    14.31 Mbps (data used: 17.5 MB)
     Upload:     8.23 Mbps (data used: 11.3 MB)
Packet Loss:     0.0%
 Result URL: https://www.speedtest.net/result/c/bee17d45-7b9c-44e6-8a6e-ef99d84ba441以上就是简单的用法，可以查看帮助了解更多的使用方法。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1906.html">
<title>两个子网间网络互访的原理</title>
<link>https://blog.niekun.net/archives/1906.html</link>
<dc:date>2020-11-13T11:29:00+08:00</dc:date>
<description>之前我介绍过子网，子网掩码，网关等基本概念解析，可以参考：https://blog.niekun.net/archives/1885.html在不同子网下的设备是不能直接访问的，因为他们在不同的网段内，比如：路由 A 下有子网 192.168.1.0/24路由 B 下有子网 192.168.3.0/24设备 james：192.168.1.10/24 网关：192.168.1.1设备 Johnny：192.168.3.10/24 网关：192.168.3.1两个路由的 wan 网口在同一网段：192.168.2.0/24 下正常情况下路由 A 下的设备无法访问路由 B 下的设备，因为他们在不同的子网网段下。路由 A 有两个网段：192.168.1.0 和 192.168.2.0，所以它可以同时看见这两个网段的设备，但是它并不知道 192.168.3.0 这一网段的存在。同样的道理，路由 B 并不知道 192.168.1.0 这一网段的存在。当你给一个设备添加一个路由表 route table，就可以告诉它有其他网段可以进行访问，同时需要告诉它一个可以访问到这个新网段的网关，这样就可以访问到其他网段了。例如让路由 A 访问到路由 B 的子网 192.168.3.0 可以通过给路由 A 添加新的路由表来实现，使用 ip route 命令：ip route add 192.168.3.0/24 via 192.168.2.2以上命令的意义是添加路由 B 子网的路由表 192.168.3.0/24，网关地址是路由 B 的 wan 地址 192.168.2.2。因为路由 B 可以访问到两个网络 192.168.2.0 和 192.168.3.0，而路由 A 和路由 B 通过 192.168.2.0 互访，所以通过给路由 A 添加以上路由表然后网关地址为路由 B 和外部通信的地址，这样路由 A 就可以访问到路由 B 的子网了。现在路由 A 可以访问到路由 B 的子网了，那么路由 A 下的设备如何访问路由 B 的子网设备呢？原理是相同的，可以通过给设备添加路由 B 子网的路由表，然后由于路由 A 已经可以访问 路由 B 子网了，所以将网关地址设置为路由 A 地址即可：ip route add 192.168.3.0/24 via 192.168.1.1在路由 A 下的 James 执行以上命令后，就可以访问到路由 B 下的 Johnny 了。同样的原理，在路由 B 上设置路由表及网关就可以实现子网互访了。参考链接：understand the 'ip route' command for cisco routers</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1904.html">
<title>nextcloud 安装教程</title>
<link>https://blog.niekun.net/archives/1904.html</link>
<dc:date>2020-11-11T10:42:14+08:00</dc:date>
<description>安装包：https://nextcloud.com/changelog/#latest20系统需求：https://docs.nextcloud.com/server/20/admin_manual/installation/system_requirements.htmlnginx 配置：https://docs.nextcloud.com/server/18/admin_manual/installation/nginx.htmlphp 配置相关：https://docs.nextcloud.com/server/20/admin_manual/installation/source_installation.html#php-fpm-tips-label修改 php 内存限制：https://www.chinaz.com/program/2011/1010/213048.shtml安装 php 内存缓存：https://docs.nextcloud.com/server/15/admin_manual/configuration_server/caching_configuration.html命令行安装：https://docs.nextcloud.com/server/stable/admin_manual/installation/command_line_installation.html</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1903.html">
<title>MySQL 用户密码规则配置</title>
<link>https://blog.niekun.net/archives/1903.html</link>
<dc:date>2020-11-11T10:37:00+08:00</dc:date>
<description>在创建 MySQL 用户时需要设置密码，有时候输入输入密码后会提示创建失败，密码设置 policy 错误。这是因为当前设置的密码和 MySQL 密码创建规则不符，可以查看当前规定的密码规则也可以进行修改。进入 MySQL 执行下面命令：SHOW VARIABLES LIKE 'validate_password%';
会列出密码创建相关参数：mysql&gt; SHOW VARIABLES LIKE 'validate_password%';
+--------------------------------------+--------+
| Variable_name                        | Value  |
+--------------------------------------+--------+
| validate_password_check_user_name    | ON     |
| validate_password_dictionary_file    |        |
| validate_password_length             | 8      |
| validate_password_mixed_case_count   | 1      |
| validate_password_number_count       | 1      |
| validate_password_policy             | MEDIUM |
| validate_password_special_char_count | 1      |
+--------------------------------------+--------+
7 rows in set (0.03 sec)其中 validate_password_length 是密码位数，validate_password_special_char_count 是密码包含特殊字符。可以通过命令修改参数值来改变密码规则，例如：取消特殊字符：SET GLOBAL validate_password_special_char_count= 0;
修改后可以测试再次建立用户设置密码。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1900.html">
<title>MySQL 8.0 修改用户密码加密方式</title>
<link>https://blog.niekun.net/archives/1900.html</link>
<dc:date>2020-11-11T09:41:00+08:00</dc:date>
<description>MySQL 8.0 默认创建的用户密码加密方式为：caching_sha2_password，有些应用在连接时由于不兼容会导致报错，可以修改为 MySQL 5 使用的加密方式：sha256_password。创建用户：create user &quot;newuser&quot;@&quot;localhost&quot; identified by &quot;PASSWORD&quot;;
授予全部数据库权限：grant all privileges on *.* to 'newuser'@'localhost';
修改成原来的加密方式：alter user &quot;newuser&quot;@&quot;localhost&quot; identified with mysql_native_password by 'PASSWORD';
刷新权限：    FLUSH PRIVILEGES;
查看已建立的用户及加密方式：SELECT user,authentication_string,plugin,host FROM mysql.user;
显示如下：+------------------+------------------------------------------------------------------------+---
| user             | authentication_string                         | plugin                | host      |
+------------------+------------------------------------------------------------------------+-----
| marco            | *D51541FCBC8DD8E                              | mysql_native_password | localhost |
| root             |                                               | auth_socket           | localhost |
+------------------+------------------------------------------------------------------------+---------以上就是修改用户密码加密方式的方法。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1899.html">
<title>MySQL 5.7 升级 8.0</title>
<link>https://blog.niekun.net/archives/1899.html</link>
<dc:date>2020-11-10T11:03:52+08:00</dc:date>
<description>首先备份本地数据库，以防升级错误：mysqldump -uUSER -pPASSWORD --all-databases &gt; /path/to/backup.sql
官网下载最新的 MySQL apt 库：https://dev.mysql.com/downloads/repo/apt/当前最新地址为：https://dev.mysql.com/get/mysql-apt-config_0.8.16-1_all.deb下载到本地后安装：dpkg -i mysql-apt-config_0.8.16-1_all.deb
期间会提示选择安装的 MySQL 版本，第一步选择当前安装的 MySQL 5.7，然后下一步选择 MySQL server 8.0，然后再下一步切换到 ok 选项确认。配置完成后更新 apt 库及安装新版 MySQL：apt update
apt install mysql-server
安装完成后验证当前安装版本：mysql -V
以上就是简单的 MySQL 升级教程。参考链接：https://dev.mysql.com/doc/mysql-apt-repo-quick-guide/en/#apt-repo-setuphttps://www.digitalocean.com/community/questions/upgrade-mysql-5-7-to-8-ubuntu-18-04</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1895.html">
<title>C++ 入门教程 -- 判断及循环</title>
<link>https://blog.niekun.net/archives/1895.html</link>
<dc:date>2020-11-07T15:53:00+08:00</dc:date>
<description>if 判断if 申明的使用场景：当一个判断条件达到是执行指令。语法结构：if (condition) {
    statements
}示例：if (7 &gt; 4) {
  cout &lt;&lt;  &quot;Yes&quot;; 
}

// Outputs &quot;Yes&quot;可以使用的相关性判断器：&lt;&gt;&gt;=&lt;===!=当条件不满足是，也可以执行命令：if (condition) {
  //statements
}
else {
 //statements
}if else 指令可以多次嵌套使用：int age = 18;
if (age &gt; 14) {
  if(age &gt;= 18) {
    cout &lt;&lt; &quot;Adult&quot;;
  }
  else {
    cout &lt;&lt; &quot;Teenager&quot;;
  }
}
else {
  if (age &gt; 0) {
    cout &lt;&lt; &quot;Child&quot;;
  }
  else {
    cout &lt;&lt; &quot;Something's wrong&quot;;
  }
}当命令只有一句时可以省略大括号：int a = 10;
if (a &gt; 4)
  cout &lt;&lt; &quot;Yes&quot;;
else
  cout &lt;&lt; &quot;No&quot;;while 循环一个 while 循环重复的执行设置的命令，直到设置的条件不满足为止。语法：while (condition) {
   statement(s);
}示例：int num = 1;
while (num &lt; 6) {
  cout &lt;&lt; &quot;Number: &quot; &lt;&lt; num &lt;&lt; endl;
  num = num + 1;
}当 num 变量小于 6 满足时，循环执行大括号内的指令，直到 num 的值大于等于 6 则跳出循环继续执行下面的指令。以上示例中当 num 第五次自加后结果为 6，则下一次循环开始时判断条件就为 false 了，就会跳出循环。for 循环for 循环指令可以实现指定循环次数，语法结构如下：for ( init; condition; increment ) {
  statement(s);
}init 用来设置变量初值，且只设置一次condition 用来给定执行循环的条件，满足则执行循环内指令increment 设置循环条件的变量值如何变化示例：for (int x = 1; x &lt; 10; x++) {
 // some code
 }定义并设置 x 变量初值 1，循环条件是 x 小于 10，每次循环后 x 自加 1。变量变化量可以自定：for (int a = 0; a &lt; 50; a+=10) {
  cout &lt;&lt; a &lt;&lt; endl;
}
/* Outputs
0
10
20
30
40
*/do while 循环不同于 while 循环，do while 循环首先执行一次循环内的指令，再判断条件是否满足。语法：do {
   statement(s);
} while (condition);示例：int a = 0;
do {
  cout &lt;&lt; a &lt;&lt; endl;
  a++;
} while(a &lt; 5);

/* Outputs
0
1
2
3
4
*/do while 即使条件不满足也至少会执行一次循环内的命令。switch 指令当需要根据一个变量值为不同的结果时执行不同的指令时可以使用 switch 指令。语法：switch (expression) {
  case value1:
    statement(s);
    break;
  case value2:
    statement(s);
    break;
    ...
  case valueN:
    statement(s);
    break;
    default:
    statement(s);
}当变量的值匹配到 switch 里定义的一个 value 值后，会执行此 case 下的指令。使用 break 来跳出 switch 指令，如果不写的话会顺序执行下面的case 指令，即使变量值并没有匹配到这个 case。default 用来定义当以上设置的 case 都没有匹配上时执行的指令。逻辑操作符有三个逻辑操作符：&& 与|| 或!  非与指令：当两个条件都满足时为 true：int age = 20;
if (age &gt; 16 &amp;&amp; age &lt; 60) {
  cout &lt;&lt; &quot;Accepted!&quot; &lt;&lt; endl;
}

// Outputs &quot;Accepted&quot;或指令：当任意一个条件满足时为 true：int age = 16;
int score = 90;
if (age &gt; 20 || score &gt; 50) {
    cout &lt;&lt; &quot;Accepted!&quot; &lt;&lt; endl;
}

// Outputs &quot;Accepted!&quot;非指令：当条件不满足时为 true：int age = 10;
if ( !(age &gt; 16) ) {
  cout &lt;&lt; &quot;Your age is less than 16&quot; &lt;&lt; endl;
}

// Outputs &quot;Your age is less than 16&quot;以上就是常用的判断及循环指令用法。</description>
</item>
</rdf:RDF>