<?xml version="1.0" encoding="UTF-8"?>
<rdf:RDF
xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
xmlns="http://purl.org/rss/1.0/"
xmlns:dc="http://purl.org/dc/elements/1.1/">
<channel rdf:about="https://blog.niekun.net/feed/rss/author/1/">
<title>Marco Nie - admin</title>
<link>https://blog.niekun.net/author/1/</link>
<description>admin</description>
<items>
<rdf:Seq>
<rdf:li resource="https://blog.niekun.net/archives/1863.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1818.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1805.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1801.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1797.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1793.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1788.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1785.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1782.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1781.html"/>
</rdf:Seq>
</items>
</channel>
<item rdf:about="https://blog.niekun.net/archives/1863.html">
<title>iptables 使用教程</title>
<link>https://blog.niekun.net/archives/1863.html</link>
<dc:date>2020-10-23T09:59:00+08:00</dc:date>
<description>ipatbles 是 Linux 下的网络防火墙规则管理/修改工具，通过控制 Linux 内核 netfilter 模块，来管理网络数据包的处理和转发。用来识别路由表中特定的流量然后执行设定的规则。只用于处理 IPv4 数据包；而对于 IPv6 数据包，则使用类似的 ip6tables 命令。基本概念结构：Tables 路由表：用来区分不同类型的数据包，如 filter，nat，mangle，每个表包含几个路由链Chain 路由链：流量的类型，如 INPUT ，FORWARD ，OUTPUT ，每种类型流量可以设置不同规则Rule 规则：用来匹配特定类型的流量，如匹配来自 192.168.1.230 的流量Target 目标：用来处理匹配到的流量，如 ACCEPT, DROP, QUEUE.Policy 策略：是默认的处理动作，用来处理没有匹配到的流量，如 ACCEPT or DROP.iptables、ip6tables等都使用Xtables框架。存在“表（tables）”、“链（chain）”和“规则（rules）”三个层面。每个“表”指的是不同类型的数据包处理流程，如filter表表示进行数据包过滤，而nat表针对连接进行地址转换操作。每个表中又可以存在多个“链”，系统按照预订的规则将数据包通过某个内建链，例如将从本机发出的数据通过OUTPUT链。在“链”中可以存在若干“规则”，这些规则会被逐一进行匹配，如果匹配，可以执行相应的动作，如修改数据包，或者跳转。跳转可以直接接受该数据包或拒绝该数据包，也可以跳转到其他链继续进行匹配，或者从当前链返回调用者链。当链中所有规则都执行完仍然没有跳转时，将根据该链的默认策略（“policy”）执行对应动作；如果也没有默认动作，则是返回调用者链。                                           netfilter hooks

                                  +-----------&gt; local +-----------+
                                  |             process           |
                                  |                               |
                                  |                               |
                                  |                               |
                                  |                               v
  MANGLE            +-------------+--------+
  FILTER            |                      |               +----------------------+    RAW
  SECURITY          |        input         |               |                      |    conntrack
  SNAT              |                      |               |     output           |    MANGLE
                    +------+---------------+               |                      |    DNAT
                           ^                               +-------+--------------+    routing
                           |                                       |                   FILTER
                           |                                       |                   SECURITY
                           |            +---------------------+    |         +-------------+
     +-----------+                      |                     |    +-------&gt; |             |
+--&gt; |pre routing+----  route    -----&gt; |      forward        |              |post routing +----&gt;
     |           |      lookup          |                     +------------&gt; |             |
     +-----------+                      +---------------------+              +-------------+
     
     RAW                                       MANGLE                         MANGLE
     conntrack                                 FILTER                         SNAT
     MANGLE                                    SECURITY
     DNAT
     routing
     内建的路由表：filter: 是默认的表，如果不指明表则使用此表。其通常用于过滤数据包。It includes chains like INPUT, OUTPUT and FORWARD.nat : 用于地址转换操作。It includes PREROUTING and POSTROUTING chains.mangle : 用于修改或标记数据包。raw : 用于处理异常。Built-in chains are PREROUTING and OUTPUT.security : Used for Mandatory Access Control内建的路由链：INPUT :输入链。发往本机的数据包通过此链FORWARD :转发链。本机转发的数据包通过此链OUTPUT :输出链。从本机发出的数据包通过此链PREROUTING :路由前链，在处理路由规则前通过此链，通常用于目的地址转换（DNAT）POSTROUTING :路由后链，完成路由规则后通过此链，通常用于源地址转换（SNAT）Note: 用户可以创建自定义路由链目标：RETURN 允许并结束在 chains 里继续匹配ACCEPT 允许但依然要在其他 chains 里继续进行匹配REJECT 拒绝DROP 丢弃REDIRECT 重定向。只适用于 NAT 路由表的 PREROUTING 和 OUTPUT 路由链MARK 只适用于 mangle 路由表。用来给特定流量做标记。root@OpenWrt:~# iptables -h
iptables v1.8.3

Usage: iptables -[ACD] chain rule-specification [options]
       iptables -I chain [rulenum] rule-specification [options]
       iptables -R chain rulenum rule-specification [options]
       iptables -D chain rulenum [options]
       iptables -[LS] [chain [rulenum]] [options]
       iptables -[FZ] [chain] [options]
       iptables -[NX] chain
       iptables -E old-chain-name new-chain-name
       iptables -P chain target [options]
       iptables -h (print this help information)

Commands:
Either long or short options are allowed.
  --append  -A chain        Append to chain
  --check   -C chain        Check for the existence of a rule
  --delete  -D chain        Delete matching rule from chain
  --delete  -D chain rulenum
                Delete rule rulenum (1 = first) from chain
  --insert  -I chain [rulenum]
                Insert in chain as rulenum (default 1=first)
  --replace -R chain rulenum
                Replace rule rulenum (1 = first) in chain
  --list    -L [chain [rulenum]]
                List the rules in a chain or all chains
  --list-rules -S [chain [rulenum]]
                Print the rules in a chain or all chains
  --flush   -F [chain]        Delete all rules in  chain or all chains
  --zero    -Z [chain [rulenum]]
                Zero counters in chain or all chains
  --new     -N chain        Create a new user-defined chain
  --delete-chain
            -X [chain]        Delete a user-defined chain
  --policy  -P chain target
                Change policy on chain to target
  --rename-chain
            -E old-chain new-chain
                Change chain name, (moving any references)
Options:
    --ipv4    -4        Nothing (line is ignored by ip6tables-restore)
    --ipv6    -6        Error (line is ignored by iptables-restore)
[!] --protocol    -p proto    protocol: by number or name, eg. `tcp'
[!] --source    -s address[/mask][...]
                source specification
[!] --destination -d address[/mask][...]
                destination specification
[!] --in-interface -i input name[+]
                network interface name ([+] for wildcard)
 --jump    -j target
                target for rule (may load target extension)
  --goto      -g chain
                              jump to chain with no return
  --match    -m match
                extended match (may load extension)
  --numeric    -n        numeric output of addresses and ports
[!] --out-interface -o output name[+]
                network interface name ([+] for wildcard)
  --table    -t table    table to manipulate (default: `filter')
  --verbose    -v        verbose mode
  --wait    -w [seconds]    maximum wait to acquire xtables lock before give up
  --wait-interval -W [usecs]    wait time to try to acquire xtables lock
                default is 1 second
  --line-numbers        print line numbers when listing
  --exact    -x        expand numbers (display exact values)
[!] --fragment    -f        match second or further fragments only
  --modprobe=&lt;command&gt;        try to insert modules using this command
  --set-counters PKTS BYTES    set the counter during insert/append
[!] --version    -V        print package version.语法结构：iptables -t [TABLE] [-A/-C/-D...] [CHAIN] rule -j Target
路由链操作-A 链添加规则-A 用来给某个链添加规则和动作。丢弃所有发往本机的流量：iptables -t filter -A INPUT -j DROP
-D 链删除规则删除设定的发往本机的编号为 2 的规则：iptables -t filter -D INPUT 2
-C 链检查规则是否存在检查是否有丢弃来自 192.168.1.123 的流量的规则：iptables -t filter -C INPUT -s 192.168.1.123 -j DROP
规则匹配-p 匹配特定协议的流量可能的流量类型: tcp, udp, icmp, ssh etc.屏蔽对本机的 ping 请求：iptables -t filter -A INPUT -p icmp -j DROP
丢弃发往本机的 udp 流量：iptables -t filter -A INPUT -p udp -j DROP
--dport 匹配特定端口丢弃访问本机 1080 端口的 tcp 流量：(默认是 filter 路由表)iptables -A INPUT -p tcp --dport 1080 -j DROP
-s 匹配源地址流量接收来自 192.168.1.230 发往本机的流量：iptables -t filter -A INPUT -s 192.168.1.230 -j ACCEPT
-d 目标地址的流量丢弃发往 192.168.1.123 的流量：iptables -t filter -A OUTPUT -d 192.168.1.123 -j DROP
-i 匹配特定网络入口的流量：丢弃所有来自 wlan0 无线网口的流量：iptables -t filter -A INPUT -i wlan0 -j DROP
-o 匹配特定网络出口的流量：丢弃所有发往 eth0 网口的流量：iptables -t filter -A OUTPUT -i eth0 -j DROP
允许 loopback 本地访问允许来自本地的访问(127.0.0.1) 非常重要，应该保证为打开状态：iptables -A INPUT -i lo -j ACCEPT
iptables -A OUTPUT -o lo -j ACCEPT
规则动作-j 规则匹配后的动作丢弃所有转发链流量：iptables -t filter -A FORWARD -j DROP
-m 匹配参数的使用-m multiport 同时处理多端口允许访问本机的多个端口的 tcp 流量：(默认是 filter 路由表)iptables -A INPUT -p tcp -m multiport --dports 22,80,443 -j ACCEPT
-m mac 匹配特定 mac 地址丢弃某个 mac 地址对本地的访问：iptables -A INPUT -m mac --mac-source 00:00:00:00:00:00 -j DROP
路由转发将特定的流量转发到另一个地方，需要用到 PREROUTING 路由表来预处理流量。将来自 eth0 网口的访问本机 25 端口的 tcp 流量转发到 2525 端口：iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 25 -j REDIRECT --to-port 2525
新建路由链通过新建自定义路由链，可以放入自定义的规则到里面。自定义规则并不能被直接使用，需要使用系统内置的 chains 然后 jump 到自定义 chain。语法：iptables -t [TABLE] -N [CHAIN]
在 NAT 路由表下新建路由链 custom-chain：iptables -t nat -N custom-chain
查看新建的路由链：iptables -L
将流量转到自定义路由链：iptables -A INPUT -p tcp -j custom-chain
标记流量MARK 目标用来给流量做标记，方便识别及处理。只适用于 mangle 路由表：iptables -t mangle -A PREROUTING -p udp --dport 53 -j MARK --set-mark 1
常用命令列出当前设定的所有规则并按数字排序：iptables -L -n
列出特定路由表的规则：iptbales -t [TABLE] -L
清除设置的规则，默认为 filter 路由表：iptables -t [TABLE] --flush
保存规则：iptables-save &gt; /path/to/file
恢复规则：iptables-restore &lt; /path/to/file
参考文章iptables command in Linux with Examples25 Useful IPtable Firewall Rules Every Linux Administrator Should Knowiptables wikipediahttps://gist.github.com/mcastelino/c38e71eb0809d1427a6650d843c42ac2</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1818.html">
<title>vmware 虚拟机安装 openWRT 及路由配置</title>
<link>https://blog.niekun.net/archives/1818.html</link>
<dc:date>2020-10-15T16:51:00+08:00</dc:date>
<description>openWrt 是专门为嵌入式设备设计的 Linux 系统，常用来作为软路由系统使用。LEDE 和 openWrt 已经合并到一起。官网：https://openwrt.org/由于最近研究软路由，所以先再 Windows 上使用 VMware 虚拟机安装测试 openWrt。固件下载及转换openWrt 固件也是区分不同硬件平台的，需要根据硬件情况下载对应的系统镜像。官方固件下载地址：https://downloads.openwrt.org/目前最新的版本是 19.07.4，我电脑是 x86 平台 64位系统需下载 x86_64 固件，进入列表下载 combined-ext4.img.gz 到本地:将下载的压缩包解压出 img 镜像文件。由于我是虚拟机安装，所以需要将下载的 img 镜像转换为 VMware 的虚拟硬盘格式：.vmdk，最方便的是使用 Linux 工具 qemu-img 来完成，这里我是用 wsl 子系统来处理：apt install qemu qemu-utils
qemu-img convert -f raw -O vmdk openwrt-19.07.4-x86-64-combined-ext4.img openwrt-19.07.4-x86-64-combined-ext4.vmdk完成后得到 vmdk 文件。建立虚拟机新建虚拟机，选择自定义模式：硬件兼容选择最新的即可：然后选择稍后安装操作系统：系统选择 Linux 系统，19.07 版本是 4.14 内核，我下载的是 64 位固件，所以选择其他 Linux 4.x内核，64位：虚拟机名称自己定义：处理器默认即可：内存分配1G：剩下的全部默认确定即可，虚拟机初步建立完成。下一步开始配置虚拟网卡用来分配给 openwrt 的 lan 内网网卡，点击编辑 - 虚拟网络编辑器：点击右下角更改设置：点击添加网络：选择一个可用的网络点击确定，我选择 vnet2：选择仅主机模式，由于 openwrt 自带 DHCP 控制所以这里取消勾选 DHCP 服务：点击确认，完成虚拟网卡的建立，子网 IP 段是 192.168.111.0，子网掩码 255.255.255.0。下面编辑刚才建立的虚拟机，点击编辑虚拟机设置：移除不需要的硬件，包括硬盘，保留网络适配器。快捷键 alt + R：将上面转换的 vmdk 文件拷贝到此虚拟机文件夹：点击添加硬件：选择硬盘，点击下一步：选择使用现有虚拟磁盘：选择刚才复制到目录的 vmdk 文件，点击完成：选择转换：再次添加一个网络适配器：这里我们有了两个网络适配器，第一个分配给 lan 第二个分配给 wan，注意顺序，openWrt 默认识别第一个网卡为 lan。第一个网卡 lan 设置为我们刚才建立的虚拟网卡 vnet2，用来给 openWrt 路由的内网使用：第二个网卡 wan 设置为桥接模式，用来连接物理外网：确认后启动虚拟机，等待进入进入系统。进入系统后可以设置一个快照方便以后恢复。网络配置进入系统后，我们需要设置 lan 的 IP 地址为我们创建的虚拟网卡所在的 IP 段，就能从主机访问 openwrt 了。需要编辑 /etc/config/network 配置文件，默认配置文件如下：这里我们需要关闭网桥模式(用 #井号 屏蔽)，然后修改 lan 段里的 ipaddr 地址为虚拟网卡网段。我们这里修改为 192.168.111.2:修改完成后 reboot 系统。重启完成后使用 ip addr 查看系统网络配置，可以看到 wan 口 eth1 分配到主机网络所在局域网 IP 地址，lan 口 eth0 是虚拟网卡 IP 地址：使用 ping 查看是否可以连接外网：如果无法 ping 通，则需要检查配置问题。主机网络适配器里找到 vnet 2 虚拟网卡：查看信息，ip 地址是否正确，注意如果 openwrt 里的 IP 设置为了 192.168.111.1，则这里的IPv4 地址就需要修改为其他地址了，不然就冲突了：这时候使用主机访问 192.168.111.2 应该就可以进入 LuCl 界面了：默认没有密码，可以使用 passwd 设置登录密码。我们先给 openWrt 设置一个静态 wan 口 Ip，这样局域网设备就可以方便访问了。点击 network - interface：wan 口配置点击 edit：protocol 选择 static address，点击 switch protocol：设置本地局域网内的 IP 地址，网关地址和 DNS 地址，点击保存：点击 save：更换国内源由于虚拟机内不方便复制粘贴文本，我们使用 ssh 连接虚拟机：类似于 Debian，openWrt 也有包管理系统 opkg。默认都是国外源地址访问比较慢，可以替换为国内镜像地址，这里使用清华园镜像：https://mirrors.tuna.tsinghua.edu.cn/help/openwrt/列表路径是：/etc/opkg/，有两个 conf 文件：distfeeds.conf, customfeeds.conf一键替换命令：sed -i 's_downloads.openwrt.org_mirrors.tuna.tsinghua.edu.cn/openwrt_' /etc/opkg/distfeeds.conf
更新列表：opkg update
安装常用工具：opkg install vim-full curl luci-i18n-base-zh-cn ca-certificates luci-ssl-openssl
使用第三方源使用第三方源步骤：添加 第三方源 key 文件源仓库地址加入 /etc/opkg/customfeeds.conf 文件opkg update源仓库地址格式：src/gz example_feed_name http://www.example.com/path/to/files
示例，加入第三方开发者 kuoruan 的源：添加 key：wget -O kuoruan-public.key http://openwrt.kuoruan.net/packages/public.key
opkg-key add kuoruan-public.key添加仓库地址到配置文件：echo &quot;src/gz kuoruan_universal http://openwrt.kuoruan.net/packages/releases/all&quot; \
  &gt;&gt; /etc/opkg/customfeeds.conf

opkg update参考链接：https://openwrt.org/docs/guide-user/virtualization/vmwarehttps://github.com/kuoruan/luci-app-v2ray</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1805.html">
<title>wsl 2 激活 systemd</title>
<link>https://blog.niekun.net/archives/1805.html</link>
<dc:date>2020-10-13T12:03:00+08:00</dc:date>
<description>wsl 默认不支持 systemd，执行 systemd 命令会返回错误提示：# hostnamectl
System has not been booted with systemd as init system (PID 1). Can't operate.
Failed to create bus connection: Host is down可以安装第三方的工具 genie 来激活 systemd。GitHub：https://github.com/arkane-systems/genie安装添加第三方 apt 库，在 /etc/apt/sources.list.d 目录下新建文件 wsl-translinux.list，文件内容如下：deb [trusted=yes] https://wsl-translinux.arkane-systems.net/apt/ /更新库列表：apt update &amp;&amp; apt upgrade
安装依赖包：安装 Microsoft 依赖，下载对应系统版本的 prod 包：https://packages.microsoft.com/config/：curl -O https://packages.microsoft.com/config/ubuntu/20.04/packages-microsoft-prod.deb
dpkg -i packages-microsoft-prod.deb安装其他依赖：apt update &amp;&amp; apt install apt-transport-https daemonize dotnet-runtime-3.1安装 genie：apt install systemd-genie
使用退出 wsl 系统后关闭 所有已打开的 wsl：wsl --shutdown
启动 wsl：wsl genie -s
启动的 Linux 系统就可以正常使用 systemd 了。参考链接：https://gist.github.com/djfdyuruiry/6720faa3f9fc59bfdf6284ee1f41f950</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1801.html">
<title>wls 2 设置静态 DNS 服务地址及 Linux 和 Windows 主机网络互相访问设置</title>
<link>https://blog.niekun.net/archives/1801.html</link>
<dc:date>2020-10-13T10:01:00+08:00</dc:date>
<description>在升级到 wsl 2 后发现一些网络问题和之前的 wsl 不一样了，主要是 DNS 解析和 wsl 和 Windows 网络互访问题，这里介绍如何处理。DNS 解析wsl 2 使用的 DNS 解析服务器设置在文件：/etc/resolv.conf 内设置，这是一个 link 文件，真正的文件路径是：/run/resolvconf/resolv.conf，这个文件是每次 wsl 启动时自动生成的，内容如下：# This file was automatically generated by WSL. To stop automatic generation of this file, add the following entry to /etc/wsl.conf:
# [network]
# generateResolvConf = false
nameserver 172.24.144.1nameserver 后面的就是指定的 DNS 服务器地址。我发现有时候分配的服务器地址是无效的，如：127.0.0.53，使用 ping 来测试发现提示无法解析地址。需要设置一个固定的 DNS 地址，方法如下：新建文件：/etc/wsl.conf，内容如下：[network]
generateResolvConf = false以上配置好就不会自动创建 /run/resolvconf/resolv.conf 文件了。退出 wsl，关机然后重新启动：exit
wsl --shutdown
wsl
删除 link 文件：/etc/resolv.conf:rm /etc/resolv.conf
然后新建 /etc/resolv.conf 文件，内容如下，可自定义 nameserver 地址：nameserver 114.114.114.114
再次退出 wsl，关机然后重新启动：exit
wsl --shutdown
wsl
查看 /etc/resolv.conf 文件是否是之前自定义的地址：cat /etc/resolv.conf
测试网络服务：ping niekun.net
参考链接：https://github.com/microsoft/WSL/issues/5256#issuecomment-666545999网络访问配置以前使用 wsl 时 Linux 子系统和 Windows 主机的网络好像是直接互通的，比如我在 Windows 下建立了一个 http 网页 http://127.0.0.1:6000，可以在 Linux 子系统下直接访问地址 http://127.0.0.1:6000，同理对于 Windows 主机访问 Linux 子系统的服务也是可以使用 localhost 直接访问的。在升级到 wsl 2 后发现这一特性没有了，无法直接通过 localhost 地址来互通，查询官方说明关于wsl 2 访问网络服务 的方法可以实现访问，但是每次关机后 wsl 和 Windows 本地地址会发生变化不方便使用。可以设置静态 IP 来固定地址。Windows 终端下执行下面命令：在 wsl 下增加 IP 地址：192.168.50.16，名称为：eth0:1:(以 Ubuntu 系统为例)wsl -d Ubuntu -u root ip addr add 192.168.50.16/24 broadcast 192.168.50.255 dev eth0 label eth0:1
在 Windows 10 下增加一个 IP 地址：(此命令需要管理员权限执行)netsh interface ip add address &quot;vEthernet (WSL)&quot; 192.168.50.88 255.255.255.0
执行后，在 wsl 下通过 IP：192.168.50.88 访问 Windows 服务。在 Windows 下通过 IP：192.168.50.16 访问 wsl 服务。完成后再终端使用 ipconfig 查看设置：Ethernet adapter vEthernet (WSL):

   Connection-specific DNS Suffix  . :
   Link-local IPv6 Address . . . . . : fe60::b525:6b90:8fb0:f513%58
   IPv4 Address. . . . . . . . . . . : 172.23.64.1
   Subnet Mask . . . . . . . . . . . : 255.255.240.0
   IPv4 Address. . . . . . . . . . . : 192.168.50.88
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . :以上两个命令可以写在一个 powershell 脚本文件内，脚本内设置管理员权限执行，由于需要管理员权限所以无法通过建立 shortcut 放到开机自启动文件夹来自动启动址。wsl_ip.ps1 脚本内容如下，会自动请求管理员权限：if (-NOT ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] &quot;Administrator&quot;))  
{  
  $arguments = &quot;&amp; '&quot; +$myinvocation.mycommand.definition + &quot;'&quot;
  Start-Process powershell -Verb runAs -ArgumentList $arguments
  Break
}

wsl -d Ubuntu -u root ip addr add 192.168.50.16/24 broadcast 192.168.50.255 dev eth0 label eth0:1
netsh interface ip add address &quot;vEthernet (WSL)&quot; 192.168.50.88 255.255.255.0
为了方便使用，可以将脚本路径加入系统 PATH 中，这样可以方便的在终端直接运行脚本，PATH 设置参考：https://blog.niekun.net/archives/413.html完成后打开终端直接执行命令：wsl_ip 即可快速设置 IP。参考链接：https://github.com/MicrosoftDocs/WSL/issues/418#issuecomment-648570865</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1797.html">
<title>解决 proxifier 和 wsl 2 无法同时使用的问题</title>
<link>https://blog.niekun.net/archives/1797.html</link>
<dc:date>2020-10-12T15:18:00+08:00</dc:date>
<description>今天将 Windows 10 升级到了 build 2004 版，顺便将 wsl 升级到了 wsl 2，升级教程参考：https://blog.niekun.net/archives/1785.html。运行 wsl 2 时，发现如下报错：PS C:\Users\Marco Nie&gt; wsl
The attempted operation is not supported for the type of object referenced.无法正常使用 wsl，查询后得知是由于我正在使用的 proxifier 和 wsl 有了冲突，proxifier 是我一直使用的用来代理程序的应用。在 wsl 的 github 项目讨论中看到有人问了 proxifier 开发者，得到了解决方法，需要使用提供的程序来让 wsl 在运行时不要加载 LSP DLLs。下载 NoLsp.zip，解压得到 NoLsp.exe以管理员权限运行 terminal，执行 path\to\NoLsp.exe c:\windows\system32\wsl.exe看到终端显示 Succsess!，表示操作完成，然后 wsl 系统就可以正常打开使用同时不影响 proxifier。参考链接：https://github.com/microsoft/WSL/issues/4177</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1793.html">
<title>Windows 重建图标缓存</title>
<link>https://blog.niekun.net/archives/1793.html</link>
<dc:date>2020-10-12T11:10:00+08:00</dc:date>
<description>在使用 Windows 中有时候会发现某个程序或文件的图标显示不正常，一般是图标缓存的问题，重建一下即可。以 Windows 10 为例，图标缓存文件路径为：%LOCALAPPDATA%\Microsoft\Windows\Explorer文件夹内的 iconcache_*.db 就是图标缓存文件，删除这些文件然后重启 explorer 即可。下面介绍命令的方式处理，使用 power shell 终端：# 停止 explorer 进程
taskkill /f /im explorer.exe

# 删除缓存图标文件，ps 中使用 $Env:&lt;variable-name&gt; 表达环境变量
del &quot;$env:LOCALAPPDATA\Microsoft\Windows\Explorer\iconcache*.db&quot;

# 重启 explorer
start explorer完成后查看图标是否已经正常显示。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1788.html">
<title>Windows 常用终端命令</title>
<link>https://blog.niekun.net/archives/1788.html</link>
<dc:date>2020-10-12T09:30:00+08:00</dc:date>
<description>系统版本：winver
系统详细信息：systeminfo
当前用户名：whoami

本地网络：ipconfig
刷新 DNS 缓存：ipconfig /flushdns
路由信息：pathping
tracert
cmd 命令换行符：echo abc
等同于：
echo ^
abcpowershell 命令换行符：echo abc
等同于：
echo `
abc信息过滤：类似 Linux 的 grepfindstr
systeminfo | findstr &quot;System Type&quot;
查看命令的帮助：pathping /?
findstr /?
systeminfo /?
显示所有端口情况：netstat -ano
显示某个端口的占用情况 返回的数据中最后的数字为 PID 号：netstat -aon|findstr &quot;7200&quot;
根据 PID 号结束对应进程：taskkill /f /pid  7200
结束某个进程：taskkill /f /im explorer.exe
删除某个文件：del &quot;IconCache.db&quot;
启动某个程序：start explorer
</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1785.html">
<title>Windows 10 Linux 子系统 WSL 升级到 WSL 2</title>
<link>https://blog.niekun.net/archives/1785.html</link>
<dc:date>2020-10-12T09:24:00+08:00</dc:date>
<description>Windows 10 上的 wsl 可以方便的运行 Linux 环境，最近从 wsl 升级到了 wsl 2，看了下介绍主要区别是：increase file system performancesupport full system call compatibility增加了系统性能，更加完善的 Linux 系统环境。之前再 wsl 上无法使用的一些功能如 systemd 和网络 socket 提取的功能不知道是否可用了，下面就升级到 wsl 2 进行测试。关于 wsl 的介绍和安装可以参考我的教程：https://blog.niekun.net/archives/1148.html环境要求Requirements：For x64 systems: Version 1903 or higher, with Build 18362 or higher.For ARM64 systems: Version 2004 or higher, with Build 19041 or higher.Builds lower than 18362 do not support WSL 2. Use the Windows Update Assistant to update your version of Windows.可以使用命令查看当前系统版本，快捷键 win + R，输入 winver 弹出系统信息：命令行打开系统功能再我之前写的 wsl 安装教程里，介绍了从系统控制面板和命令行打开 Windows Subsystem for Linux 功能的方法，这里只介绍命令行方式。首先以管理员权限打开 powershell。如果之前没有安装 wsl 的话首先开启 Windows Subsystem for Linux：dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart
然后开启 Virtual Machine feature：dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart
完成以上两部后，重启系统。重启完成后安装 Linux 内核更新包：点击下载再次重启系统。设置 wsl 默认版本为 2：(管理员权限打开 powershell)wsl --set-default-version 2
设置默认版本后，以后安装的 Linux 子系统默认为 wsl 2 版本。也可以将之前安装的 Linux 子系统升级到 wsl 2：# 查看当前已安装的子系统
wsl -l -v

# 升级某个子系统到 wsl 2
wsl --set-version Ubuntu 2wsl 2 安装完成后就可以去 Windows 商店下载安装 Linux 发行版了：https://aka.ms/wslstore安装 Linux 发行版后的具体设置和之前 wsl 安装教程一样：https://blog.niekun.net/archives/1148.html参考链接https://docs.microsoft.com/en-us/windows/wsl/install-win10https://docs.microsoft.com/en-us/windows/wsl/compare-versions</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1782.html">
<title>powershell 脚本实现系统消息提醒</title>
<link>https://blog.niekun.net/archives/1782.html</link>
<dc:date>2020-09-30T11:52:07+08:00</dc:date>
<description>https://mcpmag.com/articles/2017/09/07/creating-a-balloon-tip-notification-using-powershell.aspx</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1781.html">
<title>echo 命令的使用</title>
<link>https://blog.niekun.net/archives/1781.html</link>
<dc:date>2020-09-30T09:23:00+08:00</dc:date>
<description>echo 是常用的终端命令，常用来输出字符串。配合命令的 option 选项可以实现多种输出方式。语法结构：echo [option(s)] [string(s)]
常规使用输出字符串：$ echo i have a dream
i have a dream输出变量：$ x=10
$ echo $x
10输出目录下所有文件名：$ echo *
Business Card Template - PiXimperfect.psd Telegram Desktop Video desktop.ini echo.txt test1.txt test2.txt输出特定名称的文件名：$ echo *.txt
echo.txt test1.txt test2.txt将字符串输出到文件：$ echo 'abc' &gt; test.txt
$ cat test.txt
abc使用 -e 选项识别字符串内的转义符 \\b 表示清除字符间空格$ echo -e 'a \bb \bc'
abc\n 表示换行$ echo -e 'a\nb\nc'
a
b
c\t 表示添加制表符$ echo -e 'a\tb\tc'
a       b       c可以结合 \n \t 使用：$ echo -e '\ta\n\tb\n\tc'
        a
        b
        c\v 表示添加垂直方向制表符$ echo -e 'a\vb\vc'
a
 b
  c\r 表示丢弃前面的字符串$ echo -e 'a\rbc'
bc\c 表示丢弃后面的字符串$ echo -e 'a\cbc'
aroot@localhost$以上就是 echo 命令的简单使用方法。</description>
</item>
</rdf:RDF>