<?xml version="1.0" encoding="UTF-8"?>
<rdf:RDF
xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
xmlns="http://purl.org/rss/1.0/"
xmlns:dc="http://purl.org/dc/elements/1.1/">
<channel rdf:about="https://blog.niekun.net/feed/rss/category/media/">
<title>Marco Nie - media process</title>
<link>https://blog.niekun.net/category/media/</link>
<description></description>
<items>
<rdf:Seq>
<rdf:li resource="https://blog.niekun.net/archives/2522.html"/>
<rdf:li resource="https://blog.niekun.net/archives/2502.html"/>
<rdf:li resource="https://blog.niekun.net/archives/2480.html"/>
<rdf:li resource="https://blog.niekun.net/archives/2472.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1752.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1720.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1690.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1677.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1653.html"/>
<rdf:li resource="https://blog.niekun.net/archives/1643.html"/>
</rdf:Seq>
</items>
</channel>
<item rdf:about="https://blog.niekun.net/archives/2522.html">
<title>给T恤添加图案 in Photoshop</title>
<link>https://blog.niekun.net/archives/2522.html</link>
<dc:date>2022-04-01T15:56:08+08:00</dc:date>
<description>图像中的衣服是一个立体空间，如果想要将一个二维图像添加到衣服表面需要进行一些处理。下面就介绍简单的过程。之前介绍过如果给一面旗帜添加文字信息可以参考：https://blog.niekun.net/archives/261.html用到的主要技术：扭曲工具、通道选区、multiply 混合、screen 混合、curve 曲线、quick selection tool原图如下：首先导入需要添加的图案：将图案转换为 smart object，按 ctrl 点击图层选取图案部分选取，然后在图案下面新建 hue saturation 图层将图案背后的衣服部分饱和度降低，避免以后影响图案部分颜色效果：复制 dragon 图层，然后屏蔽原始 dragon 图层作为备份，将复制的图层重命名为 multiply，混合模式改为 multiply：这个图层是用来处理暗部区域，由于我们只想衣服的暗部区域加载这个暗部图案，所以我们需要分离衣服暗部和亮部区域。之前的教程中，介绍了使用 sytle 中的 blend if 来过滤暗部亮部，达到预期效果：但是这个方法也有缺陷，第二个调整栏会将当前图层下面的所有图层作为整体对待，而不能单独选取某一个图层进行混合，如果我们需要连续建立了多个进行 blend if 混合的图形对最下面的某个图片进行混合，那么这些混合图层之间互相也会影响。下面介绍如果通过选区来独立处理暗部亮部区域。选中背景图层：进入通道菜单栏，选择一个对比大的通道，按住 ctrl 点击通道获取选区，这里选择 red 通道：这里的选区选区的就是图像的亮部区域。回到图层，选择 multiply 图层添加蒙版：由于选取部分是亮部区域，但是我们的 multiply 处理的是暗部区域，所以选中图层蒙版点击 ctrl I 反转蒙版即可：这样蒙版白色区域就表示暗部区域。为了获得选区更大的对比度，可以对蒙版进行曲线操作，点击</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/2502.html">
<title>PHP频率分离处理皮肤 in Photoshop</title>
<link>https://blog.niekun.net/archives/2502.html</link>
<dc:date>2022-03-31T14:23:00+08:00</dc:date>
<description>频率分离在处理人像或需要平滑表面的地方非常有效，在之前的教程中介绍过频率分离的方法，下面介绍在实际应用中，在频率分离后如何进行下一步处理。Photoshop 皮肤处理进阶通过频率分离修复褶皱衣服 in Photoshop频率分离 action：PiX - Frequency Separation.atnPHP 表示：patching修补，healing修复，polishing抛光关于频率分离的原理和过程请参考上面的链接，下面直接使用 action 快速完成。原图如下：在分离图像前，我们首先简单处理皮肤明显的痘痕等瑕疵部分，使用污点修复工具即可，新建一个图层，选择 healing brush tool：alt 选取痘痘周边皮肤，点击修复所有的痘痘，注意 sample 选择 current and below：我们通过 action 快速分离图像，我们图像是 8 bit 模式的所以使用 FS 8bit动作(image - mode 可以查看当前图片模式)：执行 action 过程中弹出手动设置高斯模糊值，先拉到最小，然后一点点调大直到皮肤细节消失：action 会自动创建好分离图像图层：下面进行 PHP 第一步 patching，将皮肤上大块的色差区域修复，使用了 patch tool。首先关闭上面的 texture 图层，然后复制 color 图层命名为 patching：使用 patch tool 将皮肤上有明显下次和色差的部分修复：处理完成后打开 texture 图层查看效果：然后第二部 healing，也就是通过 heal tool 修复一些小瑕疵部分，复制 patching 图层，使用 heal tool 进行下一步修复，同样的需要临时关闭 texture 图层。例如我们通过 heal tool 修复额头多余的头发和面部细微部分的色差区域：处理完成后打开 texture 图层查看效果：第三步 polishing，也就是对皮肤高光阴影的平滑处理，让整体光线过渡更加均匀，复制 healing 图层重命名为 polishing，同样的暂时关闭 texture 图层。这里使用笔刷工具，流量调到 2 左右即可：我们先处理嘴唇的阴影部分，按住 alt 点击阴影部分选取颜色，然后在需要过渡的地方进行涂抹：然后鼻子上的亮度分布我们使用同样的方法进行调整，让光线更加平顺：根据情况调整其他地方的光线，完成后打开 texture 图层查看效果：最终效果对比如下：</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/2480.html">
<title>通过频率分离修复褶皱衣服 in Photoshop</title>
<link>https://blog.niekun.net/archives/2480.html</link>
<dc:date>2022-03-29T17:07:00+08:00</dc:date>
<description>之前介绍过通过高低频率分离可以处理皮肤柔化，它可以方便的单独处理颜色和反差部分。下面介绍通过高低频分离将褶皱的衣服平顺化，同时保持其原有的真实过渡部分。用到的技术主要有：高斯模糊、apply image、linear light、mixer brush tool、patch tool原图如下，可以看到衣服褶皱很明显：首先复制两个图层，分别命名为 color 和 texture：先临时关闭 texture 图层，将 color 图层执行高斯模糊：根据实际情况，调节滑块将主体的布料细节等杂乱色彩柔化，最终基本看不出明显细节：然后打开 texture 图层，执行 image - apply image。layer 选择 下方的 color 图层，混合模式选择 subtract，scale 选择 2，offset 设置为 128，上面设置的意思就是将 texture 图层每个像素都减去下方的 color 图层，将结果减为 0 的部分填充为 50度灰色，scale 影响轮廓范围：然后将 texture 混合模式改为 linear light，我们会发现现在显示的图像和原图是一样的：以上我们就将原图拆解为 color 和 texture 两部分，可以对其进行分别调整。下面我们开始处理褶皱问题，关闭 texture 图层，然后使用 mixer brush tool 将 color 图层颜色分布均匀化处理，这个笔刷可以选取周围图片某个地方的像素，然后在其他地方可以涂抹出相似的颜色。由于需要使用色彩选取功能，首先我们确保选取颜色的时候是 33 或 55 范围而不是单个像素。点击色彩选取工具，将上面的设置为合适数据：然后点击 mixer brush tool，在上面的默认数据基础上将流量调到30左右，将平滑处理降到0：然后使用柔边笔刷，选择一个有褶皱的区域，点击 alt 选取周边一个颜色，开始涂抹需要处理的区域，处理过程中注意不同区域需要尽量选取其周边颜色进行涂抹，这样过度更加自然。涂抹过程中可以打开背景图层观察效果：涂抹完成后打开 texture 查看效果：可以看到很明显的效果，大部分的褶皱都没有了，但是还是可以看到一些线条：但是在 color 图层却不明显，这些线条就是存在于 texture 图层的高频部分，需要在 texture 图层处理它们。使用的方法就是通过污点修复工具将这些线条去掉，选中 texture 图层，这里我使用 patch tool：选取一个需要去除的线条，拖拽到其他完好区域，查看效果：同样的步骤处理其他所有区域，最终效果如下：以上就完成了折痕的处理。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/2472.html">
<title>彩图转黑白 in Photoshop</title>
<link>https://blog.niekun.net/archives/2472.html</link>
<dc:date>2022-03-28T14:04:00+08:00</dc:date>
<description>黑白图片在某些场景下有其独特的风格，在人像摄影中可以体现出一种另类的雕塑感，下面通过实例介绍如何从一个彩色图片处理为一张黑白效果。使用的工具主要是 gradient map 和 camera raw。下面是原始图片：首先在原图上方建立 gradient map 图层，gradient map 的作用是根据图像的亮度分布进行颜色替换：首先将下方的 method 改为 classic，这样过渡效果更加平顺一些：默认是一个反色效果渐变，点击渐变条，修改其属性为左边黑色右边白色：下面我们增加黑白色差效果，调节左侧下方滑块可以使得黑色区域更黑，调节右侧下方滑块可以使得白色区域更白，调节中间滑块可以调节黑白区域范围：调节到合适效果后确认即可，这样我们初步就有了一个效果。下面为了让背景更加黑，我们通过选取提取出背景，创建一个纯黑背景。选中图像图层，选区工具下选中 select and mask：点击 select subject 可以自动选中主体：点击 color aware 和 shift edge 调节选区边沿：确认后可以获取到主体的选取，创建一个 solid color 黑色图层，选中蒙版，ctrl I 反转选区即可：放大我们可以发现主体边沿和背景没有完美的融合，这时可以通过复制刚才的 gradient map 图层强化黑白效果，然后通过笔刷工具将复制的图层只保留主体边沿部分，注意使用笔刷的时候不透明度调节稍微低一些：基本效果已经可以了，下面调节细节部分，首先眼睛需要提亮，新建 curves 图层，提亮曲线后反转蒙版，使用笔刷工具涂抹出眼睛的亮度：黑白图片效果一般在提高锐度的时候会更加具有特点，下面我们通过 camera raw 来做调整。首先快捷键 ctrl shift alt E 盖印图层，然后转换为 smart object 方便后期返回来调整参数：然后点击 filter - camera raw filter 进入编辑模式。为了更加强烈的反差，我首先调节了亮度参数：然后就是锐化的重点 - 提高 clarity 清晰度参数，注意不要调的过高而失真：完成后保存返回 Photoshop，适当调节不透明度使图片更加自然：最终效果如下：</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1752.html">
<title>FFmpeg 简单用法</title>
<link>https://blog.niekun.net/archives/1752.html</link>
<dc:date>2020-09-18T15:03:12+08:00</dc:date>
<description>FFmpeg 是视频处理最常用的开源软件。它功能强大，用途广泛，大量用于视频网站和商业软件（比如 Youtube 和 iTunes），也是许多音频和视频格式的标准编码/解码实现。官方网站：https://www.ffmpeg.org/安装最简单的方法就是用包管理工具如：apt 安装：apt update
apt install ffmpeg
或者也可以从源码安装，可以参考我之前的教程：https://blog.niekun.net/archives/891.html常用指令查看 ffmpeg 版本：ffmpeg -version
查看支持的编码格式：如 h.264, h.265ffmpeg -codecs
查看支持的容器：如 mp4, mp3, mkvffmpeg -formats
查看已安装的编码器：如 libx264, libx265, libvpx, aacffmpeg -encoders
使用格式FFmpeg 的命令行参数非常多，可以分成五个部分。ffmpeg {1} {2} -i {3} {4} {5}
上面命令中，五个部分的参数依次如下：全局参数
输入文件参数
输入文件
输出文件参数
输出文件参数太多的时候，为了便于查看，ffmpeg 命令可以写成多行:$ ffmpeg \
[全局参数] \
[输入文件参数] \
-i [输入文件] \
[输出文件参数] \
[输出文件]下面是一个例子:ffmpeg \
-y \ # 全局参数
-c:a libfdk_aac -c:v libx264 \ # 输入文件参数
-i input.mp4 \ # 输入文件
-c:v libvpx-vp9 -c:a libvorbis \ # 输出文件参数
output.webm # 输出文件上面的命令将 mp4 文件转成 webm 文件，这两个都是容器格式。输入的 mp4 文件的音频编码格式是 aac，视频编码格式是 H.264；输出的 webm 文件的视频编码格式是 VP9，音频格式是 Vorbis。如果不指明编码格式，FFmpeg 会自己判断输入文件的编码。一般可以省略输入文件参数。常用命令参数-c：指定编码器
-c copy：直接复制，不经过重新编码（这样比较快）
-c:v：指定视频编码器
-c:a：指定音频编码器
-i：指定输入文件
-an：去除音频流
-vn： 去除视频流
-preset：指定输出的视频质量，会影响文件的生成速度，有以下几个可用的值 ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow。
-y：不经过确认，输出时直接覆盖同名文件。常规使用方法查看元数据信息，如时长，比特率等：ffmpeg -i test.mp4
输出的信息较多，可以通过 -hide_banner 只显示媒体文件信息：ffmpeg -i test.mp4 -hide_banner
转码，如 avi to h.264:ffmpeg -i test.avi -c:v libx264 test.mp4
转换容器：ffmpeg -i test.mp4 -c copy test.webm转换容器不需要转码，所以直接 copy 即可。转换码率，转换成固定码率：ffmpeg -i test.mp4 -b:v 500k test_out.mp4
转换码率，转换成一个码率范围：ffmpeg -i test.mp4 -minrate 964K -maxrate 3856K -bufsize 2000K test_out.mp4
改变分辨率：转换成 480pffmpeg \
-i input.mp4 \
-vf scale=480:-1 \
output.mp4视频中提取音频：ffmpeg \
-i input.mp4 \
-vn -c:a copy \
output.aac上面例子中，-vn 表示去掉视频，-c:a copy 表示不改变音频编码，直接拷贝。视频截图：下面的例子是从指定时间开始，连续对1秒钟的视频进行截图ffmpeg \
-y \
-i input.mp4 \
-ss 00:01:24 -t 00:00:01 \
output_%3d.jpg%3d 在 shell 里表示至少输出3个字符空间的数字：% means &quot;Print a variable here&quot;
3 means &quot;use at least 3 spaces to display, padding as needed&quot;
d means &quot;The variable will be an integer&quot;如果只需要截一张图，可以指定只截取一帧。$ ffmpeg \
-ss 01:23:45 \
-i input \
-vframes 1 -q:v 2 \
output.jpg上面例子中，-vframes 1 指定只截取一帧，-q:v 2 表示输出的图片质量，一般是1到5之间（1 为质量最高）。裁剪:裁剪（cutting）指的是，截取原始视频里面的一个片段，输出为一个新视频。可以指定开始时间（start）和持续时间（duration），也可以指定结束时间（end）。$ ffmpeg -ss [start] -i [input] -t [duration] -c copy [output]
$ ffmpeg -ss [start] -i [input] -to [end] -c copy [output]下面是实际的例子。# 从1分50秒开始截取10.5秒
ffmpeg -ss 00:01:50 -i test.mp4 -t 10.5 -c copy out.mp4

# 从25秒开始截取10秒
ffmpeg -ss 25 -i test.mp4 -to 10 -c copy out.mp4
ffmpeg -i test.mp4 -ss 25 -to 10 -c copy out.mp4上面例子中，-c copy 表示不改变音频和视频的编码格式，直接拷贝，这样会快很多。高级用法压缩视频内容到指定容量大小使用的技术主要是 ffmpeg 的 2 pass 方法和 ffprobe 得到码率和时长信息。bash脚本：#!/bin/bash

target_video_size_MB=&quot;$2&quot;
origin_duration_s=$(ffprobe -v error -show_streams -select_streams a &quot;$1&quot; | grep -Po &quot;(?&lt;=^duration\=)\d*\.\d*&quot;)
origin_audio_bitrate_kbit_s=$(ffprobe -v error -pretty -show_streams -select_streams a &quot;$1&quot; | grep -Po &quot;(?&lt;=^bit_rate\=)\d*\.\d*&quot;)
target_audio_bitrate_kbit_s=$origin_audio_bitrate_kbit_s # TODO for now, make audio bitrate the same
target_video_bitrate_kbit_s=$(\
    awk \
    -v size=&quot;$target_video_size_MB&quot; \
    -v duration=&quot;$origin_duration_s&quot; \
    -v audio_rate=&quot;$target_audio_bitrate_kbit_s&quot; \
    'BEGIN { print  ( ( size * 8192.0 ) / ( 1.048576 * duration ) - audio_rate ) }')

ffmpeg \
    -y \
    -i &quot;$1&quot; \
    -c:v libx264 \
    -b:v &quot;$target_video_bitrate_kbit_s&quot;k \
    -pass 1 \
    -an \
    -f mp4 \
    /dev/null \
&amp;&amp; \
ffmpeg \
    -i &quot;$1&quot; \
    -c:v libx264 \
    -b:v &quot;$target_video_bitrate_kbit_s&quot;k \
    -pass 2 \
    -c:a aac \
    -b:a &quot;$target_audio_bitrate_kbit_s&quot;k \
    &quot;${1%.*}-$2mB.mp4&quot;使用方法：压缩视频到 50 MB 大小./script.sh test.mp4 50
切割视频到指定时长的多个视频使用的技术主要是 python，ffprobe 得到视频时长，然后计算需要切割为几个视频。python 脚本：#!/usr/bin/env python

import csv
import subprocess
import math
import json
import os
import shlex
from optparse import OptionParser


def split_by_manifest(filename, manifest, vcodec=&quot;copy&quot;, acodec=&quot;copy&quot;,
                      extra=&quot;&quot;, **kwargs):

    if not os.path.exists(manifest):
        print(&quot;File does not exist: %s&quot; % manifest)
        raise SystemExit

    with open(manifest) as manifest_file:
        manifest_type = manifest.split(&quot;.&quot;)[-1]
        if manifest_type == &quot;json&quot;:
            config = json.load(manifest_file)
        elif manifest_type == &quot;csv&quot;:
            config = csv.DictReader(manifest_file)
        else:
            print(&quot;Format not supported. File must be a csv or json file&quot;)
            raise SystemExit

        split_cmd = [&quot;ffmpeg&quot;, &quot;-i&quot;, filename, &quot;-vcodec&quot;, vcodec,
                     &quot;-acodec&quot;, acodec, &quot;-y&quot;] + shlex.split(extra)
        try:
            fileext = filename.split(&quot;.&quot;)[-1]
        except IndexError as e:
            raise IndexError(&quot;No . in filename. Error: &quot; + str(e))
        for video_config in config:
            split_str = &quot;&quot;
            split_args = []
            try:
                split_start = video_config[&quot;start_time&quot;]
                split_length = video_config.get(&quot;end_time&quot;, None)
                if not split_length:
                    split_length = video_config[&quot;length&quot;]
                filebase = video_config[&quot;rename_to&quot;]
                if fileext in filebase:
                    filebase = &quot;.&quot;.join(filebase.split(&quot;.&quot;)[:-1])

                split_args += [&quot;-ss&quot;, str(split_start), &quot;-t&quot;,
                               str(split_length), filebase + &quot;.&quot; + fileext]
                print(&quot;########################################################&quot;)
                print(&quot;About to run: &quot;+&quot; &quot;.join(split_cmd+split_args))
                print(&quot;########################################################&quot;)
                subprocess.check_output(split_cmd+split_args)
            except KeyError as e:
                print(&quot;############# Incorrect format ##############&quot;)
                if manifest_type == &quot;json&quot;:
                    print(&quot;The format of each json array should be:&quot;)
                    print(&quot;{start_time: &lt;int&gt;, length: &lt;int&gt;, rename_to: &lt;string&gt;}&quot;)
                elif manifest_type == &quot;csv&quot;:
                    print(&quot;start_time,length,rename_to should be the first line &quot;)
                    print(&quot;in the csv file.&quot;)
                print(&quot;#############################################&quot;)
                print(e)
                raise SystemExit


def get_video_length(filename):

    output = subprocess.check_output((&quot;ffprobe&quot;, &quot;-v&quot;, &quot;error&quot;, &quot;-show_entries&quot;,
                                      &quot;format=duration&quot;, &quot;-of&quot;, &quot;default=noprint_wrappers=1:nokey=1&quot;, filename)).strip()
    video_length = int(float(output))
    print(&quot;Video length in seconds: &quot;+str(video_length))

    return video_length


def ceildiv(a, b):
    return int(math.ceil(a / float(b)))


def split_by_seconds(filename, split_length, vcodec=&quot;copy&quot;, acodec=&quot;copy&quot;,
                     extra=&quot;&quot;, video_length=None, **kwargs):
    if split_length and split_length &lt;= 0:
        print(&quot;Split length can't be 0&quot;)
        raise SystemExit

    if not video_length:
        video_length = get_video_length(filename)
    split_count = ceildiv(video_length, split_length)
    if(split_count == 1):
        print(&quot;Video length is less then the target split length.&quot;)
        raise SystemExit

    split_cmd = [&quot;ffmpeg&quot;, &quot;-i&quot;, filename, &quot;-vcodec&quot;,
                 vcodec, &quot;-acodec&quot;, acodec] + shlex.split(extra)
    try:
        filebase = &quot;.&quot;.join(filename.split(&quot;.&quot;)[:-1])
        fileext = filename.split(&quot;.&quot;)[-1]
    except IndexError as e:
        raise IndexError(&quot;No . in filename. Error: &quot; + str(e))
    for n in range(0, split_count):
        split_args = []
        if n == 0:
            split_start = 0
        else:
            split_start = split_length * n

        split_args += [&quot;-ss&quot;, str(split_start), &quot;-t&quot;, str(split_length),
                       filebase + &quot;-&quot; + str(n+1) + &quot;-of-&quot; +
                       str(split_count) + &quot;.&quot; + fileext]
        print(&quot;About to run: &quot;+&quot; &quot;.join(split_cmd+split_args))
        subprocess.check_output(split_cmd+split_args)


def main():
    parser = OptionParser()

    parser.add_option(&quot;-f&quot;, &quot;--file&quot;,
                      dest=&quot;filename&quot;,
                      help=&quot;File to split, for example sample.avi&quot;,
                      type=&quot;string&quot;,
                      action=&quot;store&quot;
                      )
    parser.add_option(&quot;-s&quot;, &quot;--split-size&quot;,
                      dest=&quot;split_length&quot;,
                      help=&quot;Split or chunk size in seconds, for example 10&quot;,
                      type=&quot;int&quot;,
                      action=&quot;store&quot;
                      )
    parser.add_option(&quot;-c&quot;, &quot;--split-chunks&quot;,
                      dest=&quot;split_chunks&quot;,
                      help=&quot;Number of chunks to split to&quot;,
                      type=&quot;int&quot;,
                      action=&quot;store&quot;
                      )
    parser.add_option(&quot;-S&quot;, &quot;--split-filesize&quot;,
                      dest=&quot;split_filesize&quot;,
                      help=&quot;Split or chunk size in bytes (approximate)&quot;,
                      type=&quot;int&quot;,
                      action=&quot;store&quot;
                      )
    parser.add_option(&quot;--filesize-factor&quot;,
                      dest=&quot;filesize_factor&quot;,
                      help=&quot;with --split-filesize, use this factor in time to&quot;
                      &quot; size heuristics [default: %default]&quot;,
                      type=&quot;float&quot;,
                      action=&quot;store&quot;,
                      default=0.95
                      )
    parser.add_option(&quot;--chunk-strategy&quot;,
                      dest=&quot;chunk_strategy&quot;,
                      help=&quot;with --split-filesize, allocate chunks according to&quot;
                      &quot; given strategy (eager or even)&quot;,
                      type=&quot;choice&quot;,
                      action=&quot;store&quot;,
                      choices=['eager', 'even'],
                      default='eager'
                      )
    parser.add_option(&quot;-m&quot;, &quot;--manifest&quot;,
                      dest=&quot;manifest&quot;,
                      help=&quot;Split video based on a json manifest file. &quot;,
                      type=&quot;string&quot;,
                      action=&quot;store&quot;
                      )
    parser.add_option(&quot;-v&quot;, &quot;--vcodec&quot;,
                      dest=&quot;vcodec&quot;,
                      help=&quot;Video codec to use. &quot;,
                      type=&quot;string&quot;,
                      default=&quot;copy&quot;,
                      action=&quot;store&quot;
                      )
    parser.add_option(&quot;-a&quot;, &quot;--acodec&quot;,
                      dest=&quot;acodec&quot;,
                      help=&quot;Audio codec to use. &quot;,
                      type=&quot;string&quot;,
                      default=&quot;copy&quot;,
                      action=&quot;store&quot;
                      )
    parser.add_option(&quot;-e&quot;, &quot;--extra&quot;,
                      dest=&quot;extra&quot;,
                      help=&quot;Extra options for ffmpeg, e.g. '-e -threads 8'. &quot;,
                      type=&quot;string&quot;,
                      default=&quot;&quot;,
                      action=&quot;store&quot;
                      )
    (options, args) = parser.parse_args()

    def bailout():
        parser.print_help()
        raise SystemExit

    if not options.filename:
        bailout()

    if options.manifest:
        split_by_manifest(**(options.__dict__))
    else:
        video_length = None
        if not options.split_length:
            video_length = get_video_length(options.filename)
            file_size = os.stat(options.filename).st_size
            split_filesize = None
            if options.split_filesize:
                split_filesize = int(
                    options.split_filesize * options.filesize_factor)
            if split_filesize and options.chunk_strategy == 'even':
                options.split_chunks = ceildiv(file_size, split_filesize)
            if options.split_chunks:
                options.split_length = ceildiv(
                    video_length, options.split_chunks)
            if not options.split_length and split_filesize:
                options.split_length = int(
                    split_filesize / float(file_size) * video_length)
        if not options.split_length:
            bailout()
        split_by_seconds(video_length=video_length, **(options.__dict__))


if __name__ == '__main__':
    main()使用方法：将视频切割为单个视频100秒./split.py -f test.mp4 -s 100
ffprobe 使用ffprobe 可以用来得到视频信息。视频时长：秒ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 input.mp4
视频码率：bitffprobe -v error -show_entries format=bit_rate -of default=noprint_wrappers=1:nokey=1 input.mp4
参考链接http://www.ruanyifeng.com/blog/2020/01/ffmpeg.htmlhttps://stackoverflow.com/questions/29082422/ffmpeg-video-compression-specific-file-sizehttps://github.com/c0decracker/video-splitterhttps://trac.ffmpeg.org/wiki/FFprobeTips</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1720.html">
<title>自由填充 Pattern in Photoshop</title>
<link>https://blog.niekun.net/archives/1720.html</link>
<dc:date>2020-08-18T12:09:00+08:00</dc:date>
<description>对于单个 pattern 模型，如果想要在 layer 内以随机的角度或大小填充来实现更加自然的效果可以使用 script 脚本方便的实现。我们从如何定一个 pattern 开始，下面是一张 1 美元图片：使用 object selection tool 快速将主体选出来：选区边沿如果有多余的或者缺失的部分，通过 按住 shift 和 alt 键来增加/减去选区：点击添加图层蒙版，边沿如果需要调整，可以使用画笔工具来进一步修整蒙版。如果蒙版边沿有锯齿，可以双击蒙版打开属性框，调整 smooth 和 contract 来优化蒙版：使用选区工具框出一个矩形框包含我们的主体：选择 edit - define pattern：定义一个名称，点击 ok：新建图层，快捷键 shift backspace/shift delete 调出填充框：content 选择 pattern：custom pattern 里选中我们刚才新建的模型：script 前打勾，然后右侧菜单里选择 random fill：点击 ok 后进入调整菜单，首先将 下面的 color randomness 设为 0 避免图形的染色改变，brightness randomness 设置为 0.02 左右使亮度轻微可以随机改变，形成层次感：将 density 设置为最大 10，将 minimum/maximum scale factor 设置为 1，这样 pattern 会以 1:1 比例显示：将 rotate pattern 打勾，这样模型会随机旋转：设置完成后点击 ok，可以看到效果：还可以做一些优化来使层叠效果更加真实，过程就是降低 density 和 scale，添加图层阴影效果。新建图层，使用上面的方法填充 pattern，在设置中将 density 设置为 9，scale 设置为 0.25：确认后可以看到效果，单个图形变小，填充密度变小：我们给图层添加阴影效果，双击图层打开 layer style，下方点击添加阴影：再次新建图层，使用上面图层的填充设置填充 pattern，可以将空缺的部分进一步补充完整：按住 alt 键拖拽刚才的阴影特效到新图层，可以快速复制效果：可以看到还是有空白的区域没有填充完整，继续重复上面的步骤，建立多个图层，直到完全充满整个区域为止，最终效果如下：以上就是使用 script 来实现 pattern 自由填充的过程。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1690.html">
<title>眼睛进阶处理 in Photoshop</title>
<link>https://blog.niekun.net/archives/1690.html</link>
<dc:date>2020-08-14T11:16:27+08:00</dc:date>
<description>在人像照片中，一双炯炯有神的眼睛会让照片整体突出，下面我们来尝试通过提升亮度，增加细节等过程来实现。下图是我们的原图：放大眼睛细节：原图已经很好了，很清晰。下面我们进行调整。强化亮部细节需要提亮的部分是光源点的对面，再此图中就是眼睛光斑的下方，新建图层，画笔工具画圆：擦除多余部分，笔刷选择软笔刷，可以先降低不透明度来看到背景：高斯模糊使过度自然：混合模式改为 overlay 实现提亮：blend option 去掉影响阴影部分：如果想要加强效果可以再次复制图层，调整不透明度。增加高光点新建曲线图层，拉高曲线：ctrl I 反转图层蒙版，白色画笔工具软笔刷在瞳孔下方点击一下：可以看到效果太强了，调低不透明度到合适：增加明暗细节新建曲线图层，提高曲线，反转图层蒙版：白色画笔工具使用软笔刷沿着瞳孔在亮部区域画出射线，这一步注意如果有数位板来画的话会更好：降低不透明度到合适：下面增加暗部细节，再次新建曲线，然后降低曲线，反转蒙版：同样的方法画出射线：降低不透明度：眼白清理首先清理红血丝，新建图层，选择修复画笔工具混合模式设置为 screen，这样可以只处理暗部血丝：按 alt 键采样眼白，涂抹血丝区域：然后进行 dogding and burning 明暗调节，首先建立 soild color 观察图层，混合模式改为 color 来只显示亮度情况：新建图层，混合模式改为 soft light，选择笔刷工具软笔刷流量改为 1，快捷键 D 恢复颜色为黑/白，根据实际用白色笔刷涂抹暗部，黑色笔刷涂抹过亮部分：然后修复亮度调整后的颜色变化，新建图层，混合模式改为 color，快捷键 I 拾取眼白正常部分的颜色，然后在新图层上涂抹出需要修复的区域：复制效果将亮部细节处理/高光点/明暗细节处理部分建立分组然后复制一份，安住 ctrl 拖动分组到另一只眼睛部分，可以配合蒙版清理多余部分：可以使用同样的方法清理另一只眼睛的眼白部分最终效果如下：</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1677.html">
<title>cinema 4D 快捷键</title>
<link>https://blog.niekun.net/archives/1677.html</link>
<dc:date>2020-07-20T09:03:00+08:00</dc:date>
<description>1视角移动2视野放大/缩小3视角旋转  Eobject 移动Robject 旋转Tobject 放大/缩小  object 编辑 U线段功能菜单U + L选择闭合曲线U + U取消区域曲线选择M块功能菜单M + T块生成工具  Q隐藏 subdivision surface  alt + R区域渲染  </description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1653.html">
<title>快速给黑白照上色 in Photoshop</title>
<link>https://blog.niekun.net/archives/1653.html</link>
<dc:date>2020-07-14T14:37:09+08:00</dc:date>
<description>如果你需要给黑白照片添加颜色，这个教程可以帮助你快速完成。它通过把照片上传到一个免费的网站来自动给照片上色，然后再 Photoshop 中对自动处理不完美的地方进行精细调整最终得到满意的效果。免费上色网站地址为：https://imagecolorizer.com/我们首先测试人像：将图片上传到网站，等待自动处理完成后下载到本地：自动处理结果如下，可以看到基本比较完善，但是细节处有一些偏色，色条和漏掉颜色的地方：下面我们进入 Photoshop 进行处理，将原图和处理后的图片导入，将处理后的图层模式设置为 color，我们只用处理后的色彩信息：首先处理皮肤表面的不规则色条，选择 filter - blur - furface blur，放大可以看到表面的色条：调整 radius 和 threshold 使表面颜色平滑：然后我们处理脖子部分的颜色丢失：新建图层，混合模式改为 color，拾取附近色彩正常区域的颜色，快捷键 I：使用画笔工具涂抹需要重新上色的区域：面部饱和度过高，新建 hue 图层降低面部饱和度，配合蒙版操作：最终效果如下：</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/1643.html">
<title>使用 graduated filter 处理特定颜色的区域 in lightroom</title>
<link>https://blog.niekun.net/archives/1643.html</link>
<dc:date>2020-07-13T16:55:31+08:00</dc:date>
<description>在 lightroom 中想要改变一个颜色的色相，最简单的方法就是在 hue panel 来处理：通过移动某个颜色的滑块来改变这一颜色的色相，或者点击左上方的按钮，然后在图片中拖动来直接修改当前区域的色相。同理也可以修改饱和度和亮度。这里介绍另一种通过 graduated filter 工具来处理，控制自由度更大，可以设定颜色影响的范围，也可以调节修改部分的亮度清晰度等信息。develop 里，最上方找到方形的工具就是 graduated filter：它可以用直线将图片分割成两部分，一侧为保护区域一侧为修改区域，中间为过度区域。常用来单独处理天空和地面的亮度等。快捷键 O 查看修改区域的范围，红色部分为影响区域：这里我们实验修改下方树木的颜色。在下方找到 range mask，切换到 color，这就代表在当前选区下再次匹配特定颜色缩小范围：点击左侧吸管，在图片内找到树木区域通过点击或者拖拽来选取颜色：拾取颜色后调节 amount 来控制选区范围，如果看不到选区范围，按快捷键 O：选区范围完成后，按 O 取消选区显示，调节上方 hue 滑块修改颜色，点击下方的 use fine adjustment 可以精细调节色相：和其他 filter 一样，可以调节白平衡，亮度，对比度等各种参数来精细控制区域的效果：以上就是通过使用 graduated filter 处理特定颜色的区域的过程。</description>
</item>
</rdf:RDF>