<?xml version="1.0" encoding="UTF-8"?>
<rdf:RDF
xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
xmlns="http://purl.org/rss/1.0/"
xmlns:dc="http://purl.org/dc/elements/1.1/">
<channel rdf:about="https://blog.niekun.net/feed/rss/category/other/">
<title>Marco Nie - other</title>
<link>https://blog.niekun.net/category/other/</link>
<description>杂文</description>
<items>
<rdf:Seq>
<rdf:li resource="https://blog.niekun.net/archives/nftables.html"/>
<rdf:li resource="https://blog.niekun.net/archives/intel-12-CPU-vmwre.html"/>
<rdf:li resource="https://blog.niekun.net/archives/openwrt-1.html"/>
<rdf:li resource="https://blog.niekun.net/archives/Linux.html"/>
<rdf:li resource="https://blog.niekun.net/archives/Linux-ip.html"/>
<rdf:li resource="https://blog.niekun.net/archives/codesys-enum.html"/>
<rdf:li resource="https://blog.niekun.net/archives/codesys.html"/>
<rdf:li resource="https://blog.niekun.net/archives/immich.html"/>
<rdf:li resource="https://blog.niekun.net/archives/Ubuntu-20-04-ppa.html"/>
<rdf:li resource="https://blog.niekun.net/archives/WSA-Windows-Subsystem-for-Android.html"/>
</rdf:Seq>
</items>
</channel>
<item rdf:about="https://blog.niekun.net/archives/nftables.html">
<title>nftables 使用教程</title>
<link>https://blog.niekun.net/archives/nftables.html</link>
<dc:date>2024-05-08T10:14:00+08:00</dc:date>
<description>新版本的 openwrt 使用 fw4 防火墙，默认已经从 iptables 切换到了 nftables，语法有了很大的变化，下面介绍 nftables 的使用方法。路由表配置路由表是 nftables 中最顶层的容器，它管理着  chains, sets, maps, flowtables, 和 stateful objects.family 集合每个路由表都只能属于一个 family 集合，可用的 family 有：ip      监听 ipv4 的流量ip6     监听 ipv6 的流量inet    同时监听 ipv4 和 ipv6 的流量arp     监听 ARP-level 地址解析协议的流量bridge  监听 bridge 桥接流量 如交换机netdev  用于监听某个单独网卡的流量基本语法新建路由表：nft add table ip tabletest
以上命令在 ip 集合中新建一个名称为 tabletest 的路由表，可以处理 ipv4 流量路由表列表：# 列出所有路由表
nft list tables

# 列出所有 ip 集合的路由表
nft list tables ip删除一个路由表：nft delete table ip tabletest
路由链配置不同于 iptables，nftables 没有预定义的链，如 input output 等。想要在某个环节处理流量，需要定义一个自定义名称的基本链，然后将其挂载在一个特定的 netfilter hook 钩子上。下图是流量包在 linux 网络中的传输路径：外部访问流量传输到本机后如果目标地址是本机，流量传输路径是 prerouting -&gt; input hooks -&gt; 本机，然后经过本机处理后流向  本机 -&gt; output -&gt; postrouting hooks。如果传入本机的外部流量目标地址不是本机，则受 forward hook 监听，这类流量的传输路径是 prerouting -&gt; forward -&gt; postrouting。本机访问外部地址的流量传输路径是 本机 -&gt; output -&gt; postrouting hooks。注意如果本机作为 router 路由使用，需要提前开启 ip 转发功能：echo 1 &gt; /proc/sys/net/ipv4/ip_forward
以下是 netfilter 可用的 chains 和 hooks 列表：基本语法建立基本链，挂载在一个特定 type 的 netfilter hook：nft add chain [&lt;family&gt;] &lt;table_name&gt; &lt;chain_name&gt; { type &lt;type&gt; hook &lt;hook&gt; priority &lt;value&gt; \; [policy &lt;policy&gt; \;] [comment \&quot;text comment\&quot; \;] }
注意，由于 nft 语法使用了特殊字符，如: ;，在命令行中执行需要加转义符 \。或者可以使用单引号 '` 将 nft 后的语句包起来，以下两种写法效果相同：nft add chain ip tabletest input { type filter hook input priority 0 \; }
nft 'add chain ip tabletest input { type filter hook input priority 0 ; }'
另一种方法是运行 nft 在交互模式，执行以下命令后就可以不加转义符: nft -i。上面的命令在 tebletest 路由表中新建一个 input 链，挂载在 filter 路由链的 input hook 上。这样就可以监听所有进入本地的流量。priority 决定了所有链的顺序，例如在 filter input hook 上挂载了多个自定义链，通过 priority 决定其执行顺序。数值越低执行优先级越高，例如 -12, -1, 0, 10。如果给多个挂载在同一个 hook 上的自定义基本链同样的 priority，它们的先后执行顺序就是不确定的。添加以下命令后就可以在 tabletest 基本链中监听本机输出的流量：nft 'add chain ip tabletest output { type filter hook output priority 0 ; }'
如果不定义大括号中的内容，也就是不挂载在特定 hook 上，则路由链不会监听任何流量。policy 定义了默认的策略，可用的默认策略为：accept 和 drop，如果路由链中的规则都没有匹配则会应用默认策略：accept 没有匹配到的流量继续在网络层传输drop   没有匹配到的流量被丢弃type 指定自定义路由链挂载到那个基本 chain，可用的基本链：filter, 用于过滤流量包route, 用于重路由，等同于 iptables 的 mangle 路由链的 output hook (其他 mangle hooks 可以使用 filter 代替)nat, 用于运行 Networking Address Translation (NAT). 只有第一个 nat 流量包会匹配到此链剩余的包会跳过此链，因此尽量不要使用此链过滤流量hook 定义了挂载的基本链 hook，可用的 hooks 如下：ingress 只能用于 netdev 和 inet family: 监听来自于 NIC driver 的流量, 早于 prerouting.prerouting: 监听所有在 routing 前的入口流量. 流量可能重定向到 local 或 remote systems.input: 监听所有被路由或重定向到 local system 的入口流量forward: 监听所有不被重定向到 local system 的入口流量output: 监听所有在 local machine 被管理的出口流量postrouting: 监听所有被路由后的即将离开 local system 的出口流量列出一个路由表的所有路由链：nft list ip table tabletest
列出一个路由表的指定路由链：nft list chain ip tabletest output
comment 可以给规则添加注释：nft add rule ip tabletest input counter comment \&quot;test comment\&quot;
基本规则配置通过规则可以控制路由链上的流量。基本语法添加规则：nft add rule ip tabletest output ip daddr 8.8.8.8 counter
以上命令会在 tabletest 路由表的 output 链中添加一条规则，匹配出口流量中 ip 地址为 8.8.8.8 的流量并对匹配次数计数，nftables 中 counter 会默认启用即使不写。以上命令相当于 iptables 中的 -A 命令。列出某个链包含的规则：root@OpenWrt:~# nft list chain ip tabletest output
table ip tabletest {
        chain output {
                type filter hook output priority filter; policy accept;
                ip daddr 8.8.8.8 counter packets 0 bytes 0
        }
}下面测试以上规则是否生效，执行以下命令：ping -c 1 8.8.8.8再次查看此链的规则：root@OpenWrt:~# nft list chain ip tabletest output
table ip tabletest {
        chain output {
                type filter hook output priority filter; policy accept;
                ip daddr 8.8.8.8 counter packets 1 bytes 84
        }
}可以看到已经有一次计数了。指定位置添加规则：nftables 中必须通过 handle num 编号来在指定位置添加规则，需要通过 -a 查看链中已经存在的规则的编号：nft -n -a list table ip tabletest
-n 可以按数字顺序排号避免出现重复编号。再次查看链中的规则：root@OpenWrt:~# nft -n -a list table ip tabletest
table ip tabletest { # handle 4
        chain output { # handle 1
                type filter hook output priority 0; policy accept;
                ip daddr 8.8.8.8 counter packets 0 bytes 0 # handle 5
        }
}handle 5 就是这条规则的编号。下面我们通过 handle 索引在这条规则后添加一条新规则：nft add rule ip tabletest output position 5 ip daddr 127.0.0.8 drop
查看链中的规则：root@OpenWrt:~# nft -n -a list table ip tabletest
table ip tabletest { # handle 4
        chain output { # handle 1
                type filter hook output priority 0; policy accept;
                ip daddr 8.8.8.8 counter packets 0 bytes 0 # handle 5
                ip daddr 127.0.0.8 drop # handle 6
        }
}如果要在某条规则前插入一条规则需要使用 insert 指令：nft insert rule ip tabletest output position 5 ip daddr 127.1.1.8 drop
查看效果：root@OpenWrt:~# nft -n -a list table ip tabletest
table ip tabletest { # handle 4
        chain output { # handle 1
                type filter hook output priority 0; policy accept;
                ip daddr 127.1.1.8 drop # handle 7
                ip daddr 8.8.8.8 counter packets 0 bytes 0 # handle 5
                ip daddr 127.0.0.8 drop # handle 6
        }
}在某条链最前面添加一条规则：nft insert rule ip tabletest output ip daddr 192.168.2.1 counter
在最前面添加规则就不需要指定 handle 了。替换某条规则：替换一条规则也需要 handle 编号。下面示例会替换 handle 5 为新的规则：nft replace rule ip tabletest output handle 5 ip daddr 1.1.1.1
删除规则：同样的，删除某一条规则也需要获取这条规则的 handle 编号。删除 tabletest 链的 handle 7 规则： nft delete rule ip tabletest output handle 7
删除链中所有规则：nft flush chain ip tabletest output
删除路由表中所有链的所有规则：nft flush table ip tabletest
ruleset 层级的操作显示所有 family 的所有 rule 规则：nft list ruleset
显示某一个集合的所有 rule： % nft list ruleset arp
 % nft list ruleset ip
 % nft list ruleset ip6
 % nft list ruleset bridge
 % nft list ruleset inet清除所有集合的所有规则：nft flush ruleset
清除某一个集合的所有规则： % nft flush ruleset arp
 % nft flush ruleset ip
 % nft flush ruleset ip6
 % nft flush ruleset bridge
 % nft flush ruleset inet备份规则到文件：# 备份所有集合的所有规则
nft list ruleset &gt;&gt; backup.nft

# 备份 ip 集合的所有规则
nft list ruleset ip &gt;&gt; backup.nft从文件恢复规则：nft -f backup.nft
以 json 格式显示所有规则：nft --json list ruleset
流量元信息匹配通过 meta 选择器可以进行流量匹配或流量设置。下面简单介绍几个常用的匹配模式，更加详细的参考官方资料：https://wiki.nftables.org/wiki-nftables/index.php/Matching_packet_metainformationiifname 匹配网卡名称：# lo 网卡的入口流量会被接收
nft add rule tabletest input meta iifname lo acceptmark 匹配流量标记：# 流量标记为 123 的出口流量计数
nft add rule tabletest output meta mark 123 counterskgid 匹配流量由特定 gid 用户产生的数据：# 匹配来自 gid 用户 1000 的流量
nft add rule tabletest output meta skgid 1000 counter流量头信息匹配通过 ip {saddr | daddr}  可以匹配 ipv4 的源流量或目标流量：# 匹配来自 192.168.1.100 且去往 192.168.1.1 的流量并计数
# 注意本机地址必须为 192.168.1.1 才可以由 input hook 截获
nft add rule ip tabletest input ip saddr 192.168.1.100 ip daddr 192.168.1.1 counter通过 icmp type 关键词来匹配 icmp 流量，如 ping request：nft add rule ip tabletest input icmp type echo-request counter drop
可以通过命令查询所有可用的 icmp type 类型：root@OpenWrt:~# nft describe icmp type
payload expression, datatype icmp_type (ICMP type) (basetype integer), 8 bits

pre-defined symbolic constants (in decimal):
        echo-reply                                         0
        destination-unreachable                            3
        source-quench                                      4
        redirect                                           5
        echo-request                                       8
        router-advertisement                               9
        router-solicitation                               10
        time-exceeded                                     11
        parameter-problem                                 12
        timestamp-request                                 13
        timestamp-reply                                   14
        info-request                                      15
        info-reply                                        16
        address-mask-request                              17
        address-mask-reply                                18通过 ip protocol 匹配 ip family 任意类型的协议：# 匹配所有 tcp 流量
nft add rule ip tabletest output ip protocol tcp

# 匹配所有 tcp udp 流量
nft add rule ip tabletest output ip protocol { tcp, udp }通过 meta l4proto 匹配 inet family 任意类型的协议：# tabletest 需要定义为 inet 集合
nft add rule inet tabletest output meta l4proto tcp匹配特定端口的流量：# 丢弃所有端口为 1-1024 的 tcp 流量访问本机
nft add rule ip tabletest input tcp dport 1-1024 counter drop流量匹配动作accept 和 dropdrop 可以对匹配的流量直接丢弃，注意 drop 不能和其他动作组合使用：nft add rule ip tabletest input ip protocol udp drop
accept 可以对匹配的流量接收，可以和其他动作组合使用 如 counter 计数：nft add rule ip tabletest input counter accept
reject 流量不同于 drop，reject 可以在拒绝流量的基础上进行很多其他动作，如返回给源请求地址无法访问的原因等。如果不指定其他动作，默认会返回源地址一个 ICMP/ICMPv6 port unreachable 的流量包。示例如下：# 拒绝所有 input 的 udp 流量
nft add rule ip tabletest input ip protocol udp reject

# 拒绝指定流量并返回 icmp host-unreachable
nft add rule ip tabletest input reject with icmp type host-unreachableicmp 可用如下原因：net-unreachable: Destination network unreachable
host-unreachable: Destination host unreachable
prot-unreachable: Destination protocol unreachable
port-unreachable: Destination port unreachable (this is the default)
net-prohibited: Network administratively prohibited
host-prohibited: Host administratively prohibited
admin-prohibited: Communication administratively prohibitedjump 跳转到其他 chain注意只能跳转到同一个路由表的其他 chain。首先我们新建一个 chain：nft add chain ip tabletest tcp-chain
然后定义这个链的规则：nft add rule ip tabletest tcp-chain counter
然后可以定义将所有匹配的流量跳转过去：ft add rule ip tabletest input ip protocol tcp jump tcp-chain
以上示例实现的就是将所有 input 的 tcp 流量跳转到 tcp-chain 计数，然后就返回原始 input 环节继续流转。log 日志通过 log 可以记录匹配到的流量信息，在系统日志中可以查看到。下面是一个示例，可以记录所有对本机的 ping 请求：nft add rule ip tabletest input icmp type echo-request log prefix \&quot;New ping request: \&quot; accept从局域网对本机进行 ping 后，系统日志如下：Thu May  9 11:58:04 2024 kern.warn kernel: [ 3741.786865] New ping request: IN=br-lan OUT= MAC=00:0c:29:c5:39:8d:00:50:56:c0:00:02:08:00 SRC=192.168.244.2 DST=192.168.244.1 LEN=60 TOS=0x00 PREC=0x00 TTL=128 ID=49655 PROTO=ICMP TYPE=8 CODE=0 ID=1 SEQ=6609网络地址转换nat 链类型可以执行网络地址转换的功能，这种链类型有其特有的属性：流量中只有第一个包会被用来进行匹配规则流量包中后续的流量不会被检查nat 链类型特有的规则赋予其他链类型会报错先定义一个 nat 类型的基本链：nft add chain ip tabletest postrouting { type nat hook postrouting priority 0 \; }
以上定义了一个 nat 类型的基本链挂载在 postrouting hook 上。snat 表示源地址。下面的规则可以将来自 192.168.1.0/24 从 eth0 网卡发出的流量在发送出去的时候，将源地址修改为 1.2.3.4nft add rule ip tabletest postrouting ip saddr 192.168.1.0/24 oif eth0 snat to 1.2.3.4
也可以定义一个地址范围：# 将所有 tcp 流量的源地址都修改为指定的ip范围内
nft add rule ip tabletest postrouting ip protocol tcp snat ip to 10.0.0.1-10.0.0.100:3000-4000下面介绍如何修改目标地址，再定义一个 nat 类型的基本链：nft add chain ip tabletest prerouting { type nat hook prerouting priority 0 \; }
以上定义了一个 nat 类型的基本链挂载在 prerouting hook 上。dnat 表示目标地址。下面规则会将要进入 eth0 的 tcp 80 443 端口的流量的目标地址改为 192.168.1.120 也就是重定向：nft 'add rule ip tabletest prerouting iif eth0 tcp dport { 80, 443 } dnat to 192.168.1.120'
redirect 是一种特殊的 dnat，它会将流量重定向到本机设备上：nft add rule ip tabletest prerouting tcp dport 22 redirect to 2222
以上规则会将进入的 tcp 22 端口的流量转发到本机 2222端口上。需要注意的是 redirect 只能应用于 nat 链类型的 prerouting 和 output hooks。设置流量包元信息设置 mark 标记：nft add rule ip tabletest output mark set 123
set 架构nftables 提供了 set 架构可以用任意支持的选择器来搭建 sets。匿名 set匿名 set 是直接定义在 rule 内的 set，它没有特定的名称，也不可以更新 set 中的元素，下面是一个示例：nft add rule ip tabletest output tcp dport { 22, 23 } counter
{ 22, 23 } 就属于一个匿名 set。规则会去尝试匹配 set 中的每个元素。非匿名 set可以通过 nft add set 来创建一个有名称的 set，例如：nft add set ip tabletest blackhole { type ipv4_addr \; comment \&quot;drop all packets from these hosts\&quot; \; }
blackhole 就是这个 set 的名称，后续可以再 rule 中使用。set 类型指定是 ipv4 数据。set 名称需要小于等于16个字符，comment 注释是可选项。可用的 type 类型有：ipv4_addr: IPv4 addressipv6_addr: IPv6 address.ether_addr: Ethernet address.inet_proto: Inet protocol type.inet_service: Internet service (read tcp port for example)mark: Mark type.ifname: Network interface name (eth0, eth1..)建立好之后就可以往 set 里添加元素了：nft add element ip tabletest blackhole { 192.168.3.4 }
nft add element ip tabletest blackhole { 192.168.1.4, 192.168.1.5 }如果要添加一个 ip 网段则需要将 set 定义 flags interval：nft add set ip tabletest blackhole { type ipv4_addr \; flags interval \; }
然后就可以添加一个 ip 网段了：nft add element ip tabletest blackhole { 192.168.1.0/24 }
可以查询 set 中现有的元素：root@OpenWrt:~# nft list set ip tabletest blackhole
table ip tabletest {
        set blackhole {
                type ipv4_addr
                comment &quot;drop all packets from these hosts&quot;
                elements = { 192.168.1.4, 192.168.1.5,
                             192.168.3.4 }
        }
}下面就可以通过 set 名称在 nftables 规则中应用：nft add rule ip tabletest input ip saddr @blackhole drop
nft add rule ip tabletest output ip daddr != @blackhole accept以上就是 natables 的基本用法。参考链接nftables HOWTO documentation pageNftables familiesNetfilter hooksOperations at ruleset level</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/intel-12-CPU-vmwre.html">
<title>解决在 intel 12代以后的 CPU 上 vmwre 虚拟机性能低下问题</title>
<link>https://blog.niekun.net/archives/intel-12-CPU-vmwre.html</link>
<dc:date>2024-04-18T13:01:52+08:00</dc:date>
<description>最近更换了新的电脑，是 i7 12700H 的 CPU，按理说比以前的电脑性能好一些，但是导入之前的 vmware 虚拟机后发现运行起来优点卡顿，但是观察主机资源占用很低，cpu 占用也很低，研究了下才发现是由于新款 cpu 采用了大小核设计导致这个问题。我的这一款是 6 大核 8 小核 20 线程设计。默认情况下启动虚拟机资源分配是交给 windows 主机自己协调的，很可能会分配给小核运行虚拟机导致运行卡顿，资源管理器可以看到 cpu 负载都在后面的小核上：解决方法就是以管理员权限运行 vmware，这样 VMware 会自己调度资源使用，优先级大概是大核&gt;小核&gt;超线程。实际效果很明显，基本都运行在了大核上：</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/openwrt-1.html">
<title>openwrt 系统升级</title>
<link>https://blog.niekun.net/archives/openwrt-1.html</link>
<dc:date>2024-04-02T10:26:03+08:00</dc:date>
<description>小版本升级小版本升级，例如 19.05-&gt; 19.07。这种小版本的升级最方便的就是通过 Attended Sysupgrade 功能，可以保留已安装的包和系统设置。最大限度地无缝过渡。官方介绍：https://openwrt.org/docs/guide-user/installation/attended.sysupgrade需要先安装 Attended Sysupgrade luci 界面包：opkg install luci-app-attendedsysupgrade
建议使用此功能前依然做一次数据备份。然后重新登录 luci，在 system - Attended Sysupgrade 找到入口，点击 search for firmware upgrade 即可在线搜索可更新的系统。大版本升级最方便的就是通过 luci 界面升级系统，目前支持直接升级的大版本顺序是：19.07 &gt; 21.02 &gt; 22.03 &gt; 23.05。大版本升级改动openwrt 21：https://openwrt.org/releases/21.02/notes-21.02.0WPA3 support included by defaultTLS and HTTPS support included by defaultLuCI is now available over HTTPSInitial DSA support replaces the swconfig systemNew network configuration syntax and board.json changeKernel with container supportopenwrt 22：https://openwrt.org/releases/22.03/notes-22.03.0Firewall4 based on nftables，superseding the iptables-based firewall3Dark mode in LuCIopenwrt 23：https://openwrt.org/releases/23.05/notes-23.05.0Switch from wolfssl to mbedtls as default，TLS 1.3 SupportRust Package Support数据备份每个版本升级实际上就是重新刷入了一次固件，所以之前的配置文件什么的基本上都会被覆盖，所以系统内修改过的配置最好做一次备份。打开 luci 界面，选择 system - backup/flash firmware，在 configuration 菜单栏中将需要保存的文件或目录定义出来，然后在 action 菜单栏中选择 backup - generate archive 即可保存备份到本地。已安装包列表可以通过 awk 脚本识别出自己手动安装的包列表，方便更新系统后安装回去，下载脚本：https://github.com/richb-hanover/OpenWrtScripts/blob/main/opkgscript.sh执行以下命令会保存已安装的包列表到 /etc/config/opkg.installed：opkgscript.sh -v write
执行以下命令会识别并安装 /etc/config/opkg.installed 列表中的包：opkgscript.sh -v install
也可以执行以下 awk 脚本可以单独列出自己手动安装的包列表：#!/usr/bin/awk -f
BEGIN {
    ARGV[ARGC++] = &quot;/usr/lib/opkg/status&quot;
    cmd=&quot;opkg info busybox | grep '^Installed-Time: '&quot;
    cmd | getline FLASH_TIME
    close(cmd)
    FLASH_TIME=substr(FLASH_TIME,17)
}
/^Package:/{PKG= $2}
/^Installed-Time:/{
    INSTALLED_TIME= $2
    # Find all packages installed after FLASH_TIME
    if ( INSTALLED_TIME &gt; FLASH_TIME ) {
        cmd=&quot;opkg whatdepends &quot; PKG &quot; | wc -l&quot;
        cmd | getline WHATDEPENDS
        close(cmd)
        # If nothing depends on the package, it is installed by user
        if ( WHATDEPENDS == 3 ) print PKG
    }
}
EOF保存以上内容到 listuserpackages.awk 文件中并执行即可列出用户自行安装包列表。下载升级固件x86 版本的 openwrt 的升级固件就是全新安装时候用的固件，直接在官网下载需要版本的 gz 压缩包即可。下载地址：https://downloads.openwrt.org/releases/我下载的是：generic-ext4-combined.img.gz，注意不要解压出来，保留压缩包即可。进入 luci 的 system - backup/flash firmware 选择 Flash image ，然后选择刚才下载的压缩包即可上传更新，会提示是否保留设置和配置，跨大版本的升级必须取消选择保留数据，否则可能升级失败：如果升级后卡在 grub 界面说明可能是由于选择了保留配置导致升级失败了，可以参考官方教程通过 failsafe mode 恢复默认配置：Failsafe mode, factory reset, and recovery mode，或者直接重新安装系统。网络配置稍等几分钟安装好后你可能会发现 luci 无法在局域网中访问了，这是由于新安装的固件恢复了 network 配置，需要直接到 openwrt 设备上配置网络。配置教程参考：openwrt network 配置配置好网络后在局域网设备中可以用 ssh 登录了，此时会发现提示：@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the RSA key sent by the remote host is
SHA256:U9XODs/7A4k065pxSMyEtQ2m98v2P0bf/ML0MfzU.
Please contact your system administrator.
Add correct host key in C:\\Users\\Marco Nie/.ssh/known_hosts to get rid of this message.
Offending RSA key in C:\\Users\\Marco Nie/.ssh/known_hosts:6
Host key for 192.168.244.1 has changed and you have requested strict checking.
Host key verification failed.这是由于更新系统后 ssh 指纹发生了变化，需要删除本地缓存的 openwrt 设备的指纹在登陆，windows 系统 ssh 指纹保存地址为当前用户目录下的 .ssh 文件夹。升级后续升级后可以通过之前的脚本列出的已安装包的列表将自己需要的包安装回去，同时将备份数据按照新系统的格式恢复回去。从 openwrt 21 开始修改了 network 配置文件格式，参考：https://blog.niekun.net/archives/2291.html从 openwrt 22 开始替换 iptables 为 nftables，需要原始工具的话可以自行安装回去：opkg install iptables参考链接Opkg package managerOpenWRT 19.07 to 21.02.0 upgrade</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/Linux.html">
<title>Linux 查询及编辑用户及用户组</title>
<link>https://blog.niekun.net/archives/Linux.html</link>
<dc:date>2024-04-01T16:20:00+08:00</dc:date>
<description>查询当前所有用户compgen -u
查询当前所有用户组compgen -g
添加一个用户到某个组sudo usermod -a -G groupName userName
newgrp groupName
删除一个用户从某个组sudo usermod -G groupName userName
newgrp groupName
用户和组对文件的权限管理参考：chown 和 chmod 管理文件权限</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/Linux-ip.html">
<title>Linux 获取本地网关所有 ip 段地址</title>
<link>https://blog.niekun.net/archives/Linux-ip.html</link>
<dc:date>2024-03-28T15:35:07+08:00</dc:date>
<description>执行下面命令即可获取本地网关所有的 ip 段地址：$ ip address | grep -w inet | awk '{print $2}'
127.0.0.1/8
192.168.122.2/24
172.18.0.1/16
172.17.0.1/16
172.19.0.1/16</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/codesys-enum.html">
<title>codesys enum 枚举数据类型单元的使用</title>
<link>https://blog.niekun.net/archives/codesys-enum.html</link>
<dc:date>2024-03-07T08:21:07+08:00</dc:date>
<description>enum 类型的 dut 可以定义一组属性及其值，调用的时候可以方便的通过写其属性名称得到属性的值，也可以获取到属性本身的名称。下面举一个例子说明：{attribute 'qualified_only'}            // 必须先写类型名称再写属性名称 (例如 eColor.Red)
// {attribute 'strict'}                 //取消 'strict' 以允许转换 UDINT 数据类型
{attribute 'to_string'}                 // 运行字符串转换 (例如 TO_STRING(eColor.Red) = 'Red')
TYPE eColor :
(
    Red         := 16#FFFF0000,
    Green       := 16#FF00FF00,
    Blue        := 16#FF0000FF
    Yellow      := 16#FFFFFF00,
) UDINT;                                // 声明 UDINT 作为 int 整形类型
END_TYPE

// 定义一些变量
    ColorVar1   : eColor;
    ColorVar2   : eColor;
    ColorName   : STRING;
    ColorValue  : UDINT;

    ColorVar1 := eColor.Green;            // ColorVar1 = 16#FF00FF00
    ColorName := TO_STRING(ColorVar1);    // ColorName = 'Green';
    ColorValue := TO_UDINT(ColorVar1);    // ColorValue = 16#FF00FF00

    ColorVar2 := 16#FF00FF00;             // ColorVar2.Green
    ColorName := TO_STRING(ColorVar2);    // ColorName = 'Green';
    ColorValue := TO_UDINT(ColorVar2);    // ColorValue = 16#FF00FF00

    ColorVar1 := ColorVar2 OR eColor.Red; // 按位相与得到 Yellow=16#FFFFFF00
    ColorName := TO_STRING(ColorVar1);    // ColorName = 'Yellow';
    ColorValue := TO_UDINT(ColorVar1);    // ColorValue = 16#FFFFFF00以上示例列举了常用的 enum 类型可进行的数据交互方式。eColor.Green 可以获取enum类型属性的值，并可以赋值给其他对应 enum 实例TO_STRING(ColorVar1) 可以转换获取 enum 实例当前值对应属性名称字符串</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/codesys.html">
<title>codesys 常见编译及下载时报错解决方法</title>
<link>https://blog.niekun.net/archives/codesys.html</link>
<dc:date>2024-03-06T16:35:00+08:00</dc:date>
<description>No source code available for this object下载时出现此报警，原因是 task 任务中对 gou 的排序有问题，放在前面的 pou 中使用了后面 pou 才设定好的数据，需要重新排列 task 任务序列：SMC_FB_CALLED_FROM_WRONG_TASKmc_power mc_jog 等控制轴的功能块，一运行就报错 SMC_FB_CALLED_FROM_WRONG_TASK，可能是不同的 pou 放在了多个 task 任务中，循环中内部有了冲突，将所有的 pou 放在同一个 task 中就可以解决问题。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/immich.html">
<title>服务器部署 immich 照片备份工具</title>
<link>https://blog.niekun.net/archives/immich.html</link>
<dc:date>2024-03-04T09:30:00+08:00</dc:date>
<description>目前有很多的云备份服务可以使用，比如 icloud，google photos 等。immich 是一款实现类似功能的本地部署工具，将数据都存储在自己本地服务器上，拥有完善的手机端 app 可以方便的同步备份手机图片。GitHub 主页：https://github.com/immich-app/immich官网教程：https://immich.app/docs/overview/introduction/安装服务端使用 docker compose 安装，新建一个 immich 文件夹，下载 docker-compose.yml 和 .env 文件到文件夹：wget https://github.com/immich-app/immich/releases/latest/download/docker-compose.yml
wget -O .env https://github.com/immich-app/immich/releases/latest/download/example.env打开 .env 文件配置环境变量，主要就是配置备份路径和数据库密码，修改 UPLOAD_LOCATION 和 DB_PASSWORD。启动容器：docker compose up -d后续更新只需要进入 immich 文件夹执行下面命令即可：docker compose pull &amp;&amp; docker compose up -d
docker-compose.yml 文件中默认将 3001 端口映射到了本地 2283 端口，3001就是服务端访问端口号。下面是所有可用的端口，根据需要可以修改 docker-compose 文件映射到本地：PORTWeb Port3000webSERVER_PORTServer Port3001serverMICROSERVICES_PORTMicroservices Port3002microservicesMACHINE_LEARNING_HOSTMachine Learning Host0.0.0.0machine learningMACHINE_LEARNING_PORTMachine Learning Port3003machine learning配置账户网页端访问：http://you.machine.ip:2283 进入配置页面，根据提示建立一个管理员账户，后续可以在管理员账户中建立其他子账户供其他人使用。登录 app下载手机端 app，ios 直接在 app store 搜索 immich 下载，安卓在 github 发布页下载 apk：https://github.com/immich-app/immich/releases在手机端输入以下网址进入：http://you.machine.ip:2283/api然后就可以配置需要备份的手机端图片文件夹了。外网访问服务器在本地，如果要外网域名远程访问图库，需要一些额外的配置，我这里是通过 cloudflare 配置子域名，nginx 配置反向代理到 frps，最后本地服务器 frpc 配置本地 2283 端口绑定到远程域名访问即可。可以参考我之前的关于 frp 的教程：https://blog.niekun.net/archives/539.html</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/Ubuntu-20-04-ppa.html">
<title>Ubuntu 20.04 添加第三方 ppa</title>
<link>https://blog.niekun.net/archives/Ubuntu-20-04-ppa.html</link>
<dc:date>2024-02-22T09:18:33+08:00</dc:date>
<description>我服务器目前安装的是 Ubuntu 20.04 系统，很多新的软件包并没有在官方维护的源中提供，所以为了方便需要可以添加第三方的源。添加需要用到的命令是：add-apt-repository，但是默认系统并没有安装这个环境，需要先手动安装 package software-properties-common：sudo apt install software-properties-common
然后就可以安装需要的源了，推荐两个：https://launchpad.net/%7Esavoury1/+archive/ubuntu/backports?field.series_filter=bionichttps://launchpad.net/%7Esavoury1/+archive/ubuntu/utilities?field.series_filter=bionic安装方法很简单：sudo add-apt-repository ppa:savoury1/backports
sudo add-apt-repository ppa:savoury1/utilities
sudo apt-get update执行 apt update 后会发现很多可更新的软件了。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/WSA-Windows-Subsystem-for-Android.html">
<title>WSA (Windows Subsystem for Android) 的安装及使用</title>
<link>https://blog.niekun.net/archives/WSA-Windows-Subsystem-for-Android.html</link>
<dc:date>2024-02-20T15:47:00+08:00</dc:date>
<description>之前介绍过 Windows10 安装 wsl 的教程，可以方便的在 Windows 下使用 Ubuntu 系统。今天介绍安装 wsa 用来在 Windows 下使用 Android 系统及安装第三方 apk。安装wsa 没有在官方的 store 中提供，这里使用开源的 WSA-Script 很方便的一键安装。GitHub 主页：https://github.com/YT-Advanced/WSA-Script在 release 页面下载最新打包的版本：https://github.com/YT-Advanced/WSA-Script/releases/latest我需要使用 google play 框架及 root 权限，所以下载的是框出来的版本：下载好解压到一个特定的目录，运行 Run.bat，期间会提示需要管理员权限以及提示收集信息的对话框，点击确认即可。安装完成后会自动运行 Windows Subsystem For Android™ 应用。设置代理如果需要使用 play 商店，就需要配置代理服务。如果本机有代理工具的话，可以让 wsa 直接调用本机代理。这里需要使用 adb 工具，下载链接：https://dl.google.com/android/repository/platform-tools-latest-windows.zip解压压缩包，可以看到其中有一个 adb.exe，可以将目录添加到系统 path 以方便在 terminal 调用。首先需要设置 wsa 打开开发者模式，进入设置打开选项：默认 wsa 是运行在本地的 58526 端口的。建立一个 powershell 脚本，如：wsaproxy.ps1，内容如下：$WinNetIP=$(Get-NetIPAddress -InterfaceAlias 'vEthernet (WSLCore)' -AddressFamily IPV4) # get android network gateway addr
adb connect 127.0.0.1:58526 # android port
adb shell settings put global http_proxy &quot;$($WinNetIP.IPAddress):1082&quot; # local proxy port第一次执行会弹出对话框是否信任外部访问，点击允许即可。以上脚本会获取到 wsa 所在网卡的网关地址，然后用 adb 连接到 wsa，最后配置代理，注意脚本里的本地代理端口修改为实际值即可。运行脚本即可让 wsa 配置好代理服务。以后只需要执行这个脚本就可以自动设置代理。如果需要取消代理运行下面命令即可：adb shell settings put global http_proxy :0安装 apk推荐直接在 play 商店安装应用程序，如果需要安装自己下载的第三方 apk，直接使用 adb 工具即可。安装命令：adb connect 127.0.0.1:58526
adb install xxx.apk文件共享可以配置一个 Windows 主机的路径作为同 wsa 共享目录，这样两边就可以互传文件了。打开 Windows Subsystem For Android™ 进入 advanced settings - experimental feature，启用 share user folders 功能并选择一个本地目录作为共享目录：通过 system - turnoff 关闭 wsa，然后点击 files 会重新运行 wsa：可以看到有一个 windows 文件夹：这个文件夹就是对应的 windows 共享目录。系统设置默认情况下只有在第一次安装成功后会自动启动 Android 设置界面，并且找不到设置的启动图标在哪里，我们可以在浏览器里直接访问 android settings 地址的方式启动。浏览器中输入以下地址并访问：wsa://com.android.settings，会提示是否需要跳转到设置，点击确认即可进入设置：参考链接Windows Android 子系统 WSA 代理设置方法教程WSA (Windows Subsystem for Android) 使用 Windows 上的代理</description>
</item>
</rdf:RDF>