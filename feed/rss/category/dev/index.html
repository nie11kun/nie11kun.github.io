<?xml version="1.0" encoding="UTF-8"?>
<rdf:RDF
xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
xmlns="http://purl.org/rss/1.0/"
xmlns:dc="http://purl.org/dc/elements/1.1/">
<channel rdf:about="https://blog.niekun.net/feed/rss/category/dev/">
<title>Marco Nie - Development</title>
<link>https://blog.niekun.net/category/dev/</link>
<description></description>
<items>
<rdf:Seq>
<rdf:li resource="https://blog.niekun.net/archives/2208.html"/>
<rdf:li resource="https://blog.niekun.net/archives/2201.html"/>
<rdf:li resource="https://blog.niekun.net/archives/2195.html"/>
<rdf:li resource="https://blog.niekun.net/archives/2189.html"/>
<rdf:li resource="https://blog.niekun.net/archives/2184.html"/>
<rdf:li resource="https://blog.niekun.net/archives/2183.html"/>
<rdf:li resource="https://blog.niekun.net/archives/2176.html"/>
<rdf:li resource="https://blog.niekun.net/archives/2175.html"/>
<rdf:li resource="https://blog.niekun.net/archives/2169.html"/>
<rdf:li resource="https://blog.niekun.net/archives/2165.html"/>
</rdf:Seq>
</items>
</channel>
<item rdf:about="https://blog.niekun.net/archives/2208.html">
<title>QT 中通过 QCustomPlot widget 绘制可视化曲线表</title>
<link>https://blog.niekun.net/archives/2208.html</link>
<dc:date>2021-03-19T17:24:46+08:00</dc:date>
<description>今天在项目中需要添加一个柱状图，但由于我们的项目是 QT 4.8 的所以不支持 QtCharts。查询了下发现有 QCustomPlot 可以完美的实现需求，使用方法也很简单。官网：https://www.qcustomplot.com/下载：https://www.qcustomplot.com/index.php/downloadQCustomPlot 只有两个文件 qcustomplot.cpp 和 qcustomplot.h，将其复制到项目目录中并添加到项目中。然后引用头文件即可：#include &quot;qcustomplot.h&quot;
我们需要在 ui 中添加一个 widget 然后右键点击控件，选择提升：提升的 class 名称修改为 QCustomPlot：点击 add 然后点击 promote 即可。编译后可以看到图表样式：在使用中如果需要根据数据变化刷新渲染的图形，记得在修改数据后调用</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/2201.html">
<title>React 入门教程之七 -- List 和 Form</title>
<link>https://blog.niekun.net/archives/2201.html</link>
<dc:date>2021-03-05T16:13:20+08:00</dc:date>
<description>list 列表和 key在 JavaScript 中我们通常使用 map method 来对一个 list 的每个元素进行操作：const numbers = [1, 2, 3, 4, 5];
const double = numbers.map((number) =&gt; { return number * 2});
console.log(double)

//output:
//[ 2, 4, 6, 8, 10 ]在 React 中对一个 list 的元素进行操作方法类似。我们可以在 JSX 中通过大括号{} 来建立一个 elements 的集合，下面示例中我们将 map 的返回定义为 &lt;li&gt; 元素并赋值给 listItems：const numbers = [1, 2, 3, 4, 5];
const listItems = numbers.map((number) =&gt; &lt;li&gt;{number}&lt;/li&gt;)

ReactDOM.render(
    &lt;ul&gt;{listItems}&lt;/ul&gt;,
    document.getElementById('root')
);注意在 render 中我们将 listItems 放在 &lt;ul&gt; 元素中。通常情况下我们将 lists 放在一个 component 中：const NumberList = (props) =&gt; {
    const numbers = props.numbers;
    const listItems = numbers.map((number) =&gt; &lt;li&gt;{number}&lt;/li&gt;)
    return (
        &lt;ul&gt;{listItems}&lt;/ul&gt;
    )
}

const numbers = [1, 2, 3, 4, 5];
ReactDOM.render(
    &lt;NumberList numbers={numbers}/&gt;,
    document.getElementById('root')
);当运行以上代码时，在浏览器终端会有一个 warning 警告信息：Each child in a list should have a unique "key" prop.：Key 是一个特殊的 string 字符串属性需要给创建的 list element 添加的。它可以用来定位 list 中的每个元素。下面我们给 list item 添加 Key 字符串属性：const NumberList = (props) =&gt; {
    const numbers = props.numbers;
    const listItems = numbers.map((number) =&gt;
        &lt;li key={number.toString()}&gt;
            {number}
        &lt;/li&gt;);
    return (
        &lt;ul&gt;{listItems}&lt;/ul&gt;
    );
}添加后报警就会消除。KeysKey 可以帮助 React 识别哪个 item 修改过，被删除，被添加。以上示例中，我们在 map 中创建 item 时给其 key 属性，这样每个 item 可以有确切的属性值。每个 list item 最好设置一个特殊的标识 key string 来区别于其他 items。最常用的就是使用数据中的 ID 作为 key：const TodoItems = (props) =&gt; {
    const todos = props.todos;
    const listItems = todos.map((todo) =&gt; 
        &lt;li key={todo.id}&gt;
            {todo.text}
        &lt;/li&gt;
    )
    return (
        &lt;ul&gt;{listItems}&lt;/ul&gt;
    );
}
const todos = [
    {id: 1, text: '123'},
    {id: 2, text: '456'}
];
ReactDOM.render(
    &lt;TodoItems todos={todos} /&gt;,
    document.getElementById('root')
);当没有特定的 ID 来作为标识时，作为最后的选择，可以使用 item 的 index 作为 key：const TodoItems = (props) =&gt; {
    const todos = props.todos;
    const listItems = todos.map((todo, index) =&gt; 
        &lt;li key={index}&gt;
            {todo.text}
        &lt;/li&gt;
    )
    return (
        &lt;ul&gt;{listItems}&lt;/ul&gt;
    );
}如果 items 的顺序可能会发生变化的话，不推荐使用 index 作为 key 使用，因为可能对性能产生影响并且对 component 的 state 造成问题。如果没有定义确切的 key 给 items，React 默认会使用 index 作为 keys。拆解 component 时 key 的处理keys 是对应与一个数组的内容而言的，它并不能单独存在。例如我们要拆解上面的 NumberList，提取出 ListItem，则需要将 key 定义在 &lt;ListItem /&gt; 元素中而不是 ListItem component 内部的 &lt;li&gt; 中：const ListItem = (props) =&gt; {
    return (
        &lt;li&gt;{props.value}&lt;/li&gt;
    );
}

const NumberList = (props) =&gt; {
    const numbers = props.numbers;
    const listItems = numbers.map((number) =&gt;
        &lt;ListItem key={number.toString()} value={number}/&gt;);
    return (
        &lt;ul&gt;{listItems}&lt;/ul&gt;
    );
}

const numbers = [1, 2, 3, 4, 5];
ReactDOM.render(
    &lt;NumberList numbers={numbers} /&gt;,
    document.getElementById('root')
);如果写成下面模式就是错误的：function ListItem(props) {
  const value = props.value;
  return (
    &lt;li key={value.toString()}&gt;
      {value}
    &lt;/li&gt;
  );
}每个 item 的 key 必须是特定的数组中每个 items 使用的 key 必须是互相独立且不相同的，但并不需要在全局下互相独立。在两个单独的数组中可以，其元素可以使用相同的 key：const React = require('react')
const ReactDOM = require('react-dom')

const Blog = (props) =&gt; {
    const sideBar = (
        &lt;ul&gt;
            {props.posts.map((post) =&gt;
                &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;
            )}
        &lt;/ul&gt;
    );
    const content = props.posts.map((post) =&gt;
        &lt;div key={post.id}&gt;
            &lt;h3&gt;{post.title}&lt;/h3&gt;
            &lt;p&gt;{post.content}&lt;/p&gt;
        &lt;/div&gt;
    );
    return (
        &lt;div&gt;
            {sideBar}
            &lt;hr/&gt;
            {content}
        &lt;/div&gt;
    );
}

const posts = [
    {id: 1, title: 'Hello World', content: 'Welcome to learning React!'},
    {id: 2, title: 'Installation', content: 'You can install React from npm.'}
];

ReactDOM.render(
    &lt;Blog posts={posts} /&gt;,
    document.getElementById('root')
);上面示例中，我们在 Blog component 中定义了两个 JSX，都创建了 list elements，每个元素的 key 使用了对应的 id 属性。在每个 list 内部 key 是互相独立的。可以看到不只是 &lt;li&gt; 元素可以加 key，只要通过 map 定义了一个 array 数组，就可以给每个元素加上 key 属性来互相独立识别。key 是为了给 React 识别用的。它本身并不作为一个普通 prop 传给 components，也就是在 component 内部并不能使用这个 key 数据，如果想要在 component 中使用这个数据则需要单独定义一个其他 prop 来传入 key 数据：const Post = (props) =&gt; {
    return (
        &lt;li&gt;
            {props.id}: {props.title}
        &lt;/li&gt;
    )
}
const Blog = (props) =&gt; {
    const sideBar = (
        &lt;ul&gt;
            {props.posts.map((post) =&gt;
                &lt;Post key={post.id} id={post.id} title={post.title} /&gt;
            )}
        &lt;/ul&gt;
    );
...
...
...
}上面示例中，Post component 无法直接访问 key 的数据，所以我们在调用 Post 时单独定义一个 id 属性并赋值为 key 相同的数据，这样就间接的可以在 Post component 中通过 id 来读取 key 的数据。在之前的 ListItem 示例中，我们声明了一个单独的 listItems 变量并在后续返回中将其放在 &lt;ul&gt; 中：const NumberList = (props) =&gt; {
    const numbers = props.numbers;
    const listItems = numbers.map((number) =&gt;
        &lt;ListItem key={number.toString()} value={number}/&gt;);
    return (
        &lt;ul&gt;{listItems}&lt;/ul&gt;
    );
}JSX 支持嵌入任何的 JavaScript 表达式，只需要使用大括号包围即可，所以上面的代码可以修改为以下模式：    return (
        &lt;ul&gt;
            {numbers.map((number) =&gt;
                &lt;ListItem key={number.toString()} value={number} /&gt;);}
        &lt;/ul&gt;
    );使用哪种方式来定义 JSX 取决于对应的使用场景，总的原则是要方便与代码阅读，逻辑清晰。需要注意的是如果 map() method 中层级太复杂，可以考虑将其拆分为多个 components。Forms 表格</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/2195.html">
<title>React 入门教程之六 -- Conditional Rendering</title>
<link>https://blog.niekun.net/archives/2195.html</link>
<dc:date>2021-03-02T23:10:22+08:00</dc:date>
<description>在 React 中，我们可以创建独立的 component 来封装特定的功能。因此，可以根据不同的程序的 state 选择性的做部分渲染。和 JavaScript 的相同，React 中也可以使用 conditions 语法来选择性的渲染内容。如使用 if 或 conditional operator 来根据不同 state 状态创建不同 elements 然后让 React 更新 UI 来匹配 DOM。考虑下面两个 components：const UserGreeting = (props) =&gt; {
    return &lt;h1&gt;welcome back&lt;/h1&gt;
}

const GuestGreeting = (props) =&gt; {
    return &lt;h1&gt;please sign up&lt;/h1&gt;
}然后我们创建一个 Greeting component 来根据是否有用户登陆来显示以上两个中的一个：const Greeting = (props) =&gt; {
    let isLoggedIn = props.isLoggedIn;
    if (isLoggedIn)
        return &lt;UserGreeting /&gt;;
    else
        return &lt;GuestGreeting /&gt;;
}

ReactDOM.render(
    &lt;Greeting isLoggedIn={true} /&gt;,
    document.getElementById('root')
);以上示例会根据 isLoggedIn 属性的值来渲染不同的内容。elements 变量可以使用变量存储 elements，这样可以方便的根据情况 render 部分的 component 而不需要改变输出的指令内容。考虑下面两个 component 表示 login 和 logout：const LoginButton = (props) =&gt; {
    return (
        &lt;button onClick={props.onClick}&gt;
            login
        &lt;/button&gt;
    );
}

const LogoutButton = (props) =&gt; {
    return (
        &lt;button onClick={props.onClick}&gt;
            logout
        &lt;/button&gt;
    );
}然后我们创建 LoginControl component，它将根据当前情况渲染 login 或 logout button 以及之前创建的 Greeting element：class LoginControl extends React.Component {
    constructor(props) {
        super(props);
        this.handleLoginClick = this.handleLoginClick.bind(this);
        this.handleLogoutClick = this.handleLogoutClick.bind(this);
        this.state = {isLoggedIn: false};
    }

    handleLoginClick() {
        this.setState({isLoggedIn: true});
    }

    handleLogoutClick() {
        this.setState({isLoggedIn: false});
    }

    render() {
        let isLoggedIn = this.state.isLoggedIn;
        let button;
        if (isLoggedIn)
            button = &lt;LogoutButton onClick={this.handleLogoutClick} /&gt;
        else
            button = &lt;LoginButton onClick={this.handleLoginClick} /&gt;

        return (
            &lt;div&gt;
                &lt;Greeting isLoggedIn={isLoggedIn} /&gt;
                {button}
            &lt;/div&gt;
        );
    }

}

ReactDOM.render(
    &lt;LoginControl /&gt;,
    document.getElementById('root')
);inline condition 单语句判断使用 element 变量以及使用 if 语句根据条件渲染 component 是一种很好的方法。但是有时候可以使用简化语法。下面接收几种 inline condition 语法。inline if with && operator在 JSX 可以通过使用大括号{}来嵌入 JavaScript 表达式，包括逻辑符号：&amp;&amp;，在根据条件判断是否包含一个 element 时很有用。请看下面示例：const InlineCom = (props) =&gt; {
    return(
        &lt;div&gt;
            &lt;h1&gt;hello world&lt;/h1&gt;
            {props.count &gt; 10 &amp;&amp;
                &lt;h2&gt;count is: {props.count}&lt;/h2&gt;
            }
        &lt;/div&gt;
    );
}

ReactDOM.render(
    &lt;InlineCom count={20} /&gt;,
    document.getElementById('root')
);如果 props.count &gt; 10 满足条件则后面的 element 就会成为 component 一部分。在 JavaScript 中，true &amp;&amp; expression 将会评估为 expression，而 false &amp;&amp; expression 将会评估为 false。因此当 condition 为 true 时，&amp;&amp; 后的 element 将会输出，否则 React 将会忽略它。inline condition operator另一种根据情况通过 inline 单行判断来渲染 element 就是使用 JavaScript conditional operator：condition ? true : false。给 LoginControl 的返回添加如下：        return (
            &lt;div&gt;
                the user is &lt;b&gt;{isLoggedIn ? 'currenty' : 'not'}&lt;/b&gt; logged in.
                &lt;Greeting isLoggedIn={isLoggedIn} /&gt;
                {button}
            &lt;/div&gt;
        );通过 inline conditional operator 来输出不同的信息。也可以在较长的表达式中使用，例如可以将示例中 button 部分在 render 中这样处理：        return (
            &lt;div&gt;
                the user is &lt;b&gt;{isLoggedIn ? 'currenty' : 'not'}&lt;/b&gt; logged in.
                &lt;Greeting isLoggedIn={isLoggedIn} /&gt;
                {button}
                {isLoggedIn 
                    ? &lt;LogoutButton onClick={this.handleLogoutClick} /&gt;
                    : &lt;LoginButton onClick={this.handleLoginClick} /&gt;
                }
            &lt;/div&gt;
        );使用中根据实际情况选择最合适的方式处理 condition，最终目的是为了使结构更加清晰，代码易读。注意如果判断过复杂就需要考虑拆解 component 为多个个体了。阻止 component 渲染某些情况下我们可能需要将一个 component 隐藏起来，即使它在别的 component 中已经渲染了。可以通过 return null 来代替它的输出。下面示例中 WarningBanner 会根据 warn 属性的值来选择性渲染：const React = require('react')
const ReactDOM = require('react-dom')

const WarningBanner = (props) =&gt; {
    if (!props.warn) {
        return null;
    }
    return (
        &lt;div className='warning'&gt;
            warning!
        &lt;/div&gt;
    );
}

class Page extends React.Component {
    constructor(props) {
        super(props);
        this.state = {showWarning: true};
        this.handelToggleClick = this.handelToggleClick.bind(this);
    }
    handelToggleClick() {
        this.setState({showWarning: !this.state.showWarning});
    }

    render() {
        return (
            &lt;div&gt;
                &lt;WarningBanner warn={this.state.showWarning} /&gt;
                &lt;button onClick={this.handelToggleClick}&gt;
                    {this.state.showWarning ? 'hide' : 'show'}
                &lt;/button&gt;
            &lt;/div&gt;
        );
    }
}

ReactDOM.render(
    &lt;Page /&gt;,
    document.getElementById('root')
);在 render method 中 return null 不会影响到 component 的 lifecycle method。例如每次更新 componentDidUpdate 依然会被自动调用。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/2189.html">
<title>React 入门教程之五 -- Event</title>
<link>https://blog.niekun.net/archives/2189.html</link>
<dc:date>2021-02-25T17:23:00+08:00</dc:date>
<description>events 处理处理 React elements events 和处理 DOM elements 很相似，但有一些语法区别：React events 命名使用 camelCase 规则，而不是 lowercase使用 JSX 传入 function 作为 events handler，而不是 string 字符串HMTL 中处理 events 示例如下：&lt;button onclick=&quot;activateLasers()&quot;&gt;
  Activate Lasers
&lt;/button&gt;React 中示例如下：&lt;button onClick={activateLasers}&gt;
  Activate Lasers
&lt;/button&gt;注意它们的区别之处一个是 event 名称，一个是 handler 定义方式。另一个区别是在 React 中不能通过 return false 的方式防止 events 的默认行为，需要明确的调用 preventDefault method 来实现。例如在一个 html 页面中定义一个 a tag 并取消其默认打开新页面的行为，实现如下：&lt;a href=&quot;#&quot; onclick=&quot;console.log('The link was clicked.'); return false&quot;&gt;
  Click me
&lt;/a&gt;React 中实现同样功能代码如下：class Link extends React.Component {
    constructor(props) {
        super(props);
        this.handleClick = this.handleClick.bind(this);
    }
    handleClick(e) {
        e.preventDefault();
        console.log('clicked me');
    }
    render() {
        return (
            &lt;a href='#' onClick={this.handleClick}&gt;click me&lt;/a&gt;
        )
    }
}e 表示 synthetic 综合的 event，当前哪个 event 触发了 e 就表示哪一个。使用 bind 绑定 的 method 在调用时会自动将 e 传入 method。下面会对 bind 是什么作出解释。React events 同原生的 events 不完全相同，查看所有可用的 events 查看官方介绍：https://reactjs.org/docs/events.html在 React 中一般情况下不需要通过调用 addEventListener 来给 element 添加 event listener。直接在 element 初始化时为其设置 event listener 即可。当通过 class 来定义 component 时 event handler 一般是一个 class method，例如上面示例的 handleClick。下面的示例我们构建一个 Toggle component 可以让用户通过一个 button 来切换 ON/OFF 状态：const React = require('react')
const ReactDOM = require('react-dom')

class Toggle extends React.Component {
    constructor(props) {
        super(props);
        this.state = { isToggleOn: true };
        this.handleClick = this.handleClick.bind(this);
    }
    handleClick() {
        this.setState({ isToggleOn: !this.state.isToggleOn });
    }
    render() {
        return (&lt;button onClick={this.handleClick}&gt; { this.state.isToggleOn ? 'ON' : 'OFF'} &lt;/button&gt;);
    }
}

ReactDOM.render(&lt;
    Toggle /&gt;,
    document.getElementById('root')
);在 JSX callback 中使用 this 需要特别注意，JavaScript class 的 methods 默认是相互隔离的，如果没有主动 bind 捆绑 method 到 this，在另一个 method 中使用 this.method 会报错 undefined。如果调用 method 时不写括号() 例如：onClick={this.handleClick} 则需要提前 bind 这个 method 到 this 中，如上面的示例，bind 语法如下：this.handleClick = this.handleClick.bind(this);
一般将其放在 constructor 中，这样初始化中就会自动执行，当然也可以在调用时直接定义：&lt;button onClick={this.handleClick.bind(this)}&gt; { this.state.isToggleOn ? 'ON' : 'OFF'} &lt;/button&gt;
如果不想使用 bind 语法来处理，那么还有两种方式来处理 class 中 methods 互相隔离这个问题。第一种叫做 class fields syntax 语法，通过使用 arrow function 的模式定义 method，这样就可以通过通过 this.method 的方法调用 method：    constructor(props) {
        super(props);
        this.state = { isToggleOn: true };
    }
    handleClick = () =&gt; {
        this.setState({ isToggleOn: !this.state.isToggleOn });
    }
    render() {
        return (&lt;button onClick={this.handleClick} &gt; { this.state.isToggleOn ? 'ON' : 'OFF'} &lt;/button&gt;);
    }这样就不需要在 constructor 中定义 bind 同时可以在 callback 中直接调用 this.handleClick。但是需要注意目前这只是 React 实验性的语法，不一定保证以后会一直可用。第二种是在 callback 中通过 arrow function 的模式调用 method：    handleClick() {
        this.setState({ isToggleOn: !this.state.isToggleOn });
    }
    render() {
        return (&lt;button onClick={() =&gt; this.handleClick()} &gt; { this.state.isToggleOn ? 'ON' : 'OFF'} &lt;/button&gt;);
    }注意这种方法需要在 method 名称后加括号()。这种方法的缺点是当每次重新 render 渲染时都会创建新的 callback。当这个 callback 包含传给其 child component 的 props 时，可能会导致 child 重新被渲染。通常情况下推荐使用 constructor 定义 bind 或者使用 class fields syntax 语法来避免这些性能问题。给 event handler 传入数据有时候需要给 event handler 传入附加的参数，如下面示例 button 点击时输出一个输入数据到终端：    handleClick(a, e) {
        this.setState({ isToggleOn: !this.state.isToggleOn });
        console.log(e._reactName);
        console.log(a);
    }
    render() {
        return (&lt;button onClick={this.handleClick.bind(this, 'aaa')} &gt; { this.state.isToggleOn ? 'ON' : 'OFF'} &lt;/button&gt;);
    }上面的示例将字符串 aaa 作为 handleClick 的传入参数，并将 bind 绑定过程直接放在 callback 中，这样就不需要在 constructor 中进行 bind 定义了。通过 bind 绑定后会自动将 e：synthetic 综合的 event 作为第二个参数传入 function，e._reactName 返回 event 名称。上面的示例也可以通过 arrow function 在 callback 中定义实现：    handleClick(a, e) {
        this.setState({ isToggleOn: !this.state.isToggleOn });
        console.log(e._reactName);
        console.log(a);
    }
    render() {
        return (&lt;button onClick={(e) =&gt; this.handleClick('aaa', e)} &gt; { this.state.isToggleOn ? 'ON' : 'OFF'} &lt;/button&gt;);
    }上面的示例中 e 依然表示 synthetic event。两种方法都会将 e 作为第二个参数传入。在 arrow function 中我们可以清晰地看到数据的位置，但是通过 bind 的方式会将有些参数自动转发过去。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/2184.html">
<title>React 入门教程之四 -- rendering, components 和 state</title>
<link>https://blog.niekun.net/archives/2184.html</link>
<dc:date>2021-02-24T17:17:00+08:00</dc:date>
<description>rendering elements 渲染元素一个 element 表示我们想要显示在屏幕上的内容：const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;
不同于浏览器 DOM 中的 elements，React elements 是简单的 objects 且可以很方便的创建，React DOM 会严格的刷新 DOM 并匹配对应的 React elements。容易混淆的概念是 component 和 element，区别是 component 是用来创建 element 的。在后续章节会介绍。在 DOM 中渲染元素我们的 html 页面中定义了一个 div 容器：&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
我们将其称作 root DOM 节点，因为它所有的内容都是被 React DOM 管理的。通常情况下使用 React 创建的程序只有一个 root DOM 节点。如果你是将 React 整合到现有网站中，你可以有任意个独立的 root DOM 节点。将 React elements 渲染到 root DOM 节点，需要通过调用 ReactDOM.render()，并将 React element 和 root DOM 节点作为传入参数：const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;

ReactDOM.render(
    element,
    document.getElementById('root')
);此时页面会显示 hello world。刷新渲染的元素React element 是 immutable 不可改变的，当创建了一个 element 后不可以修改其 children 或 attributes，一个 element 就好像一个视频的一帧，它表示了某一时间点的 UI。从我们目前学到的知识，唯一刷新 UI 的方法就是重新创建新的 elements 然后调用 ReactDOM.render()，通过设置 setInterval 来定时刷新：const tick = () =&gt; {
    const element = &lt;h1&gt;{new Date().toLocaleTimeString()}&lt;/h1&gt;;

    ReactDOM.render(
        element,
        document.getElementById('root')
    );
}
setInterval(tick, 1000);这样就会每秒钟创建一个新的 element 并通过 ReactDOM.render() 渲染到界面。通常情况下大多数 React app 只会调用 ReactDOM.render() 一次。下一章节会介绍如何将封装到 component 中。React 只会更新必要的内容React DOM 会比较其当前和上一个状态的，然后只对有了变化的部分进行更新来达到最终期望的状态。我们打开上面示例的运行页面，通过chrome 的开发工具查看 elements 情况，可以看到只有时间元素每秒在刷新：![2021-02-24T07:44:17.png][即使我们每秒钟都新建并渲染 element，但是只有时间文本 node 是一直通过 React DOM 在刷新的。通过以上的实验，思考我们的 UI 在某个时间点应该是什么样的，而不是只想这着去修改它。components 和 propscomponents 将 UI 元素分割为独立的，可复用的片段，每个片段都是单独存在的。这一章节介绍 component 的概念，更多细节参考：React.Componentcomponents 类似于 JavaScript 的 functions，它可以接受抽象的输入数据(props)，然后返回 React elements 用来在界面上显示。Function 和 Class Components最简单的定义 component 方式就是定义一个 JavaScript function：const Welcome = (props) =&gt; {
    return &lt;h1&gt; hello, {props.name}&lt;/h1&gt;
}上面的 function 是一个有效的 React component，因为它接受一个单参数 props object 作为传入数据并返回一个 React element。我们称这种 component 为 function component。也可以使用 ES6 的 class 定义 component：class Welcome extends React.Component {
    render() {
        return &lt;h1&gt;hello, {this.props.name}&lt;/h1&gt;
    }
}以上两种定义方式是一致的。需要注意的是 components 名称必须是以大写字母开头，因为 React 会见以小写字母开头的 components 作为 DOM tags 标签，如：&lt;div /&gt; 表示一个 html div 标签。rendering a component上面的介绍中，我们只遇到了 DOM tags 标签类型的 React elements，例如：const element = &lt;div /&gt;;
elements 也可以表示用户自定义的 components：const element = &lt;Welcome name='marco' /&gt;
当 React 检测到使用了用户自定义的 components 它会将此 JSX 内的 attributes 或 children 作为一个 object 传入 component，这个 object 叫做 props。下面的示例会输出 hello, marco:const Welcome = (props) =&gt; {
    return &lt;h1&gt; hello, {props.name}&lt;/h1&gt;;
}

const element = &lt;Welcome name='marco' /&gt;;
ReactDOM.render(
    element,
    document.getElementById('root')
);以上示例过程如下：首先调用 ReactDOM.render() 渲染 &lt;Welcome name=&quot;Sara&quot; /&gt; 元素.React 调用 Welcome component 使用 {name: 'Sara'} 作为 props.Welcome component 返回一个 &lt;h1&gt;Hello, Sara&lt;/h1&gt; 元素.React DOM 高效的更新 DOM 来匹配 &lt;h1&gt;Hello, Sara&lt;/h1&gt; 结果.构建 componentcomponent 可以在其输出中引入关联其他 components。这可以让我们在一个 component 内抽象出一个多层的结构。一个 button，一个 form，一个 dialog 或者一个 screen，在 React app 中他们都统称为 components。例如我们可以创建一个 App component 来渲染多个 Welcome component：const Welcome = (props) =&gt; {
    return &lt;h1&gt; hello, {props.name}&lt;/h1&gt;;
}

const App = () =&gt; {
    return (
        &lt;div&gt;
            &lt;Welcome name='marco' /&gt;
            &lt;Welcome name='tim' /&gt;
            &lt;Welcome name='jone' /&gt;
        &lt;/div&gt;
    )
}
ReactDOM.render(
    &lt;App /&gt;,
    document.getElementById('root')
);以上示例中，没有定义 App 的 props，因为不需要给其传入数据，也是可以的。一般情况下，新建的 React app 只有一个顶层的 App component。拆解 component不要害怕将一个 component 拆解为多个小 components。例如下面这个 Comment component：function Comment(props) {
  return (
    &lt;div className=&quot;Comment&quot;&gt;
      &lt;div className=&quot;UserInfo&quot;&gt;
        &lt;img className=&quot;Avatar&quot;
          src={props.author.avatarUrl}
          alt={props.author.name}
        /&gt;
        &lt;div className=&quot;UserInfo-name&quot;&gt;
          {props.author.name}
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div className=&quot;Comment-text&quot;&gt;
        {props.text}
      &lt;/div&gt;
      &lt;div className=&quot;Comment-date&quot;&gt;
        {formatDate(props.date)}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}它的 props 包含一个 author object，一个 text，一个 data，描述了一个社交网站上一个 commit 的内容。修改这个 component 有点困难，因为它有很多的嵌套，同时也难以复用它的内部组件。下面我们尝试拆解这个 component。首先我们拆解出 Avatar：const Avatar = (props) =&gt; {
    return (
        &lt;img className=&quot;Avatar&quot;
            src={props.user.avatarUrl}
            alt={props.user.name}
        /&gt;
    );
}Avatar 并不需要知道它被用于 commit 中，因此我们修改其 prop 名称为一个更加通用的：user。推荐从 component 本身为出发点命名 props，而不是考虑什么地方使用它。现在我们可以简化 Commit component：function Comment(props) {
    return (
        &lt;div className=&quot;Comment&quot;&gt;
            &lt;div className=&quot;UserInfo&quot;&gt;
                &lt;Avatar user={props.author} /&gt;
                &lt;div className=&quot;UserInfo-name&quot;&gt;
                    {props.author.name}
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div className=&quot;Comment-text&quot;&gt;
                {props.text}
            &lt;/div&gt;
            &lt;div className=&quot;Comment-date&quot;&gt;
                {formatDate(props.date)}
            &lt;/div&gt;
        &lt;/div&gt;
    );
}我们将 props.author 作为 user 数据传入 Avatar component 中。下面我们拆解 UserInfo，其中包含一个 Avatar component：const UserInfo = (props) =&gt; {
    return (
        &lt;div className=&quot;UserInfo&quot;&gt;
            &lt;Avatar user={props.user} /&gt;
            &lt;div className=&quot;UserInfo-name&quot;&gt;
                {props.user.name}
            &lt;/div&gt;
        &lt;/div&gt;
    );
}然后进一步简化 Commit：function Comment(props) {
    return (
        &lt;div className=&quot;Comment&quot;&gt;
            &lt;UserInfo user={props.user} /&gt;
            &lt;div className=&quot;Comment-text&quot;&gt;
                {props.text}
            &lt;/div&gt;
            &lt;div className=&quot;Comment-date&quot;&gt;
                {formatDate(props.date)}
            &lt;/div&gt;
        &lt;/div&gt;
    );
}拆解 component 在开始看起来使工作量变大了，但是在稍微复杂写的 app 中我们就能够利用这些可复用的 components。一条基本准则是：如果 UI 中的某一部分被多次使用，如 button，panel，Avatar等，或者其自身结构比较复杂，如：App, FeedStory, Comment 等，将他们拆解为独立 components 是一个好的选项。props 是只读的当把一个 component 定义为 function 或 class 时，需要注意的是不可以修改 props 的值。考虑下面的 function：function sum(a, b) {
  return a + b;
}以上的 function 被称作 pure 纯粹的，以为它没有尝试修改输入数据。作为对比，下面的就是 impure 不纯粹的 function，因为会尝试修改它的输入数据：function sum(a, b) {
  a = b;
}React 程序有一条限制条件：所有的 React components 都需要是 pure function 来对待 props 数据。当然应用程序的 UI 是随时间动态变化的。下一节我们会介绍 state 的概念。通过 state 可以使 React components 在运行期间修改它们的输出 elements 来响应用户动作，网络响应等。同时不违反上面的那条规则。state 和 lifecycle这一节介绍 React components 中 state 和 lifecycle 的概念。在前一章的示例中，我们通过一个 tick function 在指定时间间隔通过创建新 element 并渲染的方式刷新 UI：const tick = () =&gt; {
    const element = (
        &lt;div&gt;
            &lt;h1&gt;hello world&lt;/h1&gt;
            &lt;h2&gt;{new Date().toLocaleTimeString()}&lt;/h2&gt;
        &lt;/div&gt;
    );

    ReactDOM.render(
        element,
        document.getElementById('root')
    );
}
setInterval(tick, 1000);下面我们介绍通过创建一个封装好的 Clock component，设置定时器并更新其自身。首先我们根据上面的示例创建 Clock component：const Clock = (props) =&gt; {
    &lt;div&gt;
        &lt;h1&gt;hello world&lt;/h1&gt;
        &lt;h2&gt;{props.date.toLocaleTimeString()}&lt;/h2&gt;
    &lt;/div&gt;
}

const tick = () =&gt; {
    ReactDOM.render(
        &lt;Clock date={new Date()} /&gt;,
        document.getElementById('root')
    );
}
setInterval(tick, 1000);在 tick 调用 Clock component 并定义 date prop 的数据供 Clock 使用。但是上面的实现缺乏一个基本需求，那就是 Clock 应该在其自身中定义定时器并每秒刷新数据的。我们想要在渲染时达到如下效果调用 Clock：ReactDOM.render(
  &lt;Clock /&gt;,
  document.getElementById('root')
);为了实现上述功能，需要为 Clock 添加 state。state 类似于 props 但是它是由 component 私有且完全控制的。首先我们需要将 component 转换为 class 模式，转换过程如下：首先创建一个 ES6 class，且继承自 React.Component。添加一个 render() function，将原 component function 的返回元素放入其返回值中在 render() 中用 this.props 代替 propsclass Clock extends React.Component {
    render() {
        return (
            &lt;div&gt;
                &lt;h1&gt;hello world&lt;/h1&gt;
                &lt;h2&gt;{this.props.date.toLocaleTimeString()}&lt;/h2&gt;
            &lt;/div&gt;
        );
    }
}当 update 更新发生时会自动调用 render function。但当我们将 &lt;Clock /&gt; 放入 DOM 后，将只会有一个 Clock object 实例被使用，这就让我们可以使用 state 或 lifecycle 等功能。添加 state下面我们将 date 数据直接放入 CLock component 中。首先将 render 中的 this.props.date 修改为 this.state.date：class Clock extends React.Component {
    render() {
        return (
            &lt;div&gt;
                &lt;h1&gt;hello world&lt;/h1&gt;
                &lt;h2&gt;{this.state.date.toLocaleTimeString()}&lt;/h2&gt;
            &lt;/div&gt;
        );
    }
}然后添加 class constructor 构造器给 this.state 赋初值：class Clock extends React.Component {
    constructor(props) {
        super(props);
        this.state = {date: new Date()}
    }
    render() {
        return (
            &lt;div&gt;
                &lt;h1&gt;hello world&lt;/h1&gt;
                &lt;h2&gt;{this.state.date.toLocaleTimeString()}&lt;/h2&gt;
            &lt;/div&gt;
        );
    }
}注意 class component 总是应该使用 constructor 且初始化参数为 props。child class 有 constructor 时需要调用 super 来初始化 parent class，具体语法参考我的 JavaScript 教程：https://blog.niekun.net/archives/2011.html然后删除渲染到 DOM 中 Clock 的 date prop，以及我们设置的 setInterval 定时器：ReactDOM.render(
    &lt;Clock /&gt;,
    document.getElementById('root')
);修改完成后的完整代码如下：class Clock extends React.Component {
    constructor(props) {
        super(props);
        this.state = {date: new Date()}
    }
    render() {
        return (
            &lt;div&gt;
                &lt;h1&gt;hello world&lt;/h1&gt;
                &lt;h2&gt;{this.state.date.toLocaleTimeString()}&lt;/h2&gt;
            &lt;/div&gt;
        );
    }
}

ReactDOM.render(
    &lt;Clock /&gt;,
    document.getElementById('root')
);下面我们实现 Clock 设置自己的定时器并每秒更新。添加 lifecycle method对于包含很多 components 的程序，但某个 component 不再需要是需要及时释放其占用的资源。我们需要 Clock 第一次在 DOM 中渲染时设置一个 timer 定时器，在 React 中叫做 mounting 载入。同时我们需要当 Clock 在 DOM 中被删除时清除这个定时器，在 React 中叫做 unmounting 卸载。我们可以在 components 载入或载出时通过定义特殊的 method 来运行特定指令：  componentDidMount() {
  }

  componentWillUnmount() {
  }这些 methods 叫做 lifecycle methods。componentDidMount method 会在 component 第一次输出到 DOM 后被自动调用，我们可以将定时器定义在这里：    componentDidMount() {
        this.timerID = setInterval(() =&gt; this.tick(), 1000);
    }这样当 Clock 渲染到 UI 后会自动启动这个定时器。注意使用 this 定义的参数可以在 class 中任意地方被调用。注意 setInterval 中定义的响应动作需要写在 callback 内 () =&gt; {} 中，不要直接写：setInterval(this.tick, 1000)。因为如果要在 callback 调用 method 需要在 constructor 中做如下定义：this.tick = this.tick.bind(this);
componentWillUnmount method 会在 component 将要被删除时自动调用，我们将定时器在这里取消：    componentWillUnmount() {
        clearInterval(this.timerID);
    }接下来我们定义每秒都会自动运行的 tick method，通过 this.setState() 来更新本地 state 中的设置：    tick() {
        this.setState({ date: new Date() });
    }最终的完整代码如下：const React = require('react')
const ReactDOM = require('react-dom')

class Clock extends React.Component {
    constructor(props) {
        super(props);
        this.state = { date: new Date() }
    }

    componentDidMount() {
        this.timerID = setInterval(() =&gt; this.tick(), 1000);
    }

    componentWillUnmount() {
        clearInterval(this.timerID);
    }

    tick() {
        this.setState({ date: new Date() });
    }

    render() {
        return (
            &lt;div&gt;
                &lt;h1&gt;hello world&lt;/h1&gt;
                &lt;h2&gt;{this.state.date.toLocaleTimeString()}&lt;/h2&gt;
            &lt;/div&gt;
        );
    }
}

ReactDOM.render(
    &lt;Clock /&gt;,
    document.getElementById('root')
);现在整个处理流程如下：当 ReactDOM.render() 传入 &lt;Clock /&gt; 后，React 调用 Clock 构造器初始化 state 为一个包含 date 的 object然后 React 调用 Clock 的 render() 查询到需要显示的 UI 元素，然后更新 DOM 以匹配 Clock 的输出当 Clock 的输出嵌入到 DOM 后会调用 componentDidMount，Clock 告诉浏览器设置一个定时器每秒调用 tick()每秒钟调用一次 tick()，这里面 Clock component 通过 setState() 配置了其 UI 更新任务，通过 setState() React 就知道了 state 发生了变化并再次调用 render() 监测需要显示的内容，此时的 this.state.date 和上一次的发生了变化，React 就会更新 DOM 到最新的状态。当 Clock 从 DOM 中删除后，React 会调用 componentWillUnmount 并结束定时器正确使用 state关于 state 的使用需要如下的几点要求。第一点，不要直接修改 state。下面的语法不会触发重新 render 渲染 component：this.state.comment = 'Hello';
正确的语法为使用 setState()：this.setState({comment: 'Hello'});
唯一可以对 state 赋值的是在 constructor 构造器中。第二点，state 更新是异步的。React 为了性能可能会在一次 component update 更新中捆绑多个 setState() 调用，由于 this.props 和 this.state 可能会被异步更新，所以不要依赖他们的数据来计算后续的 state。如下示例可能会错误的更新 counter：this.setState({
  counter: this.state.counter + this.props.increment,
});为了实现是这个需求，使用 setState 的另一种格式：传入一个 function，第一个参数为当前 state，第二个参数为 props 然后内部计算 state 更新：this.setState(function (state, props) {
    return {
        counter: state.counter + props.increment
    };
});第三点，state 更新会合并。当调用 setState() 后，会合并设置的 object 到当前 state 中。如下示例，state 可能包含多个独立的变量：    constructor(props) {
        super(props);
        this.state = {
            posts: [],
            comments: []
        };
    }然后我们可以单独调用 setState() 来分别更新它们：    componentDidMount() {
        fetchPosts().then(response =&gt; {
            this.setState({
                posts: response.posts
            });
        });

        fetchComments().then(response =&gt; {
            this.setState({
                comments: response.comments
            });
        });
    }合并过程是自动完成的，所以通过 setState 修改 comments 只会更新 comments 而不会改变 posts。数据向下传递一个 component 的 child 或 parent 都不会知道当前 component 是包含 state 还是不包含，且不关心是通过 function 还是 class 方式构建的 component。所以 state 被认为是封装的不能够被外界所访问。component 的 state 可以作为 props 向它的 child component 传递：&lt;FormattedDate date={this.state.date} /&gt;
如上所示 FormattedDate 可以接受 date prop，它并不知道数据来自 parent 的 state 还是 props：function FormattedDate(props) {
  return &lt;h2&gt;It is {props.date.toLocaleTimeString()}.&lt;/h2&gt;;
}通常这叫做 top-down 或 unidirectional 数据流。任何 state 都被某个特定 component 所有，state 的数据只能在其 component 的 child 中传递出去。我们通过建立 App component 并构建三个 Clock component 来展示 component 之间是互相独立的：function App() {
    return (
        &lt;div&gt;
            &lt;Clock /&gt;
            &lt;Clock /&gt;
            &lt;Clock /&gt;
        &lt;/div&gt;
    );
}

ReactDOM.render(
    &lt;App /&gt;,
    document.getElementById('root')
);每个 Clock 都有个各自的定时器并独立更新。在 React 中，components 定义为 stateful 还是 stateless 的取决于其在运行中可能的变化，可以在 stateful 的 component 中使用 stateless 的 component，反过来亦可。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/2183.html">
<title>React 入门教程之三 -- 介绍  JSX</title>
<link>https://blog.niekun.net/archives/2183.html</link>
<dc:date>2021-02-24T14:45:12+08:00</dc:date>
<description>请看下面的一个定义：const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;
它既不是一个 string 也不是 html。它叫做 JSX，是一种对 JavaScript 语法的扩展。推荐在 React 中使用 JSX 来描述 UI，它用来创建 React 类型的 elements 然后将其在 DOM 中渲染。下面对 JSX 做一些基本介绍。使用 JSX 的原因React 认同这种观点：渲染逻辑结构和 UI 逻辑结构是原生相互耦合的，events 的处理，状态的变化，数据何时显示等。不同于人为的将 markup 部分和 logic 逻辑部分放在单独的文件，React 的耦合单元叫做 components 可以同时包含 markup 和 logic 部分。React 并不强制要求使用 JSX，但是大部分开发者认为它可以帮助在 JavaScript 中处理 UI 的问题。它也可以帮助 React 显示更多的 error 或 warning 信息。JSX 中使用 JavaScript 表达式下面的示例中，我们声明一个变量并在 JSX 中通过大括号{} 调用变量：const name = 'marco nie';
const element = &lt;h1&gt;hello, {name}&lt;/h1&gt;

ReactDOM.render(
    element,
    document.getElementById('root')
);我们可以将任意的 JavaScript 表达式通过大括号{}放如 JSX 中。例如：1 + 1，user.name 都是有效的 JavaScript 表达式：const city = 'han zhong';
const user = {
    name: 'marco',
    age: 20
}
const element = &lt;h1&gt;hello, {user.name}, from {city}, time: {1 + 20}&lt;/h1&gt;可以将 JSX 分割成多行以提高代码可读性，需要使用小括号包围起来，防止编译器错误的自动添加分行符：const element = (
    &lt;h1&gt;
        hello, {user.name}, from {city}, time: {1 + 20}
    &lt;/h1&gt;
);编译后 JSX 表达式会转换为通用的 JavaScript function 或 objects。这就意味着我们可以在 if 或 for 表达式中，传入数据中或者 返回值中使用 JSX：const testFuc = () =&gt; {
    return &lt;h1&gt;hello, {user.name}&lt;/h1&gt;
}JSX 中定义属性可以使用引号 &quot;&quot; 将一个字符串作为属性：const el1 = &lt;div tabIndex=&quot;0&quot;&gt;&lt;/div&gt;
可以以通过大括号{} 将一个 JavaScript 表达式嵌入属性：const el2 = &lt;img src={user.name}&gt;&lt;/img&gt;
当使用 JavaScript 嵌入属性时不能在大括号中使用引号，同一个属性中只能使用引号嵌入字符串或者大括号嵌入 JavaScript 表达式中的一种。由于 JSX 更加接近于 JavaScript 而不是 html，所以 React 中的 DOM 使用 camelCase 属性命名规范代替 html 中的属性名称，例如 html 元素的 class 属性在 JSX 中定义为 className，tabindex 在 JSX 中为 tabIndex。定义子元素如果一个 tag 元素内容是空的则可以使用 /&gt; 立刻结束定义：const el3 = &lt;img src=''/&gt;
JSX tag 标签内也可以有子元素：const el4 = (
    &lt;div&gt;
        &lt;h1&gt;hello,&lt;/h1&gt;
        &lt;h2&gt;i am your friend&lt;/h2&gt;
    &lt;/div&gt;
);注意只能在一个元素内定义子元素，不能直接定义两个同级的元素否则会报错。防止 injection 注入攻击在 JSX 中嵌入用户输入是安全的：const title = response.potentiallyMaliciousInput;
// This is safe:
const element = &lt;h1&gt;{title}&lt;/h1&gt;;默认情况下 React 在渲染前会将脱开所有嵌入 JSX 中的数据，因此可以确保不会注入任何没有明确定义在应用中的数据。渲染前所有的所有内容都会转换为 string 字符串形式。则能够防止 XSS (cross-site-scripting) 攻击。JSX 表达 objectsBabel 会将 JSX 向下编译为对 React.createElement() 的调用，以下两种定义方法是相同的：const el5 = (
    &lt;h1 className='test'&gt;
        hello world
    &lt;/h1&gt;
);const el6 = React.createElement(
    'h1',
    {className: 'test'},
    'hello world'
)通过 React.createElement() 创建元素会额外做一些语法检查来防止错误代码。但通常我们使用下面语法创建一个 object：const el7 = {
    type: 'h1',
    props: {
        className: 'test',
        children: 'hello world'
    }
}以上方式创建的 object 叫做 React elements。React 使用这些 objects 来构建 DOM 并及时更新。推荐代码编辑器使用 Babel 语法定义环境，这样可以同时支持 ES6 和 JSX 语法结构。设置方法参考：https://babeljs.io/docs/en/editors</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/2176.html">
<title>React 入门教程之二 -- hello world</title>
<link>https://blog.niekun.net/archives/2176.html</link>
<dc:date>2021-02-24T12:40:18+08:00</dc:date>
<description>下面我们通过创建 Create React App 介绍 React 的基本语法。通过上一节介绍的方法创建一个新程序 my-app-1:npx create-react-app my-app-1
cd my-app-1关于创建新项目及可能出现的问题参考上一篇：https://blog.niekun.net/archives/2175.htmlCreate React App 官方教程：https://create-react-app.dev/docs/documentation-intro项目结构程序目录结构如下：my-app-1
├── README.md
├── node_modules
├── package.json
├── .gitignore
├── public
│   ├── favicon.ico
│   ├── index.html
│   ├── logo192.png
│   ├── logo512.png
│   ├── manifest.json
│   └── robots.txt
└── src
    ├── App.css
    ├── App.js
    ├── App.test.js
    ├── index.css
    ├── index.js
    ├── logo.svg
    ├── serviceWorker.js
    └── setupTests.js对于一个项目而言，下面两个文件是必须的:public/index.html 是页面的模板文件;src/index.js 是 JavaScript 入口文件.其他文件可以根据需要添加，删除或重命名。可以在 src 目录下建立子目录，为了加快 build 编译项目的速度，只有在 src 目录下的文件才会被 webpack 处理。所以需要将所有的 js 和 css 文件放在 src 目录下，否则 webpack 打包器不会识别到它们。只有在 public 目录下的文件才会被 public/index.html 文件识别到。所以所有的项目文件都需要放在 public 和 src 目录下，与项目无关的文件可以放在上级路径内，例如项目说明文件等。可用脚本指令在项目目录下，可以执行如下命令。npm start开发模式下运行 app：npm start
打开 http://localhost:3000 可以查看效果。对代码作出修改后页面会自动重新加载。npm test交互模式下运行 test 运行器。更多介绍参考：https://create-react-app.dev/docs/running-testsnpm run build编译项目程序到 build 目录下，会自动将 React 转换为产品模式，并优化项目结构以提高性能。代码是经过 minified 最小化处理过的，文件名都包含 hashes 以在客户端能够及时识别更新。更多 build 参考：https://create-react-app.dev/docs/production-build清理项目默认使用的模板是 cra-template，包含一个基本的页面和 React component，我们先将项目清理掉不需要的内容。打开 public 目录下的 index.html 可以看到 body 块内定义了：&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
index.html 内可以使用 %PUBLIC_URL% 表示 public 目录地址。删除 src 目录内所有文件，并新建 index.js 文件。运行程序：npm start
会自动在浏览器打开项目。hello world最简单的 React 示例如下，将代码加入 index.js 文件：const React = require('react')
const ReactDOM = require('react-dom')

ReactDOM.render(
    &lt;h1&gt;hello world&lt;/h1&gt;,
    document.getElementById('root')
);保存文件后刷新浏览器页面查看效果。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/2175.html">
<title>React 入门教程之一 -- 简介</title>
<link>https://blog.niekun.net/archives/2175.html</link>
<dc:date>2021-02-23T15:39:00+08:00</dc:date>
<description>React 是一个用来创建用户界面的 JavaScript 库。它从一开始就被设计为 gradual adoption 渐进式融入的模式，你可以根据需求使用 React 到你的项目中，无论是使用 React 对你的 html 页面做简单交互，或者完全使用 React 搭建程序。对现有网页加入 React 支持当你需要对现有的网页做一些简单的交互动作时，React 也可以方便的加入进来。下面的示例中我们介绍如何通过 React 给页面添加一个 component 元素。首先给 html 页面添加一个 DOM 元素：&lt;!-- ... existing HTML ... --&gt;
&lt;div id=&quot;like_button_container&quot;&gt;&lt;/div&gt;
&lt;!-- ... existing HTML ... --&gt;然后在 body 块结尾添加 React 模块的 script 脚本标签：  &lt;!-- ... other HTML ... --&gt;

  &lt;!-- Load React. --&gt;
  &lt;!-- Note: when deploying, replace &quot;development.js&quot; with &quot;production.min.js&quot;. --&gt;
  &lt;script src=&quot;https://unpkg.com/react@17/umd/react.development.js&quot; crossorigin&gt;&lt;/script&gt;
  &lt;script src=&quot;https://unpkg.com/react-dom@17/umd/react-dom.development.js&quot; crossorigin&gt;&lt;/script&gt;

  &lt;!-- Load our React component. --&gt;
  &lt;script src=&quot;like_button.js&quot;&gt;&lt;/script&gt;

&lt;/body&gt;前两个 script 加载 React，最后一个是我们加载自定义 component 的代码。如果 script 部署在 CDN 上，推荐加上 crossorigin 属性可以提高加载速度。然后我们使用 React 编写 like_button.js，详细的实现代码我们在后续介绍，最后我们通过下面指令将 React component 加入 html 容器：// ... the starter code you pasted ...

const domContainer = document.querySelector('#like_button_container');
ReactDOM.render(e(LikeButton), domContainer);以上就是将 React component 加入现有网页的过程。缩小 JavaScript 文件尺寸在部署我们的网站前，要注意没有经过缩小化处理的 JavaScript 脚本会导致页面加载缓慢。首先我们将加载 React 的脚本使用缩小化的版本链接：&lt;script src=&quot;https://unpkg.com/react@17/umd/react.production.min.js&quot; crossorigin&gt;&lt;/script&gt;
&lt;script src=&quot;https://unpkg.com/react-dom@17/umd/react-dom.production.min.js&quot; crossorigin&gt;&lt;/script&gt;对于我们自己编写的 React 脚本可以通过工具得到缩小后的版本，这里介绍通过 node.js 的 terser 库来实现：首先安装 node.js在项目目录下运行 npm init -y运行 npm install terser例如需要缩小 like_button.js，在终端运行：npx terser -c -m -o like_button.min.js -- like_button.js
就会在当前目录下得到缩小后的脚本文件 like_button.min.js。创建一个新的 React 程序以上介绍了如何将 React 添加到现有的 html 中，但是通过一套整合的工具链可以得到更好的用户和开发体验。React 团队推荐下面几种解决方案：如果你要学习 React 或者要创建一个单页面 app，推荐使用 Create React App如果你要使用 node.js 创建一个 server-rendered 服务器端渲染的网站，推荐使用 Next.js如果你要建立一个静态内容的网站，推荐使用 GatsbyCreate React AppCreate React App 是学习 React 很好的环境，也是建立单页面 React 应用程序最好的方式。官方网站：https://create-react-app.dev/它会自动设置开发环境是我们可以使用最新的 JavaScript 功能，提供很好的开发体验以及对发布时对程序进行优化。使用下面指令创建并运行一个新项目：npx create-react-app my-app
cd my-app
npm start注意如果你之前使用 npm install -g create-react-app全局安装过 create-react-app，推荐先卸载它 npm uninstall -g create-react-app 从而确保 npx 能够安装最新的版本。node.js 会自动安装 react, react-dom, 和 react-scripts with cra-template。通过 --template 选项可以自定义使用什么模板创建新程序，默认为：cra-template，模板可以在官网搜索：cra-template-*如果安装中报错，可以尝试更新 npm 以及清除缓存，然后再次尝试安装：npm i -g npm@latest
npm cache clean -f
如果在本地开发推荐替换 npm 国内源可以提高下载速度，参考：https://blog.niekun.net/archives/2085.html创建 React App 不会处理后端的数据和逻辑，它只建立前端通道。所以你可以使用任何后端服务。通过 npm start 运行程序后，打开 http://localhost:3000/ 可以查看程序运行效果。当程序需要进行部署时，运行 npm run build 会在 build 目录下创建一个经过最小化代码优化处理的项目包，可以将其部署到服务器。Next.jsNext.js 是一个流行的 React framework 来创建 static 和 server‑rendered 程序。官网：https://nextjs.org/GatsbyGatsby 是通过 React 创建静态网站的最好的工具。它使我们可以使用 React components 但输出预渲染的 html 和 css 以确保页面加载速度。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/2169.html">
<title>node.js 入门教程之十四 -- TypeScript</title>
<link>https://blog.niekun.net/archives/2169.html</link>
<dc:date>2021-02-21T22:02:00+08:00</dc:date>
<description>TypeScript 是微软开发的开源编程语言，在全世界的开发者中流行。本质上来说 typescript 是 JavaScript 的超集，为其添加了很多功能。标志性的就是添加了 static type 静态类型定义，它可以声明期待的数据类型，例如：声明 function 中的期待的传入数据类型，期望的返回值的类型，object 的结构及 property 的数据类型等。typescript 是一个强大的工具，给 JavaScript 项目开启了新的世界。它使我们的代码更加的安全有力，在程序发布前就可以防止很多的 bug 出现。在编写代码期间就能够及时反映出问题点，并且它已经被整合在现代的编译器中，如 VS code。语法说明下面是一个 typescript 代码示例：type User = {
    name: string;
    age: number;
};

function isAdult(user: User): boolean {
    return user.age &gt;= 18;
}

const justine: User = {
    name: 'Justine',
    age: 23,
};

const isJustineAnAdult: boolean = isAdult(justine);首先我们通过 type 关键词定义一个自定义的 object 类型 User，其中定义了 User 的两个 properties 及其数据类型。然后在定义的 function isAudlt 中接收一个参数，此参数类型为 User 类型，然后返回值类型为 boolean 类型。然后我们定义了 justine object 且其类型为 User。在其中定义的两个 properties 也符合 User 中的类型。最后定义了变量 isJustineAnAdult 且其数据类型为 boolean，将 isAudlt 的返回值赋给它。如果我们在编程中没有使用指定的数据类型，typescript 将会给出警告提醒我们错误的地方，比如上面的示例中修改 justine 的 age 为一个字符串：在 vs code 中会提示此处有错误。另一方面也并不需要将所有地方的数据类型都做出声明，typescript 会自动推断出需要的类型。例如：即使我们不给 isJustineAnAdult 声明 boolean 类型，typescript 也会自动推断它是 boolean 类型的。那么如何运行 typescript 代码呢？首先需要通过 npm 安装 typescript，它会安装我们需要的一些可执行程序：npm install typescript
下面我们可以通过 tsc 命令将 typescript 代码转换为标准 JavaScript 代码。我们将上面示例中的代码保存为 demo.ts 文件，然后通过 npx 调用 tsc 命令(如果以 global 方式安装 typescript 则可以直接运行命令)：npx tsc demo.ts
以上命令会转换 JavaScript 代码并自动创建一个 demo.js 文件，此文件可以在 node.js 运行:function isAdult(user) {
    return user.age &gt;= 18;
}
var justine = {
    name: 'Justine',
    age: 23
};
var isJustineAnAdult = isAdult(justine);如果 typescript 代码中包含错误，则使用上面的转换命令会出现报错信息：% npx tsc demo.ts
demo.ts:12:5 - error TS2322: Type 'string' is not assignable to type 'number'.

12     age: '23',
       ~~

  demo.ts:3:5
    3     age: number;
          ~~
    The expected type comes from property 'age' which is declared here on type 'User'


Found 1 error.可以看到 typescript 成功的防止将包含潜在错误代码的程序发布出去。更多介绍除此之外 typescript 也包含了很多其他很好的工具，如：interfaces, classes, utility types 等。更多使用方法参考 typescript 官方文档：https://www.typescriptlang.org/docs。typescript 在 node.js 生态中已经有了很好的发展，且被用于很多开源项目和框架中。以下是一些使用 typescript 的开源项目：NestJS - robust and fully-featured framework that makes creating scalable and well-architected systems easy and pleasantTypeORM - great ORM influenced by other well-known tools from other languages like Hibernate, Doctrine or Entity FrameworkPrisma - next-generation ORM featuring a declarative data model, generated migrations and fully type-safe database queriesRxJS - widely used library for reactive programming总结通过这 14 篇教程，我们介绍了 node.js 的基本语法和相关使用场景。后期可以在具体项目中进行更加详细的体验。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/2165.html">
<title>node.js 入门教程之十三 -- environment，error handler 和 log object</title>
<link>https://blog.niekun.net/archives/2165.html</link>
<dc:date>2021-02-20T17:19:00+08:00</dc:date>
<description>environment 运行环境production environment 产品环境和 development environment 开发环境可以设置不同的配置。node.js 默认为 development env 开发环境。通过设置环境变量：NODE_ENV=production 可以告诉 node.js 当前为产品环境。Linux 中可以通过如下指令修改：export NODE_ENV=production
这样在当前 shell 中就会以 production 模式运行 node 程序，如果要永久修改此环境变量可以将命令写入 ~/.bashrc 文件。也可以在运行 node 程序时定义 NODE_ENV：NODE_ENV=production node app.js

设置 NODE_ENV 为 production 有如下优势：日志记录保持在最小 level更多的 caching 缓存级别来提高运行效率可以通过状态判读符来判断当前运行环境，执行不同指令：if (process.env.NODE_ENV === 'development') {
    console.log('running on development environment')
}
if (process.env.NODE_ENV === 'production') {
    console.log('running on production environment')
}
if (['production', 'staging'].indexOf(process.env.NODE_ENV) != -1) {
    console.log('running on production environment')
} else {
    console.log('running on development environment')
}上面第三个指令通过调用 array 的 indexOf 来获取某个字符串在数组中的索引号，如果不存在这个字符串则返回 -1。注意使用类型判断符=== 是为了保证类型和数值都匹配。error handling 错误处理node.js 中通过 exceptions 来处理 error 情况。可以通过 throw 创建一个 exception：const test = 123;
throw test;当 JavaScript 执行到上面的 throw 时程序会立刻停止，然后控制权会交给最近的 exception handler 例外控制器。JavaScript 中 test 可以是任意的字符串，数字或者 object。但在 node.js 中只用来 throw Error objects。一个 error object 可以是 Error 的实例或者是 Error class 的 child class 的实例：throw new Error('error')

class childError extends Error {
}
throw new childError('error')下面介绍几种 exception handler 处理器。第一种是通过 try/catch 声明来处理，在 try 中定义任意 exception 以及对应的 catch 块来响应：try {
    const a = 1;
    if (a == 0) {
        throw 'abc'
    } else {
        throw 123
    }
} catch (e) {
    console.log(e)
}catch 的参数 e 就是对应 throw 的数据。如果在程序执行中，如果某个 throw 的 exception 没有被 catch，程序就会立刻 crash。可以通过监听 process 的 uncaughtException event 事件来解决这个问题：process.on('uncaughtException', err =&gt; {
    console.log('there was a uncaught error: ', err.message)
    process.exit(1)
})

throw new Error('error')第二种是 promise 中的 error handler。使用 promise 可以将多个操作过程组合成链，在链的最后处理 error 情况，下面是一个简单示例：let a = 0;
let b = 0;

const doSomething1 = new Promise((resolve, reject) =&gt; {
    if (a == 0)
        resolve('resolve 1')
    else
        reject('reject 1')
})

const doSomething2 = (data) =&gt; {
    return new Promise((resolve, reject) =&gt; {
        if (b == 0)
            resolve(data + ' : resolve 2')
        else
            reject('reject 2')

    })
}

doSomething1
    .then(doSomething2)
    .then(res =&gt; console.log(res))
    .catch(rej =&gt; console.log(rej))当 doSomething1 为 resolve 时会执行 doSomething2()，为 reject 时会直接进入 catch 块。同样的 doSomething2 返回的 promise 为 reject 时也会进入 catch 块。此时通过输出的信息可以知道是在哪一个 promise 链响应了 exception。第三种是 async/await 的 error handling。使用 async/await 也是通过 try/catch 来处理 exception 情况的：let a = 1;
const demo = new Promise((resolve, reject) =&gt; {
    if (a == 0) {
        setTimeout(resolve, 1000, 'resolve');
    } else {
        reject('reject')
    }
})

const test = async() =&gt; {
    try {
        const data = await demo
        console.log(data)
    } catch (error) {
        console.log(error)
    }
}
test()

//output:
//reject当 demo promise 为 reject 时会响应 test() 中的 catch 块。日志输出 object当我们在浏览器中使用 console.log() 输出某个 object 时，会得到一个很好的效果：点击箭头可以展开日志，完整地展示 object 的 properties：在 node.js 中和浏览器有所不同，它是将 object 的内容以字符串的形式输出到终端或者日志文件中。对于简单的 object 来说没有什么问题，但是对于包含超过 2 层嵌套以上的 object 来说 node.js 就会放弃输出所有内容而用一个 [Object] 占位符表示剩余内容：const obj = {
    name: 'joe',
    age: 35,
    person1: {
        name: 'Tony',
        age: 50,
        person2: {
            name: 'Albert',
            age: 21,
            person3: {
                name: 'Peter',
                age: 23
            }
        }
    }
}
console.log(obj)输出结果为：{
  name: 'joe',
  age: 35,
  person1: {
    name: 'Tony',
    age: 50,
    person2: { name: 'Albert', age: 21, person3: [Object] }
  }
}可以看到第三层的内容已经用 [Object] 取代。强制要求输出 object 所有内容的最好的方法就是使用 JSON.stringify()：console.log(JSON.stringify(obj, undefined, 2))输出如下：{
  &quot;name&quot;: &quot;joe&quot;,
  &quot;age&quot;: 35,
  &quot;person1&quot;: {
    &quot;name&quot;: &quot;Tony&quot;,
    &quot;age&quot;: 50,
    &quot;person2&quot;: {
      &quot;name&quot;: &quot;Albert&quot;,
      &quot;age&quot;: 21,
      &quot;person3&quot;: {
        &quot;name&quot;: &quot;Peter&quot;,
        &quot;age&quot;: 23
      }
    }
  }
}第一个参数定义需要输出的 object，第二个参数是定义一个 function 用来转换字符串内容也可以不定义，第三个是定义缩进量。</description>
</item>
</rdf:RDF>