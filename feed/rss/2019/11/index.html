<?xml version="1.0" encoding="UTF-8"?>
<rdf:RDF
xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
xmlns="http://purl.org/rss/1.0/"
xmlns:dc="http://purl.org/dc/elements/1.1/">
<channel rdf:about="https://blog.niekun.net/feed/rss/2019/11/">
<title>Marco Nie - 2019年11月</title>
<link>https://blog.niekun.net/2019/11/</link>
<description>you are the company you keep...</description>
<items>
<rdf:Seq>
<rdf:li resource="https://blog.niekun.net/archives/548.html"/>
<rdf:li resource="https://blog.niekun.net/archives/547.html"/>
<rdf:li resource="https://blog.niekun.net/archives/546.html"/>
<rdf:li resource="https://blog.niekun.net/archives/544.html"/>
<rdf:li resource="https://blog.niekun.net/archives/543.html"/>
<rdf:li resource="https://blog.niekun.net/archives/539.html"/>
<rdf:li resource="https://blog.niekun.net/archives/534.html"/>
<rdf:li resource="https://blog.niekun.net/archives/526.html"/>
<rdf:li resource="https://blog.niekun.net/archives/525.html"/>
<rdf:li resource="https://blog.niekun.net/archives/524.html"/>
</rdf:Seq>
</items>
</channel>
<item rdf:about="https://blog.niekun.net/archives/548.html">
<title>胶卷底片复原照片 in Photoshop</title>
<link>https://blog.niekun.net/archives/548.html</link>
<dc:date>2019-11-28T19:55:47-05:00</dc:date>
<description>过去胶卷时代，相机拍摄的胶卷底片需要冲洗才能得到最后的照片，如果你手头有一些底片，可以使用 Photoshop 还原成真实照片。首先将底片放置着白色发光底板上，可以使用手机当作底板，尽量使用好的拍照设备拍摄底片：导入 ps 建立 invert 图层反转图像，可以看到图片基本转换为了正常的色彩亮度：新建曲线图层，使用左侧 middle tone 工具，拾取图片应该是中间调灰度的地方来调整白平衡等色彩信息：配合 alt 键，调节滑块左右，调整高光阴影，曲线调节对比度：根据情况，增加 color balance 图层，精细调节色彩：剪裁出有效图片：</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/547.html">
<title>Linux 管道命令的使用</title>
<link>https://blog.niekun.net/archives/547.html</link>
<dc:date>2019-11-27T01:36:24-05:00</dc:date>
<description>配合 Linux 管道符，可以根据情况执行多条命令，常用的符号有：'|' '&&' ';' '||' '&gt;' '&gt;&gt;'|管道符 "|" 主要用来将上一个命令的输出作为下一个命令的输入。例如：ps aux | grep test.sh
将当前所有进程信息作为输出信息，grep 将输出的内容作为输入，列出有 "test.sh" 的行。可同时使用多条管道：cat /etc/passwd | grep /bin/bash | wc -l
这条命令使用了两个管道，利用第一个管道将cat命令（显示passwd文件的内容）的输出送给grep命令，grep命令找出含有“/bin /bash”的所有行；第二个管道将grep的输出送给wc命令，wc命令统计出输入中的行数。这个命令的功能在于找出系统中有多少个用户使用bash。多命令顺序执行符;     命令1;命令2    多个命令顺序执行，命令之间无任何逻辑关系
&amp;&amp;    命令1&amp;&amp;命令2   逻辑与：当命令1正确执行后，命令2才会正确执行，否则命令2不会执行
||    命令1||命令2   逻辑或：当命令1不正确执行后，命令2才会正确执行，否则命令2不会执行例如：pwd;ls;date
ls test.sh &amp;&amp; echo found file
ls test.sh || echo no file
重导向重导向就是使命令改变它所认定的标准输出。'&gt;' 可将结果输出到文件中，该文件原有内容会被删除，'&gt;&gt;' 则将结果附加到文件中，原文件内容不会被删除。将 file1.txt 的内容复制到 file2.txt，file2.txt 原内容会被清空。cat file1.txt &gt; file2.txt
将 file1.txt 的内容附加到 file2.txt，file2.txt 原内容保留。cat file1.txt &gt;&gt; file2.txt
</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/546.html">
<title>grep 全局匹配打印命令 in Linux</title>
<link>https://blog.niekun.net/archives/546.html</link>
<dc:date>2019-11-27T01:15:56-05:00</dc:date>
<description>grep: global regular expression print常用来查找包含特定字符串的文件所在行并显示，也可以配合管道符：| 来有条件的过滤显示终端输出内容。安装apt-get install grep
使用查找当前目录下后缀有 file 文件中包含 test 字符串的文件，并打印出该字符串的行：grep test file
查找当前目录下文件名包含 file 的所以文件：grep test *file*
查找目录及其子目录中所有文件包含 test 字符串的文件，并打印出该字符串的行：grep -r test /path
忽略字符串匹配大小写：-igrep -i &quot;test&quot; file
字符串匹配完整 word，不匹配 word 内字符串：-wgrep -w &quot;is&quot; file
上面命令不会匹配：his this 等单词。配合其他命令过滤结果可以使用管道符：| 将其他命令的输出作为处理对象例如：ps aux | grep file.sh
输出当前进程中包含 file.sh 的行，即可查看 file.sh 当前执行信息。</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/544.html">
<title>tar 打包/压缩 in Linux</title>
<link>https://blog.niekun.net/archives/544.html</link>
<dc:date>2019-11-26T20:42:00-05:00</dc:date>
<description>tar 是 Linux 下常用的处理打包或压缩的常用命令，常用来处理后缀名为：tar, tar.gz tar.bz2 的文件。tar：存档格式，未经过压缩tar.gz：在tar基础上进行 gzip 压缩，tar.gz 和 tgz 类似tar.bz2：比 gzip 压缩比更高，但更耗时， tar.bz2，tbz 和 tb2 类似语法tar [options] [archive-file] [file or directory to be archived]
-c : 建立存档-x : 解压存档-f : 指定文件名-t : 列出文档内容-u : archives and adds to an existing archive file-v : 显示处理过程信息-z : zip, 指定处理 gzip-j : 指定处理 tbzip-W : 验证存档-r : 添加文件/文件夹到已知存档打包存档tar：tar -cvf test.tar /home/test
tar.gz：tar -zcvf test.tar.gz /home/test或tar -zcvf test.tgz /home/test
tar.bz2：tar -jcvf test.tar.bz2 /home/test或tar -jcvf test.tar.tb2 /home/test或tar -jcvf test.tar.tbz /home/test
将文件/文件夹添加到存档tar -rvf test.tar file
tar -rvf test.tar.gz file
tar -rvf test.tar.zb2 file
解压存档tar：tar -xvf test.tar
解压到特定目录：-Ctar -xvf test.tar -C /home/path/
tar.gz:tar -zxvf test.tar.gz
解压到特定目录：-Ctar -zxvf test.tar.gz -C /home/path/
tar.bz2：tar -jxvf test.tar.bz2
解压到特定目录：-Ctar -jxvf test.tar.bz2 -C /home/path/
解压存档部分文件/文件夹解压单个文件：tar -xvf test.tar file.sh
tar -zxvf test.tar.gz file.sh
tar -jxvf test.tar.zb2 file.sh
解压多个文件：tar -xvf test.tar &quot;file1&quot; &quot;file2&quot;
tar -zxvf test.tar.gz &quot;file1&quot; &quot;file2&quot;
tar -jxvf test.tar.zb2 &quot;file1&quot; &quot;file2&quot;
解压特定名字的文件：tar -xvf test.tar --wildcards '*.php'
tar -zxvf test.tar.gz --wildcards '*.php'
tar -jxvf test.tar.zb2 --wildcards '*.php'
list 存档内容tar -tvf test.tar
tar -tvf test.tar.gz
tar -tvf test.tar.zb2
验证存档只能验证 tar 打包的存档：-Wtar tvfW test.tar
检查存档大小sizetar czf file.tar | wc -c
tar czf file.tar.gz | wc -c
tar czf file.tar.tbz | wc -c
</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/543.html">
<title>Linux 查询程序或文件位置 which/find/locate</title>
<link>https://blog.niekun.net/archives/543.html</link>
<dc:date>2019-11-25T22:42:00-05:00</dc:date>
<description>经常忘记将一些文件放在什么，或者安装一个应用程序后不知道准确的安装路径。使用命令可以进行查询：whichwhich python
which 命令可用来查询 app 安装位置，返回值为路径。findfind / -name file -type f
斜线：/ 代表从系统根目录查找，也可以定义特定的目录开始搜索-name：代表只找文件名匹配，不找文件内的字符串-iname：代表文件名不区分大小写-type：搜索的文件类型 f 代表只找文件不找文件夹匹配，l 代表软链接文件-mtime：指定查找日期天数-exec：查找后执行 command 命令，注意最后要有分号 ;例如，查找指定目录三天前的文件，然后删除文件：find /temp/* -mtime +2 -exec rm -rf {} \;
-mtime 使用加号 + 代表指定日期前查找，减号 - 代表指定日期内查找。查找天数为取整关系，例如 2.5 天前的文件会被包含在 -mtime -2 内而不在 -mtime +2 内。-exec 指令后跟需要执行的命令。查询已知文件名的文件的所有位置，find 命令直接从文件系统 filesystem 查找文件，速度可能会比较慢，但优点是找到的文件当前肯定在系统内。locatelocate 用来根据文件名寻找文件，它和 find 命令不同点是，find 从当前文件系统直接查找匹配，而 locate 命令会有一个背景进程，记录当前所有文件名到一个数据库文件中，当新建或删除一个文件时会动态更新这个数据库。当使用 locate 命令查找文件时，会从这个数据库里查找，这样速度会相比 find 快很多。语法：locate [option] strFile
strFile：将匹配所有包含此字符串的文件option：-i：不区分大小写-c：输出匹配到的文件的个数对于一些刚刚建立的文件，可能数据库没有更新到，所以无法通过命令查找到，这时候可以手动更新数据库：sudo updatedb
</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/539.html">
<title>使用 frp 实现内网穿透/远程管理</title>
<link>https://blog.niekun.net/archives/539.html</link>
<dc:date>2019-11-25T07:34:00-05:00</dc:date>
<description>首先判断自己网络 IP 地址是固定 IP/动态 IP/内网 IP，通过站长工具可以查询，或者终端执行如下指令查看外网看本地 IP 地址：curl https://info.niekun.net/ip
然后从本地通过 ipconfig(win)/ifconfig(linux) 来查看网络路径，如果本地 IP 和上面检测出的一致，那就是有外网 IP，如果不一样则很可能自己分配到的是一个运营商内网。如下是我本地 Windows 电脑的结果，确认是内网：对于有外网 IP 但是是动态的，每隔一段时间自动变化的情况，可以使用 DDNS 来处理。对于大多数家庭网络用户，都没有固定的 IP 地址或者也没有动态的 IP 地址，在本地搭建网络服务无法直接在外网访问，使用 frp 可以实现这一需求。使用场景：路由器远程访问 远程访问/控制电脑 网搭建网站公网访问项目地址：https://github.com/fatedier/frp使用手册：https://github.com/fatedier/frp/blob/master/README_zh.mdWindows 脚本参考：https://sspai.com/post/52523环境需求：一台有独立 IP 的服务器可安装 frp 的本地主机或路由器(windows/linux)安装从 release 页面分别下载合适版本的最新程序到客户端和独立 IP 的服务端。程序内包含服务端程序(frps)及客户端程序(frpc)，以及对应配置文件。使用服务器端修改 frps.ini 文件，示例：[common]
# 服务端和客户端的 common 配置中的 token 参数一致则身份验证通过
token=12345678

# 服务端本地地址和客户端握手端口，bind_port 设置同 server_port
bind_addr = 0.0.0.0
bind_port = 6000

# udp 内网穿透端口
bind_udp_port = 6001

# kcp 协议端口，可以和 bind_port 一样，不设置的话不开启
kcp_bind_port = 6000

# http 和 https web 服务访问端口，如：test.com:8080，即可访问内网 web 页面
vhost_http_port = 6002
vhost_https_port = 6003

# frp状态面板端口，用来显示一些连接状态的 web 页面，0.0.0.0 表示开放给外网访问
dashboard_addr = 0.0.0.0
dashboard_port = 6004

# 设置面板的账户密码访问，不设置默认为 admin
dashboard_user = admin
dashboard_pwd = admin

# 日志记录文件定义，不写则不记录
log_file = ./frps.log
log_level = info
log_max_days = 3
disable_log_color = false

# 为给客户端开放的端口，用于和客户端数据交互，如不设置此条目，则默认开放所有端口
allow_ports = 6000-6100,8000

# 如果想要通过域名访问 http/https web 服务，需要在服务端指定服务器的域名
subdomain_host = niekun.net执行以下命令启动：./frps -c ./frps.ini
客户端修改 frpc.ini 文件，示例：[common]
# 服务端和客户端的 common 配置中的 token 参数一致则身份验证通过
token=12345678

# 远程独立 IP 地址
server_addr = xxx.xxx.xxx.xxx

# 和服务端握手端口，bind_port 设置同 server_port
server_port = 6000

# 日志记录文件定义，不写则不记录
log_file = ./frpc.log
log_level = info
log_max_days = 3
disable_log_color = false

# 查看 frpc 客户端配置文件等信息的 web 地址
admin_addr = 127.0.0.1
admin_port = 6005
admin_user = admin
admin_pwd = admin

# 定义链接服务器的协议，支持 tcp，kcp，websocket, default is tcp
protocol = kcp

#加密连接服务端
tls_enable = true

# ssh 是自定义代理块标记，可以是任意的名称
[ssh]

# tcp | udp | http | https | stcp | xtcp, default is tcp
type = tcp

# 客户端 ssh 服务的地址和端口
local_ip = 127.0.0.1
local_port = 22

# 远程 frps 连接地址
remote_port = 6006

# 和 frps 的数据是否加密，默认 false
use_encryption = false

# if true, 数据会被压缩传输
use_compression = false

# remote disktop 远程桌面设置
[rdp]
type = tcp
local_ip = 127.0.0.1

# 远程访问端口是3389
local_port = 3389

remote_port = 6010

use_encryption = true
use_compression = true

# web 服务
[web01]

# 支持 http https
type = http

# 客户端 http 页面的地址和端口
local_ip = 127.0.0.1
local_port = 80

use_encryption = false
use_compression = true

# 如果服务端域名为 niekun.net, 可以通过链接访问 web01: http://web01.niekun.net:8080，此子域名需要在域名服务商处进行 DNS 解析
subdomain = web01

# custom_domains 为 域名/服务器 IP 如果上面定义了 subdomain 此处可以不要
#custom_domains = web01.niekun.net/IP

# 如访问 web 页面是不需要密码则去掉 客户端 http_user 及 http_pwd
http_user = xxxx
http_pwd = xxxxxxxxxxx

# https web 示例
[web02]
type = https

# 客户端 https 页面的地址和端口
local_ip = 127.0.0.1
local_port = 443

use_encryption = false
use_compression = false

subdomain = web02

# if not empty, frpc will use proxy protocol to transfer connection info to your local service
# v1 or v2 or empty
proxy_protocol_version = v2执行以下命令启动：./frpc -c ./frpc.ini
测试访问内网 sshssh -oPort=6006 username@x.x.x.x
IP 为远程服务器的 IP，username 为内网设备的用户名。输入后提示密码，也为内网设备 ssh 密码。web 服务http://web01.niekun.net:6002
如果设置有用户名密码，会提示口令，然后进入 web 页面。frps 控制面板http://xxx.xxx.xxx.xxx:6004
服务端 nginx 代理 frp我服务器上使用 nginx 管理 http 请求，可以使用 nginx 代理 frp 的 http 服务。这样可以实现不带端口访问 frp 和使用 nginx 上已经设置的 https 加密而不需要单独给 frp 配置 https。客户端和服务端使用上面示例的配置，web01 页面可通过：http://web01.niekun.net:6002 访问。下面我们设置 nginx 代理服务：server {
    listen        443 ssl http2;
    listen        [::]:443 ssl http2;
    server_name   frp.niekun.net;
    include       my-server/ssl; ssl 配置文件

    location / {
        proxy_pass          http://127.0.0.1:6004;
        proxy_redirect      off;
    }
}

server {
    listen        443 ssl http2;
    listen        [::]:443 ssl http2;
    server_name   web01.niekun.net;
    include       my-server/ssl;

    location / {
        proxy_pass          http://127.0.0.1:6002;
        proxy_redirect      off;

        proxy_set_header    Host              $http_host;
        proxy_set_header    X-Real-IP         $remote_addr;
        proxy_set_header    X-Forwarded-For   $proxy_add_x_forwarded_for;
        proxy_set_header    X-Forwarded-Proto $scheme;
        proxy_set_header    Upgrade           $http_upgrade;
        proxy_set_header    Connection        &quot;upgrade&quot;;
        proxy_http_version  1.1;
    }
}我的 https 配置文件放在 my-server/ssl 文件内。第一个 server 配置了 frp.niekun.net 域名转发给 frps 控制面板端口 6004，这样访问：https://frp.niekun.net 就可以访问 frps 控制面板。第二个 server 配置了 web01.niekun.net 域名转发给 frps 监听的 http 端口 6002，访问：https://web01.niekun.net 就可以访问内网的 web01 页面了。proxy_set_header 设置转发给 frps 的请求头，有些网页如果缺少一些请求头信息会报错。更详细的 nginx 代理服务器的使用参考我的文章：NGINX Reverse Proxy 反向代理的使用注意：由于 rdp 是 tcp 协议，所以不能通过 nginx 代理使用域名进行访问。nginx 和 frp 的更多配合方式参考示例：https://github.com/raymond9zhou/frps-nginx-httpsWindows 运行脚本及自启动Windows 下可以写一个 bat 脚本，双击直接后台运行命令：@echo off
if &quot;%1&quot; == &quot;h&quot; goto begin
mshta vbscript:createobject(&quot;wscript.shell&quot;).run(&quot;&quot;&quot;%~nx0&quot;&quot; h&quot;,0)(window.close)&amp;&amp;exit
:begin
REM
cd C:\frp
frpc -c frpc.ini
exit上面的 frp 地址修改为实际地址，程序会在后台运行，想要关闭可以在任务管理器中结束进程： frpc.exe将脚本快捷方式放到开机启动文件夹可以实现开机自启动，Windows 10 自启文件夹地址是：%APPDATA%\Microsoft\Windows\Start Menu\Programs\Startup以上就是 frp 的简单使用，高级用法参考官方手册。详细配置文件：frps：https://github.com/fatedier/frp/blob/master/conf/frps_full.inifrpc：https://github.com/fatedier/frp/blob/master/conf/frpc_full.ini</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/534.html">
<title>cat 命令 in Linux</title>
<link>https://blog.niekun.net/archives/534.html</link>
<dc:date>2019-11-18T08:48:00-05:00</dc:date>
<description>cat 是 Linux 下常用的一个命令。主要功能是：显示文件内容/新建文件/合并文件输出文件内容到终端输出一个文件：cat file1
输出多个文件：cat file1 file2
输出文件内容，显示行号：cat -n song.txt

1  &quot;Heal The World&quot;
2  There's A Place In
3  Your Heart
4  And I Know That It Is Love
5  And This Place Could行尾和空行显示 $:cat -e test

hello everyone, how do you do?$
$
Hey, am fine.$
How's your training going on?$
$新建文件：新建空文件：cat /dev/null &gt; file
将文件复制到新文件：cat file1 &gt; file2
将文件复制添加到文件末尾：cat file1 &gt;&gt; file2
将多个文件合并到一个文件：cat file1 file2 file3 &gt; file_new
cat file* &gt; file_new</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/526.html">
<title>Linux kernel 内核相关</title>
<link>https://blog.niekun.net/archives/526.html</link>
<dc:date>2019-11-17T09:36:00-05:00</dc:date>
<description>Linux内核（英语：Linux kernel），是一种开源的类Unix操作系统宏内核。如果你在安装新硬件后遇到：网卡不能使用，亮度不能调节，触摸板不能识别，蓝牙不能使用等等，这些关系都和linux的内核有关系。Kernel 是 Linux 系统的核心，主要负责硬件的支持。Linux 内核提供了安全补丁，bugfix 和新特性。参考链接：https://linux.cn/article-10103-1.htmlhttps://www.cyberciti.biz/faq/installing-latest-stable-mainline-linux-kernel-on-ubuntu-with-apt-get/Ubuntu 不同版本系统支持内核情况：https://wiki.ubuntu.com/Kernel/Support查看当前运行内核：uname -r

4.4.0-124-genericLinux 内核版本号由 3 组数字组成：第一个组数字。第二组数字。第三组数字第一个组数字：目前发布的内核主版本。第二个组数字：偶数表示稳定版本；奇数表示开发中版本。第三个组数字：错误修补的次数。查看当前设备已安装的内核：dpkg --get-selections| grep linux

libselinux1:amd64                               install
linux-firmware                                  install
linux-generic-lts-xenial                        install
linux-headers-4.4.0-124                         install
linux-headers-4.4.0-124-generic                 install
linux-headers-generic-lts-xenial                install
linux-image-4.4.0-116-generic                   deinstall
linux-image-4.4.0-119-generic                   deinstall
linux-image-4.4.0-121-generic                   deinstall
linux-image-4.4.0-124-generic                   install
linux-image-4.4.0-31-generic                    deinstall
linux-image-extra-4.4.0-116-generic             deinstall
linux-image-extra-4.4.0-119-generic             deinstall
linux-image-extra-4.4.0-121-generic             deinstall
linux-image-extra-4.4.0-124-generic             install
linux-image-extra-4.4.0-31-generic              deinstall
linux-image-generic-lts-xenial                  install
linux-libc-dev:amd64                            install
python-selinux                                  install
selinux-policy-default                          install
selinux-utils                                   install
util-linux                                      install可以看到一台设备可以安装多个内核，但只能使用一个。apt 安装内核apt 安装首先搜索可用内核：apt-get update
apt-cache search linux-generic
在输出的结果中，找到合适的内核版本进行安装：apt-get install linux-image-4.10.0-27-generic
清空下载的 deb 安装包文件，重启系统：rm *.deb
sudo reboot
重启后查看内核版本：uname -r
此方法一般无法安装最新版内核。apt 卸载内核首先使用以上命令查看当前已安装的内核，然后卸载：dpkg --get-selections| grep linux
sudo apt-get purge -f xxx
切换内核版本一个系统可以同时安装多个内核，但是运行时只能选择一个，当启动电脑时，在显示 grub 菜单时可以选择加载哪一个内核。（当只有一个系统安装时，grub 菜单可能被跳过，强制显示 grub 菜单可以在启动电脑时一直按住 Shift 按键）从 kernel 官网安装内核官网：https://www.kernel.org/以上官网列出的多个版本内核代表意义不同：5.3.11 是最新的稳定版4.19.84 是最新的 LTS 版本4.14.154、4.9.202、以及 4.4.202 是仍然处于维护状态的老的 LTS 版本建议使用的内核的分级，从最佳的方案到最差的方案如下：你最喜欢的 Linux 发行版支持的内核最新的稳定版最新的 LTS （长期支持）版本仍然处于维护状态的老的 LTS 版本绝对不要去使用的内核：不再维护的内核版本下载安装首先根据自己 Linux 系统版本，找到合适的可安装的最高版本内核：https://wiki.ubuntu.com/Kernel/Support了解到需要安装的内核后，进入一下官方网站找到需要版本内核的目录进入：https://kernel.ubuntu.com/~kernel-ppa/mainline/下载对应版本的 deb 安装包：wget https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.3.11/linux-headers-5.3.11-050311_5.3.11-050311.201911121635_all.deb
wget https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.3.11/linux-headers-5.3.11-050311-generic_5.3.11-050311.201911121635_amd64.deb
wget https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.3.11/linux-image-unsigned-5.3.11-050311-generic_5.3.11-050311.201911121635_amd64.deb
wget https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.3.11/linux-modules-5.3.11-050311-generic_5.3.11-050311.201911121635_amd64.deb
安装：dpkg -i *.deb
如果安装过程报错，需要立刻卸载掉已安装的相关新内核部分：dpkg --get-selections| grep linux
sudo apt-get purge -f xxx
如果安装顺利完成，重启系统：reboot
查看内核版本：uname -r

</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/525.html">
<title>Linux 命令行 换行符</title>
<link>https://blog.niekun.net/archives/525.html</link>
<dc:date>2019-11-17T08:25:18-05:00</dc:date>
<description>当需要输入一段很长的命令时，为了书写或查看方便，可以对命令分割换行处理，使用换行符 \例如：sudo apt-get install --install-recommends -y \
linux-generic-lts-xenial等价于：sudo apt-get install --install-recommends -y linux-generic-lts-xenial</description>
</item>
<item rdf:about="https://blog.niekun.net/archives/524.html">
<title>github page build failed 问题修复</title>
<link>https://blog.niekun.net/archives/524.html</link>
<dc:date>2019-11-17T07:40:00-05:00</dc:date>
<description>在使用 github page 时可能会遇到提示 build failed 的问题，但是在本地加载页面没有问题，原因是 当你没有使用 Jekyll 建立网站时，github page 会错误的将一些 characters, specifically curly braces, as jekyll objects, tags, etc.，导致错误。最简单的办法是在仓库根目录建立一个 .nojekyll 文件，让 github page 在 build 时跳过 Jekyll。参考：https://github.community/t5/GitHub-Pages/GitHub-Pages-Builds-Fail/td-p/29172</description>
</item>
</rdf:RDF>