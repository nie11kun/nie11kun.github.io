<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
xmlns:content="http://purl.org/rss/1.0/modules/content/"
xmlns:dc="http://purl.org/dc/elements/1.1/"
xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
xmlns:atom="http://www.w3.org/2005/Atom"
xmlns:wfw="http://wellformedweb.org/CommentAPI/">
<channel>
<title>Marco Nie - 2021年1月</title>
<link>https://blog.niekun.net/2021/01/</link>
<atom:link href="https://blog.niekun.net/feed/2021/01/" rel="self" type="application/rss+xml" />
<language>zh-CN</language>
<description>you are the company you keep...</description>
<lastBuildDate>Thu, 28 Jan 2021 08:17:25 +0800</lastBuildDate>
<pubDate>Thu, 28 Jan 2021 08:17:25 +0800</pubDate>
<item>
<title>创建新文件 in Linux</title>
<link>https://blog.niekun.net/archives/2086.html</link>
<guid>https://blog.niekun.net/archives/2086.html</guid>
<pubDate>Thu, 28 Jan 2021 08:17:25 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[下面介绍几种常用的命令行创建新文件的方法。touch：touch test1.txt&gt;:&gt; test2.txtcat:cat /dev/null &gt; test3.txtecho...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>下面介绍几种常用的命令行创建新文件的方法。</p><p><strong>touch</strong>：</p><pre><code>touch test1.txt
</code></pre><p><strong>&gt;</strong>:</p><pre><code>&gt; test2.txt
</code></pre><p><strong>cat</strong>:</p><pre><code>cat /dev/null &gt; test3.txt
</code></pre><p><strong>echo</strong>:</p><pre><code>echo &gt; test4.txt
</code></pre><p><strong>vim</strong>:</p><pre><code>vim test5.txt
:wq
</code></pre><p>使用中选择最简单的方式即可。</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2086.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/2086.html</wfw:commentRss>
</item>
<item>
<title>node.js 入门教程之三 -- npm</title>
<link>https://blog.niekun.net/archives/2085.html</link>
<guid>https://blog.niekun.net/archives/2085.html</guid>
<pubDate>Tue, 26 Jan 2021 15:45:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[调用 node.js 文件node.js 有内建的 module system 模块系统，一个node.js 文件可以导入其他 node.js 文件内定义的功能。语法如下：const libra...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<h3>调用 node.js 文件</h3><p>node.js 有内建的 module system 模块系统，一个node.js 文件可以导入其他 node.js 文件内定义的功能。</p><p>语法如下：</p><pre><code>const library = require('./libs')</code></pre><p>和导入其他第三方模块类似使用 <strong>require</strong> 指令，需要指定 node.js 文件路径。以上示例表示导入当前目录下的 <strong>libs.js</strong> 文件。</p><p>js 文件中默认定义的 objects 等元素是私有的，不能够被外部使用。在被导入的文件中，需要在引用前 expose 暴漏出需要被外部使用的功能。需要使用到 module system 的 <strong>module.exports</strong> API 来实现。</p><!--more--><p>当给一个 <strong>object</strong> 或 <strong>function</strong> 赋予 <strong>exports</strong> 属性时，就表明这些元素可以暴漏给外部。<strong>有两种方法来实现</strong>。</p><p><strong>第一种方法</strong>是将某个 object 直接赋值给 <strong>module.exports</strong>，<strong>module.exports</strong> 是 module system 的一个 object 用来将某个 object 暴漏出来，且只能在一个文件中赋值给某一个元素，下面是一个示例：</p><p><strong>libs.js</strong> 文件：</p><pre><code>const person = {
    name: 'marco',
    age: 20
}

module.exports = person;</code></pre><p><strong>main.js</strong> 文件：</p><pre><code>const libs = require('./libs');

console.log(libs.age);

//OUTPUT:
//20</code></pre><p>上面示例中，我们将 <strong>libs.js</strong> 文件的 <strong>person</strong> object 赋值给了 <strong>module.exports</strong>，在 <strong>main.js</strong> 中调用 <strong>libs.js</strong> 文件后，<strong>main.js</strong> 中的 <strong>libs</strong> object 就相当于 <strong>person</strong> object。</p><p>我们可以发现，这种定义方法可以将某个 node.js 文件中的一个 object 暴漏给外部使用。</p><p><strong>第二种方法</strong>是将需要暴漏的元素定义为 <strong>exports</strong> 的 properties，这种方式可以将多个 objects 或 function 暴漏给外部。</p><p>libs.js 文件：</p><pre><code>const person = {
    name: 'marco',
    age: 20
}
exports.person = person;

exports.car = {
    brand: 'bmw',
    color: 'red'
}</code></pre><p>main.js 文件：</p><pre><code>const libs = require('./libs');

console.log(libs.person.age);
console.log(libs.car.brand);

//OUTPUT:
//20
//bmw</code></pre><p>以上示例中，我们先在 <strong>libs.js</strong> 中定义了两个 object，并都作为 <strong>exports</strong> 的一个 property，可以看到有两种方式定义。在 <strong>main.js</strong> 中调用后，通过调用 <strong>libs</strong> object 对应的 properties 名称即可调用对应暴露的元素。</p><h3>npm 包管理器</h3><p><strong>npm</strong> 是 <strong>node.js</strong> 的标准包管理器。</p><p>一开始，npm 作为下载和管理 node.js 包的依赖的工具，现在也成为了 JavaScript 前端开发工具。</p><h4>下载包</h4><p>如果项目中有 <strong>package.json</strong> 文件，可以通过下面指令自动安装所有在文件中定义的模块，安装路径为 <strong>node_modules</strong> 文件夹内：</p><pre><code>npm install
</code></pre><p>安装某一个模块包：</p><pre><code>npm install &lt;package-name&gt;
</code></pre><p>在项目中安装的包会自动添加条目到 <strong>package.json</strong> 文件中。也可以在安装时使用 <code>--save</code> 选项来添加到文件。</p><h4>更新包</h4><p>更新项目中所有包：</p><pre><code>npm update
</code></pre><p>更新某一个包：</p><pre><code>npm update &lt;package-name&gt;
</code></pre><h4>执行任务</h4><p><strong>package.json</strong> 文件内支持定义指定的命令行指令，通过下面的语法来执行：</p><pre><code>npm run &lt;task-name&gt;
</code></pre><p>指令定义在 <strong>scripts</strong> 块内，例如：</p><pre><code>{
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;uname -r&quot;
  }
}</code></pre><p>此时我们在终端执行下面命令：</p><pre><code>$ npm run start
Debugger attached.

&gt; start
&gt; uname -r

5.8.0-38-generic
Waiting for the debugger to disconnect...</code></pre><p>可以看到通过 run 定义命令的名称就可以执行对应的命令。</p><h4>包安装路径</h4><p>当使用 npm 安装包时，可以定义两种安装模式：</p><ul><li>local install 逻辑安装</li><li>global install 全局安装</li></ul><p>默认情况下当我们使用下面指令安装包：</p><pre><code>npm install chalk
</code></pre><p>包会安装到当前项目路径下的 node_modules 文件夹内。此时 npm 会将对应包的信息写入 <strong>package.json</strong> 文件内的 <strong>dependencies</strong> 块内，如：</p><pre><code>{
  &quot;dependencies&quot;: {
    &quot;chalk&quot;: &quot;^4.1.0&quot;,
    &quot;inquirer&quot;: &quot;^7.3.3&quot;,
    &quot;minimist&quot;: &quot;^1.2.5&quot;,
    &quot;progress&quot;: &quot;^2.0.3&quot;
  }
}</code></pre><p>全局安装通过 <code>-g</code> 标记实现：</p><pre><code>npm install -g chalk
</code></pre><p>使用全局安装模式时，npm 不会将包安装到项目路径下，而是 <strong>global</strong> location 路径下。通过 <code>npm root -g</code> 命令可以返回 golbal 路径的地址，Linux 默认地址为：<code>/usr/local/lib/node_modules</code>，Windows 默认地址为：<code>C:\Users\YOU\AppData\Roaming\npm\node_modules</code>。</p><h4>可执行程序</h4><p>当安装一个包后，我们通过 <strong>require</strong> 关键词来调用模块：</p><pre><code>const inquirer = require('inquirer')
</code></pre><p>当安装的包是可执行程序的时候呢？当安装的包含有可执行程序时，程序会放在 <code>node_modules/.bin/</code> 文件夹内，关于如何运行这些可执行程序，我们通过 <strong>cowsay</strong> 包来演示。</p><p>首先安装 <strong>cowsay</strong>，这里安装到 global 路径下：</p><pre><code>npm install -g cowsay
</code></pre><p>我的 global 路径地址为：<code>/opt/node-v15.5.1-linux-x64/lib/node_modules</code>，可执行文件被安装在 <code>/opt/node-v15.5.1-linux-x64/bin/</code> 目录下：</p><pre><code>cowsay -&gt; ../lib/node_modules/cowsay/cli.js</code></pre><p>查看属性可以看到此可执行文件是指向 cli.js 的一个链接。</p><p>通过 <strong>npx</strong> 命令可以方便的执行此程序，不需要提供程序所在路径：</p><pre><code>$ npx cowsay wow
 _____
&lt; wow &gt;
 -----
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||</code></pre><h3>package.json 文件</h3><p>package.json 文件是其项目的一个声明，它可以用来做一些完全没有关联的事情。例如，它是配置工具的仓库，也存储着 npm 安装的包的版本信息。</p><p>下面是最简单的文件形式：</p><pre><code>{}
</code></pre><p>文件需要遵守 json 格式，否则无法被程序读取其定义的内容。没有什么内容是必须的，所以可以是一个简单的大括号。如果你要做一个通过 npm 分享的 node.js 包，那么 package.json 文件需要定义一些必须的属性以供了解这个包的信息，后面会做详细介绍。</p><p>下面是另一个示例：</p><pre><code>{
  &quot;name&quot;: &quot;test-node&quot;
}</code></pre><p>以上定义了一个 <strong>name</strong> property，定义了这个 app 或 package 的名称。文件和项目文件在同一文件夹下。</p><p>下面是一个更加复杂的示例：</p><pre><code>{
  &quot;name&quot;: &quot;test-project&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;A Vue.js project&quot;,
  &quot;main&quot;: &quot;src/main.js&quot;,
  &quot;private&quot;: true,
  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;,
    &quot;start&quot;: &quot;npm run dev&quot;,
    &quot;unit&quot;: &quot;jest --config test/unit/jest.conf.js --coverage&quot;,
    &quot;test&quot;: &quot;npm run unit&quot;,
    &quot;lint&quot;: &quot;eslint --ext .js,.vue src test/unit&quot;,
    &quot;build&quot;: &quot;node build/build.js&quot;
  },
  &quot;dependencies&quot;: {
    &quot;vue&quot;: &quot;^2.5.2&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;autoprefixer&quot;: &quot;^7.1.2&quot;,
    &quot;babel-core&quot;: &quot;^6.22.1&quot;,
    &quot;babel-eslint&quot;: &quot;^8.2.1&quot;,
    &quot;babel-helper-vue-jsx-merge-props&quot;: &quot;^2.0.3&quot;,
    &quot;babel-jest&quot;: &quot;^21.0.2&quot;,
    &quot;babel-loader&quot;: &quot;^7.1.1&quot;,
    &quot;babel-plugin-dynamic-import-node&quot;: &quot;^1.2.0&quot;,
    &quot;babel-plugin-syntax-jsx&quot;: &quot;^6.18.0&quot;,
    &quot;babel-plugin-transform-es2015-modules-commonjs&quot;: &quot;^6.26.0&quot;,
    &quot;babel-plugin-transform-runtime&quot;: &quot;^6.22.0&quot;,
    &quot;babel-plugin-transform-vue-jsx&quot;: &quot;^3.5.0&quot;,
    &quot;babel-preset-env&quot;: &quot;^1.3.2&quot;,
    &quot;babel-preset-stage-2&quot;: &quot;^6.22.0&quot;,
    &quot;chalk&quot;: &quot;^2.0.1&quot;,
    &quot;copy-webpack-plugin&quot;: &quot;^4.0.1&quot;,
    &quot;css-loader&quot;: &quot;^0.28.0&quot;,
    &quot;eslint&quot;: &quot;^4.15.0&quot;,
    &quot;eslint-config-airbnb-base&quot;: &quot;^11.3.0&quot;,
    &quot;eslint-friendly-formatter&quot;: &quot;^3.0.0&quot;,
    &quot;eslint-import-resolver-webpack&quot;: &quot;^0.8.3&quot;,
    &quot;eslint-loader&quot;: &quot;^1.7.1&quot;,
    &quot;eslint-plugin-import&quot;: &quot;^2.7.0&quot;,
    &quot;eslint-plugin-vue&quot;: &quot;^4.0.0&quot;,
    &quot;extract-text-webpack-plugin&quot;: &quot;^3.0.0&quot;,
    &quot;file-loader&quot;: &quot;^1.1.4&quot;,
    &quot;friendly-errors-webpack-plugin&quot;: &quot;^1.6.1&quot;,
    &quot;html-webpack-plugin&quot;: &quot;^2.30.1&quot;,
    &quot;jest&quot;: &quot;^22.0.4&quot;,
    &quot;jest-serializer-vue&quot;: &quot;^0.3.0&quot;,
    &quot;node-notifier&quot;: &quot;^5.1.2&quot;,
    &quot;optimize-css-assets-webpack-plugin&quot;: &quot;^3.2.0&quot;,
    &quot;ora&quot;: &quot;^1.2.0&quot;,
    &quot;portfinder&quot;: &quot;^1.0.13&quot;,
    &quot;postcss-import&quot;: &quot;^11.0.0&quot;,
    &quot;postcss-loader&quot;: &quot;^2.0.8&quot;,
    &quot;postcss-url&quot;: &quot;^7.2.1&quot;,
    &quot;rimraf&quot;: &quot;^2.6.0&quot;,
    &quot;semver&quot;: &quot;^5.3.0&quot;,
    &quot;shelljs&quot;: &quot;^0.7.6&quot;,
    &quot;uglifyjs-webpack-plugin&quot;: &quot;^1.1.1&quot;,
    &quot;url-loader&quot;: &quot;^0.5.8&quot;,
    &quot;vue-jest&quot;: &quot;^1.0.2&quot;,
    &quot;vue-loader&quot;: &quot;^13.3.0&quot;,
    &quot;vue-style-loader&quot;: &quot;^3.0.1&quot;,
    &quot;vue-template-compiler&quot;: &quot;^2.5.2&quot;,
    &quot;webpack&quot;: &quot;^3.6.0&quot;,
    &quot;webpack-bundle-analyzer&quot;: &quot;^2.9.0&quot;,
    &quot;webpack-dev-server&quot;: &quot;^2.9.1&quot;,
    &quot;webpack-merge&quot;: &quot;^4.1.0&quot;
  },
  &quot;engines&quot;: {
    &quot;node&quot;: &quot;&gt;= 6.0.0&quot;,
    &quot;npm&quot;: &quot;&gt;= 3.0.0&quot;
  },
  &quot;browserslist&quot;: [&quot;&gt; 1%&quot;, &quot;last 2 versions&quot;, &quot;not ie &lt;= 8&quot;]
}</code></pre><p>包含了很多的属性设置：</p><ul><li><strong>version</strong> 表示当前版本号</li><li><strong>name</strong> 设置包名称</li><li><strong>description</strong> 对 app 简要的描述</li><li><strong>main</strong> 设置 app 的入口文件</li><li><strong>private</strong> 如果设置为 true 可以防止包被无意的发布到 npm</li><li><strong>scripts</strong> 定义可以运行的脚本命令</li><li><strong>dependencies</strong> npm 依赖包列表</li><li><strong>devDependencies</strong> 定义开发使用的 npm 包列表</li><li><strong>engines</strong> 设置 app 运行的 node 版本</li><li><strong>browserslist</strong> 指定支持的浏览器版本</li></ul><p>以上所有的属性都可以被 npm 或其他工具使用。</p><h4>常用属性</h4><p>下面介绍一些常规使用的属性，包括你在本地开发的项目也可以使用。</p><p><strong>name</strong> 定义app 名称：</p><pre><code>&quot;name&quot;: &quot;test-project&quot;
</code></pre><p>name 必须小于 214 个字符，不能含有空格，只能包含<strong>小写字母，横杠<code>-</code> 或下划线<code>_</code></strong>。如果将包发布到 npm，会生成一个独有的链接。</p><p><strong>author</strong> 定义作者信息：</p><pre><code>&quot;author&quot;: &quot;marco &lt;me@niekun.net&gt; (https://niekun.net)&quot;
</code></pre><p>或者：</p><pre><code>  &quot;author&quot;: {
    &quot;name&quot;: &quot;marco&quot;,
    &quot;email&quot;: &quot;me@niekun.net&quot;,
    &quot;url&quot;: &quot;https://niekun.net&quot;
  }</code></pre><p><strong>contributors</strong> 定义代码贡献者信息，可以包含多人：</p><pre><code>  &quot;contributors&quot;: [
    {
      &quot;name&quot;: &quot;marco&quot;,
      &quot;email&quot;: &quot;me@niekun.net&quot;,
      &quot;url&quot;: &quot;https://niekun.net&quot;
    }
  ]</code></pre><p><strong>bugs</strong> 定义反馈 bug 的链接，一般是 GitHub issue 页面：</p><pre><code>&quot;bugs&quot;: &quot;https://github.com/whatever/package/issues&quot;
</code></pre><p><strong>homepage</strong> 定义包的主页链接：</p><pre><code>&quot;homepage&quot;: &quot;https://whatever.com/package&quot;
</code></pre><p><strong>version</strong> 定义当前包的版本：</p><pre><code>&quot;version&quot;: &quot;1.0.0&quot;
</code></pre><p>此属性遵守 semantic versioning (semver) notation 语义版本标记语法。也就是由三个数字表示：x.x.x</p><p><strong>license</strong> 定义包的授权信息：</p><pre><code>&quot;license&quot;: &quot;MIT&quot;
</code></pre><p><strong>keywords</strong> 定义关于这个包实现功能的关键词，是一个数组：</p><pre><code>  &quot;keywords&quot;: [
    &quot;learning&quot;,
    &quot;nodejs&quot;
  ]</code></pre><p>使用 keywords 可以帮助别人找到你的包，或者在 <a href="https://www.npmjs.com/">https://www.npmjs.com/</a> 网站上搜索关键词。</p><p><strong>description</strong> 定义一个对此 app 的简短描述：</p><pre><code>&quot;description&quot;: &quot;a node.js beginner guide&quot;
</code></pre><p><strong>repository</strong> 定义项目仓库地址：</p><pre><code>&quot;repository&quot;: &quot;github:whatever/node-project&quot;
</code></pre><p>注意如果不是使用的 GitHub 也可以定义其他工具：</p><pre><code>&quot;repository&quot;: &quot;gitlab:whatever/node-project&quot;
</code></pre><p>也可以明确的定义版本控制系统信息：</p><pre><code>  &quot;repository&quot;: {
    &quot;type&quot;: &quot;git&quot;,
    &quot;url&quot;: &quot;https://github.com/whatever/testing.git&quot;
  }</code></pre><p><strong>main</strong> 设置包的入口：</p><pre><code>&quot;main&quot;: &quot;./main.js&quot;
</code></pre><p><strong>private</strong> 如果设置为 true，可以防止包被无意的发布到 npm：</p><pre><code>&quot;private&quot;: &quot;true&quot;
</code></pre><p><strong>scripts</strong> 定义可执行的 node 脚本：</p><pre><code>  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;uname -r&quot;,
    &quot;test&quot;: &quot;echo abcd&quot;
  }</code></pre><p>定义的脚本是命令行程序，通过 npm run xxx 执行，如：</p><pre><code>npm run start
</code></pre><p><strong>dependencies</strong> 定义 app 需要安装的 npm 依赖包：</p><pre><code>  &quot;dependencies&quot;: {
    &quot;chalk&quot;: &quot;^4.1.0&quot;,
    &quot;inquirer&quot;: &quot;^7.3.3&quot;,
    &quot;minimist&quot;: &quot;^1.2.5&quot;,
    &quot;progress&quot;: &quot;^2.0.3&quot;
  }</code></pre><p>当通过 <code>npm install &lt;PACKAGENAME&gt;</code> 安装包，会自动将包写入 package.json 文件的 dependencies 块。</p><p><strong>devDependencies</strong> 定义 app 开发需要的 npm 依赖包：</p><pre><code>&quot;devDependencies&quot;: {
  &quot;autoprefixer&quot;: &quot;^7.1.2&quot;,
  &quot;babel-core&quot;: &quot;^6.22.1&quot;
}</code></pre><p>和 <strong>dependencies</strong> 的区别是这里定义的包只是在开发设备上安装，而不需要在执行设备上安装。开发包通过以下命令安装：</p><pre><code>npm install --save-dev &lt;PACKAGENAME&gt;
</code></pre><p><strong>engines</strong> 设置此包运行的 node 版本和其他命令版本：</p><pre><code>  &quot;engines&quot;: {
    &quot;node&quot;: &quot;&gt;= 6.0.0&quot;,
    &quot;npm&quot;: &quot;&gt;=3.0.0&quot;
  }</code></pre><p><strong>browserslist</strong> 定义 app 支持的浏览器版本：</p><pre><code>&quot;browserslist&quot;: [
  &quot;&gt; 1%&quot;,
  &quot;last 2 versions&quot;,
  &quot;not ie &lt;= 8&quot;
]</code></pre><p>以上定义的意义是：支持所有类型浏览器的最近两个版本且需要至少有 1% 的占有率，不包括小于等于 IE8 版本的浏览器。浏览器占有率信息来自于 <a href="https://caniuse.com/">https://caniuse.com/</a> 统计。</p><h4>依赖包版本信息</h4><p>在 <strong>dependencies</strong> 和 <strong>devDependencies</strong> 中定义了依赖包列表，每个包都定义了版本信息，如：<strong>^0.13.0</strong> 或 <strong>~3.0.0</strong>，通过版本号前的符号可以们定义接受那些版本的升级，下面介绍版本标记的用法：</p><ul><li>无标记，如 1.0.0 定义只安装此版本的包</li><li><strong>latest</strong> 定义安装最新版本的包</li><li><strong>^</strong> 只能升级到不改变最左边第一个非零数字的版本，如定义 <strong>^0.13.0</strong>，通过 npm update 可以升级到 0.13.1 或 0.13.2，但不能升级到 0.14.0，定义 <strong>^1.13.0</strong>，能够升级到 1.13.1 或 1.14.0，不能升级到 2.0.0</li><li><strong>~</strong> 只能升级最后一位数字变化的版本，如 定义 <strong>~1.13.0</strong>，能够升级到 1.13.1，但不能升级到 1.14.0</li><li><strong>&gt;</strong> 接受大于定义的版本号的更新</li><li><strong>&gt;=</strong> 接受大于等于定义的版本号的更新</li><li><strong>&lt;</strong> 接受小于定义的版本号的更新</li><li><strong>&lt;=</strong> 接受小于等于定义的版本号的更新</li><li><strong>-</strong> 设置一个版本范围，如：1.0.0 - 2.0.0</li><li><strong>||</strong> 组合设置，如：&lt; 2.0.0 || &gt; 3.0.0</li></ul><p>更加详细的定义方法参考：<a href="https://nodejs.dev/learn/semantic-versioning-using-npm">https://nodejs.dev/learn/semantic-versioning-using-npm</a></p><h3>package-lock.json 文件</h3><p>在 npm 5 版本中 npm 引入了 package-lock.json 文件。</p><p>前面介绍了 package.json 文件，它是一个通用的被广泛使用的配置文件。package-lock.json 文件的目的是更加确切的追踪安装的依赖包的版本，以用来 100% 复制开发者的安装环境到其他安装者设备上，即使某些包已经够了更新版本。</p><p>这解决了一个 package.json 遗留的问题，在 package.json 中你可以定义某个包可接受的版本升级范围，版本格式遵守 semantic versioning (semver) notation 语义版本标记语法，例如：</p><ul><li><strong>~1.13.1</strong> 可以升级到 1.13.2，但不可以升级到 1.14.0</li><li><strong>^1.13.1</strong> 可以升级到 1.14.0，但不能升级到 2.0.0</li><li><strong>1.13.1</strong> 只能安装 1.13.1 版本，不能升级到其他任何版本</li></ul><p>你发布的包中并不包含开发环境中的  node_modules 文件夹因为它占用空间很大。当在其他设备中通过 <code>npm install</code>  命令安装依赖包时，竟会遵循上面定义的版本范围安装支持的最新版本到设备中，这就会导致用户安装的版本和你开发环境的版本不一致，可能导致 bug 的出现。</p><p>package-lock.json 中定义了你当前开发环境安装的各种依赖包的准确版本，这样通过 <code>npm install</code> 命令安装的就是其中定义的准确版本。</p><p>这一概念并不是 npm 独创的，其他编程语言也在使用类似的模式，如 php 的 Composer。</p><p>package-lock.json 文件需要打包在仓库中，以供其他人使用。当使用 <code>npm update</code> 更新包时，package-lock.json 中的定义也会同步更新。</p><p>下面是一个 package-lock.json 文件的示例，当我们执行 <code>npm install cowsay</code> 时，会创建以下内容：</p><pre><code>{
  &quot;requires&quot;: true,
  &quot;lockfileVersion&quot;: 1,
  &quot;dependencies&quot;: {
    &quot;ansi-regex&quot;: {
      &quot;version&quot;: &quot;3.0.0&quot;,
      &quot;resolved&quot;: &quot;https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.
0.0.tgz&quot;,
      &quot;integrity&quot;: &quot;sha1-7QMXwyIGT3lGbAKWa922Bas32Zg=&quot;
    },
    &quot;cowsay&quot;: {
      &quot;version&quot;: &quot;1.3.1&quot;,
      &quot;resolved&quot;: &quot;https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz&quot;
,
      &quot;integrity&quot;: &quot;sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkM
Ajufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==&quot;,
      &quot;requires&quot;: {
        &quot;get-stdin&quot;: &quot;^5.0.1&quot;,
        &quot;optimist&quot;: &quot;~0.6.1&quot;,
        &quot;string-width&quot;: &quot;~2.1.1&quot;,
        &quot;strip-eof&quot;: &quot;^1.0.0&quot;
      }
    },
    &quot;get-stdin&quot;: {
      &quot;version&quot;: &quot;5.0.1&quot;,
      &quot;resolved&quot;: &quot;https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.
1.tgz&quot;,
      &quot;integrity&quot;: &quot;sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g=&quot;
    },
    &quot;is-fullwidth-code-point&quot;: {
      &quot;version&quot;: &quot;2.0.0&quot;,
      &quot;resolved&quot;: &quot;https://registry.npmjs.org/is-fullwidth-code-point/-/
is-fullwidth-code-point-2.0.0.tgz&quot;,
      &quot;integrity&quot;: &quot;sha1-o7MKXE8ZkYMWeqq5O+764937ZU8=&quot;
    },
    &quot;minimist&quot;: {
      &quot;version&quot;: &quot;0.0.10&quot;,
      &quot;resolved&quot;: &quot;https://registry.npmjs.org/minimist/-/minimist-0.0.10
.tgz&quot;,
      &quot;integrity&quot;: &quot;sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8=&quot;
    },
    &quot;optimist&quot;: {
      &quot;version&quot;: &quot;0.6.1&quot;,
      &quot;resolved&quot;: &quot;https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz&quot;,
      &quot;integrity&quot;: &quot;sha1-2j6nRob6IaGaERwybpDrFaAZZoY=&quot;,

      &quot;requires&quot;: {
        &quot;minimist&quot;: &quot;~0.0.1&quot;,
        &quot;wordwrap&quot;: &quot;~0.0.2&quot;
      }
    },
    &quot;string-width&quot;: {
      &quot;version&quot;: &quot;2.1.1&quot;,
      &quot;resolved&quot;: &quot;https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz&quot;,
      &quot;integrity&quot;: &quot;sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==&quot;,
      &quot;requires&quot;: {
        &quot;is-fullwidth-code-point&quot;: &quot;^2.0.0&quot;,
        &quot;strip-ansi&quot;: &quot;^4.0.0&quot;
      }
    },
    &quot;strip-ansi&quot;: {
      &quot;version&quot;: &quot;4.0.0&quot;,
      &quot;resolved&quot;: &quot;https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz&quot;,
      &quot;integrity&quot;: &quot;sha1-qEeQIusaw2iocTibY1JixQXuNo8=&quot;,
      &quot;requires&quot;: {
        &quot;ansi-regex&quot;: &quot;^3.0.0&quot;
      }
    },
    &quot;strip-eof&quot;: {
      &quot;version&quot;: &quot;1.0.0&quot;,
      &quot;resolved&quot;: &quot;https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz&quot;,
      &quot;integrity&quot;: &quot;sha1-u0P/VZim6wXYm1n80SnJgzE2Br8=&quot;
    },
    &quot;wordwrap&quot;: {
      &quot;version&quot;: &quot;0.0.3&quot;,
      &quot;resolved&quot;: &quot;https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz&quot;,
      &quot;integrity&quot;: &quot;sha1-o9XabNXAvAAI03I0u68b7WMFkQc=&quot;
    }
  }
}</code></pre><p>我们安装的 cowsay 有如下依赖，它们会被自动安装：</p><ul><li>get-stdin</li><li>optimist</li><li>string-width</li><li>strip-eof</li></ul><p>以上的依赖包可能也会有它们各自的其他依赖包，会自动安装相关其他包，每个包的依赖包在 <strong>requires</strong> 属性中定义。</p><p>所有的包以字母排序顺序在文件中。每个包都有 <strong>version</strong> 属性定义了各自当前安装的版本，<strong>resolved</strong> 定义了包地址，<strong>integrity</strong> 字符串用来验证包。</p><h3>包版本管理及安装</h3><p>下面的指令查询当前安装的所有包及其依赖包：</p><pre><code>npm list
</code></pre><p>输出信息示例：</p><pre><code>❯ npm list
/Users/joe/dev/node/cowsay
└─┬ cowsay@1.3.1
  ├── get-stdin@5.0.1
  ├─┬ optimist@0.6.1
  │ ├── minimist@0.0.10
  │ └── wordwrap@0.0.3
  ├─┬ string-width@2.1.1
  │ ├── is-fullwidth-code-point@2.0.0
  │ └─┬ strip-ansi@4.0.0
  │   └── ansi-regex@3.0.0
  └── strip-eof@1.0.0</code></pre><p>当然也可以直接打开 package-lock.json 文件查看，但这样不太方便观察结构。</p><p><code>npm list -g</code> 用来查看 global 安装的包。</p><p>如果只想查询顶层的包，也就是你主动通过 <code>npm install</code> 安装的那些包，可通过 <code>npm list --depth=0</code> 查询：</p><pre><code>❯ npm list --depth=0
/Users/joe/dev/node/cowsay
└── cowsay@1.3.1</code></pre><p>也可以单独查询某个包：</p><pre><code>❯ npm list cowsay
/Users/joe/dev/node/cowsay
└── cowsay@1.3.1</code></pre><p>使用下面命令查询某个包当前发布的最新版本：</p><pre><code>❯ npm view cowsay version
1.4.0</code></pre><p>要安装某个包的特定版本需要加上 <code>@</code> 标记：</p><pre><code>npm install cowsay@1.2.0
</code></pre><p>查看某个包的所有历史版本列表：</p><pre><code>$ npm view cowsay versions
[
  '1.0.0', '1.0.1', '1.0.2',
  '1.0.3', '1.1.0', '1.1.1',
  '1.1.2', '1.1.3', '1.1.4',
  '1.1.5', '1.1.6', '1.1.7',
  '1.1.8', '1.1.9', '1.2.0',
  '1.2.1', '1.3.0', '1.3.1',
  '1.4.0'
]</code></pre><p>通过 <code>npm update</code> 可以更新所有已安装的包，更新版本规则遵循 package.json 定义的版本升级范围，同时会更新 package-lock.json 文件内的当前包版本信息。</p><p>想要查询当前有哪些包有更新版本时，可以执行 <code>npm outdated</code> 命令：<br><img src="https://blog.niekun.net/usr/uploads/2021/01/1402612766.png" alt="2021-01-29T01:29:02.png" title="2021-01-29T01:29:02.png"></p><p>其中有些更新是大版本更新， <code>npm update</code> 并不会更新到这些大版本，因为这些更新可能包含有重大的变化。如果要强制更新到最新的版本包括大版本更新，可以按顺序执行下面的命令：</p><pre><code>npm install -g npm-check-updates
ncu -u
npm update</code></pre><p>使用下面命令卸载某个包：</p><pre><code>npm uninstall &lt;package-name&gt;
</code></pre><p>添加 <code>-S</code> 或 <code>--save</code> 标记删除 package.json 中的相关信息。如果要删除的包是一个开发包，在 devDependencies 中定义过，则需要添加 <code>-D</code> 或 <code>--save-dev</code> 标记来删除相关信息：</p><pre><code>npm uninstall -S &lt;package-name&gt;
npm uninstall -D &lt;package-name&gt;</code></pre><p>如果包是 global 安装的，则卸载需要添加 <code>-g</code> 标记：</p><pre><code>npm uninstall -g &lt;package-name&gt;
</code></pre><h3>npm local 和 global 安装</h3><p>本地包和全局包的区别是本地包通过 <code>npm install</code> 安装到当前项目下的 node_modules 文件夹内，全局包通过 <code>npm install -g</code> 安装到系统路径下，路径地址可通过 <code>npm root -g</code> 查询。</p><p>在程序中，只能 require 本地包：</p><pre><code>require('package-name')
</code></pre><p>通常情况下推荐所有的包都以本地模式安装。这可以让不同的程序使用各自不同版本的包。更新一个全局包会同时影响所有使用这个包的 app。</p><p>当一个包含有可执行程序时，应该安装为 global 全局包。这样所有的项目都可以调用执行。</p><h3>npm dependencies 和 devDependencies</h3><p>当通过 npm intall 安装包时，表示将包作为 dependency。包信息会自动写入 package.json 文件的 dependencies 块内。当安装时添加 <code>-D</code> 标记，表示将包作为 devdependency 安装。包信息会自动写入 devDependencies 块内。</p><p>开发包的目的是用来开发程序时使用，作为产品运行时是不需要的。</p><p>执行 npm install 会默认安装这些开发包。如果不需要安装开发包需要加上 <code>--production</code> 标记：</p><pre><code>npm install --production xxx
</code></pre><h3>npx 包运行器</h3><p>npx 可以用来运行 node.js 程序。node.js 开发者通常将大部分含有可执行程序的包作为 global 包发布，这样就使得可执行程序在系统 PATH 路径下可以被直接执行。但这样的弊端就是不能安装不同版本的包。</p><p>使用 npx 命令可以自动寻找 node_modules 文件夹内的对应的名称的可执行程序，而不需要知道程序具体的路径，也不需要以 global 方式安装包。</p><p>npx 另一个很好的功能是可以直接运行某些命令而不需要提前安装它们，还可以通过 <code>@</code> 标记来执行不同版本的同一命令。</p><p>cowsay 是一个很好的示例来说明 npx 的使用，如果我们以 global 模式安装 cowsay，可以通过下面方式执行：</p><pre><code>cowsay &quot;wow&quot;
</code></pre><p>以上命令只有通过 global 方式安装才能够正常执行，否则会报错提示命令不存在。</p><p>如果以 local 方式安装 cowsay，可以通过 npx 执行：</p><pre><code>npx cowsay &quot;Hello&quot;
</code></pre><p>通过 <code>@</code> 标记来执行不同版本的命令：</p><pre><code>npx node@10 -v #v10.18.1
npx node@12 -v #v12.14.1</code></pre><p>npm 也可以直接执行来自 url 的任意代码片段，而不仅限于 npm 官方渠道发布的包。下面示例是执行部署在 glist 的包：</p><pre><code>npx https://gist.github.com/zkat/4bc19503fe9e9309e2bfaa2c58074d32
</code></pre><p>可执行程序路径定义在 package.json 文件的 bin 属性内。</p><p>glist 包含内容如下：<br><img src="https://blog.niekun.net/usr/uploads/2021/01/1152197546.jpg" alt="1.jpg" title="1.jpg"></p><p>当然执行不受控制网络的代码需要多加注意。</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2085.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/2085.html</wfw:commentRss>
</item>
<item>
<title>服务器部署 WebDAV 服务</title>
<link>https://blog.niekun.net/archives/2074.html</link>
<guid>https://blog.niekun.net/archives/2074.html</guid>
<pubDate>Fri, 22 Jan 2021 11:16:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[WebDAV(Web-based Distributed Authoring and Versioning) 一种基于 HTTP 1.1协议的通信协议。它扩展了HTTP 1.1在 GET、POS...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>WebDAV(Web-based Distributed Authoring and Versioning) 一种基于 HTTP 1.1协议的通信协议。它扩展了HTTP 1.1在 <strong>GET</strong>、<strong>POST</strong>、<strong>HEAD</strong>等几个HTTP标准方法以外添加了一些新的方法，使应用程序可对Web Server直接读写，并支持写文件锁定(Locking)及解锁(Unlock)，还可以支持文件的版本控制。</p><p>简单说 webdav 就像一个网盘，可以远程访问他的目录名对其文件进行读写操作。</p><p><strong>WebDAV 允许客户端进行下列操作：</strong></p><ul><li>处理服务器上 WebDAV 发布目录中的资源</li><li>具有正确权限的用户可以在 WebDAV目录中复制和移动文件</li><li>修改与某些资源相关联的属性。例如，用户可写入并检索文件的属性信息</li><li>锁定并解锁资源以便多个用户可同时读取一个文件。但每次只能有一个人修改文件</li><li>搜索 WebDAV 目录中的文件的内容和属性</li></ul><!--more--><p>下面介绍如何在服务器上部署 WebDAV 服务。这里通过 nginx 来代理。</p><h3>编译 nginx</h3><p>我们通过 nginx 来代理 webdav 服务，nginx 自带有 ngx_http_dav_module 模块，但是其不支持一些 webdav 的 method 如：PROPFIND, OPTIONS, LOCK, UNLOCK。可以通过第三方模块来完整支持 webdav 的特性。</p><p>下载以下两个第三方模块：<br><strong>nginx-dav-ext-module</strong>：<a href="https://github.com/arut/nginx-dav-ext-module">https://github.com/arut/nginx-dav-ext-module</a><br><strong>headers-more-nginx-module</strong>：<a href="https://github.com/openresty/headers-more-nginx-module">https://github.com/openresty/headers-more-nginx-module</a></p><p>以上两个模块需要在编译时通过 <strong>--add-module</strong> 参数来引入模块，同时需要包含 <strong>--with-http_dav_module</strong> 模块，否则编译会报错。</p><p>从源码编译 nginx 参考我之前的教程：<a href="https://blog.niekun.net/archives/30.html">https://blog.niekun.net/archives/30.html</a></p><p>我使用的完整的编译参数如下：</p><pre><code>./configure --prefix=/opt/nginx-1.19.6 \
--user=nginx --group=nginx \
--with-compat --with-file-aio --with-threads \
--with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_mp4_module --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module \
--with-mail --with-mail_ssl_module \
--with-stream --with-stream_realip_module --with-stream_ssl_module --with-stream_ssl_preread_module \
--add-module=../echo-nginx-module \
--add-module=../ngx-fancyindex \
--add-module=../headers-more-nginx-module \
--add-module=../nginx-dav-ext-module</code></pre><h3>配置文件</h3><p>nginx 编译安装完成后，需要配置 conf 文件来使 webdav 生效。我提前已经设置了一个单独的子域名来访问 webdav 服务，且使用 ssl 加密。</p><p>首先建立 webdav 文件夹并设置正确的权限，否则在读写时会提示权限不足：</p><pre><code>mkdir /home/www/webdav
chown -R www-data:www-data /home/www/webdav</code></pre><p>如果想要限制用户访问，可以使用 <strong>ngx_http_auth_basic_module</strong> 模块来建立账号访问，具体参考：<a href="https://blog.niekun.net/archives/730.html">https://blog.niekun.net/archives/730.html</a></p><p>完整配置文件如下：</p><pre><code>dav_ext_lock_zone zone=foo:10m;
server {
    listen        443 ssl http2;
    listen        [::]:443 ssl http2;
    server_name   webdav.xxx.xxx;
    include       my-server/ssl;

    # 限制访问
    auth_basic           &quot;Restricted Access&quot;;
    auth_basic_user_file ../users/.adminpasswd;

    # webdav 目录
    root /home/www/webdav;
    client_body_temp_path /opt/nginx/client_body_temp;

    # webdav 设置
    dav_access      user:rw  group:rw  all:r;
    dav_methods PUT DELETE MKCOL COPY MOVE;
    dav_ext_methods PROPFIND OPTIONS LOCK UNLOCK;
    dav_ext_lock zone=foo;
    create_full_put_path on;

    # 优化大文件上传
    send_timeout 3600;
    client_body_timeout 3600;
    keepalive_timeout 3600;
    lingering_timeout 3600;
    client_max_body_size 2G;

    location / {
        # 创建文件夹操作时结尾添加斜杠
        if ($request_method = MKCOL) {
            rewrite ^(.*[^/])$ $1/ break;
        }

        # 移动文件夹操作时结尾添加斜杠
        if (-d $request_filename) {
            rewrite ^(.*[^/])$ $1/;
            set $md /;
        }

        set $x $http_destination$request_method;
        if ($x ~ [^/]MOVE) {
            more_set_input_headers -r &quot;Destination: ${http_destination}${md}&quot;;
        }
    }

    # 拒绝 Windows 或 macos 多余文件上传到 webdav 路径
    location ~ \.(_.*|DS_Store|Spotlight-V100|TemporaryItems|Trashes|hidden|localized)$ {
        access_log  off;
        error_log   off;

        if ($request_method = PUT) {
            return 403;
        }
        return 404;
    }

    location ~ \.metadata_never_index$ {
        return 200 &quot;Don't index this drive, Finder!&quot;;
    }
}</code></pre><p>注意第一句 <strong>dav_ext_lock_zone</strong> 要放在 http 块内。否则会报错。</p><p>配置文件修改好后，使用下面指令测试配置是否正确：</p><pre><code>nginx -t
</code></pre><p>如果返回 ok 重启服务即可：</p><pre><code>systemctl restart nginx
</code></pre><h3>客户端连接</h3><p>nginx 配置好 webdav 模块并启动后，可以尝试在客户端访问。</p><p>Windows 的 file explorer 和 macos 的 finder 都可以直接连接 webdav。</p><h3>Windows 端</h3><p>在 file explorer 中点击 home - easy access - map as drive：<br><img src="https://blog.niekun.net/usr/uploads/2021/01/797689005.jpg" alt="1.jpg" title="1.jpg"></p><p>在弹出窗口中点击 connect to a web site：<br><img src="https://blog.niekun.net/usr/uploads/2021/01/1204074620.jpg" alt="2.jpg" title="2.jpg"></p><p>点击 next 在地址栏输入服务器 nginx 定义的 webdav 访问地址：<br><img src="https://blog.niekun.net/usr/uploads/2021/01/3507948553.jpg" alt="3.jpg" title="3.jpg"></p><p>点击 next 后如果设置了 <strong>auth_basic</strong> 会提示要求输入账户和密码，输入账户密码后就进入了 webdav 目录了，下面就可以测试新建文件，修改文件等操作。</p><p><strong>注意 Windows 中默认只有 https 方式访问的地址才可以设置 auth，否则不会弹出输入账户和密码的提示框，而是直接提示无法访问此地址。</strong>如果想要开放 http 方式的 auth 验证，需要修改注册表 <code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\WebClient\Parameters\BasicAuthLevel</code> 的值为 2，然后重启系统即可，此键值定义为：</p><ul><li>0 - Basic authentication disabled</li><li>1 - Basic authentication enabled for SSL shares only</li><li>2 or greater - Basic authentication enabled for SSL shares and for non-SSL shares</li></ul><h3>macos 端</h3><h3>参考链接：</h3><p><a href="https://www.robpeck.com/2020/06/making-webdav-actually-work-on-nginx/">Making Native WebDAV Actually Work on nginx with Finder and Explorer</a><br><a href="https://www.codetd.com/en/article/9724623">Nginx repair of WebDAV functionality</a><br><a href="http://nginx.org/en/docs/http/ngx_http_dav_module.html">Module ngx_http_dav_module</a><br><a href="https://www.webdavsystem.com/server/prev/v2/documentation/authentication/basic_auth_vista/">Using Basic Authentication with Windows 7 and Windows Vista WebDAV Client</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2074.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/2074.html</wfw:commentRss>
</item>
<item>
<title>修复 ubuntu vmware 虚拟机无法访问主机共享目录</title>
<link>https://blog.niekun.net/archives/2071.html</link>
<guid>https://blog.niekun.net/archives/2071.html</guid>
<pubDate>Fri, 15 Jan 2021 16:32:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[今天发现在 Ubuntu 20.04 虚拟机内无法访问设置的共享文件夹，在 /mnt/hgfs 目录下是空的，检查虚拟机设置并没有什么问题。最后发现是虚拟机没有自动挂载共享目录，命令行下进行挂载...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>今天发现在 Ubuntu 20.04 虚拟机内无法访问设置的共享文件夹，在 <code>/mnt/hgfs</code> 目录下是空的，检查虚拟机设置并没有什么问题。最后发现是虚拟机没有自动挂载共享目录，命令行下进行挂载即可。</p><p>首先查看当前设置的共享目录有哪些：</p><pre><code>$ vmware-hgfsclient 
Development
Downloads
InstallationPackage</code></pre><p>挂载主机共享路径到虚拟机对应路径下，设置所有用户可访问：</p><pre><code>$ sudo vmhgfs-fuse .host:/ /mnt/hgfs -o allow_other
</code></pre><p>执行以上命令后，发现共享文件夹出现了：</p><pre><code>$ ls /mnt/hgfs/
Development  Downloads  InstallationPackage</code></pre><p>以上就是解决 VMware Linux 虚拟机没有自动挂载共享目录的方法。</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2071.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/2071.html</wfw:commentRss>
</item>
<item>
<title>c++ 类型转换</title>
<link>https://blog.niekun.net/archives/2066.html</link>
<guid>https://blog.niekun.net/archives/2066.html</guid>
<pubDate>Thu, 14 Jan 2021 11:58:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[Implicit conversion 隐式转换当一个数据复制为兼容格式的类型时，隐式转换可以自动完成。请看下面示例：double a = 100.1;int b;b = a;cout &lt;...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<h3>Implicit conversion 隐式转换</h3><p>当一个数据复制为兼容格式的类型时，隐式转换可以自动完成。</p><p>请看下面示例：</p><pre><code>double a = 100.1;
int b;
b = a;
cout &lt;&lt; b &lt;&lt; endl;

//output:
//100</code></pre><!--more--><p>以上示例中，我们将 <strong>double</strong> 类型的数据复制给 <strong>int</strong> 类型的变量，不会引起语法报错，这就是 <strong>Implicit</strong> 隐式类型转换，也叫 <strong>standard conversion</strong> 标准转换。标准转换对一些基本的数据类型有效，能够对一些 <strong>numerical</strong> 数值类型的数据间进行转换，如：double to int，int to float，short to double，int to bool 等，也可以在 pointer 指针类型间转换。</p><p>从小一些的整型如 short 转换到 int 类型，或者从 float 类型转换到 double 类型，这种转换过程叫做 <strong>promotion</strong> 晋升操作。这种转换可以确保原始数据完整的复制到目标数据类型中。</p><p>其他数学运算类型间的转换可能不一定会完整的保留原始数据，下面是几种情况举例：</p><ul><li>一个负整数转换为 unsigned 类型，结果为 unsigned 类型数据所能表达的最大值数据</li><li>转换为 bool 类型的数据时，对于数值类型原始数据为 0 时，对于指针类型指针数据为 null pointer 时，对应转换为 false。原始数据为所有其他情况时，转换结果为 true。</li><li>浮点型数据转换为整型数据，数据会被截取整数部分，如果数据结果超出目标数据类型所能表达的最大值，会得到 undefined</li></ul><p>我们可以看到，隐式转换可能会带来数据精度的丢失，编译器此时会提示一条 warning 警告。可以通过使用 <strong>explicit conversion</strong> 显式转换来避免警告信息。</p><h3>class 的隐式转换</h3><p>class 中的隐式转换通过以下三个 function 控制：</p><ul><li>单参数的 constructors 允许从一个特定类型的数据隐式转换构造为一个 object</li><li>通过等号操作符 Assignment operator 复用来隐式转换</li><li>类型传播符 Type-cast 来隐式转换为特定的类型</li></ul><p>下面示例解释各种方式的含义：</p><pre><code>class A {};

class B {
public:
    B(A a) {} //constructor: conversion from A
    B operator=(A a) {return *this;} // assignment operator: conversion from A
    operator A() {return A();} // type-cast: conversion to A
};

int main()
{
    A a; // instance a
    B b = a; // constructor b from a
    B c(a); // constructor c from a
    b = a; // assignment a to b
    a = b; // convert b to A type and assignment to a

    return 0;
}</code></pre><p>以上实例分别介绍了三种隐式转换的方式。</p><ul><li>构造器的一个传入参数为 A 类型数据，也就是等同于可以将 A 类型因素转换为 B 类型</li><li>通过操作符复用将等号<code>=</code> 重新定义，等号右边的为 A 类型数据时，以A类型数据作为构造器参数返回 B 类型 object 指针</li><li>当执行 B 类型数据赋值给 A 类型时，会通过类型传播符定义的 function 返回 A 类型 object</li></ul><p>构造器初始化 object时，当只有一个参数时，就相当于把传入数据转换为对应 object 类型了。上面示例中可以看到，有两种方法来构造 object：</p><pre><code>B b = a; // constructor b from a
B c(a); // constructor c from a</code></pre><p>以上两种方式都是将 a 作为初始化参数构造 B 类型的 object。</p><p>编写了等号操作符复用后，对某个指定类型的外部 object 进行等号操作时就会将其转换为当前 object 类型，而不会报错。</p><p>通过类型传播符可以将 object 转换为其他指定类型的 object。</p><p>关于操作符复用的语法参考我之前的教程：<a href="https://blog.niekun.net/archives/1920.html">https://blog.niekun.net/archives/1920.html</a></p><h3>explicit 关键词</h3><p>当调用一个 function 时，对于其传递参数 c++ 允许进行隐式转换，这在一些情况下会引起一些问题，因为我们并不是所有情况下都希望自动进行转换的。</p><p>在以上示例中加入 function：</p><pre><code>void function(B b) {}
</code></pre><p>此 function 有一个 B 类型的参数，但是在实际调用中，由于 B 中定义了 A 的隐式转换相关模块，所以我们在这里可以将 A 类型数据作为传入数据：</p><pre><code>fun(a);
</code></pre><p>实际中我们可能并不需要这种转换，我们希望的是这里只能将 B 类型数据作为传入参数。通过关键词 <strong>explicit</strong> 来定义 constructor 可以实现这个需求，修改 B 的 constructor：</p><pre><code>explicit B(A a) {}
</code></pre><p>再次执行程序，会发现以下几个指令会报错：</p><pre><code>B b = a;
fun(a);</code></pre><p>通过 关键词 <strong>explicit</strong> 定义 constructor 的 class 不能通过 assignment 赋值符来初始化 object，也不能对 function 的传入参数进行隐式转换。</p><h3>explicit conversion 显式转换</h3><p>c++ 是一种严格区分数据类型的语言，对于那些会影响数据本身的转换，需要进行 explicit conversion 显式转换也叫做 <strong>type-casting</strong>。</p><p>在过去的语法中有两种常规的 type-casting 方式：</p><pre><code>double e = 10.11;
int f = int(e);
int g = (int)e;</code></pre><p>第一种叫做 function 样式，第二种叫做 c-like C语言模式。</p><p>对于那些基础数据类型的数据，这种转换模式没有什么问题，但这种语法对于 class 和 pointer 类型数据也会不加判断的进行转换，从而导致运行时的 runtime error。</p><p>为了控制这些在 class 间进行转换的过程，新版 c++ 提供了 4 种 <strong>casting operators</strong> 传播符来供不同场景下使用：</p><ul><li>dynamic_cast &lt;new_type&gt; (expression)</li><li>reinterpret_cast &lt;new_type&gt; (expression)</li><li>static_cast &lt;new_type&gt; (expression)</li><li>const_cast &lt;new_type&gt; (expression)</li></ul><h4>dynamic_cast</h4><p><strong>dynamic_cast</strong> 只能用于某个 class 或(void*) 的指针。他的作用是确保转换后的目标类型指针指向的是一个完整有效的 object，而不是空 object。例如，从 derived class 指针转换为 base class 指针。但是对于多态化的 polymorphic class(包含 virtual 元素的 class)，当且仅当指向的 object 是一个完整有效的目标 object 类型，使用 <strong>dynamic_cast</strong> 就可以从 base class 指针转换为 derived class 指针，请看如下示例：</p><pre><code>class Base { virtual void dummy() {} };
class Derived: public Base {int a;};

int main()
{
    try {
        Base *b1 = new Base;
        Base *b2 = new Derived;
        Derived *d;

        d = dynamic_cast&lt;Derived*&gt;(b1);
        if (d == 0)
            cout &lt;&lt; &quot;null pointer on first type cast&quot; &lt;&lt; endl;

        d = dynamic_cast&lt;Derived*&gt;(b2);
        if (d == 0)
            cout &lt;&lt; &quot;null pointer on second type cast&quot; &lt;&lt; endl;
    } catch(exception e) {
        cout &lt;&lt; e.what() &lt;&lt; endl;
    }
    return 0;
}

//output:
//null pointer on first type cast</code></pre><p>以上示例中，我们建立了 <strong>Base</strong> class 和 <strong>Derived</strong> class，其中 <strong>Base</strong> 含有一个 <strong>virtual</strong> function。然后我们创建两个 <strong>Base</strong> 类型指针，两个指针分别预分配类型为 <strong>Base</strong> 和 <strong>Derived</strong>。在之前的 c++ 教程中提到过可以新建 <strong>base</strong> 类型的变量然后使用 <strong>derived</strong> 类型数据，需要了解的可以查看：<a href="https://blog.niekun.net/archives/1927.html">https://blog.niekun.net/archives/1927.html</a>。然后我们创建一个 <strong>Derived</strong> 类型指针，使用 <strong>dynamic_cast</strong> 分别将上面建立的两个 <strong>Base</strong> 类型指针转换为 <strong>Derived</strong> 类型。</p><p>由于 <strong>b2</strong> 虽然是 <strong>Base</strong> 类型指针，但是我们预分配内存类型为 <strong>Derived</strong> 类型，所以它其实包含了 <strong>Derived</strong> object 所有属性。这样转换后的类型为完整的 <strong>Derived</strong> 类型指针。所以 <strong>d</strong> 指针不为空。而 <strong>b1</strong> 完全是 <strong>Base</strong> 类型指针，所以转换后的类型是不完整的 <strong>Derived</strong> 类型指针，所以赋值后结果为空。</p><p><strong>dynamic_cast</strong> 可以将任意指针转换为 <strong>void</strong>* 类型指针。</p><h4>static_cast</h4><p><strong>static_cast</strong> 可以转换任意相关联 class 类型的指针。不仅仅从 derived 到 base，也可以从 base 到 derived。不会判断是否转换到目标指针是完整的数据类型，所以完全由编程人员判断转换操作是否是安全的。相比于 <strong>dynamic_cast</strong> 有更大适用范围。</p><p>以下示例语法不会报错：</p><pre><code>class Base {};
class Derived: public Base {};

Base * a = new Base;
Derived * b = static_cast&lt;Derived*&gt;(a);</code></pre><p>b 指针会得到一个不完整的 Derived 类型数据，运行时可能报错。因此，使用 <strong>static_cast</strong> 不仅可以转换那些直接支持隐式转换的 class 指针，也可以在那些不支持转换的 class 间进行转换。</p><p>我们测试在其他数据将进行转换：</p><pre><code>double a = 12.23;
int b = static_cast&lt;int&gt;(a);
cout &lt;&lt; b &lt;&lt; endl;

//OUTPUT:
//12</code></pre><p>以上，我们将 double 类型的数据转换为 int 类型，这种转换可以直接通过隐式转换完成，但是使用显式转换语法实现更加明确清晰。但前提是原类型和目标类型必须是 related 有关联的 object 类型。</p><h4>reinterpret_cast</h4><p><strong>reinterpret_cast</strong> 可以将任意类型指针转换为其他任意类型指针，甚至是完全没有关联的两个类型。转换的过程就是将源数据的二进制数据复制到新指针地址。相比于 <strong>static_cast</strong> 有更大适用范围。</p><p>以下代码可以正常执行：</p><pre><code>class A { /* ... */ };
class B { /* ... */ };
A * a = new A;
B * b = reinterpret_cast&lt;B*&gt;(a);</code></pre><p>此时 b 指针指向的是一个和 B 类型完全不相干的数据，此时访问 b 指向的数据是不安全的。</p><h3>const_cast</h3><p><strong>const_cast</strong> 可以操作 const 类型的指针数据，例如当一个 function 需要非 const 类型传入数据时，可以通过 <strong>const_cast</strong> 进行转换。</p><p>请看下面示例：</p><pre><code>void test(int a) {
    cout &lt;&lt; a &lt;&lt; endl;
}

const int a = 10;
test(a);</code></pre><p>以上示例中，调用 test function 会报错，因为传入参数需要是非 const 类型的数据。</p><p>修改以上代码：</p><pre><code>const int a = 10;
int *b = const_cast&lt;int*&gt;(&amp;a);
test(*b);

//output:
//10</code></pre><p>通过 <strong>const_cast</strong> 将 <strong>const int</strong> 转换为 <strong>int</strong>，这样就可以在 function 中使用了。</p><h3>参考链接</h3><p><a href="http://www.cplusplus.com/doc/tutorial/typecasting/">Type conversions</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2066.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/2066.html</wfw:commentRss>
</item>
<item>
<title>VMware 虚拟机 NAT 网络下配置端口转发到主机</title>
<link>https://blog.niekun.net/archives/2061.html</link>
<guid>https://blog.niekun.net/archives/2061.html</guid>
<pubDate>Tue, 12 Jan 2021 11:06:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[今天安装了 Ubuntu 虚拟机用来做 node.js 开发，在选择网络模式时我选择了 NAT 模式，因为这样可以在主机处于不同网络环境下使虚拟机都有着同一个 IP 地址，方便管理。但是在此时中...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>今天安装了 Ubuntu 虚拟机用来做 node.js 开发，在选择网络模式时我选择了 NAT 模式，因为这样可以在主机处于不同网络环境下使虚拟机都有着同一个 IP 地址，方便管理。</p><p>但是在此时中发现，虚拟机可以正常访问主机及外网，但是主机无法通过分配的 NAT 地址来 ssh 访问虚拟机。查询后发现这是正常现象。可以通过设置端口转发来将虚拟机端口映射到主机端口来实现对虚拟机的访问。</p><!--more--><p>首先给虚拟机设置一个静态 ip 地址：<br><img src="https://blog.niekun.net/usr/uploads/2021/01/1335854183.jpg" alt="1.jpg" title="1.jpg"></p><p>然后打开<strong>虚拟网络编辑器</strong>：<br><img src="https://blog.niekun.net/usr/uploads/2021/01/2454627578.jpg" alt="2.jpg" title="2.jpg"></p><p>选中 NAT 对应的网卡，这里是 vnet 8，点击 <strong>NAT 设置</strong>：<br><img src="https://blog.niekun.net/usr/uploads/2021/01/2210698665.jpg" alt="3.jpg" title="3.jpg"></p><p>在端口转发栏点击<strong>添加</strong>：<br><img src="https://blog.niekun.net/usr/uploads/2021/01/725240944.jpg" alt="4.jpg" title="4.jpg"></p><p>设置要转发到的主机端口及对应虚拟机 IP 和端口等信息，这里我需要转发 ssh 的 22 端口到主机的 2222 端口：<br><img src="https://blog.niekun.net/usr/uploads/2021/01/406942165.jpg" alt="5.jpg" title="5.jpg"></p><p>点击确定保存设置即可。</p><p>设置好后就可以通过访问主机本地 2222 端口实现 ssh 访问虚拟机了。可以根据需要设置多个端口转发。</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2061.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/2061.html</wfw:commentRss>
</item>
<item>
<title>vs code 通过 ssh 远程连接服务器调试</title>
<link>https://blog.niekun.net/archives/2053.html</link>
<guid>https://blog.niekun.net/archives/2053.html</guid>
<pubDate>Tue, 12 Jan 2021 09:01:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[安装扩展插件： Remote - SSH可以实现远程文件访问终端调试远程端口转发到本地https://code.visualstudio.com/docs/remote/ssh-tutorial]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>安装扩展插件： Remote - SSH<br>可以实现远程文件访问<br>终端调试<br>远程端口转发到本地</p><p><a href="https://code.visualstudio.com/docs/remote/ssh-tutorial">https://code.visualstudio.com/docs/remote/ssh-tutorial</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2053.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/2053.html</wfw:commentRss>
</item>
<item>
<title>node.js 入门教程之二 -- Getting Started</title>
<link>https://blog.niekun.net/archives/2051.html</link>
<guid>https://blog.niekun.net/archives/2051.html</guid>
<pubDate>Sat, 09 Jan 2021 15:48:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[V8 JavaScript EngineV8 是 chrome 浏览器的 JavaScript Engine 名称，它是用来在 chrome 中获取和执行 JavaScript 代码的工具。V8...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<h3>V8 JavaScript Engine</h3><p>V8 是 chrome 浏览器的 JavaScript Engine 名称，它是用来在 chrome 中获取和执行 JavaScript 代码的工具。V8 提供了一个 JavaScript 的运行环境，DOM 及其他 web API 是由 browser 提供的。</p><p>JavaScript Engine 是独立于其所寄生的浏览器的，这一特性才使 node.js 得以诞生。node.js 选择了 V8 Engine 且随着 node.js 的不断成长，大量服务端通过 JavaScript 编写的程序使用 v8 Engine。</p><p>基于 V8 同样可以创造桌面应用，例如 Electron 项目。</p><p>不同的浏览器有着各自的 Engine：</p><ul><li><strong>Firefox</strong> has SpiderMonkey</li><li><strong>Safari</strong> has JavaScriptCore (also called Nitro)</li><li><strong>Edge</strong> was originally based on Chakra but has more recently been rebuilt using Chromium and the V8 engine.</li></ul><p>所有的 Engine 都遵守 ECMAScript 标准。</p><!--more--><p>在最初时候 JavaScript 被作为一种  interpreted language 解释型语言。但是现代 JavaScript Engine 不在单单 interpret 解释代码，而是要 compile 编译代码。</p><p>从 2009 年起，Firefox 将 SpiderMonkey 编译器集成到浏览器中，从此大家都开始引入这一方案。</p><p>JavaScript 代码被 V8 通过内部的 just-in-time (JIT) 编译器编译来提高执行效率。</p><h3>命令行运行 node.js 代码</h3><p>一般情况下在安装好 node.js 后，可以通过 node 命令执行 node.js 代码，需要传递被执行文件的路径：</p><pre><code>node app.js
</code></pre><h3>触发信号的使用</h3><p>当在终端中执行 node.js 程序时，可以通过快捷键 <code>ctrl C</code> 退出程序。当我们下面介绍如果通过更加<strong>程序化的方式</strong>实现退出动作。</p><p><strong>首先介绍第一种比较直接粗暴的方式</strong>：</p><pre><code>process.exit()
</code></pre><p>通过调用 <strong>precess</strong> 模块的 <strong>exit</strong> function ，进程会立即被强行终止。这意味着任何它当前挂起的任务，正在传输的数据，对文件的访问和读写等都会被以一种不友好的方式终止掉。</p><p><strong>process</strong> 不需要通过 <strong>require</strong> 的方式引入，他是默认被包含的。</p><p>你可以传递一个整型数字作为 exit code 退出码，不写的话默认为 <code>0</code>：</p><pre><code>process.exit(1)
</code></pre><p>不同的退出码有不同的意义，你可以使用不同的退出码来和其他程序响应。各种退出码的意义：<a href="https://nodejs.org/api/process.html#process_exit_codes">https://nodejs.org/api/process.html#process_exit_codes</a></p><p>你也可以提前设置退出码：</p><pre><code>process.exitCode = 1
</code></pre><p>在后续执行到 <code>process.exit</code> 时会返回此处设置的值。</p><p><strong>下面介绍更加友好的退出方式</strong>。</p><p>在上一节中，我们介绍了通过 http 模块搭建一个简单的 web 服务器，使用 express 模块也可以搭建 web 服务器，默认没有安装此模块，首先需要通过 npm 进行安装，模块会安装到当前路径下：</p><pre><code>npm install express
</code></pre><p>新建 js 文件，内容如下：</p><pre><code>const express = require('express')
const app = express()

app.get('/', (req, res) =&gt; {
  res.send('Hi!')
})

const server = app.listen(3000, () =&gt; console.log('Server ready'))</code></pre><p>打开浏览器访问本地 3000 端口即可看到输出。</p><p>这个 web 服务会一直进行下去，如果调用了 <code>process.exit()</code>，当前的响应会立刻被终止，这是显然不太好的。</p><p>我们可以通过发送一个 <strong>SIGTERM</strong> 信号，然后处理对这个信号的响应。响应的动作可以是关闭这个 web 服务，上面的示例增加如下代码：</p><pre><code>process.on('SIGTERM', () =&gt; {
    server.close(() =&gt; console.log('process termimated'));
});</code></pre><p>这里我们监控一个 <strong>SIGTERM</strong> signal 作为一个 event 事件，然后响应关闭服务器的动作。</p><p><code>process.on</code> 叫做 <strong>signal handler</strong> 信号响应器，用来定义接受的信号及对应的响应动作。这里定义当 <strong>SIGTERM</strong> 信号被触发后，执行关闭 server 动作及输出 log。</p><p><strong>SIGTERM</strong> 是告诉系统将进程友好终止的信号。此信号被触发后，首先会执行 <strong>signal handler</strong> 信号响应器所定义的响应动作，也就是关闭 web 服务器，最后再终止对应进程。</p><p><strong>SIGTERM</strong> 信号一般是由进程管理器，如：<strong>upstart</strong>，<strong>supervisord</strong> 发出。这里我们在程序内部触发此信号：</p><pre><code>setTimeout(() =&gt; {
    process.kill(process.pid, 'SIGTERM')
}, 3000);</code></pre><p><code>process.kill()</code> method 用来将 <strong>signal</strong> 信号发送给对应 <strong>pid</strong> 进程。语法如下：</p><pre><code>process.kill(pid, signal)
</code></pre><ul><li><strong>pid</strong> <number> 进程 ID</li><li><strong>signal</strong> <string> | <number> 要发送的信号, 大写字母的字符串或数字. 默认为: 'SIGTERM'</li></ul><p>当 pid 对应进程不存在时将会 throw 一个 error。<code>process.pid</code> 返回值为当前程序的进程 ID。</p><p>虽然 <code>process.kill</code> 名称看起来是要终止一个进程，但是他的确仅仅是一个 <strong>signal sender</strong> 信号发送器。具体会有什么样的结果完全取决于发送的是什么信号，以及对应信号的响应。<strong>kill</strong> method 的文档：<a href="https://nodejs.org/api/process.html#process_process_kill_pid_signal">https://nodejs.org/api/process.html#process_process_kill_pid_signal</a></p><p>以上示例中，加入对 <strong>SIGTERM</strong> 信号的触发和响应后，效果为：首先开启一个 web 服务器，3 秒后会尝试关闭此服务器并输出 log，此处会等待服务器完全结束当前 request 才会结束，最后终止进程：</p><pre><code>$ node express.js 
Server ready
process termimated</code></pre><p>注意 Windows 下 <strong>signal handler</strong> 信号响应器会无效，以上示例如果在 Windows 下执行不会输出最后一行 log 信息。</p><p><strong>常见的信号：</strong></p><ul><li><strong>SIGTERM</strong> 告诉系统需要友好的终止某个进程</li><li><strong>SIGKILL</strong> 立即结束对应进程，类似于 <code>process.exit()</code> 的效果</li><li><strong>beforeExit</strong> 进程退出前会触发此信号</li><li><strong>exit</strong> 进程退出时会触发此信号</li></ul><p>下面是一个对部分信号触发时间的测试：</p><pre><code>process.on(&quot;beforeExit&quot;, () =&gt;
    console.log(&quot;before exit&quot;));

process.on(&quot;exit&quot;, () =&gt;
    console.log(&quot;exit&quot;));

console.log(&quot;running&quot;);</code></pre><p>以上程序执行后输出信息如下：</p><pre><code>$ node process.js 
running
before exit
exit</code></pre><p>更多信号的意义参考：<a href="https://man7.org/linux/man-pages/man7/signal.7.html">signal(7) — Linux manual page</a><br>更多使用方法参考：<a href="https://nodejs.org/api/process.html#process_signal_events">Signal events</a></p><h3>环境变量的读取</h3><p>node.js 的核心模块 <strong>process</strong> 提供了 <strong>env</strong> properties 寄存了当前程序开始时的所有 environment variables 环境变量。执行以下命令可以输出所有变量：</p><pre><code>console.log(process.env);
</code></pre><p>查看某一个变量：</p><pre><code>console.log(process.env.HOME);

//-&gt; /home/marco</code></pre><p>也可以设置自定义的环境变量并给其赋值：</p><pre><code>console.log(process.env.TEST);
process.env.TEST = &quot;dev&quot;;
console.log(process.env.TEST);

// output:
// undefined
// dev</code></pre><h3>node.js REPL</h3><p>通常情况下我们将代码写在 js 文件中，然后通过 node 命令执行：</p><pre><code>node app.js
</code></pre><p>如果不指定需要执行的 js 文件，则会进入 REPL (Read Evaluate Print Loop) 编程环境，可以通过直接输入指令，逐行执行代码。</p><p>进入 REPL：</p><pre><code>$ node
Welcome to Node.js v15.5.1.
Type &quot;.help&quot; for more information.
&gt; </code></pre><p>尝试输出 log 信息：</p><pre><code>&gt; console.log('test')
test
undefined
&gt; </code></pre><p>可以发现首先会输出指定的字符串内容，然后输出 <strong>undefined</strong>，它是 <code>console.log</code> function 的返回值。</p><p>同样在 REPL 中也可以使用 tab 键来自动补全指令名称。</p><p>输入 JavaScript object 名称和符号点<code>.</code>，然后点击 tab 键会输出指定 object 的所有 properties。例如 Array：</p><pre><code>&gt; Array.
Array.__defineGetter__      Array.__defineSetter__      Array.__lookupGetter__      Array.__lookupSetter__
Array.__proto__             Array.hasOwnProperty        Array.isPrototypeOf         Array.propertyIsEnumerable
Array.toLocaleString        Array.valueOf

Array.apply                 Array.arguments             Array.bind                  Array.call
Array.caller                Array.constructor           Array.toString

Array.from                  Array.isArray               Array.length                Array.name
Array.of                    Array.prototype

&gt; Array.</code></pre><p>使用这种方式输出  global objects 全局可用的所有 objects：</p><pre><code>&gt; global.
global.__defineGetter__      global.__defineSetter__      global.__lookupGetter__      global.__lookupSetter__
global.__proto__             global.hasOwnProperty        global.isPrototypeOf         global.propertyIsEnumerable
global.toLocaleString        global.toString              global.valueOf

global.constructor

global.AbortController       global.AbortSignal           global.AggregateError        global.Array
global.ArrayBuffer           global.Atomics               global.BigInt                global.BigInt64Array
global.BigUint64Array        global.Boolean               global.Buffer                global.DataView
global.Date                  global.Error                 global.EvalError             global.Event
global.EventTarget           global.FinalizationRegistry  global.Float32Array          global.Float64Array
global.Function              global.Infinity              global.Int16Array            global.Int32Array
global.Int8Array             global.Intl                  global.JSON                  global.Map
global.Math                  global.MessageChannel        global.MessageEvent          global.MessagePort
global.NaN                   global.Number                global.Object                global.Promise
global.Proxy                 global.RangeError            global.ReferenceError        global.Reflect
global.RegExp                global.Set                   global.SharedArrayBuffer     global.String
global.Symbol                global.SyntaxError           global.TextDecoder           global.TextEncoder
global.TypeError             global.URIError              global.URL                   global.URLSearchParams
global.Uint16Array           global.Uint32Array           global.Uint8Array            global.Uint8ClampedArray
global.WeakMap               global.WeakRef               global.WeakSet               global.WebAssembly
global._                     global._error                global.assert                global.async_hooks
global.buffer                global.child_process         global.clearImmediate        global.clearInterval
global.clearTimeout          global.cluster               global.console               global.constants
global.crypto                global.decodeURI             global.decodeURIComponent    global.dgram
global.diagnostics_channel   global.dns                   global.domain                global.encodeURI
global.encodeURIComponent    global.escape                global.eval                  global.events
global.fs                    global.global                global.globalThis            global.http
global.http2                 global.https                 global.inspector             global.isFinite
global.isNaN                 global.module                global.net                   global.os
global.parseFloat            global.parseInt              global.path                  global.perf_hooks
global.process               global.punycode              global.querystring           global.queueMicrotask
global.readline              global.repl                  global.require               global.setImmediate
global.setInterval           global.setTimeout            global.stream                global.string_decoder
global.sys                   global.timers                global.tls                   global.trace_events
global.tty                   global.undefined             global.unescape              global.url
global.util                  global.v8                    global.vm                    global.wasi
global.worker_threads        global.zlib

&gt; global.</code></pre><p>REPL 有一些特殊指令，以 <code>.</code> 开始：</p><ul><li><code>.help</code>: shows the dot commands help</li><li><code>.editor</code>: enables editor mode, to write multiline JavaScript code with ease. Once you are in this mode, enter ctrl-D to run the code you wrote.</li><li><code>.break</code>: when inputting a multi-line expression, entering the .break command will abort further input. Same as pressing ctrl-C.</li><li><code>.clear</code>: resets the REPL context to an empty object and clears any multi-line expression currently being input.</li><li><code>.load</code>: loads a JavaScript file, relative to the current working directory</li><li><code>.save</code>: saves all you entered in the REPL session to a file (specify the filename)</li><li><code>.exit</code>: exits the repl (same as pressing ctrl-C two times)</li></ul><h3>来自命令行的传递参数</h3><p>在执行某个 js 文件时，你可以传入任意个数的数据作为传入参数供程序内使用。参数可以是独立的，也可以是以 key/value 形式：</p><pre><code>node app.js jon
node appljs name=jon age=20</code></pre><p>如果使用第二种方式，则需要对其进行解析，后面会介绍。</p><p>通过访问 <strong>process</strong> 模块的 <strong>argv</strong> property 可以 retrieve 这些传入参数，<strong>argv</strong> 是一个数组，它的首个元素是 node 可执行文件路径，第二个元素是当前执行的 js 文件路径，其他元素就是传入参数数据。</p><p>我们新建 argv.js 文件内容如下：</p><pre><code>process.argv.forEach((val, index) =&gt; {
    console.log(`${index}: ${val}`);
});</code></pre><p>执行以下指令：</p><pre><code>$ node argv.js ABC
0: /opt/node-v15.5.1-linux-x64/bin/node
1: /mnt/hgfs/Development/node.js/argv.js
2: ABC</code></pre><p>可以看到第三个元素是我们传入的数据。</p><p>可以通过 array 的 <strong>slice</strong> method 将所有传入参数单独提取出来：</p><pre><code>const val = process.argv.slice(2);
</code></pre><p><strong>slice</strong> 语法如下：</p><pre><code>array.slice(start, end)
</code></pre><p>将指定的数组范围内的元素生成一个新数组并返回，<strong>start</strong> 参数为起始元素索引，<strong>end</strong> 为终止元素索引，<strong>end</strong> 默认值为原数组最后一个元素。</p><p><strong>如果传入参数没有定义索引 key：</strong></p><pre><code>node app.js jon
</code></pre><p>使用以下方法调用：</p><pre><code>const val = process.argv.slice(2);
console.log(val[0]);</code></pre><p><strong>如果传入参数定义了索引 key：</strong></p><pre><code>node app.js name=jon
</code></pre><p>此时 <strong>args[0]</strong> 的值为 <strong>name=joe</strong>，需要对其进行解析操作，最简单的是使用 minimist 库实现(先通过 <strong>npm</strong> 安装)：</p><pre><code>const args = require('minimist')(process.argv.slice(2));
console.log(args['name']);
console.log(args['age']);</code></pre><p>此时我们需要在传入参数的索引 key 前加双横杠<code>--</code>:</p><pre><code>$ node argv.js --name=jon --age=20
jon
20</code></pre><h3>命令行输出</h3><p>node.js 提供了一个 <strong>console</strong> 模块提供了很多有用的方法来在命令行下交互信息。它同浏览器下的 <strong>console</strong> object 类似。</p><p>最基础的就是 <code>console.log</code> method，可以将传入数据输出为字符串到终端。如果传入一个 object，会将其渲染为 string。</p><p>你可以输出多个数据，例如：</p><pre><code>let a = 1;
let b = 2;
console.log(a, b);

//output:
//1 2</code></pre><p>可以使用连接符来组合字符串和变量：</p><pre><code>console.log('num1 is ' + a + ', num2 is ' + b)
</code></pre><p>通过传入变量和一个对应的 format specifier 格式占位符来使格式解析更加明晰：</p><pre><code>console.log('num1 is %s, num2 is %s', a, b)
</code></pre><ul><li><strong>%s</strong> 格式化一个变量成字符串</li><li><strong>%d</strong> 格式化一个变量成数字</li><li><strong>%i</strong> 格式化一个变量成整数</li><li><strong>%o</strong> 格式化一个变量为 object</li></ul><p>调用 <strong>clear</strong> method 可以清空当前终端的信息:</p><pre><code>console.clear();
</code></pre><p><strong>count</strong> method 可以实现对一个输出字符串的累计计数，输出字符串的同时会显示此字符串已经输出的次数，执行以下代码：</p><pre><code>console.count('count1')
console.count('count2')
console.count('count1')
console.count('count1')</code></pre><p>输出结果为：</p><pre><code>count1: 1
count2: 1
count1: 2
count1: 3</code></pre><p>结合 <strong>time</strong> 和 <strong>timeEnd</strong> method 可以计算执行一段代码花费的时间：</p><pre><code>const doSomeThing = () =&gt; console.log('test');
const measureTime = () =&gt; {
    console.time();
    doSomeThing();
    console.timeEnd();
}
measureTime()

//output:
//test
//default: 5.937ms</code></pre><p>以上示例中，调用 <code>console.time()</code> 开始计时，调用 <code>console.timeEnd()</code> 终止计时并返回总时间。</p><p>通过 <code>console.log</code> 等输出到终端的信息称之为 standard 标准输出：<strong>stdout</strong>，通过 <code>console.error</code> 会输出到 <strong>stderr</strong> stream 流，不会显示到终端而是输出到了 error log。</p><p>可以通过  <code>escape sequences</code> 转义序列来给输出信息添加颜色，执行下面示例：</p><pre><code>console.log('\x1b[31m%s, \x1b[33m%s', 'hello', 'world')
</code></pre><p>输出如下：<br><img src="https://blog.niekun.net/usr/uploads/2021/01/4134573984.png" alt="2021-01-12T07:41:15.png" title="2021-01-12T07:41:15.png"></p><p><code>\x1b[</code> 后跟对应颜色的数字编号即可：</p><ul><li>30m    Black</li><li>31m    Red</li><li>32m    Green</li><li>33m    Yellow</li><li>34m    Blue</li><li>35m    Purple</li><li>36m    Cyan</li><li>37m    White</li></ul><p>但这种方法比较麻烦，输入也不太友好。</p><p>最好的方式是通过 Chalk 库来实现这个功能，它不仅可以修改颜色，还可以设置粗体，下划线，斜体等效果。需要通过 <code>npm install chalk</code> 安装库。</p><p>使用方法如下：</p><pre><code>const chalk = require('chalk')
console.log(chalk.yellow('hello world'))</code></pre><p>这种方法使代码更加清晰可读。更多 chalk 使用方法参考：<a href="https://github.com/chalk/chalk">https://github.com/chalk/chalk</a></p><p><strong>创建进度条</strong></p><p>Progress 模块可以用来在终端创建进度条效果，通过 <code>npm install progress</code> 安装。</p><p>下面示例创建一个 10 级的进度条，每 100 ms 进一格，完成后取消定时器：</p><pre><code>const ProgressBar = require('progress')

const bar = new ProgressBar(':bar', { total: 10 })
const timer = setInterval(() =&gt; {
    bar.tick();
    if (bar.complete) {
        clearInterval(timer);
    }
}, 100);</code></pre><p>每调用一次 <code>bar.tick()</code> 就会前进一格，可以在程序中添加进度条来提示进度。</p><h3>命令行输入</h3><p>下面介绍如何在命令行下进行输入输出交互。</p><p>node.js 从 version 7 开始提供了 <strong>readline</strong> module 可以在程序运行期间获取一个可读取的 stream 流的数据，如 <strong>process.stdin</strong> stream，一次读取一行数据。</p><p>请看下面示例：</p><pre><code>const readline = require('readline').createInterface({
    input: process.stdin,
    output: process.stdout
});

readline.question(&quot;what is your name\n&quot;, name =&gt; {
    console.log(`Hi, ${name}`);
    readline.close();
});

//output:
//what is your name
//marco
//Hi, marco</code></pre><p><strong>question()</strong> method 显示第一个参数数据到命令行，然后等待用户输入数据，当用户输入数据并敲回车后会自动调用定义的 function，并将输入数据作为传入数据。</p><p>readline 的更多用法参考：<a href="https://nodejs.org/api/readline.html">https://nodejs.org/api/readline.html</a></p><p>但需要输入一个密码时，我们希望在输入时可以隐藏输入的信息，我们可以通过 <strong>Inquirer.js</strong> 模块来实现需求。</p><p><strong>Inquirer.js</strong> 项目地址：<a href="https://github.com/SBoudrias/Inquirer.js">https://github.com/SBoudrias/Inquirer.js</a></p><p>通过 npm 安装：</p><pre><code>npm install inquirer
</code></pre><p><strong>inquirer</strong> 可以实现很多输入交互方式，如：常规输入，密码，列表，选项框等，下面举例说明：</p><pre><code>const inquirer = require('inquirer')

var questions = [
    {
        type: 'input',
        name: 'name',
        message: 'what is your name\n',
        default: function () {
            return 'Doe';
        }
    },
    {
        type: 'input',
        name: 'age',
        message: 'how old are you?\n'
    },
    {
        type: 'input',
        name: 'phone number',
        message: 'please input your phone number\n',
        validate: function (value) {
            var pass = value.match(
              /^1[3|4|5|6|7|8|9][0-9]{9}$/
            );
            if (pass)
              return true;
            else
                return 'Please enter a valid phone number';
        }
    },
    {
        type: 'password',
        name: 'password',
        message: 'your password\n'
    }
];

inquirer.prompt(questions)
.then(answers =&gt; {
    console.log(`Hi, ${answers['name']}, you age is ${answers['age']}, your phone number is ${answers['phone number']}`);
});</code></pre><p><strong>questions</strong> 数组定义了需要输入的内容，可以定义多项输入信息，每个输入内容都是一个独立的 question object 用来定义这个 question 具体的模式，下面介绍最常用的几个 properties：</p><ul><li>type 提示框的类型，默认为 input，可选项有: input, number, confirm, list, rawlist, expand, checkbox, password, editor</li><li>name 定义了此 question 的名称，用来在 answers 中读取数据时使用</li><li>message 定义一个打印输出的字符串提示信息</li><li>default 如果没有输入内容，则使用此处定义的默认值，可以是变量或 function</li><li>validate 用来判断输入信息是否满足一定条件，如果满足则返回 true，不满足返回预定一个提示信息并停留在当前 question 等待用户修改输入内容</li></ul><p>更多使用 question object 的属性参考：<a href="https://github.com/SBoudrias/Inquirer.js#question">https://github.com/SBoudrias/Inquirer.js#question</a></p><p>在上面的示例中，通过 <strong>validate</strong> function 判断电话号码是否有效，通过 <strong>string</strong> 的 <strong>match</strong> method 使用正则表达式来匹配信息。<strong>match</strong> method 语法如下：</p><pre><code>string.match(regexp)
</code></pre><p>注意 regexp 是一个字符串，需要使用斜杠<code>/</code>来包围，如：</p><pre><code>var str = &quot;abcdefab&quot;;
if (str.match(/ab/))
    console.log(true);
else
    console.log(false);

//output:
//true</code></pre><p>还可以使用修饰符来设置正则匹配限制，可用的修饰符有 <code>g</code> 和 <code>i</code>，放在正则表达式结尾斜杠<code>/</code>后面。</p><p><code>g</code> 修饰符表示 global 全局查找，当使用 g 时，所有匹配结果将会返回，当不使用 g 时，只有第一个匹配的结果会返回，且包含其 groups，index 等信息：</p><pre><code>var str = &quot;abcdefab&quot;;
console.log(str.match(/ab/));
console.log(str.match(/ab/g));

//OUTPUT:
//[ 'ab', index: 0, input: 'abcdefab', groups: undefined ]
//[ 'ab', 'ab' ]</code></pre><p><code>i</code> 修饰符用来设置忽略大小写：</p><pre><code>var str = &quot;abcdefabAB&quot;;
console.log(str.match(/ab/g));
console.log(str.match(/ab/gi));

//OUTPUT:
//[ 'ab', 'ab' ]
//[ 'ab', 'ab', 'AB' ]</code></pre><p>当 <strong>question</strong> object 的 <strong>type</strong> 定义为 <strong>password</strong> 类型时，输入时信息会被隐藏。</p><p><strong>prompt</strong> method 用来显示提示框，传入参数就是预定义的 question 数组，其返回值为 <strong>promise</strong> 类型，所以可以通过 <strong>then</strong> method 来实现异步响应。promise 的用法参考：<a href="https://blog.niekun.net/archives/2011.html">https://blog.niekun.net/archives/2011.html</a></p><p>这里通过 <strong>then</strong> method 定义了 success 的 function，传入参数就是用户输入的数据构成的 object，通过 <strong>question</strong> object 中 <strong>name</strong> property 定义的名称来索引到具体的某个输入数据。</p><p>更多 inquirer 示例：<a href="https://github.com/SBoudrias/Inquirer.js/tree/master/packages/inquirer/examples">https://github.com/SBoudrias/Inquirer.js/tree/master/packages/inquirer/examples</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2051.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/2051.html</wfw:commentRss>
</item>
<item>
<title>node.js 入门教程之一 -- 介绍</title>
<link>https://blog.niekun.net/archives/2043.html</link>
<guid>https://blog.niekun.net/archives/2043.html</guid>
<pubDate>Fri, 08 Jan 2021 09:28:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[Node.js 是一个开源跨平台的 JavaScript 运行环境，它是时下最流行的工具，能够应用于几乎所有的项目。Node.js 运行 V8 JavaScript engine。它是 chro...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>Node.js 是一个开源跨平台的 JavaScript 运行环境，它是时下最流行的工具，能够应用于几乎所有的项目。Node.js 运行 V8 JavaScript engine。它是 chrome 的核心，这让 Node.js 可以脱离浏览器运行 JavaScript 代码。</p><p>一个 Node.js app 运行在一个线程中，不会给每个 request 建立一个进程。Node.js 在其标准库中提供了一个 asynchronous I/O primitives 异步 IO 原生语法库来防止阻塞，同时 Node.js 中的库使用一种 non-blocking paradigms 无阻塞范式，将阻塞作为一种 exception 来处理。</p><p>当 Node.js 执行 IO 动作，例如读取文件，访问数据库等，不同于等待进程，占用 CPU 资源，Node.js 会在收到 request 响应后再去处理后续操作。这将使 Node.js 可以在一个 server 上同时处理上千条链接而不会引入大量的进程而导致 bug 出现。</p><p>Node.js 的另一大优势是使用 JavaScript 的前端开发者可以同时编写 server 端的代码而不用学习新的语言。</p><p>最新的 ECMAScript 标准可以在 Node.js 中使用，你不需要等待用户去更新浏览器。通过使用不同版本的 Node.js 来切换不同的 ECMAScript 标准。</p><!--more--><p>Node.js 使用 JavaScript 语言，如果你还不太了解 js 可以参考我之前的 8 篇 JavaScript 教程：<a href="https://blog.niekun.net/archives/1979.html">JavaScript 入门教程之一 -- 总览</a></p><h3>海量的第三方库</h3><p>通过 <strong>npm</strong> 简单的结构帮助 Node.js 生态系统快速的增长。目前 <strong>npm</strong> 注册超过 1,000,000 个开源库可供免费使用。</p><h3>hello world</h3><p>web server 是最常见的 hello world 示例。</p><p>新建一个 js 文件，内容如下：</p><pre><code>const http = require('http')

const hostname = '127.0.0.1'
const port = 8080

const server = http.createServer((req, res) =&gt; {
  res.statusCode = 200
  res.setHeader('Content-Type', 'text/plain')
  res.end('Hello World!\n')
})

server.listen(port, hostname, () =&gt; {
  console.log(`Server running at http://${hostname}:${port}/`)
})</code></pre><p>以上代码首先引入 <strong>http</strong> 模块。Node.js 使用 CommonJS module 系统，使用内建的 <strong>require</strong> 关键词来引入其他文件写好的 module 模块。</p><p>Node.js 有一个很好的标准库：<a href="https://nodejs.org/api/">https://nodejs.org/api/</a>，包含有对 network 的直接支持。</p><p><strong>createServer</strong> method 创建一个新的 http server 并返回它。定义了一个 <strong>requestListener</strong> function，会被自动添加到 <strong>request</strong> event。</p><p><strong>listen</strong> method 定义特定的监听地址和端口。当 server 运行起来后， <strong>listen</strong> method 调用的 function 会被执行，这里我们显示 server 已启动的信息。</p><p>当收到一个 request，会自动调用 <strong>request</strong> event，并传入两个 object：一个 <strong>request</strong> (an http.IncomingMessage object) 和一个 <strong>response</strong> (an http.ServerResponse object)。</p><p>这两个 object 是处理 http 访问的核心。</p><p><strong>request</strong> object 提供了 request 请求的信息，在以上示例中没有使用到这个，但是我们可读取 request header 和 data 数据。</p><p><strong>response</strong> object 用来返回数据给发起请求者，在这里通过：</p><pre><code>res.statusCode = 200
</code></pre><p>返回一个 200 状态码，表示一次成功的响应。</p><p>然后我们设置一个 header：</p><pre><code>res.setHeader('Content-Type', 'text/plain')
</code></pre><p>最后我们关闭 response 响应，并将响应内容作为 <strong>end</strong> method 的参数传入：</p><pre><code>res.end('Hello World\n')
</code></pre><h3>Node.js Frameworks and Tools</h3><p>Node.js 是一个底层平台，为了让开发更加容易，海量的基于 Node.js 的第三方库通过社区建立。它们中的很多已经非常流行，以下是一些常见的第三方库：</p><ul><li><strong>AdonisJs</strong>: A full-stack framework highly focused on developer ergonomics, stability, and confidence. Adonis is one of the fastest Node.js web frameworks.</li><li><strong>Express</strong>: It provides one of the most simple yet powerful ways to create a web server. Its minimalist approach, unopinionated, focused on the core features of a server, is key to its success.</li><li><strong>Fastify</strong>: A web framework highly focused on providing the best developer experience with the least overhead and a powerful plugin architecture. Fastify is one of the fastest Node.js web frameworks.</li><li><strong>Gatsby</strong>: A React-based, GraphQL powered, static site generator with a very rich ecosystem of plugins and starters.</li><li><strong>hapi</strong>: A rich framework for building applications and services that enables developers to focus on writing reusable application logic instead of spending time building infrastructure.</li><li><strong>koa</strong>: It is built by the same team behind Express, aims to be even simpler and smaller, building on top of years of knowledge. The new project born out of the need to create incompatible changes without disrupting the existing community.</li><li><strong>Loopback.io</strong>: Makes it easy to build modern applications that require complex integrations.</li><li><strong>Meteor</strong>: An incredibly powerful full-stack framework, powering you with an isomorphic approach to building apps with JavaScript, sharing code on the client and the server. Once an off-the-shelf tool that provided everything, now integrates with frontend libs React, Vue, and Angular. Can be used to create mobile apps as well.</li><li><strong>Micro</strong>: It provides a very lightweight server to create asynchronous HTTP microservices.</li><li><strong>NestJS</strong>: A TypeScript based progressive Node.js framework for building enterprise-grade efficient, reliable and scalable server-side applications.</li><li><strong>Next.js</strong>: React framework that gives you the best developer experience with all the features you need for production: hybrid static & server rendering, TypeScript support, smart bundling, route pre-fetching, and more.</li><li><strong>Nx</strong>: A toolkit for full-stack monorepo development using NestJS, Express, React, Angular, and more! Nx helps scale your development from one team building one application to many teams collaborating on multiple applications!</li><li><strong>Sapper</strong>: Sapper is a framework for building web applications of all sizes, with a beautiful development experience and flexible filesystem-based routing. Offers SSR and more!</li><li><strong>Socket.io</strong>: A real-time communication engine to build network applications.</li><li><strong>Strapi</strong>: Strapi is a flexible, open-source Headless CMS that gives developers the freedom to choose their favorite tools and frameworks while also allowing editors to easily manage and distribute their content. By making the admin panel and API extensible through a plugin system, Strapi enables the world's largest companies to accelerate content delivery while building beautiful digital experiences.</li></ul><h3>安装</h3><p>在官方下载页面下载对应系统的安装包：<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a></p><p>macOS 可以通过 brew 来安装：</p><pre><code>brew install node
</code></pre><h3>node.js 和浏览器端的区别</h3><p>浏览器端和 node.js 都是使用 JavaScript 作为编程语言，但他们是完全不同的。</p><p>node.js 可以同时开发前端和后端 application，这样使用一种语言就可以完成所有的开发。</p><p>浏览器中使用 DOM 结构，或者其他 web 平台的 API 如：cookies，这些在 node.js 中都是没有的，<strong>document</strong> 或 <strong>window</strong> 等这些 object 是没有的。</p><p>使用 node.js 由你来控制 environment，你知道 application 所使用的 node.js 是哪个版本的，相比较于浏览器，你并不知道用户使用了什么浏览器。所以你可以使用更加现代的 ES 标准来编写程序。</p><p>另一个区别是 node.js 使用 <strong>CommonJS</strong> 模块系统，浏览器端我们已经可以使用 ES 的标准命令来导入模块了。也就是说 node.js 中使用 <strong>require()</strong> 而浏览器端使用 <strong>import</strong>。</p><h3>参考链接</h3><p><a href="https://nodejs.dev/learn/introduction-to-nodejs">https://nodejs.dev/learn/introduction-to-nodejs</a></p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2043.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/2043.html</wfw:commentRss>
</item>
<item>
<title>修复 parallels desktop 16 网络无法连接问题</title>
<link>https://blog.niekun.net/archives/2040.html</link>
<guid>https://blog.niekun.net/archives/2040.html</guid>
<pubDate>Sun, 03 Jan 2021 22:40:00 +0800</pubDate>
<dc:creator>admin</dc:creator>
<description><![CDATA[随着升级到 macOS Big Sur 后，虚拟机 parallels desktop 也更新到了 16 版本。我当然是继续安装破解版啦。但是安装好后，启动虚拟机会有一个报错：Network I...]]></description>
<content:encoded xml:lang="zh-CN"><![CDATA[
<p>随着升级到 macOS Big Sur 后，虚拟机 parallels desktop 也更新到了 16 版本。我当然是继续安装破解版啦。</p><p>但是安装好后，启动虚拟机会有一个报错：<strong>Network Initialization Failed</strong>，启动后会发现虚拟机无法联网，网络设置中无法正常在各种模式中切换。</p><p>在寻找解决方案期间，了解到了这可能是由于破解的原因，正版用户没有这个问题。网上有人提供了一个方法，执行一条命令就启动虚拟机就可以正常联网了。但是会导致虚拟机无法访问主机的共享目录及无法访问 USB 设备。而且一旦重启 parallels desktop 后又回恢复之前的状态，我也就没有去做。</p><p>这两天看到网上终于有人找到的解决方法，测试后的确可用，所以介绍给大家参考。</p><!--more--><p>解决的方法都是通过修改相关配置文件实现的。首先需要彻底退出 parallels desktop。</p><h3>网络问题</h3><p>修改 <code>/Library/Preferences/Parallels/network.desktop.xml</code> 文件。</p><p>在终端或者 vs code 中打开这个文件，找到 <code>&lt;UseKextless&gt;</code> 标签，将其中的内容改为 0：</p><pre><code>&lt;UseKextless&gt;0&lt;/UseKextless&gt;
</code></pre><p>注意如果你的这个文件内没有这个标签，则需要在 <code>&lt;ParallelsNetworkConfig&gt;</code> 根标签内手动创建它即可。</p><p>修改完成后保存文件，需要输入账户密码。</p><h3>USB 问题</h3><p>修改 <code>/Library/Preferences/Parallels/dispatcher.desktop.xml</code> 文件。</p><p>在终端或者 vs code 中打开这个文件，找到 <code>&lt;Usb&gt;</code> 标签，将其中的内容改为 1：</p><pre><code>&lt;Usb&gt;1&lt;/Usb&gt;
</code></pre><p>修改完成后保存文件，需要输入账户密码。</p><p>修改完以上两个文件后，重启 parallels desktop 就会发现一切都正常了。</p>
]]></content:encoded>
<slash:comments>0</slash:comments>
<comments>https://blog.niekun.net/archives/2040.html#comments</comments>
<wfw:commentRss>https://blog.niekun.net/feed/archives/2040.html</wfw:commentRss>
</item>
</channel>
</rss>