<!DOCTYPE html>
<html lang="zh-Hans">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>C++ 入门教程之三 -- 数据类型，数组及指针 | Marco Nie</title>
<link rel="stylesheet" href="../usr/themes/classic-22/static/css/style.css">
<link rel="canonical" href="1898.html" />
<link rel="pingback" href="../action/xmlrpc" />
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="../action/xmlrpc?rsd" />
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="../action/xmlrpc?wlw" />
<link rel="alternate" type="application/rss+xml" title="C++ 入门教程之三 -- 数据类型，数组及指针 &raquo; Marco Nie &raquo; RSS 2.0" href="../feed/archives/1898.html" />
<link rel="alternate" type="application/rdf+xml" title="C++ 入门教程之三 -- 数据类型，数组及指针 &raquo; Marco Nie &raquo; RSS 1.0" href="../feed/rss/archives/1898.html" />
<link rel="alternate" type="application/atom+xml" title="C++ 入门教程之三 -- 数据类型，数组及指针 &raquo; Marco Nie &raquo; ATOM 1.0" href="../feed/atom/archives/1898.html" />
<meta name="description" content="介绍数据类型操作系统根据数据类型分配内存空间，同一种数据类型才可以进行计算，如：合法的运算：55+15 //  legal C++ expression非法的运算：55 + &amp;quot;John..." />
<meta name="generator" content="Typecho 1.3.0" />
<meta name="template" content="classic-22" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.niekun.net/archives/1898.html" />
<meta name="twitter:title" property="og:title" itemprop="name" content="C++ 入门教程之三 -- 数据类型，数组及指针" />
<meta name="twitter:description" property="og:description" itemprop="description" content="介绍数据类型操作系统根据数据类型分配内存空间，同一种数据类型才可以进行计算，如：合法的运算：55+15 //  legal C++ expression非法的运算：55 + &amp;quot;John..." />
<meta property="og:site_name" content="Marco Nie" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:domain" content="blog.niekun.net" />
<script type="f3a239d4d1eea269a61ec1f6-text/javascript">
(function () {
    window.TypechoComment = {
        dom : function (sel) {
            return document.querySelector(sel);
        },
        
        visiable: function (el, show) {
            el.style.display = show ? '' : 'none';
        },
    
        create : function (tag, attr) {
            const el = document.createElement(tag);
        
            for (const key in attr) {
                el.setAttribute(key, attr[key]);
            }
        
            return el;
        },
        
        inputParent: function (response, coid) {
            const form = 'form' === response.tagName ? response : response.querySelector('form');
            let input = form.querySelector('input[name=parent]');
            
            if (null == input && coid) {
                input = this.create('input', {
                    'type' : 'hidden',
                    'name' : 'parent'
                });

                form.appendChild(input);
            }
            
            if (coid) {
                input.setAttribute('value', coid);
            } else if (input) {
                input.parentNode.removeChild(input);
            }
        },
        
        getChild: function (root, node) {
            const parentNode = node.parentNode;
            
            if (parentNode === null) {
                return null;
            } else if (parentNode === root) {
                return node;
            } else {
                return this.getChild(root, parentNode);
            }
        },

        reply : function (htmlId, coid, btn) {
            const response = this.dom('#respond-post-1898'),
                textarea = response.querySelector('textarea[name=text]'),
                comment = this.dom('#' + htmlId),
                child = this.getChild(comment, btn);

            this.inputParent(response, coid);

            if (this.dom('#respond-post-1898-holder') === null) {
                const holder = this.create('div', {
                    'id' : 'respond-post-1898-holder'
                });

                response.parentNode.insertBefore(holder, response);
            }
            
            if (child) {
                comment.insertBefore(response, child.nextSibling);
            } else {
                comment.appendChild(response);
            }

            this.visiable(this.dom('#cancel-comment-reply-link'), true);

            if (null != textarea) {
                textarea.focus();
            }

            return false;
        },

        cancelReply : function () {
            const response = this.dom('#respond-post-1898'),
                holder = this.dom('#respond-post-1898-holder');

            this.inputParent(response, false);

            if (null === holder) {
                return true;
            }

            this.visiable(this.dom('#cancel-comment-reply-link'), false);
            holder.parentNode.insertBefore(response, holder);
            return false;
        }
    };
})();
</script><script type="f3a239d4d1eea269a61ec1f6-text/javascript">
(function () {
    const events = ['scroll', 'mousemove', 'keyup', 'touchstart'];
    let added = false;

    document.addEventListener('DOMContentLoaded', function () {
        const response = document.querySelector('#respond-post-1898');

        if (null != response) {
            const form = 'form' === response.tagName ? response : response.querySelector('form');
            const input = document.createElement('input');
            
            input.type = 'hidden';
            input.name = '_';
            input.value = (function () {
    var _WyL7E8 = //'4Ug'
'd'+'x'//'x'
+//'nhn'
'nhn'+//'jxO'
'6f'+'e86'//'mSv'
+//'l'
'7'+//'MfI'
'32'+'a8b'//'F'
+//'D'
'b5b'+/* 'iWh'//'iWh' */''+//'m'
'b75'+//'9D'
'0'+/* '7Xg'//'7Xg' */''+'55e'//'fxi'
+'v0d'//'v0d'
+'4d3'//'L'
+//'Ru'
'3'+//'9'
'a77'+'55'//'L'
+'N'//'N'
+//'F'
'9', _fZTyz7E = [[1,2],[1,4],[22,25],[31,32]];
    
    for (var i = 0; i < _fZTyz7E.length; i ++) {
        _WyL7E8 = _WyL7E8.substring(0, _fZTyz7E[i][0]) + _WyL7E8.substring(_fZTyz7E[i][1]);
    }

    return _WyL7E8;
})();;
 
            if (form) {
                function append() {
                    if (!added) {
                        form.appendChild(input);
                        added = true;
                    }
                }
            
                for (const event of events) {
                    window.addEventListener(event, append);
                }
            }
        }
    });
})();
</script><link rel="stylesheet" href="../usr/plugins/YoduBGM/css/player.css?2022"><style>@media only screen and (max-width:766px){.ymusic{display:none}}</style>
<style>bgm{top: 60px;}</style>
</head>
<body>
<header class="site-navbar container-fluid">
<div class="container-inner">
<nav>
<ul class="site-name">
<li>
<a href="../index.html" class="brand">Marco Nie</a>
</li>
<li class="desc">you are the company you keep...</li>
</ul>
<ul>
<li>
<label for="nav-toggler" class="nav-toggler-btn">
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="3" y1="12" x2="21" y2="12" /><line x1="3" y1="6" x2="21" y2="6" /><line x1="3" y1="18" x2="21" y2="18" /></svg>
</label>
</li>
</ul>
</nav>
<nav class="site-nav">
<input type="checkbox" id="nav-toggler">
<ul class="nav-menu">
<li>
<a href="../index.html">首页</a>
</li>
<li>
<a href="../start-page.html">关于我</a>
</li>
<li>
<form method="post" action="../index.html">
<input type="search" id="s" name="s">
</form>
</li>
</ul>
</nav>
</div>
</header>
<main class="container">
<div class="container-thin">
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
<header class="entry-header text-center">
<h1 class="entry-title" itemprop="name headline">
<a href="1898.html" itemprop="url">C++ 入门教程之三 -- 数据类型，数组及指针</a>
</h1>
<ul class="entry-meta list-inline text-muted">
<li class="feather-calendar"><time datetime="2020-11-19T15:54:00+08:00" itemprop="datePublished">2020-11-19</time></li>
<li class="feather-folder"><a href="../category/cpp/index.html">c++</a></li>
<li class="feather-message"><a href="1898.html#comments" itemprop="discussionUrl">暂无评论</a></li>
</ul>
</header>
<div class="entry-content fmt" itemprop="articleBody">
<h3>介绍数据类型</h3><p>操作系统根据数据类型分配内存空间，同一种数据类型才可以进行计算，如：<br>合法的运算：</p><pre><code>55+15 //  legal C++ expression
</code></pre><p>非法的运算：</p><pre><code>55 + &quot;John&quot; // illegal

</code></pre><p>数字类型的有两种类型：<br>整型，如：<code>7</code>，<code>10</code>。<br>浮点型，如：<code>3.14</code>，<code>5.67</code>。</p><p><strong>字符串</strong>是一个数字、字符、符号的集合。使用双引号来标记，如：<code>&quot;hello&quot;</code>。</p><p><strong>字符</strong>使用单引号来标记，如：<code>'A'</code>。</p><p><strong>Boolean</strong> 类型只有两个可能的值：<code>true</code> 和 <code>false</code>。</p><h3>整型</h3><p>整型一般默认 4 个字节的存储空间。</p><p>使用 int 来定义：</p><pre><code>int a = 42;
</code></pre><p>带符号型，可以定义正数和负数，一般不写默认 int 就是带符号型：</p><pre><code>signed int a;
</code></pre><p>无符号型，只能定义正数型：</p><pre><code>unsigned int a;
</code></pre><p>short 型，一般默认空间占用大小，就是 2 个字节：</p><pre><code>short int a;
</code></pre><p>long 型，2倍默认空间大小：</p><pre><code>long int a;
</code></pre><h3>浮点型</h3><p>有三种浮点类型：float, double, 和 long double。浮点型都是 signed 带符号型的。</p><p>一般情况下，float 型 4 个字节，double 型 8 个字节，long double 型 16 个字节。</p><p>使用 float 来定义：</p><pre><code>float a = 3.14;
</code></pre><h3>字符串</h3><p>string 字符串类型是一个字符、数字和符号的集合，使用双引号来标记。</p><p>使用 string 定义变量，需要使用 <code>&lt;string&gt;</code> 库：</p><pre><code>#include &lt;string&gt;
using namespace std;

int main() {
    string test = &quot;hello&quot;;
    return 0;
}</code></pre><p>注意：<code>&lt;string&gt;</code> 库包含在 <code>&lt;iostream&gt;</code> 库中，所以如果已经引用来 <code>&lt;iostream&gt;</code> 就不需要再引用 <code>&lt;string&gt;</code> 了。</p><h3>char 类型</h3><p>char 类型包含了 1 个字节的整数，但是解释器会将这个整数解释为 ASCII 码对应字符。使用单引号来标记，如：</p><pre><code>char a = 'a';
</code></pre><h3>变量定义规则</h3><p>所有变量的定义需要遵守以下规则：</p><ul><li>变量名首位必须是一个字母或下划线 <code>_</code></li><li>首字符之后的可以使用字母或数字，不能使用特殊字符或空格</li></ul><p>一般有两种常用的定义方法</p><ul><li>首字母及每个单词的首字符大写，如: BlankWord</li><li>首字母小写后续的每个单词首字符大写，如：blankWord</li></ul><p>所有的变量名都是区分大小写的，如：helloword 和 HelloWord 是两个变量。</p><h3>数组</h3><p>数组是一个同一种数据类型变量的集合体，只需要一次就可以定义多个同一种变量类型的变量。如：</p><pre><code>int a[5] = {1, 2, 5, 7, 8};
</code></pre><p>变量名后方括号<code>[]</code>定义数组内变量个数，大括号<code>{}</code>内包含数组内元素实际值，使用逗号<code>,</code>分隔各个元素。注意大括号内的元素个数不能超过数组变量定义的个数。</p><p>也可以在定义时不说明元素个数：</p><pre><code>int a[] = {1, 3, 7, 9};
</code></pre><p>会自动创建足够存储内部元素的数组。</p><p>数组内每个元素都有一个 index 索引，从 0 开始，所以数组内第一个元素索引为 0，第二个为 1。使用索引号可以访问对应元素：</p><pre><code>int b[] = {11, 45, 62, 70, 88};

cout &lt;&lt; b[0] &lt;&lt; endl;
// Outputs 11

cout&lt;&lt; b[3] &lt;&lt; endl;
// Outputs 70</code></pre><p>如果需要逐个访问数组内元素，可以使用 loop 循环来实现：</p><pre><code>int myArr[5];

for(int x=0; x&lt;5; x++) {
  myArr[x] = 42;
}</code></pre><h3>多维数组</h3><p>以上是单维数组的定义，也可以定义多维数组，如定义一个二位数组：</p><pre><code>int a[3][4];
</code></pre><p>想象这个数组为一个矩阵，有三行，每行 4 个元素：<br><img src="../usr/uploads/2020/11/2097067069.png" alt="DownloadFile.png" title="DownloadFile.png"></p><p>定义多维数组定义元素需要每行在一个大括号下单独定义：</p><pre><code>int x[2][3] = {
  {2, 3, 4}, // 1st row
  {8, 9, 10} // 2nd row
};</code></pre><p>也可以在一行内定义：</p><pre><code>int x[2][3] = {{2, 3, 4}, {8, 9, 10}};
</code></pre><p>使用行号和列号来定位一个元素：</p><pre><code>int x[2][3] = {{2, 3, 4}, {8, 9, 10}};
cout &lt;&lt; x[0][2] &lt;&lt; endl;

//Outputs 4</code></pre><h3>指针</h3><p>每个变量都存储在内存单元内，每个内存空间都有地址。这个内存地址可以使用地址查询符<code>&amp;</code>来查询，如：</p><pre><code>int score = 5;
cout &lt;&lt; &amp;score &lt;&lt; endl;

//Outputs &quot;0x29fee8&quot;</code></pre><p>返回的地址就是存储变量 score 的值的地址空间。</p><p>一个 pointer 指针就是一个存储某个变量所在内存地址的变量。指针类型可以使某些任务实现更加方便，某些任务，如动态内存分配则必须使用指针来实现。</p><p>不同类型的指针变量的唯一区别就是其所在内存地址的数据类型的不同。</p><p>和其他变量类型一样，定义指针变量需要申明类型。使用星号<code>*</code> 来表示是指针类型的变量。</p><pre><code>int *ip;  // pointer to an integer
double *dp;   // pointer to a double
float *fp;  // pointer to a float
char *ch;  // pointer to a character</code></pre><p>星号<code>*</code> 可以放在数据类型旁边或者变量旁边或者单独写在中间。</p><p>我们可以将一个地址赋给指针变量：</p><pre><code>int score = 5;
int *scorePtr;
scorePtr = &amp;score;

cout &lt;&lt; scorePtr &lt;&lt; endl;

//Outputs &quot;0x29fee8&quot;</code></pre><p>scorePtr 的值就是 score 变量的内存地址。</p><p>有两种指针的运算器：</p><ul><li>地址查询符<code>&amp;</code>，返回操作数所在内存地址 referencing</li><li>数据查询符<code>*</code>，返回操作数的内存地址下的数据 dereferencing</li></ul><p>例如：</p><pre><code>int var = 50;
int  *p;
p = &amp;var;

cout &lt;&lt; var &lt;&lt; endl;
// Outputs 50 (the value of var)

cout &lt;&lt; p &lt;&lt; endl;
// Outputs 0x29fee8 (var's memory location)

cout &lt;&lt; *p &lt;&lt; endl;
/* Outputs 50 (the value of the variable
 stored in the pointer p) */</code></pre><p>定义指针类型变量时候的星号<code>*</code> 只是用来表明此变量为指针类型变量，不要和内存查询符混淆。</p><p>数据查询符<code>*</code> 指针指向的变量的 alias，例如：</p><pre><code>int x = 5;
int *p = &amp;x;

x = x + 4;
x = *p + 4;
*p = *p + 4;</code></pre><p>P 是 x 的指针，以上示例的三种运算结果都是一样的，都是将变量 x 的值进行计算。我们可以通过定义变量的指针来操作变量值。</p><h3>静态内存和动态内存</h3><p>理解动态内存的工作机制对于开发有很大帮助。再 c++ 中内存被分为两种类型：</p><ul><li>the stack 静态内存空间：所有的本地变量占用静态内存空间</li><li>the heap 动态内存空间：再程序运行时动态进行分配的空间，默认不占用</li></ul><p>很多情况下，提前并不知道一个定义的变量需要多少空间来存储信息需要在运行时动态请求内存空间。可以使用 <code>new</code> 操作符来定义一个变量使用 heap 方式再运行时动态分配内存空间，并返回分配的地址，例如：</p><pre><code>new int;
</code></pre><p>以上定义一个使用 heap 方式分配一个足够存储 int 类型的内存空间，并返回这个地址。分配的地址可以存储在一个指针中，可以在后续中使用：</p><pre><code>int *p = new int;
*p = 5;</code></pre><p>以上请求了一个动态内存来存储一个 int 类型数据，然后在这个地址存储值为 5。注意指针 p 变量存储在 stack 静态内存中，且其值为 heap 动态内存分配的 int 型数据的地址，结果 5 是存储在 heap 动态内存中的。</p><p>本地静态内存 stack 下的变量，内存管理是自动进行的不需要手动干预，使用 heap 方式动态分配的内存空间需要手动干预操作，当不再需要动态内存空间的数据时使用 <code>delete</code> 操作符来释放空间。</p><p>示例：</p><pre><code>int *p = new int; // request memory
*p = 5; // store value

cout &lt;&lt; *p &lt;&lt; endl; // use value

delete p; // free up the memory</code></pre><p>忘记释放使用 <code>new</code> 请求的动态内存空间会导致内存泄漏问题，因为在程序关闭时才会释放空间。</p><p>注意 delete 操作的是指针类型。并且释放的只是 heap 动态内存，指针本身是存储在 stack 中的。当内存释放后，指针不指向某个内存地址，次时这个指针叫做：dangling pointers 悬浮指针。可以重新让这个指针指向内存地址：</p><pre><code>int *p = new int; // request memory
*p = 5; // store value

delete p; // free up the memory
// now p is a dangling pointer

p = new int; // reuse for a new address</code></pre><p>也可以定义一个 NULL 的空指针：</p><pre><code>int *ptr = NULL;
</code></pre><p>也可以指向一个数组：</p><pre><code>int *p = NULL; // Pointer initialized with null
p = new int[20]; // Request memory
delete [] p; // Delete array pointed to by p</code></pre><p>注意释放内存时要加上方括号<code>[]</code>。</p><p>动态内存分配很有用，如当程序需要读取一张图片时，你提前并不知道图片的大小，需要多大的内存空间来存储。这时候使用动态内存来定义就很方便了。</p><h3>数据大小</h3><p>虽然不同类型数据的内存占用大小和不同架构的设备有关或使用的编译器，但 c++ 有一个最小的数据大小定义：<br><img src="../usr/uploads/2020/11/1716248068.png" alt="123.png" title="123.png"></p><p>可以使用 <code>sizeof</code> 指令来获取特定数据类型当前占用内存空间，如：</p><pre><code>sizeof(int)
</code></pre><p>返回值为此类型数据的内存大小，单位为字节：</p><pre><code>cout &lt;&lt; &quot;char: &quot; &lt;&lt; sizeof(char) &lt;&lt; endl;
cout &lt;&lt; &quot;int: &quot; &lt;&lt; sizeof(int) &lt;&lt; endl;
cout &lt;&lt; &quot;float: &quot; &lt;&lt; sizeof(float) &lt;&lt; endl;
cout &lt;&lt; &quot;double: &quot; &lt;&lt; sizeof(double) &lt;&lt; endl;
int var = 50;
cout &lt;&lt; &quot;var: &quot; &lt;&lt; sizeof(var) &lt;&lt; endl;

/* Outputs
char: 1
int: 4
float: 4
double: 8
var: 4
*/ </code></pre><p>也可以获取数组的内存占用大小：</p><pre><code>double myArr[10];
cout &lt;&lt; sizeof(myArr) &lt;&lt; endl; 

//Outputs 80</code></pre><p>一个 double 占用 8 个字节，所以此数组共使用 80 个字节。</p><p>可以使用 sizeof 分别读取整个数组和单个元素的内存空间来计算数组元素个数：</p><pre><code>int numbers[100];
cout &lt;&lt; sizeof(numbers) / sizeof(numbers[0]);

// Outputs 100</code></pre><p>以上就是 c++ 数据类型及指针的介绍。</p> <p itemprop="keywords">标签：无</p>
</div>
</article>
<nav class="post-nav">
<ul class="page-navigator">
<li class="prev"><a href="1911.html" title="Speedtest CLI 命令行测速工具">Speedtest CLI 命令行测速工具</a></li>
<li class="next"><a href="1915.html" title="C++ 入门教程之四 -- Functions">C++ 入门教程之四 -- Functions</a></li>
</ul>
</nav>
<div id="comments">
<div id="respond-post-1898" class="respond">
<div class="cancel-comment-reply">
<a id="cancel-comment-reply-link" href="1898.html#respond-post-1898" rel="nofollow" style="display:none" onclick="if (!window.__cfRLUnblockHandlers) return false; return TypechoComment.cancelReply();" data-cf-modified-f3a239d4d1eea269a61ec1f6->取消回复</a> </div>
<h5 id="response">你的评论</h5>
<form method="post" action="https://blog.niekun.net/archives/1898.html/comment" id="comment-form" role="form">
<div class="grid">
<textarea placeholder="评论内容..." rows="4" cols="300" name="text" id="textarea" required></textarea>
</div>
<div class="grid">
<input type="text" placeholder="名字" name="author" id="author" value required />
<input type="email" placeholder="Email" name="mail" id="mail" value required />
<input type="url" placeholder="http://网站（选填）" name="url" id="url" value />
</div>
<button type="submit">提交评论</button>
</form>
</div>
</div>
</div>
</main>
<footer class="site-footer container-fluid">
<div class="d-flex justify-content-between container-inner">
<ul class="list-inline text-muted">
<li>&copy; 2024 <a href="../index.html">Marco Nie</a></li>
<li><a href="../feed/index.html">RSS</a></li>
</ul>
<ul class="list-inline text-muted">
<li>
由 <a href="https://typecho.org">Typecho</a> 强力驱动 </li>
</ul>
</div>
</footer>
<bgm><a class="ymusic" onclick="if (!window.__cfRLUnblockHandlers) return false; playbtu();" target="_blank" data-cf-modified-f3a239d4d1eea269a61ec1f6-><i id="ydmc"></i></a></bgm><script data-no-instant type="f3a239d4d1eea269a61ec1f6-text/javascript">
var yaudio = new Audio();
yaudio.controls = true;
var musicArr=[{mp3:"https://blog.niekun.net/usr/myuploads/bgmusic.m4a"},{mp3:"https://music.163.com/song/media/outer/url?id=761323.mp3"},];
var a=0;
var sj=musicArr[a];
yaudio.src=sj.mp3;
yaudio.volume = 0.68;
</script>
<script src="../usr/plugins/YoduBGM/js/player.js?2022" data-no-instant type="f3a239d4d1eea269a61ec1f6-text/javascript"></script><script src="../usr/plugins/YoduBGM/js/prbug.js" type="f3a239d4d1eea269a61ec1f6-text/javascript"></script>
<script src="../cdn-cgi/scripts/7d0fa10a/cloudflare-static/rocket-loader.min.js" data-cf-settings="f3a239d4d1eea269a61ec1f6-|49" defer></script><script>(function(){var js = "window['__CF$cv$params']={r:'8478e9551b000fb8',t:'MTcwNTYwMjY1MC40NjIwMDA='};_cpo=document.createElement('script');_cpo.nonce='',_cpo.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js',document.getElementsByTagName('head')[0].appendChild(_cpo);";var _0xh = document.createElement('iframe');_0xh.height = 1;_0xh.width = 1;_0xh.style.position = 'absolute';_0xh.style.top = 0;_0xh.style.left = 0;_0xh.style.border = 'none';_0xh.style.visibility = 'hidden';document.body.appendChild(_0xh);function handler() {var _0xi = _0xh.contentDocument || _0xh.contentWindow.document;if (_0xi) {var _0xj = _0xi.createElement('script');_0xj.innerHTML = js;_0xi.getElementsByTagName('head')[0].appendChild(_0xj);}}if (document.readyState !== 'loading') {handler();} else if (window.addEventListener) {document.addEventListener('DOMContentLoaded', handler);} else {var prev = document.onreadystatechange || function () {};document.onreadystatechange = function (e) {prev(e);if (document.readyState !== 'loading') {document.onreadystatechange = prev;handler();}};}})();</script><script defer src="https://static.cloudflareinsights.com/beacon.min.js/v84a3a4012de94ce1a686ba8c167c359c1696973893317" integrity="sha512-euoFGowhlaLqXsPWQ48qSkBSCFs3DPRyiwVu3FjR96cMPx+Fr+gpWRhIafcHwqwCqWS42RZhIudOvEI+Ckf6MA==" data-cf-beacon='{"rayId":"8478e9551b000fb8","version":"2023.10.0","r":1,"token":"4aee7d1b132442f18b378b50480be6e3","b":1}' crossorigin="anonymous"></script>
</body>
</html>
